# Пошаговые вычисления метрик для test_line_graph

## Структура графа
```
A → B → C → D
```
- 4 узла (n = 4)
- 3 ребра, все с weight = 1.0
- Направленный граф (DiGraph)
- D - висячий узел (dangling node, нет исходящих рёбер)

## 1. Degree метрики

### degree_in и degree_out
- **A**: degree_in = 0, degree_out = 1
- **B**: degree_in = 1, degree_out = 1  
- **C**: degree_in = 1, degree_out = 1
- **D**: degree_in = 1, degree_out = 0 (dangling node!)

### degree_centrality
Формула для directed: `(degree_in + degree_out) / (n - 1)` где n = 4

- **A**: (0 + 1) / 3 = 0.333...
- **B**: (1 + 1) / 3 = 0.666...
- **C**: (1 + 1) / 3 = 0.666...
- **D**: (1 + 0) / 3 = 0.333...

## 2. PageRank (с учётом dangling nodes)

### Параметры
- damping_factor (α) = 0.85
- n = 4 узла
- max_iter = 100 (достаточно для сходимости)
- weight = 1.0 для всех рёбер

### Итеративная формула
```
PR(v) = (1-α)/n + α * [Σ(PR(u)*w(u,v)/out_weight(u)) + s/n]
```
где:
- s = сумма PageRank всех dangling nodes
- w(u,v) = вес ребра u→v
- out_weight(u) = сумма весов исходящих рёбер из u

### Начальные значения
PR₀(A) = PR₀(B) = PR₀(C) = PR₀(D) = 0.25

### Итерация 1
- Dangling: s = PR₀(D) = 0.25 (D не имеет исходящих)
- base = (1-0.85)/4 + 0.85*(0.25/4) = 0.0375 + 0.053125 = 0.090625
- PR₁(A) = base = 0.090625 (нет входящих)
- PR₁(B) = base + 0.85*0.25/1 = 0.090625 + 0.2125 = 0.303125
- PR₁(C) = base + 0.85*0.25/1 = 0.090625 + 0.2125 = 0.303125
- PR₁(D) = base + 0.85*0.25/1 = 0.090625 + 0.2125 = 0.303125

### Итерация 2
- Dangling: s = PR₁(D) = 0.303125
- base = 0.0375 + 0.85*(0.303125/4) = 0.0375 + 0.06441 = 0.10191
- PR₂(A) = base = 0.10191
- PR₂(B) = base + 0.85*0.090625/1 = 0.10191 + 0.07703 = 0.17894
- PR₂(C) = base + 0.85*0.303125/1 = 0.10191 + 0.25766 = 0.35957
- PR₂(D) = base + 0.85*0.303125/1 = 0.10191 + 0.25766 = 0.35957

### Итерации 3-5 (из лога выполнения)
- Итерация 3: [0.1139, 0.2005, 0.2660, 0.4195]
- Итерация 4: [0.1267, 0.2235, 0.2971, 0.3528]
- Итерация 5: [0.1125, 0.2201, 0.3024, 0.3650]

### После сходимости (46 итераций)
Точные значения из JavaScript реализации:
- **A**: 0.1161558230
- **B**: 0.2148882726
- **C**: 0.2988108548
- **D**: 0.3701450496

Проверка: сумма = 1.0000000000 ✓

## 3. Betweenness Centrality

### Подготовка
Добавляем inverse_weight к рёбрам:
- Все рёбра: inverse_weight = 1.0 / 1.0 = 1.0

### Кратчайшие пути (с учётом inverse_weight)
- A→B: путь A→B, длина = 1.0
- A→C: путь A→B→C, длина = 2.0
- A→D: путь A→B→C→D, длина = 3.0
- B→C: путь B→C, длина = 1.0
- B→D: путь B→C→D, длина = 2.0
- C→D: путь C→D, длина = 1.0

### Подсчёт betweenness
Узел находится "между" если он внутренний узел кратчайшего пути:
- **A**: не является внутренним узлом ни одного пути = 0
- **B**: внутренний для A→C (1 путь), A→D (1 путь) = 2
- **C**: внутренний для A→D (1 путь), B→D (1 путь) = 2
- **D**: не является внутренним узлом = 0

### Нормализация для directed
Делим на (n-1)*(n-2) = 3*2 = 6:
- **A**: 0 / 6 = 0.0
- **B**: 2 / 6 = 0.333...
- **C**: 2 / 6 = 0.333...
- **D**: 0 / 6 = 0.0

## 4. Closeness Centrality (Out-closeness)

### Формула для directed с частичной достижимостью
Если узел v достигает k узлов из n-1:
```
closeness(v) = (k / sum_distances) * (k / (n-1))
```

### Вычисление для каждого узла
- **A**: достигает B,C,D (k=3)
  - Расстояния: 1 + 2 + 3 = 6
  - closeness = (3/6) * (3/3) = 0.5 * 1.0 = 0.5

- **B**: достигает C,D (k=2)
  - Расстояния: 1 + 2 = 3
  - closeness = (2/3) * (2/3) = 0.666... * 0.666... = 0.444...

- **C**: достигает D (k=1)
  - Расстояния: 1
  - closeness = (1/1) * (1/3) = 1.0 * 0.333... = 0.333...

- **D**: не достигает никого (k=0)
  - closeness = 0.0

## 5. Component ID
Все узлы принадлежат одной weakly connected component:
- **Все узлы**: component_id = 0

## 6. Prerequisite Depth
Уровни в дереве PREREQUISITE зависимостей:
- **A**: нет входящих PREREQUISITE → depth = 0
- **B**: A→B есть PREREQUISITE → depth = 1
- **C**: B→C есть PREREQUISITE → depth = 2
- **D**: C→D есть PREREQUISITE → depth = 3

## 7. Learning Effort
Накопленная сложность по PREREQUISITE путям:
- **A**: difficulty(A) = 1 → effort = 1
- **B**: effort(A) + difficulty(B) = 1 + 2 = 3
- **C**: effort(B) + difficulty(C) = 3 + 3 = 6
- **D**: effort(C) + difficulty(D) = 6 + 4 = 10

## 8. Educational Importance

PageRank по подграфу educational_edge_types (PREREQUISITE, ELABORATES, EXAMPLE_OF, TESTS).
В нашем случае все рёбра типа PREREQUISITE, поэтому результат совпадает с обычным PageRank:

- **A**: 0.1161558230
- **B**: 0.2148882726
- **C**: 0.2988108548
- **D**: 0.3701450496

Проверка: сумма = 1.0000000000 ✓

## Итоговая таблица метрик

| Узел | degree_in | degree_out | degree_centrality | pagerank | betweenness | closeness | component_id | prereq_depth | learning_effort | educational_importance |
|------|-----------|------------|-------------------|----------|-------------|-----------|--------------|--------------|-----------------|------------------------|
| A    | 0         | 1          | 0.3333            | 0.1162   | 0.0000      | 0.5000    | 0            | 0            | 1               | 0.1162                 |
| B    | 1         | 1          | 0.6667            | 0.2149   | 0.3333      | 0.4444    | 0            | 1            | 3               | 0.2149                 |
| C    | 1         | 1          | 0.6667            | 0.2988   | 0.3333      | 0.3333    | 0            | 2            | 6               | 0.2988                 |
| D    | 1         | 0          | 0.3333            | 0.3701   | 0.0000      | 0.0000    | 0            | 3            | 10              | 0.3701                 |

## Проверки инвариантов
- ✓ Сумма PageRank = 1.0000
- ✓ Сумма educational_importance = 1.0000
- ✓ Educational_importance = PageRank (все рёбра educational типа)
- ✓ PageRank растёт вдоль цепочки (учитывая redistribution от dangling node)
- ✓ D имеет максимальный PageRank как конечная точка обучения
- ✓ B и C имеют одинаковый betweenness (симметрия в линейной структуре)
- ✓ Closeness убывает вдоль цепочки (узлы дальше от остальных)
- ✓ Learning effort растёт накопительно: 1→3→6→10

## Проверки инвариантов
- ✓ Сумма PageRank = 1.0000
- ✓ PageRank растёт вдоль цепочки (но не экстремально из-за redistribution)
- ✓ D имеет максимальный PageRank как конечная точка обучения
- ✓ B и C имеют одинаковый betweenness (симметрия в линейной структуре)
- ✓ Closeness убывает вдоль цепочки (узлы дальше от остальных)