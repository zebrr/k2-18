[
    {
        "path": "/handbook/algorithms/article/kak-ustroen-hendbuk-algorithms",
        "content": "В&nbsp;этом параграфе мы&nbsp;расскажем, какие возможности предлагает хендбук, как по&nbsp;нему обучаться и&nbsp;отслеживать свой прогресс.\n\n## О&nbsp;хендбуке\n\nХендбук&nbsp;— это цифровой учебник, который содержит теорию и&nbsp;практические задания с&nbsp;автопроверкой.\n\nВы&nbsp;можете проходить его как самостоятельный курс, изучая параграф за&nbsp;параграфом последовательно, или&nbsp;же пользоваться им&nbsp;как справочником, чтобы освежить знания.\n\nОсновная ценность цифрового учебника (в&nbsp;отличие от&nbsp;бумажного)&nbsp;— актуальная информация: мы&nbsp;будем обновлять материалы по&nbsp;мере устаревания знаний и&nbsp;добавлять новые задачи.\n\nА&nbsp;чтобы быть в&nbsp;курсе свежих изменений — советуем вам <a href=\"https://forms.yandex.ru/surveys/13462038.3745c4e68094350aeff0d46c080fb30b83148309\" target=\"_blank\">подписаться</a> на&nbsp;обновления или вступить в&nbsp;<a href=\"https://t.me/handbook_algorithms\" target=\"_blank\">комьюнити</a> учебника.\n\n<p-important>\nБольшая часть этого хендбука основана на интерактивном учебнике <a href=\"https://education.yandex.ru/handbook/algorithms/team#kulikov\" target=\"_blank\">Александра Куликова</a> и Павла Певзнера, в котором также есть задачи с алгоритмических собеседований с решениями, интерактивные алгоритмические головоломки и примеры кода на Python. Учебник доступен на <a href=\"https://stepik.org/a/126012?utm_source=yahandbook&utm_medium=page&utm_campaign=first\" target=\"_blank\">Stepik</a> и <a href=\"https://cogniterra.org/a/24?utm_source=yahandbook&utm_medium=page&utm_campaign=first\" target=\"_blank\">Cogniterra</a>.\n</p-important>\n\nМы&nbsp;стараемся постоянно улучшать контент, опираясь на&nbsp;знание своей аудитории. Давайте познакомимся?\n\n<p align=center><script src=\"https://yastatic.net/s3/frontend/forms/_/embed.js\"></script><iframe src=\"https://forms.yandex.ru/surveys/13475035.7c27b76c8957eebaed2a098f16eae3778a3a4bff/?iframe=1&what-handbooks=algorithms&handbook=algorithms\" frameborder=\"0\" name=\"ya-form-13475035.7c27b76c8957eebaed2a098f16eae3778a3a4bff\" width=\"650\"></iframe></p>\n\n## Как читать хендбук\n\nЕсли вы&nbsp;проходите курс последовательно, может быть полезным \"оставить закладку\" там, где вы&nbsp;остановились.\n\nДля этого вы&nbsp;можете отмечать главы, как прочитанные в&nbsp;конце параграфа:\n\n![Untitled.png](https://yastatic.net/s3/ml-handbook/admin/Untitled_1a5563ff86.png)\n\nЭто отразится на&nbsp;странице содержания и&nbsp;в&nbsp;прогресс-баре хендбука:\n\n![2023-07-12](https://yastatic.net/s3/ml-handbook/admin/2023_07_12_17_20_34_51f17d1913.png)\n\nА&nbsp;если вам нужно быстро найти какую-то тему или понятие&nbsp;— вы&nbsp;можете воспользоваться поиском:\n\n![2023-07-12](https://yastatic.net/s3/ml-handbook/admin/2023_07_12_17_22_57_f251def4fe.png)\n\nИ&nbsp;навигацией внутри страниц:\n\n![2023-07-12](https://yastatic.net/s3/ml-handbook/admin/2023_07_12_17_39_19_00b8c8a01b.png)\n\nВ&nbsp;конце каждого параграфа вы&nbsp;можете перейти в&nbsp;комьюнити, чтобы обсудить тему или задачи к&nbsp;ней, а&nbsp;также перейти к&nbsp;самим задачам:\n\n![Untitled.png](https://yastatic.net/s3/ml-handbook/admin/Untitled_1a5563ff86.png)\n\n## Как работать с&nbsp;системой проверки заданий\n\nДисклеймер: в&nbsp;этом пункте мы&nbsp;говорим о&nbsp;нюансах системы сдачи задач. Советуем сейчас прочитать его бегло, и&nbsp;внимательнее&nbsp;— когда приступите к&nbsp;решению задач.\n\n### Обзор\n\nВ&nbsp;конце параграфов вы&nbsp;можете найти набор задач для отработки навыков по&nbsp;теме. Мы&nbsp;рекомендуем решать задачи с&nbsp;десктопных устройств, т.к.&nbsp;в&nbsp;мобильной версии некоторые элементы могут отображаться некорректно.\n\nПри переходе внутрь задачи вы&nbsp;увидите в&nbsp;левой части экрана описание задачи, а&nbsp;в&nbsp;правой&nbsp;— поле редактора, в&nbsp;котором можно писать код решения.\n\n![2023-06-28](https://yastatic.net/s3/ml-handbook/admin/2023_06_28_13_26_46_f96f358b88.png)\n\nОписание задачи включает:\n\n* **Условие**.\n\n* **Формат и&nbsp;примеры ввода/вывода**.\n\n  В&nbsp;блоке «Формат ввода» описаны данные, аналогичные тем, что будут переданы в&nbsp;вашу программу при автоматической проверке задания. Конкретный пример входных данных можно посмотреть в&nbsp;поле «Пример → Ввод».\n\n  В&nbsp;поле «Пример → Вывод» показан результат, который ожидается от&nbsp;вашей программы при правильной обработке данных, указанных в&nbsp;поле «Пример → Ввод».\n\n* **Ограничения по&nbsp;памяти и&nbsp;времени**, в&nbsp;которые должна уложиться ваша программа.\n\n![2023-06-28](https://yastatic.net/s3/ml-handbook/admin/2023_06_28_13_30_21_a5759759d1.png)\n\nОтправить решение можно через поле редактора, либо загрузив файл с&nbsp;вашей программой в&nbsp;систему.\n\n![2023-06-28](https://yastatic.net/s3/ml-handbook/admin/2023_06_28_13_34_15_f76a10e369.png)\n\nПосле отправки решения система скомпилирует ваш код (когда это необходимо) и&nbsp;начнёт тестировать его на&nbsp;различных вариантах входных данных, сопоставляя ожидаемый эталонный вывод с&nbsp;результатами работы вашего кода.\n\nПары входных и&nbsp;выходных тестовых данных называются тестами.\n\nПроверка решения может занять некоторое время, отследить прогресс проверки вы&nbsp;можете на&nbsp;вкладке «Отправленные решения».\n\n![2023-07-11](https://yastatic.net/s3/ml-handbook/admin/2023_07_11_18_38_55_3ad599e2c1.png)\n\nВ&nbsp;зависимости от&nbsp;результата проверки вы&nbsp;увидите статус:\n\n* **Решена полностью**&nbsp;— ваше решение успешно скомпилировалось и&nbsp;прошло все тесты.\n* **Решена неверно**&nbsp;— код не&nbsp;компилируется или не&nbsp;проходит тестирование.\n\n### Как понять в&nbsp;чем ошибка?\n\nЧтобы узнать детали проверки, нужно перейти внутрь посылки:\n\n![2023-07-11](https://yastatic.net/s3/ml-handbook/admin/2023_07_11_18_35_01_ec0d0002d7.png)\n\nЗдесь вы&nbsp;увидите вердикт по&nbsp;решению. Вот некоторые варианты вердиктов:\n\n1. **OK**&nbsp;— решение прошло все тесты.\n\n2. **CE&nbsp;(Compilation Error)**&nbsp;— ошибка компиляции, в&nbsp;программе допущена синтаксическая или семантическая ошибка.\n\n   В&nbsp;этом случае разобраться поможет отчет об&nbsp;ошибке в&nbsp;блоке «Лог компиляции»:\n\n   ![2023-07-11](https://yastatic.net/s3/ml-handbook/admin/2023_07_11_18_36_20_a220054618.png)\n\n   Система подскажет, какого рода ошибка присутствует в&nbsp;коде, и&nbsp;в&nbsp;какой строке она находится.\n\n3. **WA&nbsp;(Wrong Answer)**&nbsp;— ваша программа выдала неправильный результат на&nbsp;одном из&nbsp;тестов.\n\n   Для тестов из&nbsp;примеров отображается ввод, вывод вашей программы, вывод чекера (системы проверки ответа) и&nbsp;правильный ответ. Это поможет с&nbsp;отладкой вашей программы.\n\n   ![2023-06-28](https://yastatic.net/s3/ml-handbook/admin/2023_06_28_13_49_29_9abeffde0c.png)\n\n   Мы&nbsp;не&nbsp;раскрываем другие тестовые данные. Попробуйте самостоятельно рассмотреть различные нетривиальные варианты входных данных и&nbsp;проверить, как на&nbsp;них отрабатывает ваше решение. Это поможет вам научиться тестировать свой код самостоятельно.\n\n4. **RE&nbsp;(Runtime Error)**&nbsp;— ошибка выполнения. Например, это может быть ошибка выхода за&nbsp;границы массива или необработанные исключения.\n\n5. **TL&nbsp;(Time Limit)**&nbsp;— на&nbsp;одном из&nbsp;тестов решение работает слишком долго.\n\n6. **ML&nbsp;(Memory Limit)**&nbsp;— на&nbsp;одном из&nbsp;тестов решение потребляет слишком много памяти.\n\nПодробный список ответов проверяющей системы можно посмотреть <a href=\"https://contest.yandex.ru/errors\" target=\"_blank\">здесь</a>.\n\nВ&nbsp;случае, если вы&nbsp;чувствуете, что вам необходима поддержка и&nbsp;взгляд со&nbsp;стороны, попробуйте обсудить задачу с&nbsp;участниками <a href=\"https://t.me/handbook_algorithms\" target=\"_blank\">комьюнити</a> хендбука.\n\nЖелаем вам успешного обучения!",
        "handbook": "Основы алгоритмов",
        "title": "Как устроен хендбук — Основы алгоритмов",
        "description": "В этом параграфе мы расскажем, какие возможности предлагает хендбук, как по нему обучаться и отслеживать свой прогресс"
    },
    {
        "path": "/handbook/algorithms/article/algo-vvedenie",
        "content": "Перед вами хендбук по алгоритмам от авторов, увлеченных красотой и элегантностью математики. \n\nВ этой книге мы сделаем акцент на фундаменте построения алгоритмов и преобразовании их в программы. Это важно — практически на любую задачу можно посмотреть с различных сторон, и это может привести к необычайным результатам:  где-то подход станет намного проще и понятнее, а где-то значительно вырастет эффективность, и итоговая программа будет находить результат в тысячи и даже в миллионы раз быстрее.\n\nЗачем изучать алгоритмы? Этот вопрос интересует большинство начинающих разработчиков. На него нет однозначно верного ответа, но мы считаем изучение алгоритмов важным и полезным.\n\nАлгоритмизация превращает мысли и рассуждения в последовательность действий. Но к одному и тому же результату могут приводить разные действия — поэтому составление алгоритма это ещё и поиск наиболее эффективного (в данный момент) набора действий.\n\nЗная фундаментальные алгоритмы, вы сможете виртуозно использовать стандартные библиотеки языков программирования, уверенно оценивать ожидаемое время работы программы, читать и понимать код, написанный другими программистами.\n\nАлгоритмизация важна и «для общего развития»: она помогает планировать свои действия в реальной жизни. Почти всё, что нас окружает, можно описать алгоритмически. Взять, например, очередь.\n\nЗдесь алгоритмы помогают по-разному организовать работу с клиентами — в зависимости от разных факторов: количества посетителей, количества сотрудников и так далее. Организация очереди в аэропорту и в супермаркете отличается: \n- в супермаркете клиенты оплачивают покупки по одному;\n- в аэропорту подходят к стойке в общей очереди, но «обработчики» забирают клиентов по одному, как только заканчивают работу с предыдущим.\n\nИ там, и тут — очередь, организованная по принципу «первый пришёл — первый вышел» (First In First Out, FIFO), но за счёт различий в реализации в каждом случае удаётся получить оптимальное время на обслуживание клиентов.\n\nОчередь — важный примитив из простых абстрактных структур данных, более детально о ней поговорим в одном из параграфов.\n\nВ основе нашего хендбука — перевод интерактивного учебника [Ace Your Next Coding Interview by Learning Algorithms through Programming and Puzzle Solving](https://acecodinginterview.org/) (Alexander S. Kulikov, Pavel Pevzner), дополненный новыми практическими задачами и несколькими тематическими разделами.\n\nМы уверены, что по-настоящему разобраться в новом материале помогает глубокая практическая проработка — для закрепления новых знаний необходимо попробовать решить задачу и посмотреть на неё под разными углами, задать себе вопросы о возможном применении того или иного подхода, или способах его обобщить.\n\nОбязательно решайте практические задачи, закрепляйте свои знания.\n\nПроверка решений практических заданий проводится автоматически в системе Яндекс Контест. Мы подготовили наборы тестовых примеров, которые покрывают различные возможные ошибки в программной реализации алгоритмов. Если для какой-то из задач вы обнаружите, что решение проходит системные тесты, но при этом не является корректным, присылайте ваши дополнительные тесты, обязательно добавим их в задачу, чтобы улучшить ее качество.\n\nИ последнее, на чём хочется заострить внимание: в этой книге мы будем больше фокусироваться на проектировании подходов и создании эффективных алгоритмов — где-то не будем совсем строго доказывать корректность алгоритмов, а где-то только выпишем итоговую трудоемкость, но опять же не будем её строго обосновывать. Корректность и анализ трудоемкости (в худшем случае и в среднем) — очень важные части составления алгоритмов, но всему свое время, давайте погружаться постепенно.\n\nЖелаем вам удовольствия от познания нового, а ещё — успешного применения алгоритмических подходов в жизни, при трудоустройстве и в решении практических задач. Надеемся, что вы будете так же радоваться придуманным подходам, как радуемся мы.\n\nИ ещё кое-что: для этого хендбука у нас есть коммьюнити студентов. В нём можно найти единомышленников, обсудить материалы и задания. Вступить в него можно по [ссылке](https://t.me/handbook_algorithms). А чтобы быть в курсе обновлений хендбука — советуем [подписаться](https://forms.yandex.ru/surveys/algorythm) на рассылку.\n",
        "handbook": "Основы алгоритмов",
        "title": "Введение - Основы алгоритмов",
        "description": "Перед вами хендбук по алгоритмам от авторов, увлеченных красотой и элегантностью математики. В этой книге мы сделаем акцент на фундаменте построения алгоритмов и преобразовании их в программы."
    },
    {
        "path": "/handbook/algorithms/article/algoritmy-i-slozhnost",
        "content": "## Что такое алгоритм?\n\nАлгоритм — это последовательность указаний, которые нужно исполнить, чтобы решить чётко сформулированную задачу. Мы описываем задачи исходя из *ввода* и *вывода*, и алгоритм становится способом превращения ввода в вывод. При этом формулировка задачи должна быть точной и недвусмысленной — это помогает избежать неверной интерпретации.\n\nКогда вы закончили проектировать алгоритм, необходимо ответить на два важных вопроса: «Правильно ли он работает?» и «Сколько времени занимает выполнение?». Разумеется, вас не устроит алгоритм, который выдаёт правильный результат лишь в половине случаев или требует $1~000$ лет для поиска ответа.\n\n## Псевдокод\n\nЧтобы понять, как работает алгоритм, нам необходимо перечислить шаги, которые он выполняет. Для этого мы будем использовать *псевдокод* — язык, которым пользуются разработчики для описания алгоритмов. Он игнорирует многие детали, необходимые в языках программирования, но он более точен, чем рецепт из кулинарной книги.\n\n## Задача и экземпляр задачи\n\nЗадача описывает класс возможных входных данных. Экземпляр задачи — это один конкретный ввод такого класса. Чтобы продемонстрировать понятия задачи и экземпляра задачи, рассмотрим следующий пример. Вы оказались в книжном магазине и собираетесь купить книгу за $4,23$＄, расплатившись купюрой в $5$＄. Вам должны вернуть $77$ центов в качестве сдачи. Теперь кассир принимает решение, как именно это сделать. Согласитесь, неприятно получить горсть из $77$ пенни или $15$ никелей и $2$ пенни. Возникает вопрос: как выдать сдачу, не расстроив клиента? Большинство кассиров стараются уместить сумму сдачи в наименьшее количество монет.\n\n💡  Остановитесь и подумайте:\\\n*Каково минимальное количество монет номиналом* $(25, 10, 5, 1)$, необходимо для сдачи в $77$ центов?\n\nПример с $77$ центами представляет собой экземпляр задачи `Размен`. Предполагается, что есть $d$ номиналов, которые представлены массивом $c = (c_1, c_2, \\dotsc, c_d)$. Для упрощения будем считать, что номиналы даны в порядке убывания. Например, $c = (25, 10, 5, 1)$ для монет, используемых в США.\n\n### `Задача «Размен»`\n\n*Переведите определенное количество денег в данные номиналы, используя как можно меньше монет.*\n\n* Входные данные: Целое число $money$ и массив из $d$ номиналов\n  $c = (c_1, c_2, \\dotsc, c_d)$ в порядке убывания ( $c_1 > c_2 > \\dotsb > c_d$ ).\n* Выходные данные: Список из $d$ целых чисел $i_1, i_2, \\dotsc , i_d$, в котором $c_1\\cdot i_1+c_2 \\cdot i_2+\\dotsm+ c_d \\cdot i_d = money$ и $i_1 + i_2 +\\dotsm +i_d$ как можно меньше.\n\nКассиры по всему миру решают эту проблему с помощью простого алгоритма:\n\n```cpp\nChange(money, c, d):\n    while money > 0:\n        coin = ... // монета с самым большим номиналом, который не превышает money\n        // дать монету с номиналом coin клиенту\n        money = money - coin\n```\n\nВот быстрая версия **Change**:\n\n```cpp\nChange(money, c, d):\n    for k in range(1, d + 1) \n        i_k = floor(money / c[k]) // наибольшее количество монет номинала c[k]\n        // дать i_k монет с номиналом c[k] клиенту\n        money = money - c[k] * i_k\n```\n\n## Корректные и некорректные алгоритмы\n\nМы называем алгоритм корректным, если на каждый получаемый ввод он делает правильный вывод. Алгоритм считается некорректным, если хотя бы один ввод приводит к неправильному выводу.\n\n💡  Остановитесь и подумайте:\\\n*Каково минимальное количество монет номиналами* $(25, 20, 10, 5, 1)$, необходимое для сдачи в $40$ центов?\n\n`Change` — это некорректный алгоритм! Представьте сдачу в 40 центов, выданную в номиналах $c_1 = 25$, $c_2 = 20$, $c_3 = 10$, $c_4 = 5$ и $c_5 = 1$. `Change` привел бы к неправильному результату: он выдал бы 1 четвертак (25 центов), 1 дайм (10 центов) и 1 никель (5 центов) вместо 2 монет по двадцать центов. Хоть это и может выглядеть надуманно, в 1875 году в США существовала монета в двадцать центов. Насколько мы можем быть уверены, что `Change` выдаст минимальное количество монет в современных номиналах Соединенных Штатов или любой другой страны?\n\nЧтобы исправить алгоритм `Change`, нам нужно рассмотреть все возможные комбинации монет с номиналами $c_1, c_2, \\dotsc , c_d$, которые дают в сумме $money$, и выдать комбинацию с минимальным количеством монет. Мы рассматриваем только комбинации, в которых $i_1 \\le  money/c_1$ и $i_2 \\le money/c_2$ (в целом, величина $i_k$ не должна превышать $money/c_k$), в ином случае мы вернем большее количество денег, чем $money$. В псевдокоде, приведенном ниже, используется символ $\\sum$. Он обозначает суммирование: $\\sum^m_{i=1} a_i = a_1 + a_2 + \\dotsm + a_m$. Псевдокод также использует концепт «бесконечность» (обозначается $\\infty$) в качестве начального значения для $smallestNumberOfCoins$. Реализация описанного подхода на реальных языках программирования может различаться, но сейчас подробности для нас не важны.\n\n```cpp\nBruteForceChange(money, c, d):\n    smallestNumberOfCoins = ∞\n    for each combinations of coins (i_1,...,i_d)\n    // от (0,...,0) до (money/c[1],...,money/c[d])\n        valueOfCoins = ∑ i_k*c_k // сумма по всем k от 1 до d\n        if valueOfCoins = money:\n            numberOfCoins = ∑ i_k // суммарное количество монет\n            if numberOfCoins < smallestNumberOfCoins:\n                smallestNumberOfCoins = numberOfCoins\n                change = (i_1, i_2, ... ,i_d)\n    return change\n```\n\nЦикл повторяется с каждой возможной комбинацией $(i_1, \\dotsc, i_d)$ из $d$ индексов и останавливается, когда достигает\n\n$$\\left(\\frac{money}{c_1}, \\dotsc, \\frac{money}{c_d}\\right)\n$$\n\nКак мы можем узнать, что `BruteForceChange` не содержит ту же проблему, что и `Change`, — неверный результат при каком-то вводе? Раз `BruteForceChange` рассматривает все возможные комбинации номиналов, рано или поздно алгоритм придёт к оптимальному решению и запишет его в массив $change$. В любой комбинации монет, которая даёт в сумме $M$, должно быть как минимум столько же монет, сколько и в оптимальной. Таким образом, `BruteForceChange` никогда не завершит работу с неоптимальным набором $change$.\n\nНа данный момент мы ответили только на один из двух важных вопросов об алгоритмах: \"Работает ли он?\". Однако мы не ответили на вопрос: \"Сколько времени занимает выполнение?\".\n\n💡  Остановитесь и подумайте:\\\n*Сколько примерно итераций цикла `for` выполняет `BruteForceChange`?*\n\n* $money$\n* $money^d$\n* $d$\n\n## Быстрые и медленные алгоритмы\n\nНастоящие компьютеры требуют определенное количество времени на выполнение таких операций, как сложение, вычитание или проверка условий цикла while. Суперкомпьютер может выполнить сложение за $10^{-10}$ секунды, а калькулятор — за $10^{-5}$. Представьте, что у вас есть компьютер, которому требуется $10^{-10}$ секунды на выполнение простой операции (например, сложения), и вы знаете, сколько операций выполняет какой-то конкретный алгоритм. Вы могли бы рассчитать время выполнения алгоритма, просто взяв произведение количества операций и времени, которое занимает одна операция. Однако компьютеры постоянно улучшаются, благодаря чему им требуется меньше времени на операцию. Так, ваше представление о времени выполнения быстро стало бы устаревшим. Вместо того, чтобы рассчитывать время выполнения на каждом компьютере, мы описываем время выполнения через общее количество операций, необходимых алгоритму, — это характеристика самого алгоритма, а не компьютера, который вы используете.\n\nК сожалению, нам не всегда легко определить, сколько операций выполнит алгоритм. Однако если мы можем рассчитать количество базовых операций, выполняемых алгоритмом, то это позволит сравнить его с другим алгоритмом, решающим ту же задачу. Чтобы мучительно не подсчитывать каждое умножение и сложение, можно сравнивать только те участки кода, которые при увеличении размера ввода потребуют больше операций.\n\nПредставьте, что алгоритм $A$ выполняет $n^2$ операций при вводе размера $n$, и алгоритм $B$ решает ту же задачу за $3n+2$ операций. Какой алгоритм быстрее: $A$ или $B$? Хотя $A$ и может быть быстрее, чем $B$, при более малом значении $n$ (например, при $n$ между 1 и 3), $B$ будет быстрее при больших значениях $n$ (например, $n >4$). [См. рис.](#Placeholder-1-1). Так как $f(n)=n^2$ — это, в каком-то смысле, более «быстрорастущая» функция относительно $n$, чем $g(n)=n$. При этом константы 3 и 2 в $3n+2$ не влияют на конкуренцию между двумя алгоритмами при больших значениях $n$. Мы называем $A$ *квадратичным* алгоритмом и $B$ — *линейным*. $A$ менее эффективен, чем $B$, потому что он выполняет больше операций для решения задачи, когда значение $n$ большое. Так, иногда мы будем допускать неточности при подсчете операций алгоритма: поведение алгоритма при маленьком вводе неважно.\n\n<div id=\"Placeholder-1-1\"></div>\n\n![Group](https://yastatic.net/s3/education-portal/media/Group_1_e4f2b45a91_04c613f05b.svg)\n\nРассчитаем примерное количество операций, которое потребуется для `BruteForceChange` при вводе из $M$ центов и номиналов $(c_1, c_2, \\dotsc, c_d)$. Чтобы рассчитать общее количество операций в цикле for, нам необходимо взять примерное число операций, выполняемое при каждой итерации, и умножить его на общее количество итераций. В нашем случае количество операций можно оценить сверху величиной\n\n$$\\frac{money}{c_1} \\times \\frac{money}{c_2} \\times \\dotsm \\times \\frac{money}{c_d}\n$$\n\nТакой тип алгоритмов называется *экспоненциальным* в противоположность квадратичным, кубическим или другим *полиномиальным* алгоритмам. Выражение времени выполнения экспоненциального алгоритма использует $n^d$, где $n$ и $d$ — это параметры задачи (например, $n$ и $d$ можно произвольно сделать большими, изменив ввод для алгоритма). Время выполнения полиномиального алгоритма ограничено $n^k$, где $k$ — это константа, не связанная с тестовыми данными.\n\nНапример, алгоритм с временем выполнения $n^1$ (линейный), $n^2$ (квадратичный), $n^3$ (кубический) или даже $n^{2018}$ будет полиномиальным. Конечно, алгоритм с временем выполнения $n^{2018}$ не очень практичен. Возможно, даже менее практичен, чем некоторые экспоненциальные алгоритмы. Впрочем, разработчики тратят много усилий, чтобы проектировать всё более и более быстрые полиномиальные алгоритмы. Раз значение $d$ может быть большим при вызове алгоритма с большим количеством номиналов (например, $c = (1, 2, 3, 4, 5, \\dotsc , 100)$), мы видим, что выполнение `BruteForceChange` может потребовать много времени.",
        "handbook": "Основы алгоритмов",
        "title": " Алгоритмы и сложность - Основы алгоритмов",
        "description": "Для анализа алгоритма необходимо ответить на два важных вопроса: «Правильно ли он работает?» и «Сколько времени занимает его выполнение?». В этом параграфе мы познакомимся с характеристиками алгоритмов и задач, которые они решают."
    },
    {
        "path": "/handbook/algorithms/article/polnyj-perebor-i-optimizaciya-perebora",
        "content": "За полвека программисты обнаружили, что многие алгоритмы основаны на схожих концептах, хотя и используются для решения разных проблем. Получается, основных методов проектирования алгоритмов относительно немного. Некоторые из них мы охватим в задачах, а пока расскажем о наиболее распространённых. Последующие примеры можно будет категоризировать по методологии проектирования.\n\nДля демонстрации мы рассмотрим очень простую ситуацию, с которой может столкнуться едва ли не каждый обладатель беспроводного домашнего телефона.\n\n## Метод полного перебора\n\nАлгоритм, использующий полный перебор (также этот метод называют *исчерпывающий поиск* или метод *«грубой силы»*), рассматривает все возможные варианты и находит определенное решение. Если бы вы искали телефон по такому алгоритму, то игнорировали бы звонок и проверяли бы каждый квадратный сантиметр вашего дома. Вряд ли вы бы успели взять трубку, — иначе вашей удаче можно позавидовать, — но исчерпывающий поиск гарантирует, что рано или поздно вы найдете телефон, где бы он ни был.\n\n`BruteForceChange` — это алгоритм «грубой силы». Наши задачи включают несколько дополнительных примеров таких алгоритмов. Они самые легкие с точки зрения проектирования, но слишком медленные для решения более серьёзных задач, нежели самых маленьких. Мы советуем или избегать алгоритмов «грубой силы» или находить решения, которые ускоряют их работу.\n\n## Метод ветвей и границ\n\nЕсли рассмотреть варианты, предложенные алгоритмом «грубой силы», мы увидим, что многие из них можно опустить. Эта техника называется *методом ветвей и границ*.\n\nПредставьте, что вы прочёсываете первый этаж и слышите, как над вами звонит телефон. Значит, на первом этаже и в подвале можно больше не искать — и вы сэкономили себе время.\n\nХотя алгоритмы полного перебора и не подходят для построения эффективных алгоритмов, мы рекомендуем использовать их для стресс-тестирования — техники поиска ошибок в алгоритмах, подробнее о которой мы поговорим в [параграфе 4.3](https://education.yandex.ru/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie).\n\nИтак, параграф позади! Впереди вас ждут первые задачи. Но прежде чем приступить к ним, советуем сперва взглянуть на небольшой [гайд](https://education.yandex.ru/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii?utm_source=jobs&utm_medium=referral&utm_campaign=hrtech) о том, как пользоваться системой проверки заданий.",
        "handbook": "Основы алгоритмов",
        "title": "Полный перебор и оптимизация перебора - Основы алгоритмов",
        "description": "Метод полного перебора позволяет проанализировать все возможные исходы поставленной задачи и выбрать самый оптимальный. Перечисление возможных вариантов само по себе может оказаться нетривиальным и увлекательным."
    },
    {
        "path": "/handbook/algorithms/article/zhadnye-algoritmy",
        "content": "Многие алгоритмы — это итерационные процедуры: с каждым повтором они делают выбор из определенного количества вариантов. Например, для кассира задача «Размен» может быть представлена как последовательность решений: какую монету (из $d$ ценностей) вернуть первой, какую второй и так далее. Некоторые из этих вариантов приведут к правильному ответу, а некоторые — нет.\n\nПри каждом повторе жадный алгоритм выбирает «самый привлекательный» вариант. Например, самый большой номинал из доступных монет. В случае с американскими деньгами ``Change`` использует номиналы четвертак (25 центов), дайм (10 центов), никель (5 центов) и пенни (1 цент), чтобы выдать сдачу, в данном порядке. Разумеется, мы показывали, как такой «жадный» подход приводит к неправильным результатам при добавлении монет некоторых новых номиналов.\n\nВ примере с телефоном «жадная» стратегия состояла бы в том, чтобы идти на звук, пока вы его не найдете. Но есть проблема: между вами и телефоном может оказаться стена (или хрупкая ваза). К сожалению, такие сложности часто возникают и в реальных задачах. Во многих случаях «жадный» подход выглядит естественным и очевидным, но может оказаться неправильным.\n\nВ задаче «Бронирование переговорки» <!--([попробуйте решить ее онлайн!](https://discrete-math-puzzles.github.io/puzzles/activity-selection/index.html))--> вам дается несколько временных отрезков, и нужно выбрать как можно больше отрезков таким образом, чтобы ни один из них не пересекался с другим (отрезки пересекаются, если у них есть общая точка). Название задачи основано на следующей гипотетической ситуации. Представьте, что у вас есть зал для переговоров, и вам присылают заявки на бронирование 11 компаний.\n\n<table>\n<tr>\n    <td>1</td>\n    <td>01:00PM—05:00PM</td>\n</tr>\n<tr>\n    <td>2</td>\n    <td>01:45PM—03:00PM</td>\n</tr>\n<tr>\n    <td>3</td>\n    <td>01:00PM—02:00PM</td>\n</tr>\n<tr>\n    <td>4</td>\n    <td>05:45PM—06:15PM</td>\n</tr>\n<tr>\n    <td>5</td>\n    <td>01:45PM—02:15PM</td>\n</tr>\n<tr>\n    <td>6</td>\n    <td>04:00PM—04:30PM</td>\n</tr>\n<tr>\n    <td>7</td>\n    <td>03:00PM—04:00PM</td>\n</tr>\n<tr>\n    <td>8</td>\n    <td>03:00PM—05:45PM</td>\n</tr>\n<tr>\n    <td>9</td>\n    <td>01:30PM—03:15PM</td>\n</tr>\n<tr>\n    <td>10</td>\n    <td>02:30PM—03:30PM</td>\n</tr>\n<tr>\n    <td>11</td>\n    <td>04:45PM—05:30PM</td>\n</tr>\n</table>\n\nНельзя удовлетворить все запросы (так как некоторые из них пересекаются), но мы хотим удовлетворить как можно больше. Для этого мы представим входные данные более удобным способом.\n\n![ne_ochen_2_dbb705e077.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_2_dbb705e077_f9bd6402c4.svg)\n\nТак как мы говорим о «жадных» стратегиях, давайте поэкспериментируем с разными «наиболее выгодными» подходами. Интуиция может нам подсказать, что нужно выбрать самый короткий отрезок, удалить пересекающиеся отрезки и повторить данное действие.\n\n💡  Остановитесь и подумайте:   \n*Всегда ли это приведет к оптимальному решению?*\n\nНе факт. В примере ниже такая «жадная» стратегия предлагает решение из одного отрезка посередине. Однако есть и решение из двух отрезков, которые не накладываются друг на друга.\n\n![ne_ochen_3_ce1b90271e.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_3_ce1b90271e_c15414ffff.svg)\n\nВозможно, логичнее было бы выбрать отрезок слева (тот, что начинается раньше всех), убрать все остальные и повторить данное действие.\n\n💡  Остановитесь и подумайте:   \n*Всегда ли это приведет к оптимальному решению?*\n\nУвы, но нет.\n\n![ne_ochen_4_4130b9adb1.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_4_4130b9adb1_a7bda24d45.svg)\n\n💡  Остановитесь и подумайте:   \n*Может, есть и другие «жадные» подходы?*\n\nСкажем, что $[l,r]$ — «*чемпионский* отрезок», если значение его правой границы самое маленькое из всех: для любого другого интервала $[l',r']$, будет актуально $r \\le r'$.\n\nОказывается, что следующий «жадный» алгоритм максимизирует количество непересекающихся отрезков: выбрать чемпионский отрезок, убрать все пересекающиеся с ним отрезки, повторить выбор.\n\n✒️  Упражнение:   \n*Докажите, что если набор непересекающихся отрезков не содержит чемпионский отрезок,  то при замене первого отрезка в этом наборе на чемпионский мы получаем набор непересекающихся отрезков.*\n\nВот мы и нашли оптимальную «жадную» стратегию. И действительно, если существует решение задачи, включающее в себя чемпионский интервал, мы можем выбрать этот интервал на первом шаге и решить задачу выбора непересекающихся отрезков из оставшихся.\n\nВ нашем примере алгоритм работает следующим образом.\n- Выбрать сегмент $3$ и отбросить сегменты $1$, $2$, $5$, и $9$.\n- Выбрать сегмент $10$ и отбросить сегменты $7$ и $8$.\n- Выбрать сегмент $6$.\n- Выбрать сегмент $11$.\n- Выбрать сегмент $4$.\n\n![ne_ochen_5_5397d5a742.svg](https://yastatic.net/s3/education-portal/media/ne_ochen_5_5397d5a742_348a1dff84.svg)",
        "handbook": "Основы алгоритмов",
        "title": "Жадные алгоритмы - Основы алгоритмов",
        "description": "В этом параграфе мы рассмотрим пример задачи, решение которой итеративным методом с выбором самого привлекательного шага не всегда является корректным, но в то же время обоснованный подход приводит к элегантному эффективному алгоритму."
    },
    {
        "path": "/handbook/algorithms/article/dinamicheskoe-programmirovanie",
        "content": "Некоторые алгоритмы разбивают задачу на более мелкие подзадачи и используют решения подзадач, чтобы собрать решение для главной. Во время этого процесса количество подзадач может стать очень большим, и некоторые алгоритмы решают одну и ту же подзадачу многократно, что чрезмерно увеличивает время выполнения. Динамическое программирование упорядочивает вычисления и позволяет не вычислять уже известные значения повторно. Зачастую это экономит массу времени.\n\nЗадача со звонящим телефоном не подразумевает решения с помощью динамического программирования, поэтому мы рассмотрим другую. Представьте, что вместо ответа на звонок вы решаете поиграть в «Камни»<!-- ([попробуйте сыграть онлайн!](https://discrete-math-puzzles.github.io/puzzles/take-the-last-stone/index.html))-->: игру для двух игроков с двумя наборами камней по десять штук. С каждым ходом один игрок может взять один камень (из любого набора) или два камня (по одному из обоих). Когда камень забрали, он выходит из игры. Побеждает игрок, который заберет последний камень. Первый ход за вами. <!--Мы советуем сыграть в эту игру в нашей интерактивной головоломке.-->\n\nЧтобы найти стратегию для выигрыша в игре на $10+10$, мы можем составить таблицу, которую мы назовем $R$ ([рис.](#Placeholder-1-6)). Вместо того, чтобы решать задачу с $10$ камнями в каждом из наборов, мы решим более общую задачу с $n$ камней в одном наборе и $m$ камней в другом (игра на $n + m$), где $n$ и $m$ — это произвольные целые неотрицательные числа.\n\nЕсли игрок 1 может гарантированно выигрывать игру на $n + m$, тогда мы будем говорить, что $R(n,m) = W$. Если у игрока 1 нет стратегии для выигрыша против игрока, который всегда делает правильные ходы, мы будем писать $R(n,m) = L$. Вычисление $R(n,m)$ для произвольных $n$ и $m$ может звучать сложно, но мы воспользуемся результатами вычислений для меньших значений. Некоторые варианты игры, — в особенности $R(0,1)$, $R(1,0)$ и $R(1,1)$, — явно приведут к победе игрока 1, так как игрок 1 может выиграть первым ходом. Таким образом, мы заполняем ячейки $(1, 1)$, $(0, 1)$ и $(1, 0)$ как $W$. [рис. (a)](#Placeholder-1-6)\n\n![A_V_L_3_6225d05257.svg](https://yastatic.net/s3/education-portal/media/A_V_L_3_6225d05257_b328489074.svg)\n\nЗаполнив ячейки $(0, 1)$, $(1, 0)$ и $(1, 1)$, можно попробовать заполнить другие. Например, в случае с $(2, 0)$ единственный ход, который может сделать игрок 1, приводит к $(1, 0)$ — это выигрышный вариант для оппонента. Аналогичный анализ применим к случаю $(0, 2)$, что приводит к таблице из рис. [рис. (b)](#Placeholder-1-6).\n\nВ случае $(2, 1)$ игрок 1 может сделать три разных хода, которые приведут к $(1, 1)$, $(2, 0)$ и $(1, 0)$ соответственно. Один из этих случаев, $(2, 0)$, приводит к проигрышной позиции оппонента. Соответственно, $(2, 1)$ — это выигрышная позиция. Случаи $(1, 2)$ и $(2, 1)$ симметричны, поэтому мы получаем таблицу из рис. [рис. (c)](#Placeholder-1-6).\n\nТеперь мы можем заполнить $R(2,2)$. В случае $(2, 2)$ игрок 1 может сделать три разных хода, которые приведут к ячейкам $(2, 1)$, $(1, 2)$ и $(1, 1)$. Эти ячейки — выигрышные позиции для оппонента. Так, $R(2,2) = L$: см рис. [рис. (d)](#Placeholder-1-6).\n\nМы можем продолжить заполнять $R$, обращая внимание на то, что ячейка $(i, j)$ будет $L$, если ячейки сверху, слева и слева по диагонали будут $W$. Эти ячейки ($(i - 1, j)$, $(i - 1, j - 1)$ и $(i, j - 1)$) соответствуют трем ходам, которые может сделать игрок 1. См. рис. [рис. (e)](#Placeholder-1-6)\n\n\nАлгоритм ``Rocks`` определяет, выиграет игрок 1 или нет. Если игрок 1 выигрывает $n +m$, то ``Rocks`` выдаст $W$. Если игрок 1 проигрывает, то ``Rocks`` выдаст $L$. Мы ввели искусственное начальное условие, $R(0,0) = L$, чтобы упростить псевдокод.\n\n```cpp\nRocks(n, m):\n    R(0,0) = L\n    for i from 1 to n:\n        if R(i-1,0) = W:\n            R(i,0) = L\n        else:\n            R(i,0) = W\n    for j from 1 to m:\n        if R(0,j-1) = W:\n            R(0,j) = L\n        else:\n            R(0,j) = W\n    for i from 1 to n:\n        for j from 1 to m:\n            if R(i-1,j-1)=W and R(i,j-1)=W and R(i-1,j)=W:\n                R(i,j) = L\n            else:\n                R(i,j) = W\n    return R(n,m)\n```\n\nБолее быстрый алгоритм для решения этой головоломки опирается на простую закономерность в $R$ и проверяет, чётные $n$ и $m$ или нет. Если оба числа чётные, то игрок проигрывает (см. таблицу выше).\n\n```cpp\nFastRocks(n, m):\n    if n % 2== 0 and m % 2 == 0: // оба числа чётные\n        return L\n    else:\n        return W\n```\n\nТем не менее, хотя ``FastRocks`` и эффективнее, чем ``Rocks``, изменить его для схожих вариантов игры может быть сложно. Например, вариант, в котором игрок может убирать до трёх камней из наборов. Перед нами пример того, как более медленный алгоритм может быть полезнее, чем быстрый.\n<!--\n<blockquote>\n<summary>✒️  Упражнение:</summary>\nСыграйте в нашу интерактивную версию игры «Три камня» \n(<a href=\"https://discrete-math-puzzles.github.io/puzzles/three-rocks-game/index.html\">попробуйте онлайн!</a>) и составьте таблицу динамического программирования по аналогии с таблицей выше.\n</blockquote>\n\n<blockquote>\n<summary>Остановитесь и подумайте:</summary>\nКто выиграет в «Три камня» при начальной позиции $(7,5)$?\n</blockquote>\n-->",
        "handbook": "Основы алгоритмов",
        "title": "Динамическое программирование - Основы алгоритмов",
        "description": "Здесь мы найдём оптимальную стратегию действий в игре «Камни». Решив большее количество меньших экземпляров задачи, мы сможем гарантированно определить, какой из игроков непременно победит."
    },
    {
        "path": "/handbook/algorithms/article/rekursivnye-algoritmy",
        "content": "Рекурсия — одно из самых распространенных алгоритмических понятий. Если говорить просто, то рекурсивным алгоритм становится, если вызывает сам себя.\n\n<!-- (\\href{https://discrete-math-puzzles.github.io/puzzles/hanoi-towers/index.html}{попробуйте решить ее онлайн!}) -->\n\nГоловоломка *Ханойские башни* состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3. Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх. Изначально диски расположены на левом стержне (стержень 1), самый большой диск находится внизу. Диски в игре перемещаются по одному со стержня на стержень. Диск можно надеть на стержень, только если он пустой или верхний диск на нём большего размера, чем перемещаемый. Цель головоломки — перенести все диски со стержня 1 на стержень 3. Попробуйте нашу интерактивную версию Ханойских башен и узнайте, как переместить все диски с одного стержня на другой.\n\n**Ханойские башни**: *Вывод списка действий, необходимых для решения головоломки «Ханойские башни».*\n\n- Входные данные: Целое число $n$.\n- Выходные данные: Последовательность ходов для решения головоломки «Ханойские башни» из $n$ дисков.\n\nРешить головоломку с одним диском легко — просто переместите его на правый стержень. Головоломка на два диска ненамного сложнее. Сначала нужно переместить маленький диск на стержень посередине, а большой — на стержень справа. Затем переместить маленький диск на большой на правом стержне.\n\nВерсия на три диска чуть сложнее, но и ее можно решить с помощью следующих семи шагов:\n- Переместить диск со стержня 1 на стержень 3\n<!-- \\configlr{1}{0.6}{1}{1}{1}{1.4}{1}{7} -->\n![rekursiya_0001_ef6331f8c4.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0001_ef6331f8c4_9d45ad34b9.svg)\n- Переместить диск со стержня 1 на стержень 2\n<!-- \\configlr{1}{0.6}{1}{1}{7}{0.6}{1}{4} -->\n![rekursiya_0002_9fc278419e.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0002_9fc278419e_e34519691c.svg)\n- Переместить диск со стержня 3 на стержень 2\n<!-- \\configrl{1}{0.6}{4}{0.6}{7}{0.6}{7}{4} -->\n![rekursiya_0003_894b99b719.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0003_894b99b719_78f8c4177d.svg)\n- Переместить диск со стержня 1 на стержень 3\n<!-- \\configlr{1}{0.6}{4}{0.6}{4}{1}{1}{7} -->\n![rekursiya_0004_e61ffbeb44.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0004_e61ffbeb44_23c4fea123.svg)\n- Переместить диск со стержня 2 на стержень 1\n<!-- \\configrl{7}{0.6}{4}{0.6}{4}{1}{4}{1} -->\n![rekursiya_0005_25e49682f9.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0005_25e49682f9_776cb99099.svg)\n- Переместить диск со стержня 2 на стержень 3\n<!-- \\configlr{7}{0.6}{4}{0.6}{1}{0.6}{4}{7} -->\n![rekursiya_0006_ed39e917e8.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0006_ed39e917e8_f38f5201ca.svg)\n- Переместить диск со стержня 1 на стержень 3\n<!-- \\configlr{7}{0.6}{7}{1}{1}{0.6}{1}{7} -->\n![rekursiya_0007_8624a53a41.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0007_8624a53a41_d77b446295.svg)\n\nТеперь давайте посчитаем, сколько шагов потребуется для решения версии на четыре диска. Нам нужно обязательно переместить самый большой диск, но для этого придётся сперва поместить все остальные диски на пустой стержень. Если у нас не три диска, а четыре, то нужно переложить три верхних диска на пустой стержень (7 действий), а затем переместить самый большой диск (1 действие). Теперь нужно снова переместить три диска с «временного» стержня на самый большой диск (еще 7 действий). Весь процесс будет состоять из $7 + 1 + 7 = 15$ действий.\n\nОбобщим. Чтобы переместить $n$ дисков с левого стержня на правый, сначала необходимо переместить $n - 1$ дисков на стержень посередине. Затем, когда диск под номером $n$, самый большой, оказывается на правом стержне, нужно переместить на него оставшиеся диски со стержня посередине. Чтобы переместить $n-1$ дисков со стержня посередине направо, нужно сначала переместить $n-2$ дисков на стержень слева, затем переместить $(n-1)$-й диск вправо, потом переместить $n-2$ дисков с левого стержня на правый и так далее.\n\n\nНа первый взгляд задача «Ханойские башни» может показаться сложной. Тем не менее данный *рекурсивный алгоритм* находит нужные перемещения дисков всего за 8 строк!\n\n```cpp\n HanoiTowers(n,fromPeg,toPeg)\n    if n = 1:\n        output “Move disk from peg fromPeg to peg toPeg”\n        return\n    unusedPeg = 6 - fromPeg - toPeg\n    HanoiTowers(n−1,fromPeg,unusedPeg)\n    output “Move disk from peg fromPeg to peg toPeg”\n    HanoiTowers(n−1,unusedPeg,toPeg)\n```\n\nПеременные $fromPeg, toPeg$ и $unusedPeg$ указывают на три разных стержня. Таким образом, ``HanoiTowers(n, 1, 3)`` перемещает диски ($n$ шт.) с первого стержня на третий. Переменная $unusedPeg$ указывает, какой из трёх стержней можно использовать для временного хранения первых ($n-1$) дисков. Обратите внимание, что $fromPeg+toPeg+unusedPeg$ всегда равняется $1+2+3 = 6$. Таким образом, значение переменной $unusedPeg$ можно определить как $6 - fromPeg - toPeg$. Представленная таблица показывает результаты $6 - fromPeg - toPeg$ для всех возможных переменных $fromPeg$ и $toPeg$.\n\n#|\n||\n\nfromPeg\n\n|\n\ntoPeg\n\n|\n\nunusedPeg\n\n||\n||\n\n1\n\n|\n\n2\n\n|\n\n3\n\n||\n||\n\n1\n\n|\n\n3\n\n|\n\n2\n\n||\n||\n\n2\n\n|\n\n1\n\n|\n\n3\n\n||\n||\n\n2\n\n|\n\n3\n\n|\n\n1\n\n||\n||\n\n3\n\n|\n\n1\n\n|\n\n2\n\n||\n||\n\n3\n\n|\n\n2\n\n|\n\n1\n\n||\n|#\n\nОпределив $unusedPeg$ как $6 - fromPeg - toPeg$, операторы\n\n```cpp\nHanoiTowers(n−1,fromPeg,unusedPeg)\noutput “Move disk from peg fromPeg to peg toPeg”\nHanoiTowers(n−1,unusedPeg,toPeg)\n```\n\nвыполняют более простую задачу: они сначала перемещают $n-1$ дисков на временный стержень, затем перекладывают большой диск, а потом складывают на него оставшиеся $n-1$ дисков. Обратите внимание, что нет необходимости указывать, какой диск игрок должен переложить с $fromPeg$ на $toPeg$: перемещается всегда тот диск, что является верхним на $fromPeg$.\n\n💡  Остановитесь и подумайте:   \n*Сколько нужно действий, чтобы переместить $6$ дисков?*\n\nХотя решение Ханойских башен можно уложить в 9 строк псевдокода, его выполнение займет на удивление много времени. Решение головоломки на пять дисков состоит из 31 действия. А в решении башни из сотни дисков количество действий будет исчисляться “страшными” нонилионами. Такое резкое увеличение числа действий для ``HanoiTowers`` неудивительно. Заметим, что каждый раз, когда вызывается ``HanoiTowers(n, 1, 3)``, алгоритм дважды вызывает сам себя для перемещения $n-1$ дисков, что запускает четыре вызова для перемещения $n-2$ дисков и так далее.\n\nЭто можно проиллюстрировать с помощью *рекурсивного дерева*, изображенного на [рис.](#Placeholder-1-15). Вызов ``HanoiTowers(4, 1, 3)`` приводит к вызовам ``HanoiTowers(3, 1, 2)`` и ``HanoiTowers(3, 2, 3)``; каждый из них вызывает ``HanoiTowers(2, 1, 3)``, ``HanoiTowers(2, 3, 2)`` и ``HanoiTowers(2, 2, 1)``, ``HanoiTowers(2, 1, 3)`` и так далее. Каждый вызов подпрограммы ``HanoiTowers`` занимает определенное время. Мы хотим узнать, сколько времени уйдёт на такой алгоритм.\n\n![rekursiya_0008_00e69b0a23.svg](https://yastatic.net/s3/education-portal/media/rekursiya_0008_00e69b0a23_9d3d871a78.svg)\n\nЧтобы вычислить время выполнения ``HanoiTowers`` размера $n$, мы введём в рассмотрение функцию $T(n)$ — количество перемещений дисков, которые выполняет ``HanoiTowers(n)``. Получается следующее уравнение:\n\n$$\nT (n) = 2 \\cdot T (n - 1) + 1 \\, .\n$$\n\nНачиная с $T (1) = 1$, это рекуррентное соотношение задаёт последовательность:\n\n$$\n1, 3, 7, 15, 31, 63,\n$$\n\nи так далее. Мы можем вычислить $T (n)$, прибавив 1 с обеих сторон и обнаружив, что \n\n$$\nT (n) + 1 = 2 \\cdot T (n - 1) + 1 + 1 = 2\\cdot(T (n - 1) + 1) \\, . \n$$\n\nЕсли мы введём новое обозначение, $U(n) = T (n) + 1$, то $U(n) = 2 \\cdot U(n - 1)$. Таким образом, нужно решить следующее рекуррентное соотношение: \n\n$$\nU(n) = 2 \\cdot U(n - 1) \\, .\n$$\n\nНачиная с $U(1) = 2$, получаем последовательность\n\n$$\n2, 4, 8, 16, 32, 64, \\dotsc\n$$\n\nТо есть, $U(n) = 2^n$ и $T(n) = U(n) - 1 =2^n - 1$. Следовательно, ``HanoiTowers(n)`` — экспоненциальный алгоритм.",
        "handbook": "Основы алгоритмов",
        "title": "Рекурсивные алгоритмы - Основы алгоритмов",
        "description": "Насколько эффективно алгоритму вызывать самого себя? Зависит от реализации и задачи. На примере головоломки «Ханойские башни» составим короткий и элегантный рекурсивный алгоритм."
    },
    {
        "path": "/handbook/algorithms/article/razdelyaj-i-vlastvuj",
        "content": "Одна большая задача может казаться трудной. Но если разделить её на две задачи в два раза меньше, она станет намного проще. Для таких случаев хорошо подходят алгоритмы «разделяй и властвуй». Они так и работают: разделяют задачу на более мелкие подзадачи, независимо находят решения для них и соединяют результаты в решение изначальной задачи. Конечно, реальные ситуации бывают более сложными, чем мы описали. После разделения одной задачи на подзадачи, алгоритм обычно делит их на ещё более мелкие под-подзадачи и так далее. Он продолжает это делать, пока не дойдёт до точки, где в рекурсии уже нет необходимости. Важнейший шаг в работе с алгоритмами «разделяй и властвуй» — это соединить решения подзадач в решение изначальной задачи.\n\n<!-- %Зачастую такое слияние может отнять много времени. -->\n\nВ качестве примера алгоритма «разделяй и властвуй» приведём задачу сортировки:\n\n**Сортировка**: *Отсортируйте набор целых чисел.*\n\n* Входные данные: Список из $n$ разных чисел $a = (a_1, a_2, \\dotsc , a_n)$.\n* Выходные данные: Отсортированный список целых чисел. Измененный порядок $(b_1, b_2, \\dotsc , b_n)$ целых чисел от $a$, где $b_1 < b_2 < \\dotsb < b_n$.\n\n`SelectionSort` — это простой итерационный метод решения задачи по сортировке. Сначала он находит самый маленький элемент в $a$, а затем меняет его местами с первым элементом (то есть с $a_1$). Затем он находит второй самый маленький элемент в $a$ и переставляет его на второе место, меняя элемент местами с $a_2$. Повторяя это действие в $i$-й раз, `SelectionSort` находит $i$-й самый маленький элемент в $a$ и переставляет его на $i$-е место.\n\n<!-- %Это интуитивный подход к сортировке, но не самый быстрый. -->\n\nЕсли $a = (7, 92, 87, 1, 4, 3, 2, 6)$,\n`SelectionSort(a)` будет состоять из следующих семи шагов:\n\n![podelil](https://yastatic.net/s3/education-portal/media/podelil_i_prav_1_58a2cb49e7_a756bdced3_3ff4c6ff98.svg)\n\nВремя выполнения `SelectionSort` квадратично, то есть $O(n^2)$: используется $n$ итераций, для каждого из которых требуется время, чтобы просканировать не более $n$ элементов и найти самый большой из них для суффикса $a$. Обратите внимание, что $n^2$ — это завышенная оценка времени выполнения, так как при $i$-м повторе `SelectionSort` сканирует суффикс размером $n-i+1$: при первой итерации находится максимальное значение в массиве размера $n$, при второй итерации сканируется массив размера $n-1$ и так далее. Тем не менее общее время выполнения растёт как $n^2$:\n\n$$n+(n-1)+(n-2)+\\dotsb+2+1=\\frac{n(n+1)}{2} \\, \n$$\n\n`MergeSort` — классический пример алгоритма «разделяй и властвуй» для сортировки. Он намного быстрее, чем `SelectionSort`. Начнём с задачи *слияния*, в которой нам нужно будет объединить два отсортированных списка — $List_1$ и $List_2$ — в один отсортированный список.\n\n![podelil](https://yastatic.net/s3/education-portal/media/podelil_i_prav_2_bc0d6caefb_65f621501b.svg)\n\nАлгоритм `Merge` объединяет два отсортированных списка в один за время $O(|List_1| + |List_2|)$. Для этого алгоритм повторно выбирает самый маленький элемент из оставшихся в $List_1$ и $List_2$ и перемещает его в растущий отсортированный список.\n\n```cpp\nMerge(List_1,List_2):\n    SortedList = ... // empty list\n    while both List_1 and List_2 are non-empty:\n    if the smallest element in List_1 is smaller than the smallest element in List_2:\n        move the smallest element from List_1 to the end of SortedList\n    else:\n        move the smallest element from List_2 to the end of SortedList\n    move any remaining elements from either List_1 or List_2 to the end of SortedList\n    return SortedList\n```\n\n`Merge` — полезный инструмент для сортировки произвольного списка, если мы знаем, как разделить неотсортированный список на две отсортированные половины. Вам может показаться, что мы вернулись к тому, с чего начали, только теперь нам нужно отсортировать два меньших списка вместо одного большого. Но сортировка двух мелких списков — более предпочтительная алгоритмическая задача. Чтобы понять, почему это так, мы рассмотрим алгоритм `MergeSort`. Он разделяет неотсортированный список на две части и использует рекурсию для выполнения мелких задач перед тем, как объединить отсортированные списки.\n\n```cpp\nMergeSort(List):\n     if List consists of a single element:\n        return List\n     FirstHalf = first half of List\n     SecondHalf = second half of List\n     SortedFirstHalf = MergeSort(FirstHalf)\n     SortedSecondHalf = MergeSort(SecondHalf)\n     SortedList = Merge(SortedFirstHalf,SortedSecondHalf)\n     return SortedList\n```\n\n💡  Остановитесь и подумайте:\\\n*Каково время выполнения MergeSort?*\n\nНа [рис.](#Placeholder-1-18) изображено рекурсивное дерево `MergeSort`, состоящее из $\\log_2 n$ уровней, где $n$ — размер изначального неотсортированного списка. На нижнем уровне нам нужно объединить два отсортированных списка размером примерно в $n /2$ элементов, что займёт $O(n /2 + n /2)  = O(n)$ времени. На следующем самом высоком уровне нам нужно объединить четыре списка из $n /4$ элементов, что потребует $O(n /4 + n /4 + n /4 + n /4)  = O(n)$ времени. Такой шаблон можно описать следующим образом: $i$-й уровень состоит из $2^i$ списков, каждый из которых включает в себя приблизительно $n /2^i$ элементов и занимает $O(n)$ времени для объединения. Так как в рекурсивном дереве $\\log_2 n$ уровней, выполнение `MergeSort` потребует в общем $O(n   \\log_2 n)$ времени, что даёт нам большое ускорение по сравнению с более наивным $O(n^2)$ алгоритмом сортировки.\n\n![podelil](https://yastatic.net/s3/education-portal/media/podelil_i_prav_19_6fe3f4846e_cae8cddac4.svg)\n\n<!-- \\begin{myexercisebreakblock}\nИспользуйте стратегию «разделяй и властвуй», чтобы решить нашу\nинтерактивную головоломку из \\href{https://discrete-math-puzzles.github.io/puzzles/clock-game/index.html}{21 вопроса}.\n\\end{myexercisebreakblock} -->\n",
        "handbook": "Основы алгоритмов",
        "title": "Алгоритмы «Разделяй и властвуй» - Основы алгоритмов",
        "description": " Одна большая задача может казаться трудной. Но если разделить её на две задачи в два раза меньше, она станет намного проще. Для таких случаев хорошо подходят алгоритмы «разделяй и властвуй»."
    },
    {
        "path": "/handbook/algorithms/article/randomizirovannye-algoritmy",
        "content": "Если у вас есть монетка, то прежде чем начать искать телефон, вы можете подбросить её и решить, откуда начать поиск: если выпадет решка, то сначала ищем на первом этаже, если орёл — на втором. А для выбора конкретной комнаты можно использовать игральный кубик. Хотя бросать монеты и кубики весело, этот подход однозначно не интуитивен. К тому же непонятно, даёт ли это алгоритмическое преимущество по сравнению с детерминированным алгоритмом. Наши задачи помогут разобраться, в каких ситуациях вероятностные алгоритмы будут лучше детерминированных.\n\nЧтобы продемонстрировать пример вероятностного алгоритма, обсудим сначала быстрый метод сортировки, который называется ``QuickSort``. Для упрощения будем считать, что все элементы данного массива $c$ разные.\n\n``QuickSort`` выбирает элемент $m$ (например, первый) из $c$ и просто разделяет массив на два подмассива: $c_{small}$, в который входят все элементы $c$ меньше $m$; и $c_{large}$, в который входят все элементы больше $m$.\n\nЭто разделение можно выполнить за линейное время, далее, следуя стратегии «разделяй и властвуй», ``QuickSort`` рекурсивно сортирует каждый подмассив. Итоговый отсортированный список может быть легко получен с помощью конкатенации отсортированного $c_{small}$, элемента $m$ и отсортированного $c_{large}$.\n\n```cpp\nQuickSort(c):\n     if |c| = 1: // только один элемент\n        return c\n     m = c[1] // возьмем первый элемент c\n     // определим элементы c_small меньше m\n     // определим элементы c_large больше m\n     QuickSort(c_small)\n     QuickSort(c_large)\n     // объединим c_small, m и c_large в сортированный список c_sorted\n     return c_sorted\n```\n\nДля данного подхода требуется выделить дополнительную память, в которой будут храниться массивы $c_{small}$ и $c_{large}$. Лучший подход — переставить элементы входного массива *на месте*, чтобы набор $c_{small}$ шёл первым, затем $m$, а затем $c_{large}$ (см. ниже) — однако неясно, как это сделать.\n\n✒️  Упражнение:   \n*Нико Ломуто предложил изящный алгоритм, позволяющий выполнить такую перестановку элементов на месте. Рисунок ниже показывает, как работает <i>разбиение Ломуто</i>. Посмотрите на рисунок. Сможете ли вы воссоздать логику подхода Ломуто?*\n\n![random_1_1fea2a0c5d.svg](https://yastatic.net/s3/education-portal/media/random_1_1fea2a0c5d_c346249754.svg)\n\nОказывается, что время выполнения ``QuickSort`` зависит от нашей удачи при отборе элемента $m$. Если мы выберем $m$ так, что массив $c$ разделяется на две равные части (то есть $|c_{small}| = |c_{large}|$), тогда\n\n$$\nT(n) = 2T\\left(\\frac{n}{2}\\right) + a \\cdot n\\,, \n$$\n\nгде $T(n)$ означает время, которое требуется ``QuickSort`` для сортировки массива из $n$ чисел, и $a \\cdot n$ означает время, которое потребуется для разделения массива длины $n$ на две части; $a$ — положительная константа. Это абсолютно такое же рекуррентное соотношение, как и в ``MergeSort``, соответствующее времени выполнения $O(n \\log n)$.\n\nТем не менее если мы выберем $m$ так, что $c$ разделится неровно (например, возникает крайний случай, когда набор $c_{small}$ пуст, а в наборе $c_{large}$ $n-1$ элементов), тогда рекуррентное соотношение будет\n\n$$\nT(n) = T(n - 1) + a \\cdot n \\, .\n$$\n\nЭто соотношение и приводит к времени выполнения $O(n^2)$, а этого мы пытаемся избежать. Сортировка массива $(n, n - 1, \\dotsc , 2, 1)$ с помощью ``QuickSort`` действительно занимает квадратичное время. Что ещё хуже, на обработку $(1, 2, \\dotsc , n -1, n)$ требуется время $O(n^2)$. Это выглядит излишним, ведь массив уже отсортирован.\n\nПока что алгоритм ``QuickSort`` похож на плохую имитацию ``MergeSort``. Однако если мы сможем выбрать хороший «разделитель» $m$, который разбивает массив на две равные части, мы сможем улучшить время выполнения. На самом деле, не обязательно пытаться достичь идеального разделения (50/50), чтобы получить время выполнения $O(n \\log n)$. Например, также подойдет разделение на примерно равные части (скажем, 51/49). Фактически можно доказать, что алгоритм будет иметь время выполнения $O(n \\log n)$ при условии, что оба набора $c_{small}$ и $c_{large}$ больше, чем $n/4$.\n\nИз этого следует, что из $n$ возможных вариантов для $m$, выбранного в качестве элементов массива $c$, как минимум $\\frac{3n}{4}-\\frac{n}{4}=\\frac{n}{2}$ хорошо подойдут для разделения! Другими словами, если мы возьмем $m$ случайным образом (вероятность выбрать любой из элементов $c$ одинакова), то у нас будет шанс 50\\% получить хорошее разделение. Такой вывод ложится в основу следующего вероятностного алгоритма:\n\n```cpp\nRandomizedQuickSort(c):\n     if |c| = 1: //  только один элемент\n        return c\n     m = ... // возьмем случайный элемент из c\n     // определим элементы c_small меньше m\n     // определим элементы c_large больше m\n     RandomizedQuickSort(c_small)\n     RandomizedQuickSort(c_large)\n     // объединим c_small, m и c_large в сортированный список c_sorted\n     return c_sorted\n```\n\nНа практике ``RandomizedQuickSort`` — это быстрый алгоритм. Однако его худшее время выполнения остается $O(n^2)$, так как все еще есть вероятность, что он выберет плохой разделитель. При одном и том же вводе поведение вероятностного алгоритма отличается от одного выполнения к другому. Тем не менее мы можем доказать, что его *ожидаемое* время выполнения — $O(n\\log n)$. Слово «ожидаемое» подмечает следующий эффект.  Так как ``RandomizedQuickSort`` — это *вероятностный* алгоритм, два разных запуска (при одинаковом вводе) могут занять разное количество времени: некоторые будут быстрыми, некоторые — медленными.  Таким образом, время выполнения вероятностного алгоритма — это *случайная величина*. Разработчики нередко интересуются средним значением этой случайной величины, что и называется ожидаемым временем выполнения. Можно продемонстрировать, что для каждого массива размером в $n$ ожидаемое время выполнения ``RandomizedQuickSort`` будет $O(n\\log n)$.\n\n<!-- Доказательство этого можно найти\nв наших слайдах \\href{https://www.dropbox.com/s/nz9758zpcfwurxc/03_divide_and_conquer_5_quicksort.pdf?dl=0}{slides} для специализации Coursera. -->\n\nГлавное преимущество вероятностных алгоритмов — это производительность. Вероятностные алгоритмы решают многие реальные задачи быстрее (с точки зрения ожидаемого времени выполнения), чем детерминированные алгоритмы. Еще одна привлекательная особенность — это их простота. Она демонстрируется, например, в ``RandomizedQuickSort``.\n\nМы подчеркиваем, что хотя ``RandomizedQuickSort`` и принимает решения случайным образом, он всегда выдаёт правильное решение задачи сортировки. Единственный изменяющийся параметр от одного прогона к другому — это время выполнения, но не результат. В противоположность этому, другие вероятностные алгоритмы обычно приводят к неправильным (или точнее, *приблизительным*) решениям. Вероятностные алгоритмы, которые всегда дают верные решения, называются *Лас-Вегас*. Алгоритмы, которые не приводят к верным решениям — *Монте-Карло*.",
        "handbook": "Основы алгоритмов",
        "title": "Рандомизированные алгоритмы - Основы алгоритмов",
        "description": "Случайность в действиях алгоритма может приводить к неопределённости в точности результатов или времени работы. В этом параграфе спроектируем и оценим трудоёмкость рандомизированного алгоритма для задачи сортировки."
    },
    {
        "path": "/handbook/algorithms/article/prakticheskie-zadaniya-s-avtomaticheskoj-proverkoj",
        "content": "Чтобы рассказать, как работает наша система автоматической оценки, мы по шагам разберём две простые задачи. А заодно покажем несколько распространённых проблем и способы их преодоления.\n\nИтак, решение задач по программированию состоит из пяти шагов:\n\n- **Разбор условия задачи.** Формулировка задачи указывает формат ввода и вывода, ограничения для данных ввода и использования памяти. От вас требуется написать быструю программу, которая уложится в ограничения по времени и использованию памяти.\n\n- **Проектирование алгоритма.** Когда вы поняли, в чём состоит задача, начинайте проектировать алгоритм. Не забудьте доказать, что он работает правильно.\n\n- **Реализация алгоритма.** Когда алгоритм спроектирован, его можно реализовать в вашем языке программирования.\n\n- **Тестирование и отладка.** Тестирование — это искусство поиска багов. Отладка — это искусство устранения багов. Когда программа готова, приступайте к тестированию! А если обнаружите баг — исправьте его и протестируйте программу снова.\n\n- **Отправка программы на оценку.** Когда программа протестирована, сдайте её системе оценки. Если вы увидите сообщение ``OK``, значит всё в порядке. Если нет — возвращайтесь к предыдущим шагам.\n\n\n\n## Пять простых шагов для решения задачи по программированию\n\nНиже — краткий анонс того, чему мы научимся в этом параграфе.\n\n### Разбор условий задачи\n\nДля начала прочтите формулировку задачи. В неё входят описание вычислительной части, ограничения по времени и использованию памяти и несколько демонстрационных тестов. Убедитесь, что вы понимаете, как вывод соотносится с вводом в каждом из демонстрационных примеров.\n\nЕсли ограничения по времени и памяти не указаны прямо в формулировке задачи, используются следующие значения по умолчанию.\n- **Ограничение по времени (с):** 1\n- **Ограничение памяти:** 512 Mb\n\n### Проектирование алгоритма\n\nКогда вы разработали алгоритм, докажите, что он работает верно, и попробуйте оценить время выполнения с помощью самых сложных вводных данных, указанных в секции об ограничениях. Если ваш ноутбук выполняет около $10^8$–$10^9$ операций в секунду, и максимальный размер набора данных в описании задачи $n = 10^5$, тогда алгоритм с квадратичным временем выполнения вряд ли уложится в ограничение по времени (так как $n^2 = 10^{10}$), в то время как решение с временем выполнения $O(n\\log n)$ сможет это сделать. Тем не менее решение с $O(n^2)$ подойдёт, если $n=1\\,000$ и если $n=100$. Сработать могут даже решения с $O(n^3)$. Хотя для некоторых трудных задач в книге полиномиальные алгоритмы и остаются неизвестными, решение с временем выполнения $O(2^nn^2)$ может уложиться в ограничение по времени при $n$ ниже $20$.\n\n### Реализация алгоритма\n\nНачните реализацию алгоритма на одном из языков программирования, которые поддерживаются нашей системой автоматической оценки. Напоминаем, это: ``C++``, ``Java``, ``Python3``.\n\nДля ``C++``, ``Java``, и ``Python3`` есть примеры (авторские решения) с правильным решением задачи, учитывающие ее ограничения. Они тратят максимум 1/3 заданного лимита по времени и максимум 1/2 по памяти.\n<!--Вы также можете использовать другие языки. Для них мы рассчитали множители ограничений по времени.\nОднако мы не гарантируем, что на других языках существует правильное решение конкретной задачи, которое укладывается в эти ограничения.-->\n\n<!-- В приложении перечислены версии компиляторов и флаги, используемые системой оценки.}\\stepikcourseonly{\\href{https://stepik.org/lesson/63139/step/13?unit=40268}{Здесь} перечисляются версии компиляторов и флаги, используемые системой оценки.} Мы советуем использовать те же флаги компилятора при локальном тестировании. Это увеличит вероятность того, что ваша программа поведёт себя одинаково и на вашем компьютере, и на компьютере для тестирования (заметьте, что программа с багами может работать по-разному при компиляции на разных устройствах — или даже при одном и том же компиляторе с разными флагами -->\n\n### Тестирование и отладка\n\nСдавать вашу реализацию на оценку, не проверив ее, — это плохая идея! Начните с маленьких наборов данных и убедитесь, что ваша программа выдаёт верный результат со всеми предложенными наборами данных. Затем проверьте, сколько времени занимает обработка большого набора данных. Для оценки времени выполнения имеет смысл реализовать ваш алгоритм как функцию — например, ``solve(dataset)`` — и потом реализовать дополнительную процедуру ``generate()``, которая выдаст большой набор данных.\n\nНапример, если ввод задачи — это последовательность целых чисел длиной $1 \\le n \\le 10^5$, тогда сгенерируйте последовательность длиной $10^5$, передайте ее функции ``solve()`` и убедитесь, что программа выдает правильный результат.\n\nПроверьте ограничивающие значения, чтобы можно было гарантировать, что программа правильно обрабатывает и короткие (например, из 2 элементов), и длинные последовательности (например, из $10^5$ элементов). Если последовательность целых чисел от $0$ до $10^6$ даётся в качестве ввода — проверьте, как ваша программа ведёт себя с последовательностью $0,0,\\dotsc,0$ или с $10^6,10^6,\\dotsc, 10^6$. После этого проверьте программу на случайном наборе данных. Дополнительно советуем проверить экстремальные случаи: как пустой набор данных, три точки на одной строке, дерево из одного узла и так далее.\n\nУбедившись, что ваша программа выполняет все эти тесты, переходите к стресс-тестированию. Реализуйте медленный, но простой и верный алгоритм. Проверьте, выдают ли две программы одинаковый результат — однако обратите внимание, что это не применимо к задачам, в которых вывод не уникален. Сгенерируйте случайные тестовые сценарии, а также тесты с изменением параметров — например, с использованием только маленького диапазона больших чисел, строки с одной буквой ``a`` или только двумя разными буквами (вместо строк, использующих все буквы латинского алфавита) и так далее. Подумайте, какие ещё тесты могут быть в каком-то смысле необычными.\n\nНапример, если вы генерируете графы, попробуйте генерировать древовидные, несвязные, полные, двудольные и так далее. Если вы генерируете древовидные графы, попробуйте генерировать пути, двоичные деревья, звезды и так далее. Если вы генерируете целые числа, попробуйте генерировать и простые, и составные числа.\n\n### Использование системы проверки\n\nКогда вы закончили тестирование, сдавайте вашу программу на проверку! Перейдите на страницу, где сдаются задания, и создайте новое выполненное задание. Загрузите файл с вашей программой (обязательно загрузите исходный файл, а не готовое приложение). После этого система оценки скомпилирует вашу программу и использует набор тщательно продуманных тестов, чтобы убедиться, что программа выдаёт правильный результат для всех тестов и что она укладывается в ограничения по времени и памяти. В большинстве случаев оценка занимает около минуты, но в редких случаях, когда серверы загружены, может потребоваться больше времени. Пожалуйста, наберитесь терпения. После загрузки решения можно спокойно уходить со страницы.\n\nВ качестве результата вы получите обратную связь от системы оценки. Вам нужно получить вердикт ``OK`` — он обозначает, что ваша программа прошла все тесты. Сообщения ``Wrong answer``, ``Time limit exceeded``, ``Memory limit exceeded`` означают, что программа не прошла тест по одной из этих причин. Если ваша программа дает сбой, проходя один из первых двух тестовых сценариев, система оценки скажет вам об этом и покажет тестовый сценарий и вывод вашей программы. Это должно помочь вам использовать правильный формат ввода/вывода. В остальных случаях система оценки *не* будет показывать вам тестовый сценарий, который ваша программа не смогла выполнить.",
        "handbook": "Основы алгоритмов",
        "title": "Практические задания с автоматической проверкой - Основы алгоритмов",
        "description": "Сформулируем чеклист решения алгоритмической задачи: от разбора условия до анализа вердикта системы проверки."
    },
    {
        "path": "/handbook/algorithms/article/zadacha-summa-dvuh-chisel",
        "content": "Рассмотрим совсем простую задачу.\n\n* Входные данные: Целые числа $a$ и $b$ на одной строке (разделённые пробелом).\n* Выходные данные: Сумма $a$ и $b$.\n* Ограничения: $0 \\le a, b \\le 9$.\n* Пример\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n9 7\n\n|\n\n16\n\n||\n|#\n\n* Ограничение по времени (с): 1 секунда\n* Ограничение по памяти: 512 Mb.\n\nПоскольку задача решается в одно действие, шаг ``Спроектировать алгоритм`` мы пропустим и перейдём сразу к псевдокоду.\n\n```cpp\nSumOfTwoDigits(a, b):\n    return a + b\n```\n\nТак как псевдокод не уточняет ввод $a$ и $b$, ниже мы приводим решения для языков ``C++``, ``Java`` и ``Python3``, а также рекомендации по компиляции и реализации. Вы можете скопировать и вставить код в файл, скомпилировать, запустить и протестировать с разными данными, а затем сдать исходный файл в систему проверки. Разумеется, мы рассчитываем, что вы знакомы с основами одного из языков программирования, который используется в нашей системе тестирования: ``C++``, ``Python3``, ``Java``.\n\n### ``C++``\n<!-- %-[C++]\\hfill\n\\afivebookonly{\\mycppfilesmall{starters/sum_of_two_digits_book.cpp}}\n\\afourbookonly{\\mycppfile{starters/sum_of_two_digits_book.cpp}}\n%\\end{minipage} -->\n```cpp\n#include <iostream>\n\nint sum_of_digits(int first, int second) {\n    return first + second;\n}\n\nint main() {\n    int a = 0;\n    int b = 0;\n    std::cin >> a;\n    std::cin >> b;\n    std::cout << sum_of_digits(a, b);\n    return 0;\n}\n```\n\n### ``Java``\n<!-- %-[Java]\\hfill\n\\afivebookonly{\\myjavafilesmall{starters/SumOfDigits.java}}\n\\afourbookonly{\\myjavafile{starters/SumOfDigits.java}}\n%\\end{minipage} -->\n```java\nimport java.util.Scanner;\n\nclass SumOfTwoDigits {\n    static int sumOfTwoDigits(int first_digit, int second_digit) {\n        return first_digit + second_digit;\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int a = s.nextInt();\n        int b = s.nextInt();\n        System.out.println(sumOfTwoDigits(a, b));\n    }\n}\n```\n\n### ``Python3``\n<!-- %-[Python3]\\hfill\n\\afivebookonly{\\mypythonfilesmall{starters/sum_of_two_digits_book.py}}\n\\afourbookonly{\\mypythonfile{starters/sum_of_two_digits_book.py}}\n%\\end{minipage} -->\n```python\ndef sum_of_digits(first_digit, second_digit):\n    return first_digit + second_digit\n\nif __name__ == '__main__':\n    a, b = map(int, input().split())\n    print(sum_of_digits(a, b))\n```\n\nВаша цель — реализовать алгоритм, который дает верный результат с ограничениями по времени и памяти и при любом вводе. Нет необходимости проверять, что входные данные соответствуют ограничениям: например, в задаче ``Сумма двух чисел`` вам не нужно следить за тем, чтобы целые числа $a$ и $b$ действительно были однозначными числами (это гарантировано).",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Сумма двух чисел» - Основы алгоритмов",
        "description": "Что может быть проще поиска суммы двух чисел? Для решения задачи не потребуется продвинутых навыков программирования, поэтому сфокусируем внимание на оформлении алгоритма и системе автоматической проверки."
    },
    {
        "path": "/handbook/algorithms/article/zadacha-maksimalnoe-proizvedenie",
        "content": "Разберём чуть более сложную задачу. Итак, вам дана последовательность неотрицательных целых чисел $a_1, \\dots, a_{n}$. Вычислите\n\n$$\n\\max\\limits_{1 \\le i \\neq j \\le n}a_i \\cdot a_j \\, .\n$$\n\nОбратите внимание, что $i$ и $j$ должны быть разными, хотя в каких-то случаях можно наблюдать, что $a_i=a_j$.\n\n* Формат ввода: Первая строка содержит целое число $n$. Следующая строка содержит $n$ неотрицательных целых чисел $a_1, \\dotsc, a_{n}$ (разделены пробелами).\n* Формат вывода: Максимальное попарное произведение.\n* Ограничения: $2 \\le n \\le 2\\cdot10^5$; $0 \\le a_1, \\dots, a_{n} \\le 2\\cdot 10^5$.\n* Примеры\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br/>1 2 3\n\n|\n\n6\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10<br/>7 5 14 2 8 8 10 1 2 3\n\n|\n\n140\n\n||\n|#\n\n## Наивный подход\n\nНаивный способ решить задачу ``Максимальное произведение`` — перебрать все возможные пары вводных элементов $A[1\\dotsc n]=[a_1,\\dotsc, a_n]$ и найти пару, которая даёт наибольшее произведение.\n\n```cpp\nMaxPairwiseProductNaive(A[1..n]):\n    product = 0\n    for i from 1 to n\n        for j from 1 to n\n            if i != j\n                if product < A[i] * A[j]\n                    product = A[i] * A[j]\n    return product\n```\n\nЭтот код можно оптимизировать и сократить следующим образом.\n\n```cpp\nMaxPairwiseProductNaive(A[1..n]):\n    product = 0\n    for i from 1 to n\n        for j from i+1 to n\n            product = max(product, A[i] * A[j])\n    return product\n```\n\nРеализуйте этот алгоритм, используя ваш любимый язык программирования. Если вы используете ``C++``, ``Java`` или ``Python3``, вам могут пригодиться начальные заготовки (для всех задач из книги мы предлагаем стартовые заготовки с использованием этих трёх языков в интерфейсе тестирующей системы). С другими языками вам понадобится сделать работу с нуля.\n\nСтартовые заготовки решений для ``C++``, ``Java`` и ``Python3`` представлены ниже.\n\n### ``C++``\n<!-- \\afourbookonly{\\mycppfile{starters/max_pairwise_product.cpp}}\n\\afivebookonly{\\mycppfileverysmall{starters/max_pairwise_product.cpp}} -->\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint MaxPairwiseProduct(const std::vector<int>& numbers) {\n    int max_product = 0;\n    int n = numbers.size();\n\n    for (int first = 0; first < n; ++first) {\n        for (int second = first + 1; second < n; ++second) {\n            max_product = std::max(max_product,\n                numbers[first] * numbers[second]);\n        }\n    }\n\n    return max_product;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> numbers(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> numbers[i];\n    }\n\n    std::cout << MaxPairwiseProduct(numbers) << \"\\n\";\n    return 0;\n}\n```\n\n### ``Java``\n<!-- \\afourbookonly{\\myjavafile{starters/MaxPairwiseProduct.java}}\n\\afivebookonly{\\myjavafileverysmall{starters/MaxPairwiseProduct.java}} -->\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class MaxPairwiseProduct {\n    static int getMaxPairwiseProduct(int[] numbers) {\n        int max_product = 0;\n        int n = numbers.length;\n\n        for (int first = 0; first < n; ++first) {\n            for (int second = first + 1; second < n; ++second) {\n                max_product = Math.max(max_product,\n                    numbers[first] * numbers[second]);\n            }\n        }\n\n        return max_product;\n    }\n\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner(System.in);\n        int n = scanner.nextInt();\n        int[] numbers = new int[n];\n        for (int i = 0; i < n; i++) {\n            numbers[i] = scanner.nextInt();\n        }\n        System.out.println(getMaxPairwiseProduct(numbers));\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStream stream) {\n            try {\n                br = new BufferedReader(new\n                    InputStreamReader(stream));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n\n}\n```\n\n### ``Python``\n<!--\\afourbookonly{\\mypythonfile{starters/max_pairwise_product.py}}\n\\afivebookonly{\\mypythonfileverysmall{starters/max_pairwise_product.py}} -->\n```python\ndef max_pairwise_product(numbers):\n    n = len(numbers)\n    max_product = 0\n    for first in range(n):\n        for second in range(first + 1, n):\n            max_product = max(max_product,\n                numbers[first] * numbers[second])\n\n    return max_product\n\n\nif __name__ == '__main__':\n    _ = int(input())\n    input_numbers = list(map(int, input().split()))\n    print(max_pairwise_product(input_numbers))\n```\n\nПосле проверки вы можете увидеть такое сообщение:\n\n<pre>\nFailed case #4/17: time limit exceeded\n</pre>\n\nДело в том, что мы проверяем ваше решение на тестовых примерах — это помогает убедиться, что программа работает быстро и без ошибок. В результате мы, как правило, знаем, какие ошибки вы допустили. Сообщение выше говорит о том, что предложенная программа превышает ограничение по времени в 4-м тестовом примере из 17.\n\n💡  Остановитесь и подумайте:   \n*Почему решение не укладывается в ограничение по времени?*\n\n``MaxPairwiseProductNaive`` выполняет порядка $n^2$ шагов при последовательности длиной $n$. При максимальном возможном значении $n=2\\cdot 10^5$ количество шагов будет порядка $4\\cdot 10^{10}$. Так как большинство современных компьютеров выполняют около $10^8$–$10^9$ базовых операций в секунду (разумеется, это зависит от компьютера), выполнение ``MaxPairwiseProductNaive`` может занять десятки секунд. Это превысит временное ограничение задачи.\n\nНам нужен более быстрый алгоритм!\n\n## Быстрый алгоритм\n\nА что если внимательнее рассмотреть более мелкие примеры— скажем, $[5,6,2,7,4]$? Эврика! Достаточно помножить два самых больших элемента массива — $7$ и $6$.\n\nТо есть нам достаточно просканировать последовательность лишь дважды. При первом сканировании мы найдем самый большой элемент, затем — второй по величине.\n\n```cpp\nMaxPairwiseProductFast(A[1..n]):\n    index_1 = 1\n    for i from 2 to n\n        if A[i] > A[index_1]\n            index_1 = i\n    index_2 = 1\n    for i from 2 to n\n        if A[i] != A[index_1] and A[i] > A[index_2]\n            index_2 = i\n    return A[index_1] * A[index_2]\n```\n\n## Тестирование и отладка\n\nРеализуйте этот алгоритм и протестируйте его на вводе $A=[1,2]$. Как и ожидалось, алгоритм выводит $2$. Затем проверьте на вводе $A=[2,1]$. На удивление, алгоритм выводит $4$. Изучив код, вы обнаружите, что после первого цикла $index_1=1$. Далее алгоритм инициализирует $index_2$ значением $1$, и цикл for не обновляет $index_2$. В результате перед возвратом $index_1=index_2$. Чтобы этого избежать, необходимо изменить псевдокод следующим образом:\n\n```cpp\nMaxPairwiseProductFast(A[1..n]):\n    index_1 = 1\n    for i from 2 to n\n        if A[i] > A[index_1]:\n            index_1 = i\n    if index_1 = 1\n        index_2 = 2\n    else:\n        index_2 = 1\n    for i from 1 to n\n        if A[i] != A[index_1] and A[i] > A[index_2]\n            index_2 = i\n    return A[index_1] * A[index_2]\n```\n\nОпробуйте этот код на маленьких наборах данных $[7,4,5,6]$, чтобы убедиться, что он выдает правильные результаты. Затем попробуйте ввод.\n\n<pre>\n2  \n100000 90000  \n</pre>\n\nМожет оказаться, что программа выдает что-то вроде $410\\,065\\,408$ или даже отрицательное число вместо правильного результата — $9\\,000\\,000\\,000$. Вероятнее всего, это вызвано *целочисленным переполнением*. Например, на языке ``C++`` такое большое число, как $9\\,000\\,000\\,000$, не умещается в стандартный тип ``int``, который занимает 4 байта на большинстве компьютеров и варьируется от $-2^{31}$ до $2^{31}-1$ при\n\n$$\n2^{31}=2\\,147\\,483\\,648 \\,.\n$$\n\nСоответственно, вместо использования типа ``int`` в ``C++`` при вычислении произведения и сохранении результата вам нужно использовать тип ``int64_t``. Это предотвратит целочисленное переполнение, так как тип ``int64_t`` занимает 8 байтов и хранимые значения варьируются от $-2^{63}$ до $2^{63}-1$ при\n\n$$\n2^{63}=9\\,223\\,372\\,036\\,854\\,775\\,808 \\, .\n$$\n\nЗатем протестируйте вашу программу с большими наборами данных, например, с массивом $A[1 \\dotsc 2 \\cdot 10^5]$, где $A[i]=i$ для всех $1 \\le i \\le 2 \\cdot 10^5$. Это можно сделать двумя способами:\n- Создать массив в программе и передать его ``MaxPairwiseProductFast`` (чтобы не считывать его из стандартного ввода).\n- Создать отдельную программу, которая запишет такой массив в файл ``dataset.txt``. Затем передать этот набор данных вашей программе из консоли:\n\n<pre>\nyourprogram < dataset.txt\n</pre>\n\nУбедитесь, что при обработке данных ваша программа укладывается в ограничение по времени и выдаёт верный результат: $39\\,999\\,800\\,000$. Теперь вы можете быть уверенным, что ваша программа работает!\n\nОднако система оценки снова ругается:\n\n<pre>\nFailed case #5/17: wrong answer\n</pre>\n\nНо как создать такой тестовый сценарий, который приведет к сбою программы и поможет понять, что с ней не так?\n\n### А в чём ошибка?\n\nВероятно, вас интересует, почему мы не предоставили 5-й набор данных из 17 — тот, который привел к сбою программы? Причина проста: в реальности вам не будут показывать тестовые примеры.\n\nДаже опытные программисты при решении задач с алгоритмами часто совершают ошибки, которые трудно обнаружить. Поэтому важно научиться находить баги как можно раньше. Когда авторы этой книги только начинали программировать, они ошибочно полагали, что почти все их программы правильные. Сейчас же мы знаем, что при первом запуске наши программы *почти никогда* не верны.\n\nКогда разработчик уверен в работе своей программы, он зачастую использует всего лишь несколько примеров для тестирования. Если результаты выглядят приемлемо, он считает свою работу законченной — но это путь к катастрофе. Если вы хотите убедиться, что ваша программа работает *всегда*, то советуем тщательно подобрать примеры для тестирования. Реализация алгоритмов, а также их тестирование и отладка будут бесценным навыком для вашей будущей карьеры программиста.\n\n### Стресс-тестирование\n\nПредставляем вам *стресс-тестирование* — технику, которая позволяет генерировать тысячи тестовых сценариев. С её помощью можно найти тот, из-за которого провалилось ваше решение.\n\nСтресс-тестирование состоит из четырёх частей:\n- Реализация алгоритма.\n- Альтернативная, банальная и медленная, но правильная реализация алгоритма для той же самой задачи.\n- Генератор случайных тестов.\n- Бесконечный цикл, генерирующий тесты и передающий их обоим вариантам реализации для сравнения результатов. Если результаты разнятся, выводятся оба результата и пример для тестирования, а программа останавливается. В ином случае цикл повторяется.\n\nСтресс-тестирование основано на идее, что две правильных реализации с каждым тестом должны приводить к одному ответу (при условии, что ответ на задачу уникален). Однако если одна из реализаций неправильна, должен существовать такой тест, который приводит к разным ответам. Единственный случай, при котором это не так, — когда в обеих реализациях есть одна и та же ошибка. Но это маловероятно — если ошибка не где-то в программе ввода/вывода, общей для обоих решений. Действительно, если одно решение правильно, а другое — нет, то существует сценарий тестирования, при котором они различаются. Если оба решения неверны, но баги отличаются — скорее всего, есть тест, при котором два решения дают разные результаты.\n\nПродемонстрируем стресс-тестирование ``MaxPairwiseProductFast``, используя\n\n``MaxPairwiseProductNaive`` в качестве тривиальной реализации:\n\n```cpp\nStressTest(N, M):\n    while true:\n        n = ... // случайное целое число между 2 и N\n        // создать массив A[1..n]\n        for i from 1 to n\n            A[i] = ... // случайное целое число между 0 и M\n        print(A[1..n])\n        result_1 = MaxPairwiseProductNaive(A)\n        result_2 = MaxPairwiseProductFast(A)\n        if result_1 = result_2:\n            print(\"OK\")\n        else:\n            print(\"Wrong answer:\", result_1, result_2)\n            return\n```\n\nПредставленный выше цикл ``while`` сначала генерирует длину вводной последовательности $n$, случайное число между $2$ и $N$. Оно должно быть не менее $2$: формулировка задачи гласит, что $n \\ge 2$. Параметр $N$ должен быть достаточно маленьким, чтобы позволить нам рассмотреть множество тестов, несмотря на то, что наши решения медленные.\n\nСгенерировав $n$, мы генерируем массив $A$ с $n$ целыми числами от $0$ до $M$ и выводим его, чтобы по ходу бесконечного цикла мы всегда знали, какой тест проходит сейчас. Это упростит нахождение ошибок в коде для генерации теста. Затем мы вызываем два алгоритма для $A$ и сравниваем результаты. Если результаты отличаются, мы их печатаем и останавливаемся. В ином случае мы продолжаем цикл while.\n\nДавайте запустим ``StressTest(10, 100'000)`` и скрестим пальцы в надежде, что он выдаст ``Wrong answer``. Для нас это выглядит как-то так (результат может отличаться на вашем компьютере из-за другого генератора случайных чисел).\n\n<pre>\n...  \nOK  \n67232 68874 69499  \nOK  \n6132 56210 45236 95361 68380 16906 80495 95298  \nOK  \n62180 1856 89047 14251 8362 34171 93584 87362 83341 8784  \nOK  \n21468 16859 82178 70496 82939 44491  \nOK \n68165 87637 74297 2904 32873 86010 87637 66131 82858 82935  \nWrong answer: 7680243769 7537658370  \n</pre>\n\nУра! Мы нашли пример, в котором ``MaxPairwiseProductNaive`` и ``MaxPairwiseProductFast`` приводят к разным результатам, и теперь можем проверить, что именно пошло не так. Затем мы отлаживаем это решение через этот пример, находим баг, исправляем его и повторяем стресс-тестирование.\n\n💡  Остановитесь и подумайте:   \n*Видите что-то подозрительное в найденном наборе данных?*\n\nОбратите внимание, что генерировать тесты автоматически и проводить стресс-тестирование легко, но находить и исправлять баги — сложно. Прежде чем углубиться в отладку багов, давайте попробуем сгенерировать тестовый пример поменьше — это упростит нам работу. Для этого мы поменяем $N$ с 10 на 5 и $M$ с $100\\,000$ на $9$.\n\n💡  Остановитесь и подумайте:   \n*Почему мы сначала запустили ``StressTest`` с большими параметрами $N$ и $M$, а теперь хотим запустить с маленькими?*\n\nЗатем мы заново начинаем стресс-тестирование и получаем следующее:\n\n<pre>\n...  \n7 3 6  \nOK  \n2 9 3 1 9  \n2 3  \nWrong answer: 81 27  \n</pre>\n\nМедленный алгоритм ``MaxPairwiseProductNaive`` даёт верный ответ $81$ ( $9 \\cdot 9 = 81$ ), но быстрый ``MaxPairwiseProductFast`` — неверный ($27$).\n\n💡  Остановитесь и подумайте:   \n*Как может выйти, что ``MaxPairwiseProductFast`` выдаёт $27$?*\n\nЧтобы избавиться от багов в первом решении, давайте проверим, какие два числа он считает наибольшими. Для этого мы добавим следующую строку перед ``return`` в функции ``MaxPairwiseProductFast``:\n\n```Python\nprint(index_1, index_2)\n```\n\nКогда мы снова начинаем стресс-тестирование, мы получаем следующее:\n\n<pre>\n...  \n7 3 6  \nOK  \n2 9 3 1 9  \n2 3  \nWrong answer: 81 27  \n</pre>\n\n\nОбратите внимание, что наши решения работали и давали сбой на одних и тех же примерах тестирования, так как мы ничего не меняли в генераторе тестов. Он использует псевдослучайные числа при создании тестов вместо действительно случайных. Это значит, что последовательность выглядит случайной, но она одинакова каждый раз, когда работает программа. Такое свойство удобно и важно. Советуем вам использовать эту практику, потому что в детерминированных программах (тех, что всегда выдают одинаковый результат при одинаковых вводных данных) легче находить баги, чем в недетерминированных.\n\nДавайте теперь рассмотрим $index_1=2$ и $index_2=3$. Если мы обратим внимание на код для определения второго максимального числа, то заметим неочевидный баг. Когда мы использовали условие для $i$ (число не должно быть таким же, как предыдущее самое большое), вместо сравнения $i$ и $index_1$ мы сравнили $A[i]$ и $A[index_1]$. Это означает, что второе максимальное число отличается от первого по значению, а не по индексу элемента, который мы выбрали для решения задачи. Так, наше решение не работает при любом тесте, в котором второе самое большое число равно первому. Теперь изменим условие: вместо\n\n```cpp\nA[i] != A[index_1]\n```\n\nмы используем\n\n```cpp\ni != index_1\n```\n\nПроведя стресс-тестирование еще раз, мы видим на экране шквал сообщений ``OK``. Ждём минуту, пока нам не надоест, и заключаем, что ``MaxPairwiseProductFast`` наконец-то работает правильно!\n\nОднако не стоит останавливаться на этом, так как вы сгенерировали только очень маленькие тесты с $N=5$ и $M=10$. Теперь нужно проверить, работает ли наша программа при большем $n$ и бо́льших элементах массива. Таким образом, мы меняем $N$ на $1\\,000$ (при большем $N$ примитивное решение будет довольно медленным из-за квадратичного времени выполнения). Мы также меняем $M$ на $200\\,000$ и запускаем программу. Ещё раз наблюдаем, как экран заполняется сообщениями ``OK``. Затем ждём минуту, а потом решаем, что ``MaxPairwiseProductFast`` действительно работает верно. После этого мы сдаём получившееся решение системе оценки и успешно проходим тест!\n\nКак вы можете заметить, даже при решении такой простой задачи как ``Максимальное попарное произведение`` сложно избежать труднораспознаваемых ошибок на этапе проектирования и реализации алгоритма. Приведённый ниже псевдокод — это пример более ``надежного`` способа реализации алгоритма.\n\n```cpp\nMaxPairwiseProductFast(A[1..n]):\n    index = 1\n    for i from 2 to n\n        if A[i] > A[index]:\n            index = i\n    swap(A[index], A[n]) // поставим наибольшее значение в конец массива\n    index = 1:\n    for i from 2 to n - 1\n        if A[i] > A[index]:\n            index = i\n    swap(A[index], A[n - 1]) // поставим второй по величине элемент предпоследним\n    return A[n - 1] * A[n]\n```\n\nВ этой книге вы узнаете, как проектировать и реализовывать алгоритмы так, чтобы минимизировать вероятность ошибок. А заодно научитесь тестировать вашу реализацию.\n\n## Ещё более быстрый алгоритм\n\nАлгоритм ``MaxPairwiseProductFast`` находит два самых больших числа примерно за $2n$ сравнений.\n\n💡  Остановитесь и подумайте:   \n*Найдите два самых больших элемента в массиве за $1.5n$ сравнений.*\n\nКогда вы решите эту задачу, вас ждет ещё более сложное упражнение. Попробуйте с ним справиться!\n\n💡  Остановитесь и подумайте:   \n*Найдите два самых наибольших элемента в массиве за $n + \\lceil \\log_2 n \\rceil - 2$ сравнений.*\n\nЕсли это упражнение показалось вам слишком простым, посмотрите задачи ниже. Они вполне могут оказаться на следующем собеседовании!\n\n✒️  Упражнение:  \n*Докажите, что не существует алгоритма, которому потребуется менее $n + \\lceil \\log_2 n \\rceil - 2$ сравнений, чтобы найти два самых больших элемента массива.*\n\n✒️  Упражнение:  \n*Какой алгоритм найдёт три самых больших элемента быстрее всего?*\n\n\n## Более компактный алгоритм\n\nЗадачу ``Максимальное попарное произведение`` можно решить с помощью следующего компактного алгоритма, который использует сортировку (в неубывающем порядке).\n\n```cpp\nMaxPairwiseProductBySorting(A[1..n]):\n    Sort(A)\n    return A[n-1]*A[n]\n```\n\nЭтот алгоритм делает даже больше, чем нам нужно: вместо того, чтобы найти два самых больших элемента, он сортирует весь массив. Поэтому его время выполнения $O(n\\log n)$, а не $O(n)$. Однако для таких ограничений ($2 \\le n \\le 2 \\cdot 10^5$) он достаточно быстрый, чтобы выполнить задачу за секунду и успешно пройти тесты в нашей системе оценки.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Максимальное произведение» - Основы алгоритмов",
        "description": "Без ошибок практически невозможно написать программу. В этом параграфе мы рассмотрим подробнее, как их искать. А заодно поговорим о том, как подбирать корректные входные данные, чтобы проверить работоспособность алгоритма во всех сценариях."
    },
    {
        "path": "/handbook/algorithms/article/zadachi-o-chislah-fibonachchi",
        "content": "## Числа Фибоначчи\n\nПрежде чем начать, коротко напомним, что числа Фибоначчи — числовой ряд, при котором каждое последующее число равно сумме двух предыдущих.\n\nТакие числа определяются рекурсивно:\n\n$$\nF_n=\\begin{cases} n & \\text{при $n$ равном 0 или 1}\\\\\nF_{n-2}+F_{n-1} & \\text{при $n \\ge 2$}\\end{cases}\n$$\n\nЭто приводит к следующему рекурсивному алгоритму:\n\n```cpp\nFibonacci(n):\n     if n <= 1:\n        return n\n     else:\n        return Fibonacci(n−2)+Fibonacci(n−1)\n```\n\nРассмотрим совсем простую задачу.\n\n* Входные данные: Целое число $n$.\n* Выходные данные: $F_n$.\n* Ограничения: $0 \\le n \\le 45$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n2\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10\n\n|\n\n55\n\n||\n|#\n\n\n### Решение 1: Рекурсивный алгоритм\nНиже мы описываем простую реализацию рекурсивного псевдокода для **Python**. В неё входит инструкция по обнаружению багов, которая выводит то, что вычисляется в данный момент. Мы пробуем вычислить $F_7$ с помощью этого кода.\n\n```python\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        print(f'Computing F{n} recursively...')\n        return fibonacci(n - 2) + fibonacci(n - 1)\n\n\nprint(fibonacci(7))\n```\n\n```\nComputing F7 recursively...\nComputing F5 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F4 recursively...\nComputing F2 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F6 recursively...\nComputing F4 recursively...\nComputing F2 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F5 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\nComputing F4 recursively...\nComputing F2 recursively...\nComputing F3 recursively...\nComputing F2 recursively...\n13\n```\n\nКак видите, код даёт нам верный результат ($13$), но многие вычисления повторяются. Если вы решите вычислить $F_{150}$ с помощью этого кода, то Солнце потухнет раньше, чем компьютер выдаст вам результат.\n\n💡  Остановитесь и подумайте:   \n*Как вычислить $F_7$ вручную?*\n\n### Решение 2: Итерационный алгоритм\nСкорее всего вы бы взяли лист бумаги и написали что-то вроде:\n\n$$\n\\begin{align*}\nF_0&=0\\\\\nF_1&=1\\\\\nF_2&=0+1=1\\\\\nF_3&=1+1=2\\\\\nF_4&=1+2=3\\\\\nF_5&=2+3=5\\\\\nF_6&=3+5=8\\\\\nF_7&=5+8=13\n\\end{align*}\n$$\n\nВполне разумно попросить компьютер вычислить $F_n$ таким же *итерационным* способом:\n\n```cpp\nFibonacci(n):\n    if n <= 1:\n        return n\n    allocate an array F[0..n]\n    F[0] = 0\n    F[1] = 1\n    for i from 2 to n:\n        F[i] = F[i − 2] + F[i − 1]\n    return F[n]\n```\n\nПриблизительное количество операций, необходимых алгоритму, — $n$. Этот алгоритм хорошо работает на практике.\n\n💡  Остановитесь и подумайте:   \n*Можно ли обойтись без хранения всего массива?*\n\nКак вы могли заметить, нет необходимости хранить все числа последовательности Фибоначчи: чтобы вычислить текущее число, достаточно знать два предыдущих.\n\n```cpp\nFibonacci(n):\n    if n <= 1:\n        return n\n    previous = 0\n    current = 1\n    for iter in range(n-1):\n        oldPrevious = previous\n        previous = current\n        current = oldPevious + previous\n    return current\n```\n\n### Решение 3: Запоминание\nРекурсивный алгоритм требует так много времени, потому что он повторяет множество одинаковых вычислений: например ``Fibonacci(7)`` вызывает ``Fibonacci(3)`` пять раз. Не проще ли сохранить $F_3$, как только это значение вычислено, и при необходимости использовать сохранённое значение вместо того, чтобы вычислять его с нуля? Такой простой подход называется *мемоизация*: при вычислении чего-либо сохраните это в структуре данных, чтобы избежать повторных вычислений в будущем.\n\nДавайте добавим мемоизацию в рекурсивный алгоритм, чтобы сделать его практичнее.\n\n```cpp\ntable — некоторый ассоциативный контейнер (в table[i]  будем сохранять F[i])\n\nFibonacci(n):\n    if table[n] ещё не вычисляли:\n        if n <= 1:\n            table[n] = n\n        else:\n            table[n] = Fibonacci(n−2)+Fibonacci(n−1)\n    return table[n]\n```\n\nПо сравнению с изначальным рекурсивным алгоритмом этот сделает максимум $n+1$ «серьёзных» рекурсивных вызовов: для каждого $0 \\le i \\le n$ первый вызов ``Fibonacci(i)`` вычисляет $F_i$, сохраняя в $table[i]$; затем все дальнейшие вызовы ``Fibonacci(i)`` становятся просто поиском по таблице.\n\n\n## Последняя цифра числа Фибоначчи\n\n\n* Формат ввода: Целое число $n$.\n* Формат вывода: Последняя цифра $F_n$.\n* Ограничения: $0 \\le n \\le 10^6$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n2\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n139\n\n|\n\n1\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n91239\n\n|\n\n6\n\n||\n|#\n\n*Предупреждение:* будьте аккуратны с целочисленным переполнением. Значение $F_{139}=50\\,095\\,301\\,248\\,058\\,391\\,139\\,327\\,916\\,261$ превосходит диапазон стандартных целочисленных типов, а количество цифр в $F_{91239}$ более $19\\,000$, но последняя точно 6.\n\n### Решение: Взять каждое промежуточное звено по модулю 10\nДля решения этой задачи мы вычислим $F_n$ и просто выведем последнюю цифру последовательности:\n\n```cpp\nFibonacciLastDigit(n):\n    if n <= 1:\n        return n\n    F[0..n] — массив для промежуточных значений\n    F[0] = 0\n    F[1] = 1\n    for i from 2 to n:\n        F[i] = F[i − 1] + F[i − 2]\n    return F[n] mod 10\n```\n\nОбратите внимание, что числа Фибоначчи растут очень быстро. Например,  \n\n$$\nF_{100}=354\\,224\\,848\\,179\\,261\\,915\\,075.\n$$\n\nТаким образом, если вы используете типы C++ **int32** или **int64** для хранения $F$, вы быстро придёте к целочисленному переполнению. Если вы используете числа произвольной точности, например, **BigInteger** в Java или встроенные целые числа в Python, то вы заметите, что цикл проходит намного медленнее при повышающемся числе итераций.\n\n💡  Остановитесь и подумайте:   \n*Последняя цифра в $F_{102}$ — $6$ и последняя цифра в $F_{103}$ — $7$. Какова последняя цифра в $F_{104}$?*\n\nНесложно увидеть, что последняя цифра в $F_{104}$ равна $3$, и она полностью определена последними цифрами в $F_{102}$ и $F_{103}$. Это подсказывает нам, как сделать алгоритм практичнее: вместо вычисления $F_n$ и использования последней цифры можно взять *каждое промежуточное звено* по модулю 10.\n\nГлавный посыл этой задачи: когда вам нужно вычислить результат последовательности арифметических операций по модулю $m$, берите результат каждой операции по модулю $m$. Так можно гарантировать, что числа, с которыми вы работаете,  будут маленькими (они уместятся в стандартный тип языка программирования, который вы предпочитаете) и что арифметические операции с ними будут выполняться быстро.\n\n```cpp\nFibonacciLastDigit(n):\n    if n <= 1:\n        return n\n    F[0..n] — массив для промежуточных значений\n    F[0] = 0\n    F[1] = 1\n    for i from 2 to n:\n        F[i] = (F[i − 1] + F[i − 2]) mod 10\n    return F[n]\n```\n\n\n## Огромное число Фибоначчи\n\n![Algoritmy_3_0dff0b5b41.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_3_0dff0b5b41_c365b250aa.svg)\n\n* Формат ввода: Целые числа $n$ и $m$.\n* Формат вывода: $F_n \\bmod{m}$.\n* Ограничения: $1 \\le n \\le 10^{14}$, $2 \\le m \\le 10^3$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1 239\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n115 1000\n\n|\n\n885\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2816213588 239\n\n|\n\n151\n\n||\n|#\n\n*Предупреждение:* \n  - $F_1 \\bmod{239}=1\\bmod{239}=1$.\n  - $F_{115} \\bmod{1000}=483\\,162\\,952\\,612\\,010\\,163\\,284\\,885 \\bmod{1000} =885$.\n  - $F_{2\\,816\\,213\\,588}$ содержит миллионы цифр, но $F_{2\\,816\\,213\\,588} \\bmod{239}=151$.\n\n\n\n### Решение 1: Период Пизано\n\nВ этой задаче $n$ может быть настолько большим, что алгоритму потребуется слишком много времени, чтобы пройти через все числа Фибоначчи $F_i$ для $i$ от $0$ до $n$. Чтобы понять, как решить эту задачу, не проходя через все числа $F_0, F_1, \\dotsc, F_n$, взгляните на таблицу ниже:\n\n![1_a3ea272f09.webp](https://yastatic.net/s3/education-portal/media/1_a3ea272f09_69e1f2cfb4.webp)\n\n💡  Остановитесь и подумайте:  \n*Вы могли заметить в таблице необычные свойства в последних двух рядах.*\n\nОбе эти последовательности — периодические! Период для $m=2$ — $0 1 1$. Его длина — $3$. Для $m=3$ период будет $0 1 1 2 0 2 2 1$, и его длина — $8$.\n\n![2_5a84e87768.webp](https://yastatic.net/s3/education-portal/media/2_5a84e87768_658ad306de.webp)\n\n\nВ итоге, чтобы вычислить, например, $F_{2015} \\bmod{3}$, нам понадобится найти остальную часть $2015$ при делении на $8$. Так как $2015=251 \\cdot 8 + 7$, мы можем заключить, что $F_{2015} \\bmod{3} = F_{7} \\bmod{3}=1$.\n\nОказывается, что для любого целого числа $m \\ge 2$ последовательность $F_n \\bmod{m}$ будет периодической. Период всегда начинается с $0 1$. Он называется *период Пизано* (Фибоначчи также называют Пизано).\n\n✒️ Упражнение:   \n*Каким будет период $F_i \\bmod{5}$?*\n\n✒️ Упражнение:   \n*Докажите, что для каждого числа $m$ последовательность $F_i \\bmod{m}$ будет периодической.*\n\n✒️ Упражнение:   \n*Докажите, что период последовательности $F_i \\bmod{m}$ не превышает<br>$m^2$.*\n\n\nТаблица ниже демонстрирует, что последовательность $F_n \\bmod 10$ — периодическая. Последние цифры повторяются по периоду Пизано длиной $60$. Другими словами:\n\n$$F_n \\bmod 10 = F_{n \\bmod 60} \\bmod 10 \\, .$$\n\nНапример:\n![3_e8f4183dec.webp](https://yastatic.net/s3/education-portal/media/3_e8f4183dec_fef380f042.webp)\n\n\nЧтобы доказать, что последние цифры чисел Фибоначчи периодические, обратите внимание на пары остатков по модулю $m$, следующих друг за другом чисел Фибоначчи:\n\n![4_d1d78c7b28.webp](https://yastatic.net/s3/education-portal/media/4_d1d78c7b28_703f29ef6c.webp)\n\nКаждую из колонок таблицы можно вычислить на основе предыдущей колонки \n$\\begin{bmatrix} \n  a\\\\\n  b\\\\\n\\end{bmatrix}$ \nкак \n$\\begin{bmatrix} \n  b\\\\\n  (a+b) \\bmod m\\\\\n\\end{bmatrix}$. \nПо такой же логике колонка *перед* колонкой \n$\\begin{bmatrix} \n  a\\\\\n  b\\\\\n\\end{bmatrix}$ \nбудет \n$\\begin{bmatrix} \n  (b-a) \\bmod m\\\\\n  a\\\\\n\\end{bmatrix}$. \nСледовательно, для любой колонки в таблице выше можно однозначно определить соседей слева и справа. А значит, из любой позиции можно заполнить всю таблицу.\n\nПоскольку остатков по модулю $m$ только $m$, есть только $m^{2}$ возможных пар остатков, то есть максимум $m^{2}$ возможных колонок. Таким образом, некоторые колонки в таблице повторяются и будут это делать до бесконечности. \n\n![5_26c0c230fe.webp](https://yastatic.net/s3/education-portal/media/5_26c0c230fe_d13fbbffb7.webp)\n\n   \n✒️ Упражнение:        \n*Докажите, что первая повторяющаяся колонка таблицы для $F_n \\bmod m$ будет*\n\n$\n\\begin{bmatrix} \n  0\\\\\n  1\\\\\n\\end{bmatrix}\n$\n<br>  \n  \n💡  Остановитесь и подумайте:   \n*Почему период Пизано для $m=10$ будет $60$, а не $10^2=100$ — число всевозможных пар остатков по модулю $10$?*\n\nЭто наводит нас на следующий простой псевдокод, который рассчитывает период Пизано $m$ для произвольного остатка по модулю $m$.\n\n```cpp\nPisanoPeriod(m):\n    current = 0\n    next = 1\n    period = 0\n    while True:\n        oldNext = next\n        next = (current + next) mod m\n        current = oldNext\n        period = period + 1\n        if current = 0 and next = 1:\n            return period\n```\n\nОбъединяя изложенные идеи, получаем приемлемое по скорости работы решение.\n\n\n### Решение 2: Быстрое возведение матрицы в степень\n\nЕщё один способ вычислить $F_n \\bmod m$ — обратить внимание на то, что уравнения\n\n$$\n\\begin{align*}\n\tF_n & = 0 \\cdot F_{n-1} + 1 \\cdot F_n\\\\\n\tF_{n+1} & = 1 \\cdot F_{n-1} + 1 \\cdot F_n\n\\end{align*}\n$$\n\nмогут быть представлены как умножение матрицы $2\\times2$ — \n$\\begin{bmatrix} \n\t0 & 1\\\\\n\t1 & 1\\\\\n\\end{bmatrix}$\n— и вектора \n$\\begin{bmatrix} \n\tF_{n-1}\\\\\n\tF_n\\\\\n\\end{bmatrix}$:\n\n$$\n\\begin{bmatrix} \nF_n\\\\\nF_{n+1}\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix} \n0 & 1\\\\\n1 & 1\\\\\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix} \nF_{n-1}\\\\\nF_n\\\\\n\\end{bmatrix}\n$$\n\nСледовательно:\n$$\n\\begin{bmatrix} \nF_n\\\\\nF_{n+1}\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix} \n0 & 1\\\\\n1 & 1\\\\\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix} \nF_{n-1}\\\\\nF_n\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix} \n0 & 1\\\\\n1 & 1\\\\\n\\end{bmatrix}^2\n\\cdot\n\\begin{bmatrix} \nF_{n-2}\\\\\nF_{n-1}\\\\\n\\end{bmatrix}\n=\n\\dots\n=\n\\begin{bmatrix} \n0 & 1\\\\\n1 & 1\\\\\n\\end{bmatrix}^n\n\\cdot\n\\begin{bmatrix} \nF_0\\\\\nF_1\\\\\n\\end{bmatrix}\n$$\n\nПоэтому $F_n$ — просто элемент справа вверху $n$-й степени матрицы \n$\nM=\n\\begin{bmatrix} \n0 & 1\\\\\n1 & 1\\\\\n\\end{bmatrix}\n$.   \n<br>\n   \n\n💡  Остановитесь и подумайте:   \n*Примитивный способ вычислить $M^n$ потребует $(n-1)$ умножений матриц. Получится ли у вас сделать это, ограничившись $O(\\log n)$ умножениями матрицы?*\n\nМы продемонстрируем *быстрое возведение в степень* с помощью целых чисел вместо матриц. Имея целое число $x$, можно было бы примитивно вычислить $x^9$, используя умножение 8 раз. Однако есть и более быстрый способ вычислить $x^9$, используя умножение лишь 4 раза:\n\n$$\n\\begin{align*}\n\ty_1 &= x \\cdot x,\\\\\n\ty_2&=y_1 \\cdot y_1,\\\\\n\ty_3&=y_2 \\cdot y_2,\\\\\n\ty_4 &= y_3 \\cdot x.\n\\end{align*}\n$$\n\nВ целом, при чётном $n$ вычисление $x^n$ потребует выполнить умножение лишь еще один раз по сравнению с $y=x^{n/2}$, так как $x^n =x^ {n/2}  \\cdot x^{n/2}=y \\cdot y$. Если $n$ — нечетное, то вычисление $x^n$ потребует выполнить умножение лишь ещё два раза — по сравнению с $y=x^{(n-1)/2}$, так как $x^n=(x^ {(n-1)/2}  \\cdot x^{(n-1)/2}) \\cdot x=y \\cdot y \\cdot x$.\n\n```cpp\nFastIntegerExponentiation(x, n):\n    if n = 0:\n        return 1\n    if n % 2 == 0: # чётное значение\n        y = FastIntegerExponentiation(x, n/2)\n        return y * y \n    else: # нечётное значение\n        y = FastIntegerExponentiation(x, (n−1)/2)\n        return y * y * x \n```\n\nПоскольку каждый рекурсивный вызов ``FastIntegerExponentiation`` приводит к двум операциям умножения целых чисел и разделяет $n$ пополам, он выполнит максимум $2\\log n$ операций умножения.\n\nГоворя о числах Фибоначчи, напомним, что последовательность $F_n$ равна элементу в правом верхнем углу $M^n$.  Поскольку нас интересует $F_n$ по модулю $m$, мы просто берём каждый промежуточный результат по модулю $m$:\n\n```cpp\nFastMatrixExponentiation(D, n, m):\n    if n = 0:\n        return [[1, 0], [0, 1]] # единичная 2×2 матрица\n     if n % 2 == 0: # чётное значение\n        Y = FastMatrixExponentiation(D, n/2, m)\n        return Multiply2x2Matrices(Y, Y, m)\n     else:\n        Y = FastMatrixExponentiation(D, (n−1)/2, m)\n        Y2 = Multiply2x2Matrices(Y, Y, m)\n        return Multiply2x2Matrices(Y2, D, m)\n```\n\n```cpp\nMultiply2x2Matrices(A, B, m):\n\t  C[1][1] = (A[1][1]*B[1][1] + A[1][2]*B[2][1]) mod m\n\t  C[1][2] = (A[1][1]*B[1][2] + A[1][2]*B[2][2]) mod m\n\t  C[2][1] = (A[2][1]*B[1][1] + A[2][2]*B[2][1]) mod m\n\t  C[2][2] = (A[2][1]*B[1][2] + A[2][2]*B[2][2]) mod m\n\t  return C\n```\n\nНаконец, вычисление нужного значения выглядит следующим образом:\n\n```cpp\nFibonacciModuloM(n, m):\n\tM = [[0, 1], [1, 1]]\n\tP = FastMatrixExponentiation(M, n, m)\n\treturn P[0][1]\n```\n\n\n## Последняя цифра суммы чисел Фибоначчи\n\n* Формат ввода: Целое число $n$.\n* Формат вывода: $(F_0+F_1+\\dotsb+F_n) \\bmod{10}$.\n* Ограничения: $0 \\le n \\le 10^{14}$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3\n\n|\n\n4\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n100\n\n|\n\n5\n\n||\n|#\n\n**Подсказка.** Раз исчерпывающий поиск будет слишком медленным для этой задачи, попробуйте придумать формулу для $F_0+F_1+F_2+\\dotsb+F_n$. Для лучшего понимания поиграйте с маленькими значениями $n$. Затем используйте решение для предыдущей задачи.\n\n### Решение\n\nВ таблице ниже указаны первые одиннадцать чисел Фибоначчи и первые одиннадцать чисел $S_n=F_0+F_1+\\dotsm+F_n$.\n\n![6_816551dd43.webp](https://yastatic.net/s3/education-portal/media/6_816551dd43_f37ba1673f.webp)\n\n💡  Остановитесь и подумайте:   \n*Можете заметить сходства между последовательностями $F_0, \\dotsc, F_{10}$ и $S_0, \\dotsc, S_{10}$?*\n\nПохоже, что $S_n=F_{n+2}-1$. Давайте докажем это по индукции. Это условие определённо выполняется для первого шага ($n = 0$), так как $S_0 = F_2 -1$. Для шага с индукцией предположим, что утверждение верно для $0,1,\\dotsc,n$, и докажем его для $n+1$:\n\n$$\nS_{n+1}=F_0+F_1+\\dotsm+F_n+F_{n+1}=S_n+F_{n+1}=F_{n+2}-1+F_{n+1}=F_{n+3}-1 \\, .\n$$\n\nЕщё один способ прийти к формуле $S_n=F_{n+2}-1$ — сложить равенства.\n\n$$\n\\begin{aligned}\n&F_n       &=\\quad&F_{n+2}&-\\quad&{F_{n+1}}\\\\\n&F_{n-1} &=\\quad&{F_{n+1}}&-\\quad&{F_{n}}\\\\\n&F_{n-2} &=\\quad&{F_{n}}&-\\quad&{F_{n-1}}\\\\\n&\\phantom{F_{n-2}} & \\vdots &&\\\\\n&F_2      &=\\quad&{F_4}&-\\quad&{F_3}\\\\\n&F_1      &=\\quad&{F_3}&-\\quad&{F_2}\\\\\n&F_0      &=\\quad&{F_2}&-\\quad&F_1\\\\\n\\end{aligned}\n$$\n\nТак как элементы в правых частях взаимоуничтожаются, то сумма всех элементов справа — $F_{n+2}-F_1=F_{n+2}-1$, а сумма всех элементов слева будет $S_n$, \n\nТак задача сводится к тому, чтобы найти последнюю цифру в $F_{n+2}-1$. Благодаря предыдущей задаче мы знаем, как можно быстро это сделать: исходя из того, что период Пизано по модулю $10$ равен $60$, мы имеем\n\n$$\nF_{n+2} \\bmod 10 = F_{(n+2) \\bmod 60} \\bmod 10 \\, .\n$$\n\n## Последняя цифра частичной суммы чисел Фибоначчи\n\n* Формат ввода: Целые числа $m$ и $n$.\n* Формат вывода: $(F_m+F_{m+1}+\\dotsb+F_n) \\bmod{10}$.\n* Ограничения: $0 \\le m \\le n \\le 10^{14}$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3 7\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10 10\n\n|\n\n5\n\n||\n|#\n\n### Решение\n\nСумма *частичной* суммы чисел Фибоначчи равна разнице между двумя частичными суммами:\n\n$$\n\t F_0+F_1+F_2+F_3+F_4+F_5+F_6+F_7\n$$\n\n$$\n\t -F_0                                   -F_1-F_2\n$$\n\n$$\n\t =F_3+F_4+F_5+F_6+F_7\n$$\n\nБолее обобщённо,\n\n$$\n\\sum_{i=m}^{n}F_i = \\left(\\sum_{i=0}^{n}F_i\\right) - \\left(\\sum_{i=0}^{m-1}F_i\\right) \\, .\n$$\n\nБлагодаря предыдущей задаче мы знаем, как быстро вычислять префиксные, то есть первые элементы последовательности, суммы.\n\n## Последняя цифра суммы квадратов чисел Фибоначчи\n\n![Algoritmy_4_60e837783f.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_4_60e837783f_83764e3f70.svg)\n\n* Формат ввода: Целое число $n$.\n* Формат вывода: $F_0^2+F_1^2+\\dotsb+F_n^2 \\bmod{10}$.\n* Ограничения: $0 \\le n \\le 10^{14}$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7\n\n|\n\n3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n73\n\n|\n\n1\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1234567890\n\n|\n\n0\n\n||\n|#\n\n- $F_0^2+\\dotsb+F_{7}^2=273$.\n- $F_0^2+\\dotsb+F_{73}^2=1\\,052\\,478\\,208\\,141\\,359\\,608\\,061\\,842\\,155\\,201$.\n\n**Подсказка.** Раз алгоритм исчерпывающего поиска будет слишком медленным для этой задачи ($n$ может доходить до $10^{14}$), нам нужно найти простую формулу для $F_0^2+F_1^2+\\dotsb+F_n^2$. Рисунок выше представляет сумму $F_1^2+F_2^2+F_3^2+F_4^2+F_5^2$ как площадь прямоугольника с вертикальным ребром $F_5=5$ и горизонтальным ребром $F_5+F_4=3+5=F_6$.\n\n### Решение\n\nРисунок выше подсказывает, что для каждого неотрицательного целого числа $n$\n\n$$\nF_0^2+F_1^2+\\dotsb+F_n^2=F_n \\cdot F_{n+1} \\, .\n$$\n\nМы докажем это по индукции. Для двух первых случаев $n=0$ и $n=1$ получается:\n\n$$\nF_0^2=0=F_0F_1 \\text{ and } F_0^2+F_1^2=1=F_1F_2 \\, .\n$$\n\nДля шага с индукцией предположим, что $n \\ge 2$. Так,\n\n$$\n\tF_0^2+F_1^2+\\dotsb+F_n^2+F_{n+1}^2\n$$\n\n$$\n\t=(F_0^2+F_1^2+\\dotsb+F_{n}^2)+F_{n+1}^2 \\tag{шаг индукции}\n$$\n\n$$\n\t=F_nF_{n+1}+F_{n+1}^2\n\t=F_{n+1}(F_n+F_{n+1})\n\t=F_{n+1}F_{n+2} \\, .\n$$\n\nВ итоге остаётся вычислить последние цифры $F_n$ и $F_{n+1}$.",
        "handbook": "Основы алгоритмов",
        "title": "Задачи о числах Фибоначчи - Основы алгоритмов",
        "description": "Прежде чем начать, коротко напомним, что числа Фибоначчи — числовой ряд, при котором каждое последющее число равно сумме двух предыдущих."
    },
    {
        "path": "/handbook/algorithms/article/vychislenie-nok-i-nod",
        "content": "## Наибольший общий делитель\n\n![Algoritmy_1_896ef556d4.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_1_896ef556d4_6b68c3f619.svg)\n\nНаибольший общий делитель $\\operatorname{GCD}(a,b)$ двух положительных целых чисел $a$ и $b$ — это самое большое целое число $d$, на которое можно поделить $a$ и $b$ без остатка. Двадцать три века назад греческий математик Евклид впервые описал, как найти самый большой общий делитель.Однако нам до сих пор неизвестно имя математика, разработавшего этот алгоритм за век до Евклида. Спустя много веков алгоритм Евклида ещё раз обнаружили индийские и китайские астрономы. Теперь эффективный алгоритм, вычисляющий наибольший общий делитель, — важный ингредиент для современных криптографических алгоритмов.\n\nВаша задача — использовать алгоритм Евклида для вычисления $\\operatorname{GCD}$.\n\n* Формат ввода: Целые числа $a$ и $b$ (разделённые пробелом).\n* Формат вывода: $\\operatorname{GCD}(a,b)$.\n* Ограничения: $1 \\le a, b \\le 2\\cdot 10^9$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n18 35\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n28851538 1183019\n\n|\n\n17657\n\n||\n|#\n\n— Числа 18 и 35 не обладают общими нетривиальными делителями.\n— $28851538=17657 \\cdot 1634$, $1183019=17657 \\cdot 67$.\n\n### Примитивный алгоритм для вычисления наибольшего общего делителя\n\nПростой, но ужасно медленный способ вычислить наибольший общий делитель:\n\n```cpp\nGCD(a, b):\n    for d от min(a,b) вниз до 1:\n        if a % d == 0 and b % d ==0: // d делит a и d делит b\n            return d\n```\n\n💡  Остановитесь и подумайте:   \n*Если вы вычислили $\\operatorname{GCD}(a,b)$, можете ли вы сразу найти $\\operatorname{GCD}(a-b,b)$?*\n\nРисунок к задаче даёт нам простую, но чрезвычайно важную подсказку: если и $a$, и $b$ можно разделить на $d$, значит и $a-b$ можно разделить на $d$. Оказывается, что верно и обратное.\n   \n✒️ Упражнение:   \n*Докажите, что $\\operatorname{GCD}(a,b)=\\operatorname{GCD}(a-b,b)$ при $a \\ge b > 0$.*\n\nЭто наблюдение позволяет нам вычислить наибольший общий делитель,отнимая меньшее число от большего снова и снова.В конце концов одно из чисел дойдет до нуля. В таком случае мы просто возвращаем другое число (если $c>0$, то $\\operatorname{GCD}(c, 0)=c$).\n\n```cpp\nGCD(a, b):\n    while a > 0 and b > 0:\n        if a >= b:\n            a = a−b\n        else:\n            b = b−a\n    return max(a,b)\n```\n  \n✒️ Упражнение:   \n*Насколько этот алгоритм быстрый?*\n\nЭтот алгоритм всё ещё слишком медленный. Например, при $a=10^9$ и $b=7$ он продолжает отнимать $b$ от $a$ — более миллиона раз (в то время как изначальный алгоритм находит наибольший общий делитель при $a=10^9$ и $b=7$ моментально), так как ему нужно только пройти через $d=7,\\dotsc,1$. Но не беспокойтесь. Сейчас мы сделаем наш алгоритм эффективнее.\n\n💡  Остановитесь и подумайте:   \n*Что мы получим в итоге, если мы продолжим отнимать $b=7$ <br>от $a=10^9$?*\n\nПравильно! Мы получим 6 — остаток $10^9$ при делении на 7.\n\n💡  Остановитесь и подумайте:   \n*Если вы вычислили $\\operatorname{GCD}(a,b)$, можете ли вы сразу же найти $\\operatorname{GCD}(a, a \\bmod b)$? Например, $10^9 \\bmod 7$ будет $1$. Каково отношение между $\\operatorname{GCD}(10^9,7)$ и $\\operatorname{GCD}(10^9,1)$?*\n\n### Алгоритм Евклида\nСказанное выше приводит нас к алгоритму Евклида.\n\n```cpp\nGCD(a, b):\n    while a > 0 and b > 0:\n        if a >= b:\n            a = a % b\n        else:\n            b = b % a\n    return max(a,b)\n```\n\nЭто быстрый алгоритм: при любых $a,b \\le 2 \\cdot 10^9$, он вычисляет их наибольший общий делитель мгновенно. Для значений $a, b$ в этом диапазоне количество итераций цикла ``while`` не превышает сотни. Обоснование этого утверждения можно построить на факте, что после каждой итерации одно из чисел становится как минимум в два раза меньше.\n\n💡  Остановитесь и подумайте:   \n*Докажите, что при $a \\ge b$ верно $a \\bmod{b} < a/2$. Рассмотрите два случая: $b \\le a/2$ и $b > a/2$.*\n\nСледовательно, после максимум $\\log_2a + \\log_2b + 2$ итераций или $a$, или $b$ дойдёт до нуля. Так как $a, b \\le 2^{31}$, $\\log_2a + \\log_2b + 2 < 64$.\n\nВ качестве последнего комментария мы подметим, что такой же алгоритм можно использовать рекурсивно, занимая всего три строки кода.\n\n```cpp\nGCD(a, b):\n    if a = 0 or b = 0:\n        return max(a,b)\n    return GCD(b,a mod b)\n```\n\n## Наименьшее общее кратное\n\n![Algoritmy_2_8dc420a17b.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_2_8dc420a17b_ed5011a44e.svg)\n\nНаименьшее общее кратное $\\operatorname{LCM}(a,b)$ для двух положительных целых чисел $a$ и $b$ — это самое маленькое целое число $m$, которое можно разделить и на $a$, и на $b$.\n\nРисунок выше демонстрирует $\\operatorname{LCM}$ для каждой пары чисел $6$, $10$ и $15$, а также наименьшее общее кратное для всех трёх. Рисунок ниже показывает наибольший общий делитель для этих же чисел.\n\n💡  Остановитесь и подумайте:   \n*Какова связь между $\\operatorname{LCM}(a,b)$ и $\\operatorname{GCD}(a,b)$?*\n\n* Формат ввода: Целые числа $a$ и $b$ (разделённые пробелом).\n* Формат вывода: $\\operatorname{LCM}(a,b)$\n* Ограничения: $1 \\le a, b \\le 10^9$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6 8\n\n|\n\n24\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n761457 614573\n\n|\n\n467970912861\n\n||\n|#\n\n— Среди всех положительных целых чисел, которые можно разделить и на 6, и на 8 (например, 48, 480 и 24), 24 — наименьшее число.\n— Совет: для деления целых чисел в **Python3** используйте **//** (вместо **/**)\n\n### Решение\n\nДля обоснования соотношения $\\operatorname{LCM}(a,b) = \\dfrac{a \\cdot b}{\\operatorname{GCD}(a,b)}$ рассмотрим разложение $a$ и $b$ на простые множители.\n\nЕсли простое $p$ входит в разложение $a$ в степени $\\alpha$ и в разложение $b$ — в степени $\\beta$, то $\\operatorname{GCD}(a,b)$ делится на $\\min(\\alpha, \\beta)$, а $\\operatorname{LCM}(a,b)$ должно делиться на $\\max(\\alpha, \\beta)$. Для завершения обоснования формулы стоит использовать соотношение $\\alpha + \\beta = \\min(\\alpha, \\beta) + \\max(\\alpha, \\beta)$.",
        "handbook": "Основы алгоритмов",
        "title": "Вычисление НОК и НОД - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-razmen",
        "content": "Давайте реализуем простой жадный алгоритм, которым пользуются кассиры по всему миру. Предположим, что у кассира есть бесконечное количество монет всех номиналов.\n\n* Входные данные: Целое число $money$.\n* Выходные данные: Минимальное количество монет номиналами $1$, $5$, $10$, чтобы выдать сдачу $money$.\n* Ограничения: $1 \\le money \\le 10^3$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\n\n|\n\n2\n\n||\n|#\n \n* $2=1+1$.\n \n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n28\n\n|\n\n6\n\n||\n|#\n* $28=10+10+5+1+1+1$.\n\n* Ограничение по времени (с): 1 секунда.\n* Ограничение по памяти: 512 Mb.\n\n### Решение\n\nРассмотрим основную идею решения. Пока сдача положительна $money>0$, мы выбираем монету с самым большим номиналом, не превышающем $money$, отнимаем значение номинала выбранной монеты от $money$ и увеличиваем количество монет:\n\n```cpp\nChange(money):\n    numCoins = 0\n    while money>0:\n        if money >= 10:\n            money = money − 10\n        else if money >= 5:\n            money = money − 5\n        else:\n            money = money − 1\n        numCoins = numCoins + 1\n    return numCoins\n```\n\nТакже эту задачу можно решить в одну строку:\n\n```cpp\nreturn floor(money/10) + floor((money mod 10)/5) + (money mod 5)\n```\n\nПроектировать жадные алгоритмы просто, но вот доказывать их правильность — нередко сложная задача. И возможно, вас интересует, почему мы тратим время, чтобы доказать работоспособность очевидного алгоритма ``Change``. Дождитесь, пока мы попадем в алгоритмическую ловушку, и она убедит вас, что доказательство ниже — не трата времени.\n\nЧтобы доказать, что этот жадный алгоритм работает правильно, мы покажем, что выбор монеты с самым большим номиналом соответствует некому оптимальному решению.\n\nТо есть нам нужно доказать, что для каждого положительного целого числа $money$ существует оптимальный способ выдать сдачу с $money$, который использует как минимум одну монету с номиналом $D$, где $D$ — самое большое число из $1,5,10$, не превышающее $money$. Чтобы доказать это, мы рассмотрим несколько примеров. В каждом из примеров мы выбираем оптимальное решение (то есть конкретную сдачу с $money$) и преобразовываем его так, что количество монет не увеличивается и содержит как минимум одну монету с номиналом $D$. Мы также получаем $оптимальный$ способ выдать сдачу с $money$, который содержит монету $D$, если начинаем с $оптимального$ подхода к сдаче $money$.\n\n* $1 \\le money \\lt 5$. В этом случае $D=1$, и единственный способ выдать сдачу с $money$ — это использовать $money$ монет номиналом 1.\n* $5 \\le money \\lt 10$. В таком случае $D=5$. Безусловно, любая сдача с money будет состоять только из монет с номиналами 1 и 5. Если в неё не входит монета с номиналом 5, то входят как минимум пять монет номиналом 1 (так как $money \\ge 5$). Заменив их на одну монету номиналом 5, мы улучшим это решение.\n* $10 \\le money$. В таком случае $D=10$. Рассмотрим способ выдать сдачу с $money$ и предположим, что в нём не используется монета номиналом 10. Простое, но важное замечание: сумма некой подгруппы использованных монет — 10. Это можно продемонстрировать, рассмотрев количество монет номиналом 5 в данном решении: если таких монет нет, тогда есть как минимум десять монет номиналом 1, и мы заменяем их на одну 10; если есть лишь одна монета номиналом 5, тогда есть как минимум пять монет по 1, и мы снова заменяем все монеты на одну монету номиналом 10; если есть хотя бы две монеты по 5, тогда их снова можно заменить.\n\nХотя это доказательство длинное и довольно скучное, каждый раз, когда вы придумываете жадный алгоритм, вам нужно доказательство! Следующее упражнение показывает более компактный способ доказать правильность алгоритма выше.\n\n✒️  Упражнение:  \n*Продемонстрируйте, что money mod 5 монет номиналом 1 необходимы для любого решения, а остальные следует заменить монетами номиналами 10 и максимум одной монетой номиналом 5.*\n\n**Время выполнения.** Время выполнения алгоритма ``Change`` — $O(money)$, но его однострочная версия требует лишь несколько арифметических операций.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Размен» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-specii",
        "content": "Вор пробрался в лавку специй и нашёл там четыре фунта шафрана, три фунта ванили и пять фунтов корицы. В его рюкзак можно сложить до девяти фунтов, поэтому забрать всё он не сможет. Предположим, что цены на шафран, ваниль и корицу *$5000*, *$200* и *$10* соответственно. Как унести максимально дорогую добычу? Если вор заберёт $u_1$ фунтов шафрана, $u_2$ фунтов ванили и $u_3$ фунтов корицы, общая ценность украденного составит $5000\\cdot \\dfrac{u_1}{4} + 200\\cdot \\dfrac{u_2}{3} + 10\\cdot \\dfrac{u_3}{5}$. Вор хотел бы найти максимальное значение этого выражения при следующих ограничениях: $u_1 \\le 4$, $u_2 \\le 3$, $u_3 \\le 5$, $u_1+u_2+u_3 \\le 9$.\n\n* Входные данные: Первая строка ввода содержит $n$ специй и вместимость рюкзака $W$. Следующие $n$ строк указывают цену и вес специй. $i$-я строка включает в себя цену $c_i$ и вес $w_i$ $i$-й специи.\n* Выходные данные: Максимальное значение специй, которые вместятся в рюкзак.\n* Ограничения: $1 \\le n \\le 10^3$, $0 \\le W \\le 2 \\cdot 10^6$; $0 \\le c_i \\le 2 \\cdot 10^6$, $0 < w_i \\le 2 \\cdot 10^6$ для всех $1 \\le i \\le n$. Все числа — целые.\n* В дополнение: Хотя ввод для этой задачи состоит из целых чисел, вывести необходимо нецелое число. Таким образом, абсолютное значение разницы между ответом вашей программы и оптимальным значением не должно превышать $10^{-3}$. Для этого ваш ответ должен содержать не меньше четырёх цифр в дробной части (иначе даже правильно вычисленный ответ может стать неправильным из-за проблем с округлением).\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3 50<br>60 20<br>100 50<br>120 30\n\n|\n\n180\\.0000\n\n||\n|#\n\nЧтобы получить значение $180$, вор возьмёт и первую, и третью специи полностью.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1 10<br>500 30\n\n|\n\n166\\.6667\n\n||\n|#\n\nВору нужно забрать десять фунтов единственной доступной специи.\n\n**Совет**: по возможности старайтесь избегать чисел с плавающей дробной частью.\n\n\n### Решение\n\nОпределим *стоимость* специи $i$ как $\\frac{c_i}{w_i}$. Естественной стратегией для вора было бы брать как можно больше самой дорогой специи.\n\nЧтобы доказать, что эта стратегия приводит к оптимальному решению, рассмотрим самую дорогую специю $m$. Каков максимальный объём $a$ $m$-й специи, который вор может положить в рюкзак?\n\nВо-первых, она должна уместиться в рюкзак: $a \\le W$.\n\nВо-вторых, она не должна превышать доступный объём $m$-й специи: $a \\le w_m$. \n\nСледовательно, $a=\\min\\{w_m, W\\}$. Мы утверждаем, что существует оптимальное решение, включающее в себя $a$ фунтов $m$-й специи.\n\nЧтобы это доказать, рассмотрим оптимальное решение $u_1,\\dotsc,u_n$, при котором мы получаем максимальное количество $u_m$ самой дорогой $m$-й специи из всех оптимальных решений ($u_i$ означает количество $i$-й специи). Если $u_m=a$, то ничего доказывать не нужно. Иначе $u_m \\lt a$. Поэтому $u_m \\lt w_m$ и $u_m \\lt W$. \n\nРассмотрим два варианта.\n\n* При нынешнем решении $u_1+u_2+\\dotsc+u_n \\lt W$ рюкзак заполнен не до конца. Так как $u_m \\le w_m$, можно взять немного больше $m$-й специи: так, мы получаем новое решение, которое лучше и оптимальнее нынешнего.\n* Рюкзак заполнен до конца: $u_1+\\dotsc+u_m=W$. Так как $u_m \\lt W$, при подборе $i \\neq m$ можно получить $u_i \\gt 0$. Так, вместо маленького количества $i$-й специи, можно взять такое же количество $m$-й специи. Таким образом мы сохраним общий вес, но увеличим общую ценность и количество самой дорогой $m$-й специи в рюкзаке. Это противоречит идее, что в изначальном решении был максимум $m$-й специи.\n\nДоказав, что мы можем взять самой дорогой специи столько, сколько получится, мы можем спроектировать жадный алгоритм: взять как можно больше самой дорогой специи и повторить. Мы прекратим, когда больше не останется специй или когда рюкзак будет заполнен до конца. В псевдокоде, приведённом ниже, $Weight$ и $Cost$ — массивы, содержащие значения веса и цены.\n\n```cpp\nMaximumLoot(W, Weight, Cost)\n    if W=0 or Weight is empty:\n        return 0\n    m = the index of the most expensive item\n    amount = min(Weight[m], W)\n    value = Cost[m] / Weight[m] * amount\n    remove the m-th element from Weight and Cost\n    return value + MaximumLoot(W - amount, Weight, Cost)\n```\n\n**Время выполнения.** Время выполнения этого алгоритма — $O(n^2)$. При каждой итерации сканируется список специй и находится самая дорогая. Максимальное количество итераций — $n$, так как каждая итерация снижает количество рассматриваемых специй.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Специи» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-reklamnaya-kampaniya",
        "content": "![Algoritmy_5_126dc40255.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_5_126dc40255_0d9f9de72d.svg)\n\nПредставим, что вы владелец популярной страницы в интернете, на которой есть $n=3$ рекламных мест. Вы хотите продать их рекламодателям, которые рассчитывают на $clicks_1=10$, $clicks_2=20$ и $clicks_3=30$ кликов в день и при этом готовы платить $price_1=2$, $price_2=3$ и $price_3=5$ за клик. Как подобрать пары рекламных мест и рекламодателей так, чтобы получить максимальную прибыль? Например, доход от отмеченных голубым цветом пар, приведённых выше, составит $10 \\cdot 5 + 20 \\cdot 2 + 30 \\cdot 3 = 180$ долларов; от отмеченных чёрным — $10\\cdot 3 + 20 \\cdot 5 + 30 \\cdot 2=190$.\n\n* Входные данные: В первой строке приведено целое число $n$, во второй — последовательность целых чисел $price_1, \\dotsc, price_n$, в третьей — последовательность целых чисел $clicks_1, \\dotsc, clicks_n$.\n* Выходные данные: Максимальное значение $(price_1 \\cdot c_1 + \\dotsm + price_n \\cdot c_n)$, где $c_1, \\dotsc, c_n$ — это перестановка $clicks_1, \\dotsc, clicks_n$.\n* Ограничения: $1 \\le n \\le 10^3$; $0 \\le price_i,clicks_i \\le 10^5$ для всех $1 \\le i \\le n$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1<br>23<br>39\n\n|\n\n897\n\n||\n|#\n\n$897=23 \\cdot 39$.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br>2 3 9<br>7 4 2\n\n|\n\n79\n\n||\n|#\n\n$79=7 \\cdot 9 + 2 \\cdot 2 + 3 \\cdot 4$.\n\n### Решение\n\nСуть решения заключается в том, чтобы отдать самое популярное рекламное место самому дорогому объявлению. Вас вряд ли удивит, что жадный подход даст максимальную прибыль.\n\nПредположим, что $clicks_p$ и $price_q$ — самые большие элементы: $clicks_p \\ge clicks_i$ и $price_q \\ge price_i$ для всех $i=1,\\dotsc,n$. Мы утверждаем, что существует оптимальное решение, объединяющее $clicks_p$ с $price_q$.\n\nЧтобы доказать это, возьмём оптимальное решение и предположим, что в нём объединены $clicks_p$ и $price_{q'}$ для $q' \\neq q$ и $price_q$ и $clicks_{p'}$ для $p' \\neq p$. Покажем, что замена пар $(p,q')$ и $(p',q)$ на пары $(p,q)$ и $(p',q')$ только повысит прибыль.\n\nДавайте оценим, как такая замена повлияет на общую прибыль. До замены рассматриваемые элементы давали следующую прибыль:\n\n$$\nclicks_p\\cdot price_{q'}+clicks_{p'}\\cdot price_{q}\n$$\n  \nПосле замены: \n\n$$\nclicks_{p}\\cdot price_{q}+clicks_{p'}\\cdot price_{q'}\n$$\n   \nТаким образом, замена увеличивает общую прибыль на  \n\n$$\nclicks_{p} \\cdot price_{q}+clicks_{p'}\\cdot price_{q'} - clicks_p\\cdot price_{q'}-clicks_{p'}\\cdot price_{q}=(clicks_{p}-clicks_{p'})\\cdot(clicks_{q}-clicks_{q'}) \\ge 0\n$$\n\nЭто приводит нас к алгоритму, который объединяет рекламное объявление с максимальным количеством кликов за максимальную цену, исключает их из вариантов на рассмотрение и повторяет то же самое.\n\n```cpp\nRevenue(Click,Price):\n     revenue = 0\n     while clicks is not empty:\n        p = index with largest Click[p]\n        q = index with largest Price[q]\n        revenue = revenue+Clicks[p]⋅Price[q]\n        remove p-th element of Click\n        remove q-th element of Price\n     return revenue\n```\n\n**Время выполнения.**\nВремя выполнения этого алгоритма — $O(n^2)$. В каждой из $n$ итераций мы проводим линейное сканирование и находим два самых больших элемента. Также можно отсортировать эти два списка заранее, чтобы не искать самый большой элемент с нуля при каждой итерации. Это приводит нас к решению с временем выполнения $O(n\\log n)$.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Рекламная кампания» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-sbor-podpisej",
        "content": "![Algoritmy_6_e9b5ca9eb1.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_6_e9b5ca9eb1_47980c467a.svg)\n\nНа этот раз ваша задача — собрать подписи со всех жильцов дома. Вам известно время, в которое каждый из них будет у себя. Естественно, вам хочется собрать все подписи, заходя в дом минимальное количество раз. Для простоты давайте предположим, что вы, зайдя в дом, собираете подписи сразу со всех жильцов, которые на месте.\n\nВ дальнейшем под сегментом будем понимать интервал времени нахождения жильца в доме. Количество жильцов будет соответствовать количеству сегментов.\n\n* Входные данные: Количество сегментов в первой строке — $n$. Каждая из следующих $n$ строк содержит два целых числа $l_i$ и $r_i$ (разделены пробелом), которые указывают на координаты границ $i$-го сегмента.\n* Выходные данные: Минимальное количество $k$ точек на первой строке и координаты $k$ точек целыми числами (разделены пробелом) на второй строке. Выводить точки можно в любом порядке. При наличии нескольких наборов точек, можно вывести любой из них.\n* Ограничения: $1 \\le n \\le 100$; $0 \\le l_i \\le r_i \\le 10^9$ для всех $i$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br>1 3<br>2 5<br>3 6\n\n|\n\n1<br>3\n\n||\n|#\n\nВсе три сегмента $[1,3]$, $[2,5]$, $[3,6]$ содержат точку с координатами 3.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4<br>4 7<br>1 3<br>2 5<br>5 6\n\n|\n\n2<br>3 6\n\n||\n|#\n\nВторой и третий сегменты содержат точку с координатами $3$, в то время как первый и четвертый содержат точку с координатами $6$. Одной точкой покрыть все сегменты нельзя, так как $[1,3]$ и $[5,6]$ не пересекаются. В этом случае есть еще одно верное решение — точки 2 и 5.\n\n\n### Решение\n\nРешение заключается в выявлении сегмента с наименьшим значением правой границы.\n\nСамое маленькое значение границы сегмента: $r_m=\\min\\{r_1, \\dotsc, r_n\\}$. Мы утверждаем, что существует оптимальное решение, включающее в себя точку $r_m$. Чтобы доказать это, возьмём оптимальное решение $S$. Оно должно покрывать сегмент $[l_m,r_m]$, поэтому $S$ содержит точку $x$, что приводит к $l_m \\le x \\le r_m$. Если $x=r_m$, то наша работа закончена. Иначе $x \\lt r_m$. В этом случае мы можем заменить $x$ на $r_m$ в $S$.\n\n![Algoritmy_7_3d23de95dd.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_7_3d23de95dd_f38fae33bc.svg)\n\nПонятно, что это не меняет размер решения $S$. Чтобы доказать, что $S$ всё ещё является решением, подойдём от противного и предположим, что некий сегмент $[l_i,r_i]$ покрывается $x$, но не покрывается $r_m$. Это означает $l_i \\le x \\le r_i < r_m$ и противоречит тому, что $r_m$ — самое маленькое значение правой границы.\n\n\nТаким образом, мы приходим к следующему алгоритму:\n\n* добавить в решение минимальное значение правой границы $r_m$,\n* отбросить все сегменты, покрытые $r_m$,\n* повторить.\n\n```cpp\nSegmentsCover(segments):\n    points←empty set\n    while segments is not empty:\n        r_m = minimum right endpoint of a segment from segments\n        add r_m points\n        remove segments covered by r_m from the set segments\n    return points\n```\n\nНа рисунке ниже показан пример.\n\n![Algoritmy_8_648f5034e9.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_8_648f5034e9_b2a5a00662.svg)\n\nВремя выполнения составит $O(n^2)$, где $n=|segments|$, так как используется не более $n$ итераций цикла **while** (при каждой итерации отбрасывается как минимум один сегмент), и каждая итерация сводится к проверке списка $segments$ (одним сканированием находится значение $r$, а другим убираются сегменты, покрываемые $r$).\n\nЭтот алгоритм уже достаточно быстрый, чтобы успешно пройти оценку. Однако можно дополнительно сократить время выполнения с $O(n^2)$ до $O(n\\log n)$, если отсортировать сегменты от малых до больших значений правой границы и затем просто просканировать список один раз.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Сбор подписей» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-kolichestvo-prizov",
        "content": "Вы занимаетесь организацией соревнований для детей, и у вас есть $n$ конфет, которые собираетесь раздать в качестве призов. Вы хотите отдать эти конфеты тем, кто займёт первые $k$ мест в соревнованиях, и распределить конфеты так, чтобы за более высокое место всегда выходило больше конфет. Чтобы порадовать как можно больше детей, вам понадобится найти самое большое значение $k$, при котором это возможно.\n\n![algosy_6_5_1_c964476899.svg](https://yastatic.net/s3/education-portal/media/algosy_6_5_1_c964476899_f29fc8d130.svg)\n\n* Входные данные: Целое число $n$.\n* Выходные данные: Первая строка содержит максимальное число $k$, при котором $n$ можно представить как сумму $k$ пар неповторяющихся положительных целых чисел. Вторая строка — $k$ пар неповторяющихся положительных целых чисел, сумма которых будет $n$ (если есть несколько таких вариантов, то можно использовать любой из них).\n* Ограничения: $1 \\le n \\le 10^9$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n6\n\n|\n\n3<br>1 2 3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n8\n\n|\n\n3<br>1 2 5\n\n||\n|#\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2\n\n|\n\n1<br>2\n\n||\n|#\n\n✒️  Упражнение:  \n*Можно ли представить 8 как сумму четырёх неповторяющихся положительных целых чисел?*\n\nНетрудно понять, что ответ на этот вопрос: «Нет». Предположим, что $8=a_1+a_2+a_3+a_4$ и $a_1 \\lt a_2 \\lt a_3 \\lt a_4$ . Тогда $a_1 \\ge 1$, $a_2 \\ge 2$, $a_3 \\ge 3$ и $a_4 \\ge 4$. Однако тогда $a_1+a_2+a_3+a_4 \\ge 10$.\n\nПо этой же причине, если $n$ равно сумме $k$ неповторяющихся положительных целых чисел $a_1, \\dots, a_k$, то $n=a_1+\\dots+a_k \\ge 1+\\dots+k = \\frac{k(k+1)}{2}$. Верно и обратное: если $n \\ge \\frac{k(k+1)}{2}$, то можно представить $n$ как сумму $k$ неповторяющихся целых чисел.\n\nДействительно, пусть $\\delta=n - \\frac{k(k+1)}{2} \\ge 0$. Тогда $n$ будет равно сумме следующих целых чисел: $1, 2, \\dots, k-1,k+\\delta$. Несложно заметить, что все они отличаются друг от друга.\n\nАлгоритм состоит в нахождении самого большого значения $k$, при котором $\\frac{k(k+1)}{2} \\le n$.\n\nВремя выполнения — $O(k)$ или $O(\\sqrt{n})$.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Количество призов» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-maksimalnyj-oklad",
        "content": "Перед вами, возможно, самая важная задача в книге. В качестве последнего вопроса на собеседовании будущий начальник даёт вам пять бумажек с одним числом на каждой и просит составить из них самое большое число. Получившееся число — ваша зарплата, поэтому мотивация, чтобы решить эту задачу, зашкаливает.\n\nВспомните алгоритм для этой задачи, который работает с однозначными числами.\n\n```cpp\nLargestConcatenate(Numbers):\n    yourSalary = \"\" # пустая строка\n    while Numbers is not empty:\n        maxNumber = -infinity\n        for each number in Numbers:\n            if number >= maxNumber:\n                maxNumber = number\n        yourSalary = yourSalary + maxNumber # добавляем число в конец\n        Numbers.remove(maxNumber) # удалить из рассмотрения число maxNumber\n    return yourSalary\n```\n\nТакой алгоритм не всегда будет приводить к самой большой зарплате: например, при вводе из двух целых чисел 23 и 3 он выдаст 233, в то время как самое большое число — 323.\n\nНе беспокойтесь, чтобы получить самую большую зарплату, вам всего лишь нужно заменить строку\n\n```cpp\nif number >= maxNumber:\n```\nна следующую:\n\n```cpp\nif IsBetter(number, maxNumber):\n```\n\nДля надлежаще реализованной функции ``IsBetter`` нужно учесть порядок цифр и их количество. Функции ``IsBetter(first, second)`` должна возвращать булеву величину сооветствующую ответу на вопрос: нужно ли ставить число ``first`` раньше числа ``second``. Например, ``IsBetter(3, 23)`` выдаст ``True``.\n\n💡  Остановитесь и подумайте:   \n*Как бы вы реализовали ``IsBetter``?*\n\n* Входные данные:  Первая строка ввода содержит целое число $n$. Вторая строка содержит целые числа $a_1, \\dotsc, a_n$.\n* Выходные данные: Самое большое возможное число, которое состоит из $a_1, \\dotsc, a_n$.\n* Ограничения: $1 \\le n \\le 100$; $1 \\le a_i \\le 10^3$ для всех $1 \\le i \\le n$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2<br/> 21 2\n\n|\n\n221\n\n||\n|#\n\nОбратите внимание, что в этом случае приведённый выше алгоритм также выдаёт неправильный ответ 212.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5<br/>9 4 6 1 9\n\n|\n\n99641\n\n||\n|#\n\nВвод состоит только из однозначных чисел, поэтому алгоритм выше выдаёт правильный ответ.\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br/>23 39 92\n\n|\n\n923923\n\n||\n|#\n\nТем не менее алгоритм ``LargestConcatenate`` (неверный) в этом случае приводит к правильному результату — ещё одно напоминание, что всегда стоит проверять правильность жадных алгоритмов!\n",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Максимальный оклад» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/dvoichnyj-poisk",
        "content": "## Разделяй и властвуй\n\nВ этом параграфе вы узнаете об алгоритмах «разделяй и властвуй», которые помогают выполнять поиск по огромным базам данных в миллион раз быстрее, чем алгоритмы исчерпывающего поиска. Вооружившись этой техникой, вы узнаете, что стандартный способ умножать числа (которому вас учили в начальной школе) далеко не самый быстрый. Затем мы применим подход «разделяй и властвуй», чтобы спроектировать быстрые алгоритмы для сортировки. Вы узнаете, что эти алгоритмы оптимальны — то есть даже легендарный ученый Алан Тьюринг не смог бы спроектировать алгоритм сортировки быстрее!\n\n### Основная идея\n\nЕсли вы хотите решить задачу с помощью стратегии «разделяй и властвуй», вам нужно подумать о следующих трёх шагах:\n- Разделение задачи на подзадачи поменьше.\n- Рекурсивное решение каждой подзадачи.\n- Объединение выполненных подзадач в решение изначальной задачи.\n\nПервые два шага — это и есть «разделяй», а последний — «властвуй». Мы продемонстрируем такой подход в нескольких примерах, сложность которых будет возрастать.\n\n### Угадать число\n\nИгра «Угадать число» состоит в том, что оппонент загадывает целое число $1 \\le x \\le n$. Вы задаёте вопрос: «$x=y$?». Оппонент отвечает либо «да», либо «$x<y$» (то есть «мое число меньше»), либо «$x>y$» (то есть «мое число больше»). Ваша задача — получить ответ «да», задав минимальное количество вопросов.\n\nПусть $n=3$: ваша задача — угадать $1 \\le x \\le 3$, задав не больше двух вопросов. \n\nВы можете спросить: «$x=1$?». Если ответ положительный, то вы победили.Но оппонент может ответить: «$x>1$». Вы решаете, что $x$ равен $2$ или $3$, но у вас остаётся только один вопрос. Точно так же вы можете спросить: «$x=3$?». Тогда ваш оппонент может ответить: «$x<3$». В этом случае вы не сможете получить желаемый положительный ответ, задав лишь один вопрос.\n\nПосмотрим, что будет, если вы сначала спросите: «$x=2$?». Если оппонент отвечает, что $x=2$, тогда игра окончена. Если ответ — $x<2$, то вы уже знаете, что $x=1$. Следовательно, второй раз вы просто спрашиваете: «$x=1$?». И теперь вы получаете положительный ответ.Если оппонент ответит, что $x>2$, то вы спрашиваете: «$x=3$?». Ответ на него: «Да».\n   \n✒️ Упражнение:     \n*Угадать целое число $1 \\le x \\le 7$, задав не больше трёх вопросов.*\n\nВы уже могли догадаться, что мы начнём с вопроса: «$x=4$?». Дело в том, что в обоих случаях — $x<4$ и $x>4$ — мы сокращаем пространство поиска с 7 до 3 вариантов (нам уже известно, как решить задачу с $3$ возможными вариантами):\n- если $x<4$, то $x$ будет 1, 2 или 3;\n- если $x>4$, то $x$ будет 5, 6 или 7.\n\nЭто означает, что в обоих случаях вы можете воспользоваться решением разобранного ранее случая $n=3$. Получившийся протокол вопросов показан на рисунке.\n\nСледующий код имитирует процесс угадывания. Функция ``query`` «знает» целое число $x$. Вызов ``query(y)`` сообщает нам: $x=y$, или $x<y$, или $x>y$. Функция ``guess()`` находит число $x$ с помощью вызова ``query()``. Она вызывается с двумя параметрами: ``lower`` и ``upper``— так, чтобы\n\n$$\n\\texttt{lower} \\le x \\le \\texttt{upper},\n$$\n\nто есть $x$ находится в сегменте $[\\texttt{lower},\\, \\texttt{upper}]$. Сначала она рассчитывает середину (``middle``) сегмента $[\\texttt{lower},\\, \\texttt{upper}]$, затем вызывает $\\texttt{query(middle)}$. Если $x<\\texttt{middle}$, тогда она продолжает работать с интервалом $[\\texttt{lower},\\, \\texttt{middle - 1}]$. Если $x>\\texttt{middle}$, тогда она переходит к интервалу $[\\texttt{middle}+1,\\, \\texttt{upper}]$.\n\n```cpp\nquery(y):\n    x = 1618235\n    if x == y:\n        return 'equal'\n    if x < y:\n        return 'smaller'\n    else:\n        return 'greater'\n\n\nguess(lower, upper):\n    middle = (lower + upper) / 2 // целочисленное деление\n    answer = query(middle)\n    // можно напечатать запрос и соответствующий результат\n    if answer == 'equal':\n        return\n    if answer == 'smaller':\n        guess(lower, middle - 1)\n    else:\n        guess(middle + 1, upper)\n\n\nguess(1, 2097151) // начальный возможный диапазон значений\n```\n\nРеализуйте этот алгоритм, измените значение $x$ и запустите код, чтобы увидеть последовательность вопросов  (удостоверьтесь, что $x$ находится в сегменте, который используется при вызове ``guess``).\n\nВ целом стратегия, угадывающая целое число $1 \\le x \\le n$, потребует около $\\log_2 n$ вопросов. Напомним, что $\\log_2 n$ равняется $b$, если $2^b=n$. Это значит, что если мы продолжим делить $n$ на 2, пока не получим 1, будет около $\\log_2 n$ операций деления. Важно здесь то, что $\\log_2 n$ — *медленно растущая* функция. К примеру, если $n \\le 10^9$, то $\\log_2 n < 30$.\n\n### Поиск по отсортированным данным\n\nМетод, который мы использовали для угадывания числа, известен как *двоичный поиск*. Пожалуй, самый важный случай применения двоичного поиска — это поиск по отсортированным данным. Поиск — фундаментальная задача: имея последовательность и элемент $x$, мы хотим проверить, входит ли $x$ в последовательность. Например, 3 входит в последовательность $(7, 2, 5, 6, 11, 3, 2, 9)$, а 4 — не входит. Зная о важности задачи по поиску, неудивительно, что методы для её решения есть почти во всех языках программирования.\n\n```py\nprint(3 in [7, 2, 5, 6, 11, 3, 2, 9])\nprint(4 in [7, 2, 5, 6, 11, 3, 2, 9])\n```\n\nЧто происходит внутри, когда мы вызываем метод **in**? Ожидаемо, **Python** выполняет *линейное сканирование*. На это требуется $n$ сравнений при последовательности длиной $n$. Если в последовательность не входит $x$, нам необходимо просканировать все элементы: если мы будем пропускать, то мы не можем точно знать, отсутствует ли $x$.\n\nСитуация кардинально меняется, если полученные данные *отсортированы*, то есть составляют собой отсортированную последовательность $a_0, \\dotsc, a_{n-1}$ в порядке возрастания.\n\nОказывается, что в этом случае достаточно около $\\log_2 n$ сравнений! Это значительное ускорение: линейный поиск по отсортированному массиву с миллиардом элементов потребует миллиарда сравнений, двоичному же поиску будет достаточно не больше $\\log_210^9<30$!\n\n## Двоичный поиск\n\n![Algoritmy_13_e9bbfbf4d6.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_13_e9bbfbf4d6_0d32d91800.svg)\n\nВаша задача — найти индекс элемента в сортированной последовательности равного $q$.\n\n* Формат ввода: Отсортированный массив $K$ неповторяющихся целых чисел и целое число $q$. Первые две строки ввода содержат целое число $n$ и последовательность $k_0 < k_1 < \\dotsc < k_{n-1}$ из $n$ неповторяющихся положительных целых чисел в возрастающем порядке. Следующая строка содержит целое число $q$.\n* Формат вывода: Позиция элемента в $K$ равного $q$ или $-1$ при отсутствии такого элемента.\n* Ограничения: $1 \\le n \\le 3 \\cdot 10^4$; $1 \\le k_i \\le 10^9$ для всех $0 \\le i < n$; $1 \\le q \\le 10^9$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7<br>1 3 7 8 9 12 15<br>8\n\n|\n\n3\n\n||\n|#\n\n#### Пример 2\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7<br>1 3 7 8 9 12 15<br>12\n\n|\n\n5\n\n||\n|#\n\nМожно решить эту задачу примитивным способом — просканировать массив $K$ (время выполнения составит $O(n)$). Время решения этой задачи для алгоритма ``BinarySearch`` — $O(\\log n)$. Он инициализируется при присвоении $minIndex$ значения 0 и $maxIndex$ значения $n-1$. Сначала алгоритм присваивает $midIndex$ значение $(minIndex + maxIndex)/2$, а затем проверяет, больше $q$, чем $K[midIndex]$, или нет. Если $q$ больше, чем это значение, то ``BinarySearch`` проводит итерацию на подмассиве $K$ от minIndex до $midIndex-1$. В ином случае он проводит итерацию на подмассиве $K$ от $midIndex + 1$ до $maxIndex$. В конечном счёте алгоримт определит, находится $q$ в $K$ или нет.\n\n```cpp\nBinarySearch(K[0..n−1], q)\n    minIndex = 0\n    maxIndex = n−1\n    while maxIndex >= minIndex:\n        midIndex = (minIndex+maxIndex) / 2 // целочисленное деление\n        if K[midIndex] = q:\n            return midIndex\n        else K[midIndex] < q:\n            minIndex = midIndex + 1\n        else:\n            maxIndex = midIndex - 1\n    return -1\n```\n\nНапример, если $q = 9$ и $K = [1, 3, 7, 8, 9, 12, 15]$, ``BinarySearch`` сначала задаст следующее: $minIndex=0$, $maxIndex=6$ и $midIndex=3$. Так как $q$ больше, чем $K[midIndex] = 8$, мы рассматриваем подмассив, элементы которого больше $K[midIndex]$, установив $minIndex=4$, и таким образом $midIndex$ перевычисляется как $(4+6)/2 = 5$. В этот раз $q$ меньше, чем $K[midIndex] = 12$, поэтому мы рассматриваем подмассив, элементы которого ниже этого значения. Этот подмассив состоит из одного элемента — $q$.\n\nВремя выполнения ``BinarySearch`` составляет $O(\\log n)$, так как алгоритм снижает длину подмассива минимум в два раза при каждой итерации цикла ``while``. Обратите внимание: наша система оценки не может знать, использовали вы быстрый алгоритм с трудоёмкостью $O(\\log n)$ для поиска в отсортированном массиве или примитивный алгоритм с трудоёмкостью $O(n)$. Дело в том, что любой программе требуется линейное время для чтения данных ввода. По этой причине мы предлагаем вам решить следующую более общую задачу.\n\n## Множественный поиск ключей в отсортированной последовательности\n\n- **Вывод**: При каждом $q_i$ необходимо проверить, входит ли $q_i$ в $K$.\n\n\n* Формат ввода: Отсортированный массив $K$ неповторяющихся целых чисел и массив целых чисел \n$Q=[q_0,\\dotsc,q_{m-1}]$. Первые две строки ввода содержат целое число $n$ и последовательность $k_0<k_1< \\dotsc < k_{n-1}$ из $n$ неповторяющихся положительных целых чисел в возрастающем порядке. Следующие две строки содержат целое число $m$ и $m$ положительных целых чисел $q_0, q_1, \\dotsc, q_{m-1}$.\n* Формат вывода: Для всех $i$ от $0$ до $m-1$ выведите индекс $0 \\le j \\le n-1$, чтобы $k_j=q_i$ или $-1$ при отсутствии такого индекса.\n* Ограничения: $1 \\le n \\le 3 \\cdot 10^4$; $1 \\le m \\le 10^5$; $1 \\le k_i \\le 10^9$ для всех $0 \\le i < n$; $1 \\le q_j \\le 10^9$ для всех $0 \\le j < m$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7<br>1 3 7 8 9 12 15<br>1<br>8\n\n|\n\n3\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7<br>1 3 7 8 9 12 15<br>3<br>1 12 3\n\n|\n\n0<br>5<br>1\n\n||\n|#\n\n* Совет: не используйте встроенный двоичный поиск\n\n## Двоичный поиск с дублированием\n\nКак пишет автор книги *«Искусство программирования»* Дональд Кнут: «Хотя основная идея двоичного поиска относительно проста, детали могут быть на удивление сложными». Он подразумевает изменённую версию классической задачи двоичного поиска:\n\nКогда Кнут попросил профессиональных программистов из таких ведущих компаний, как IBM, реализовать эффективный алгоритм двоичного поиска с дублированием, в 90\\% из них были баги — год за годом. И правда, хотя первый алгоритм двоичного поиска был опубликован в 1946 году, первый алгоритм для поиска с дублированием, в котором не было багов, впервые опубликовали только в 1962 году.\n\nПо аналогии с предыдущей задачей здесь мы предлагаем найти $m$ целых чисел, а не одно.\n\n* Формат ввода: Первые две строки ввода содержат целое число $n$ и последовательность $k_0 \\le k_1 \\le \\dotsb \\le k_{n-1}$ из $n$ положительных целых чисел в неубывающем порядке. Следующие две строки содержат целое число $m$ и $m$ положительных целых чисел $q_0, q_1, \\dotsc, q_{m-1}$.\n* Формат вывода: Для всех $i$ от $0$ до $m-1$ вывод индекса $0 \\le j \\le n-1$ первого встречающегося $q_i$ (то есть $k_j=q_i$) или $-1$ — если такого индекса нет.\n* Ограничения: $1 \\le n \\le 3 \\cdot 10^4$; $1 \\le m \\le 10^5$; $1 \\le k_i \\le 10^9$ для всех $0 \\le i < n$; $1 \\le q_j \\le 10^9$ для всех $0 \\le j < m$.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n7<br>2 4 4 4 7 7 9<br>4<br>9 4 5 2\n\n|\n\n6<br>1<br>-1<br>0\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br>1 1 1<br>3<br>1 2 3\n\n|\n\n0<br>-1<br>-1\n\n||\n|#\n\n* Совет: не используйте встроенный двоичный поиск\n\n### Решение\n\nУ вас есть ключ $q$ и вам необходимо найти первое, самое раннее место, где этот ключ встречается в массиве $K$. Например, если $K=\\{3, 6, 6, 7, 7, 7, 7, 9\\}$ и ключ $q$ — это $7$, тогда первое место, где он встречается, — это индекс $3$. Разумеется, вы можете найти одно из мест, просто начав двоичный поиск. Чтобы найти первое место, где ключ встречается, вы можете последовательно проверять элемент перед позицией того, который был найден, — что и демонстрируется в выделенных голубым строках приведенного ниже псевдокода.\n\n```cpp\nNaiveBinarySearchWithDuplicates(K[0..n−1], q)\n    minIndex = 0\n    maxIndex = n−1\n    while maxIndex >= minIndex:\n        midIndex = (minIndex + maxIndex) / 2\n        if K[midIndex] = q:\n            top = midIndex\n            while top > 0 and K[top − 1] = K[top]:\n                top = top - 1\n            return top\n        if K[midIndex] < q:\n            minIndex = midIndex + 1\n        else:\n            maxIndex = midIndex − 1\n    return -1\n```\n\n💡  Остановитесь и подумайте:   \n*Каково время выполнения этого алгоритма?*\n\nЭтот алгоритм может существенно замедлиться при массиве с большим количеством повторов. Например, если повторяющийся элемент занимает половину массива, то ``NaiveBinarySearchWithDuplicates`` потребует линейное время $O(n)$ вместо логарифмического времени $O(\\log n)$. Эта проблема устранена в псевдокоде ниже.\n\n```cpp\nNaiveBinarySearchWithDuplicates(K[0..n−1], q)\n    minIndex = 0\n    maxIndex = n−1\n    result = -1\n    while maxIndex >= minIndex:\n        midIndex = (minIndex + maxIndex) / 2\n        if K[midIndex] = q:\n            maxIndex = midIndex - 1\n            result = midIndex\n        else if K[midIndex] < q:\n            minIndex = midIndex + 1\n        else:\n            maxIndex = midIndex − 1\n    return result\n```",
        "handbook": "Основы алгоритмов",
        "title": "Двоичный поиск - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/poisk-dominiruyushego-elementa",
        "content": "Ваша задача — проверить, содержит ли данная последовательность элемент, который встречается более половины раз.\n\n* Формат ввода: Первая строка содержит целое число $n$, следующая — последовательность $n$ целых неотрицательных чисел $a_0, \\dotsc, a_{n-1}$.\n* Формат вывода: Выведите $1$, если в последовательности содержится элемент, который встречается больше, чем $n/2$ раз, и $0$ в противном случае.\n* Ограничения: $1 \\le n \\le 10^5$; $0 \\le a_i \\le 10^9$ для всех $0 \\le i < n$.\n* Примеры:\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5<br>2 3 9 2 2\n\n|\n\n1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4<br>1 2 3 1\n\n|\n\n0\n\n||\n|#\n\n- В первом примере $2$ — доминирующий элемент.\n- Во втором примере у последовательности нет доминирующего элемента. Обратите внимание, что элемент $1$ — не доминирующий.\n\n\n### Решение\n\nЗдесь приведён примитивный алгоритм, который решает задачу «Поиск доминирующего элемента» за квадратичное время:\n\n```cpp\nMajorityElement(A[1..n]):\n    for i from 1 to n:\n        currentElement = A[i]\n        count = 0\n        for j from 1 to n:\n            if A[j] = currentElement:\n                count = count + 1\n        if count > n/2:\n            return 1\n    return 0\n```\n\nНа практике входную последовательность можно просканировать и сохранить число вхождений каждого элемента в ассоциативном массиве. Время выполнения этого решения зависит от конкретной реализации ассоциативного массива. Если реализация представляет собой сбалансированное дерево поиска, тогда каждый уточняющий запрос в массиве занимает $O(\\log n)$, а общее время выполнения составляет $O(n\\log n)$. Для хеш-таблиц уточняющие запросы эффективны на практике, хотя и могут варьироваться в зависимости от вводных данных.\n\nСтратегия «разделяй и властвуй» приводит к простому алгоритму с временем выполнения $O(n \\log n)$. Несложная, но невероятно важная вещь: *если $e$ — это доминирующий элемент последовательности, тогда $e$ должен быть доминирующим элементом как минимум в одной из половин*. Однако обратите внимание, что обратное неверно: обе половины последовательности $(2, 3, 3, 7, 5, 7)$ содержат доминирующие элементы ($3$ и $7$ соответственно), но ни один из них не является доминирующим элементом изначальной последовательности. Это приводит нас к следующему алгоритму:  найти доминирующий элемент в обоих половинах с помощью рекурсии и для каждой из половин проверить количество вхождений в изначальную последовательность. Для последнего шага нам необходимо ещё раз сделать линейное сканирование, что может занять время $O(n)$. Следовательно, время выполнения $T(n)$ удовлетворяет $T(n) \\le 2T(n/2)+O(n)$, поэтому $T(n)=O(n\\log n)$.\n   \n✒️ Упражнение:     \n*Сможете ли вы спроектировать еще более быстрый алгоритм с временем выполнения $O(n)$? В основе лежит следующая идея. Разделить вводные элементы на пары. Рассмотреть каждую пару: если два элемента различны, отбросить оба; в противном случае отбросить один из них.*",
        "handbook": "Основы алгоритмов",
        "title": "Поиск доминирующего элемента - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/modifikaciya-bystroj-sortirovki",
        "content": "![algosy_7_3_1_c539fd6b16.svg](https://yastatic.net/s3/education-portal/media/algosy_7_3_1_c539fd6b16_647b19827a.svg)\n \n```cpp\nRandomizedQuickSort(c):\n     if |c| <= 1: # тут и сортировать нечего\n        return c\n     m = random_choice(c) # выбираем случайный элемент из массива\n     определяем элементы c_small меньшие m \n     определяем элементы c_large большие m\n     RandomizedQuickSort(c_small) # рекурсивный вызов алгоритма\n     RandomizedQuickSort(c_large)\n     объединяем c_small, m и c_large в итоговый массив c_sorted\n     return c_sorted\n```\n\nВ этом псевдокоде подразумевается, что все элементы массива разные. Ожидаемое время выполнения алгоритма составляет $O(n \\log n)$.\n\nАлгоритм легко изменить для случая, когда в этом массиве есть повторы. Чтобы это сделать, пусть в $c_{small}$ содержатся все элементы со значением *не более $m$*, а не элементы со значением менее $m$. Тем не менее такая модификация становится медленной даже относительно ожидаемого времени выполнения. Например, если все элементы $c$ одинаковы, $c$ разделяется на две части: размер $c_{small}$ составляет $n-1$, а в $c_{{large}}$ нет элементов. Так как это разделение требует от ``RandomizedQuickSort`` времени $a\\cdot n$, общее время выполнения составляет:\n\n$$\na \\cdot n+a \\cdot (n-1)+a \\cdot (n-2)+\\dotsb = a \\cdot \\frac{n \\cdot (n+1)}{2} \\,\n$$\n\nто есть $O(n^2)$ вместо $O(n \\log n)$.\n\nВаша цель — изменить описанный выше алгоритм ``RandomizedQuickSort`` так, чтобы даже при последовательностях с множеством повторяющихся элементов ожидаемое время выполнения стало $O(n \\log n)$.\n\n* Формат ввода: Первая строка содержит целое число $n$. В следующей строке содержится последовательность из $n$ целых чисел $a_0, a_1, \\dotsc, a_{n-1}$.\n* Формат вывода: Вывод последовательности в неубывающем порядке.\n* Ограничения: $1 \\le n \\le 10^5$; $1 \\le a_i \\le 10^9$ для всех $0 \\le i < n$.\n\n#### Пример:\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5<br>2 3 9 2 2\n\n|\n\n2 2 2 3 9\n\n||\n|#\n\n* Совет: не используйте встроенные алгоритмы сортировки.\n\n### Решение\n\nДля ускорения ``RandomizedQuickSort`` мы разделим входной массив на три подмассива: элементы меньше опорного, равные ему и элементы больше. В более простом подходе достаточно сканировать массив трижды и собрать необходимые элементы.\n\n✒️ Упражнение:   \n*Продемонстрируйте, как разделить массив на три части (меньше опорного элемента m, равняется ему и больше него)  **на месте** — без использования дополнительной памяти.*",
        "handbook": "Основы алгоритмов",
        "title": "Модификация быстрой сортировки - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/podschet-inversij",
        "content": "![algosy_7_4_1_cbcbdf8c04.svg](https://yastatic.net/s3/education-portal/media/algosy_7_4_1_cbcbdf8c04_5e298701a5.svg)\n\nКоличество инверсий в последовательности — показатель того, насколько последовательность отсортирована. Например, в неубывающей последовательности не будет инверсий, а последовательность в порядке убывания содержит $n(n-1)/2$ инверсий (каждые два элемента образуют инверсию).\n\nРешая задачу «Количество инверсий», примитивный алгоритм просматривает все возможные пары $(i,j)$, что требует времени выполнения $O(n^2)$. Чтобы решить эту задачу за время $O(n\\log n)$ с помощью алгоритма «разделяй и властвуй», мы разделяем вводный массив на две половины и делаем рекурсивный вызов обоих из них. Остаётся только вычислить количество инверсий, которые образованы двумя элементами из разных частей. Если делать это примитивным образом, то мы снова придём к времени выполнения $O(n^2)$, так как общее количество таких пар составляет $\\frac{n}{2} \\cdot \\frac{n}{2}=\\frac{n^2}{4}=O(n^2)$. Оказывается, что если обе части уже отсортированы, количество инверсий из элементов разных половин можно вычислить за время $O(n)$. Это подсказывает нам, что вместо решения изначальной задачи, нам стоит решить более общую: вычислить количество инверсий в заданном массиве и в то же время отсортировать его.\n   \n✒️ Упражнение:   \n*Измените алгоритм ``MergeSort`` для решения этой задачи.*\n\n* Формат ввода: Первая строка содержит целое число $n$, следующая — последовательность целых чисел $a_0, \\dotsc, a_{n-1}$.\n* Формат вывода: Количество инверсий в последовательности.\n* Ограничения: $1 \\le n \\le 30\\,000$, $1 \\le a_i \\le 10^9$ для всех $0 \\le i \\le n-1$.\n\n#### Пример:\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5<br>2 3 9 2 9\n\n|\n\n2\n\n||\n|#\n\n* В примере две инверсии: $(2,4)$ ($a_2=3 > 2=a_4$) и \n$(3,4)$ ($a_3=9 > 2=a_4$).\n\n* Совет: используйте полуоткрытые интервалы для рекурсивных реализаций\n\n### Решение\n\nПопробуем использовать самый распространённый подход к методу «разделяй и властвуй»: разделим вводную последовательность на две половины, ``LeftHalf`` и ``RightHalf``, и выполним рекурсивный вызов для каждой. Это позволит нам вычислить все инверсии, находящиеся в одной и той же половине. Однако это не подскажет нам количество *разделённых инверсий*, то есть количество пар $(a_i,a_j)$, при которых $a_i$ находится в левой половине, $a_j$ находится в правой, а $a_i > a_j$.\n\n💡  Остановитесь и подумайте:  \n*Возьмём элемент $x$ в $LeftHalf$. Каково количество разделённых инверсий, в которые входит $x$?*\n\nДаны массив $List$ и целое число $x$. Пусть $List_x$ будет количеством элементов $List$, которые меньше $x$. Так как ответ на вопрос выше — это $RightHalf_x$, наша задача заключается в том, чтобы быстро вычислить $List_x$. Таким образом, мы приходим к следующей задаче: имея последовательность целых чисел $List$ и целое число $x$, нам нужно найти в $List$ количество элементов, которые меньше $x$. В случае неотсортированного массива это можно сделать за время $O(|List|)$, так как необходимо проверить каждый элемент массива. В варианте же отсортированного за время $O(\\log |List|)$, если использовать двоичный поиск.\n   \n✒️ Упражнение:   \n*Продемонстрируйте, как реализовать метод ``CountSmaller(List, x)`` для подсчёта количества элементов $List$ со значением меньше $x$ за время $O(\\log_2|List|)$.*\n\nТак мы приходим к следующему алгоритму «разделяй и властвуй».\n\n```cpp\nCountInversions(List):\n    if ∣List∣ <= 1:\n        return 0\n    inversions = 0\n    // в случае нечётной длины\n    // центральный элемент может быть и слева, и справа\n    LeftHalf = левая половина List   \n    RightHalf = правая половина List \n    inversions = inversions + CountInversions(LeftHalf)\n    inversions = inversions + CountInversions(RightHalf)\n    sort(RightHalf) // необходимо для двоичного поиска\n    for x in LeftHalf:\n        inversions = inversions + CountSmaller(RightHalf,x)\n    return inversions\n```\n\nВремя выполнения $T(n)$ (где $n$ — длина $List$) удовлетворяет рекуррентному соотношению\n\n$$\nT(n) \\le 2T(n/2) + O(n\\log n) \\, .\n$$\n\nСлагаемое $O(n\\log n)$ включает в себя два шага: сортировку $RightHalf$ и ответ на $n/2$ запросов ``CountSmaller``. Эту рекуррентное соотношение нельзя напрямую вставить в основную теорему о рекуррентных соотношениях, так как элемент $O(n\\log n)$ не имеет форму $O(n^d)$ при константе $d$. Однако мы можем проанализировать её таким же образом: рекурсивное дерево содержит $\\log_2 n$ уровней, общий размер всех задач на каждом уровне равен $n$, а общее затраченное время на каждом уровне составляет $O(n\\log n)$. В итоге общее время выполнения составляет $O(n\\log^2n)$. Вместо того, чтобы формально это доказывать, мы улучшим вышеприведённый алгоритм так, чтобы он затрачивал время $O(n\\log n)$.\n\nМожно быстро найти все разделённые инверсии, если наряду с подсчётом инверсий сортировать входную последовательность. То есть можно предположить, что алгоритм ``CountInversionsAndSort(List)`` возвращает количество инверсий в $List$ и сортирует $List$. После двух рекурсивных вызовов обе половины $List$ отсортированы. На данном этапе нам нужно сделать две вещи: отсортировать всю последовательность $List$ и вычислить количество разделённых инверсий. Мы уже знаем, как достичь первой цели: этим занимается процедура $Merge$. Это выглядит следующим образом.Пусть $l$ и $r$ будут первыми элементами отсортированных последовательностей $LeftHalf$ и $RightHalf$. Далее выбирается самый маленький из них и перемещается в увеличивающийся отсортированный список.\n\n💡  Остановитесь и подумайте:  \n*Можете ли вы найти количество разделённых инверсий, которые образует перемещаемый элемент?*\n\nРассмотрим два случая.\n- $l \\le r$. В этом случае $l$ не больше каждого элемента $RightHalf$, и поэтому не образует разделённых инверсий.\n- $l > r$. В этом случае $r$ меньше всех элементов $LeftHalf$, и поэтому образует разделённую инверсию с каждым из них.\n\nЭто приводит нас к следующему расширению метода ``Merge``.\n\n```cpp\nMerge(LeftHalf, RightHalf):\n    SortedList = empty list\n    inversions = 0\n    while both LeftHalf and RightHalf are non-empty:\n        l = первый элемент LeftHalf\n        r = первый элемент RightHalf\n        if l <= r:\n            переместить l в SortedList\n            l = следующий элемент в LeftHalf\n        else:\n            переместить r в SortedList\n            r = следующий элемент в RightHalf\n            // учитываются только не перемещенные элементы\n            inversions = inversions + ∣LeftHalf∣\n    добавить все оставшиеся элементы LeftHalf и RightHalf в SortedList\n    return SortedList, inversions\n```\n\nИ окончательная версия алгоритма ``CountInversions``.\n\n```cpp\nCountInversions(List):\n    // список List будет отсортирован\n    if ∣List∣ <= 1:\n        return 0\n    LeftHalf = левая половина List\n    RightHalf = правая половина List\n    leftInv = CountInversions(LeftHalf)\n    rightInv = CountInversions(RightHalf)\n    List, splitInv = Merge(LeftHalf, RightHalf)\n    return leftInv + rightInv + splitInv\n```",
        "handbook": "Основы алгоритмов",
        "title": "Подсчет инверсий - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-para-blizhajshih-tochek",
        "content": "![Algoritmy_17_44e92fd3cc.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_17_44e92fd3cc_781c551b9a.svg)\n\nВаша задача — найти ближайшую пару точек из заданного множества.\n\nВ компьютерных графике и зрении есть множество вариантов применения этой задачи из вычислительной геометрии.  Примитивный алгоритм с квадратичным временем выполнения делает итерации, проходя через все пары точек, чтобы найти ближайшие друг к другу. Ваша цель — спроектировать алгоритм «разделяй и властвуй», время выполнения которого составит $O(n\\log n)$.\n\nЧтобы решить эту задачу за время $O(n\\log n)$, разобьём с помощью правильно подобранной вертикальной линии данные $n$ точек пополам — множества $S_1$ и $S_2$ размера $\\frac{n}{2}$. Ради простоты предположим, что все координаты $x$ для данных точек различные и количество точек чётное. С помощью двух рекурсивных вызовов с параметрами $S_1$ и $S_2$ мы находим минимальные расстояния $d_1$ и $d_2$ в этих поднаборах. Пусть $d=\\min\\{d_1, d_2\\}$.\n\n![Algoritmy_18_59cd80e923.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_18_59cd80e923_920223a60b.svg)\n\nОстаётся проверить, существуют ли такие точки $p_1 \\in S_1$ и $p_2 \\in S_2$, при которых расстояние между ними меньше $d$. Мы не можем себе позволить проверять все возможные такие пары, так как их $\\frac{n}{2} \\cdot \\frac{n}{2}=\\Theta(n^2)$. Для более быстрой проверки мы отбросим все точки из $S_1$ и $S_2$, расстояние которых от центральной линии по $x$ больше, чем $d$. Таким образом, мы сосредотачиваемся на следующей полосе:\n\n![Algoritmy_19_be157f5fb2.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_19_be157f5fb2_24f0bda377.svg)\n\n💡  Остановитесь и подумайте:   \n*Почему мы можем сузиться до этой полосы?*\n\nТеперь отсортируем точки из полосы по координатам $y$ и обозначим получившийся отсортированный список $P=[p_0,\\dotsc, p_{k-1}]$. Оказывается, что если $|i-j|>7$, то расстояние между точками $p_i$ и $p_j$ однозначно будет больше $d$. Упражнение ниже это демонстрирует.\n   \n✒️ Упражнение:   \n*Разделите полосу на $d \\times d$ квадратов, как показано ниже, и продемонстрируйте, что каждый из таких квадратов содержит максимум четыре точки ввода.*\n\n![Algoritmy_20_ddb168de68.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_20_ddb168de68_a2db494129.svg)\n\nЭто приводит к следующему алгоритму. Сначала мы сортируем данные нам $n$ точек по их координатам $x$, затем делим получившийся отсортированный список на две половины $S_1$ и $S_2$ размера $\\frac{n}{2}$. Находим минимальные расстояния $d_1$ и $d_2$ с помощью рекурсивных вызовов для каждого из наборов $S_1$ и $S_2$. Пусть $d=\\min\\{d_1,d_2\\}$. Тем не менее наша работа ещё не закончена, потому что нам также нужно найти минимальное расстояние между точками из разных наборов (то есть точкой из $S_1$ и точкой из $S_2$) и проверить, ниже ли это расстояние, чем $d$. Чтобы в этом убедиться, мы отфильтруем изначальный набор и оставим только точки с дистанцией по $x$ до средней линии, не превышающей $d$. После этого мы сортируем набор точек в получившейся линии по координатам $y$ и сканируем получившийся список. Вычислим расстояние от каждой точки до семи последующих точек списка и вычислим $d'$ — минимальное расстояние, которое нам встретилось во время сканирования. Затем выведем $\\min\\{d,d'\\}$.\n\nВремя выполнения алгоритма соответствует рекуррентному соотношению.\n\n$$\nT(n)=2 \\cdot T\\left(\\frac{n}{2}\\right) + O(n \\log n) \\,\n$$\n\n$O(n\\log n)$ — результат сортировки точек в полосе по координате $y$ при каждой итерации.\n    \n✒️ Упражнение:    \n*Проанализируйте рекурсивное дерево алгоритма и докажите, что $T(n)=O(n\\log^2 n)$.*\n   \n✒️ Упражнение:   \n*Продемонстрируйте, как избежать сортировки при каждом рекурсивном вызове и понизить время выполнения до $O(n \\log n)$.*\n\n* Формат ввода: Первая строка содержит $n$ точек. Каждая из следующих $n$ строк определяет точку $(x_i,y_i)$.\n* Формат вывода: Минимальное расстояние. \n* Ограничения: $2 \\le n \\le 10^5$; $-10^9 \\le x_i,y_i \\le 10^9$ — целые числа.\n* Примеры\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n2<br/>0 0<br/>3 4\n\n|\n\n5\\.0\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n11<br/>-2 4<br/>-2 -2<br/>4 4<br/>2 3<br/>-3 -4<br/>-4 0<br/>-1 3<br/>3 -1<br/>1 1<br/>-1 -1<br/>-4 2\n\n|\n\n1\\.414213\n\n||\n|#\n\n* Во втором примере самое маленькое расстояние — $\\sqrt{2}$. Есть две пары точек на этом расстоянии. Ниже они выделены голубым и красным: $(-1,-1)$ и $(-2,-2)$; $(-2,4)$ и $(-1,3)$.\n\n![Algoritmy_21_9177b21c56.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_21_9177b21c56_8e1aea64eb.svg)\n\nПомните, что расстояние между точками $(x_1,y_1)$ и $(x_2,y_2)$ равно $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$. Так, хотя ввод и содержит только целые числа, ответ не обязательно будет целым числом, и потому вам нужно обратить внимание на точность при выводе результатов. Абсолютное значение разницы между ответом вашей программы и оптимальным значением не должно превышать $10^{-3}$. Для этого ваш ответ должен содержать не меньше четырех цифр в дробной части. Иначе даже правильно вычисленный результат может не пройти нашу систему проверки из-за ошибок при округлении.\n\n\n💡  Совет: по возможности старайтесь избегать использования чисел с плавающей дробной частью, при необходимости используйте встроенные алгоритмы для сортировки.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Пара ближайших точек» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/principy-postroeniya-algoritmov",
        "content": "В этом параграфе мы реализуем разные алгоритмы динамического программирования и увидим, как они решают задачи, которые не поддавались решению с использованием «жадных» алгоритмов и подхода «разделяй и властвуй». Динамическое программирование на практике применяется в большом числе случаев. Оно подходит и для поиска похожих страниц в интернете, и для предсказывания генов в последовательностях ДНК.\n\nВ итоге вы узнаете, как одна идея позволяет автоматически исправлять орфографические ошибки и при этом находить разницу между двумя вариантами одного и того же текста.\n\n## Основная идея\n\n### Количество путей\n\nДля понимания идеи, которая используется в подходе динамического программирования, предлагаем вам попробовать решить следующую головоломку.\n\n**Интерактивная головоломка «Количество путей».**\nВ нижеприведённой сети есть множество путей ведущих от $s$ к $t$, — например: $s \\to b \\to e \\to t$ и $s \\to a \\to c \\to d \\to t$. Каково общее количество путей?\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_1_dc4717fb38_ff87308508.svg)\n\nТак как мы начинаем с $s$, существует уникальный способ добраться до $s$. Давайте запишем:\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_2_b38c28d142_7ff18bd012.svg)\n\nДля $a$ и $b$ также существует просто один путь.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_3_69c3974821_103f16eca1.svg)\n\nТак как существует только один путь к $a$ и только один к $b$, количество путей к $c$ составляет $1+1=2$ ($s \\to a \\to c$ и $s \\to b \\to c$).\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_4_3c44e226f0_1b2646f2d7.svg)\n\nАналогичным образом для достижения $d$ необходимо прийти либо к $a$, либо к $c$. Существует только один путь до $a$ и два пути до $c$. Так количество путей, которые ведут к $d$, составляет $1+2=3$ ($s\\to a \\to d$, $s\\to a \\to c \\to d$ и $s\\to b \\to c \\to d$).\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_5_9e85a123cb_49657c3ef6.svg)\n\nКоличество путей, заканчивающихся на $e$, равно $1$, так как к $e$ можно прийти только от $b$.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_6_d7332d41bb_1caceef1f6.svg)\n\nДо $c$ есть два пути, до $d$ — три пути, до $e$ — один. Выходит, что путей до $t$ существует $2+3+1=6$.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_7_8c4539b003_c7b7b8e2e2.svg)\n\n### Динамическое программирование\n\nРассмотрим наше решение головоломки «Количество путей» и изложим основные идеи динамического программирования. Для узла $v$ — $paths(v)$ будет количеством путей от стартового узла $s$ к узлу $v$. Несомненно, $paths(s)=1$. Это называется *базовый случай*. Соответствующее значение для всех других узлов можно найти с помощью *рекуррентного соотношения*:\n\n$$paths(v)= \\sum_{\\text{все предшествующие $w$ от $v$}} paths(w) \\,\n$$\n\nгде предшественник $v$ — это узел, связанный ребром с $v$.\n\nМногие алгоритмы динамического программирования используют одну схему:\n\n— Вместо того, чтобы решать изначальную задачу, алгоритм решает несколько подзадач такого же типа.\\\n— Алгоритм вычисляет решение для каждой подзадачи с помощью рекуррентного соотношения, в которое входят решения более мелких подзадач.\\\n— Алгоритм сохраняет решения подзадач и таким образом избегает перевычисления.\n\n### Ориентированный ациклический граф: кратчайший путь\n\nТеперь рассмотрим *взвешенный граф*, в котором у каждого ребра $e$ обозначена длина $length(e)$. Длина пути в таком графе определяется суммой длины рёбер.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_9_0259340995_0d93311fcf.svg)\n\nНапример, длина пути $s \\to b \\to e \\to t$ составляет $5+7+4=16$. Какова минимальная длина пути от $s$ до $t$?\n\nТак как каждый путь от $s$ до $t$ проходит через $c$, $d$ или $e$ перед тем, как прийти к $t$,\n\n$$length(t)=\\min \\{length(c)+6, length(d)+8, length(e)+4\\}\\,\n$$\n\nгде $length(v)$ — минимальная длина пути от $s$ до $v$. Расстояния до $c$, $d$ и $e$ можно найти с помощью похожих рекуррентных соотношений:\n\n$$\\begin{matrix}\n        length(c)=\\min \\{length(a)+4, length(b)+1\\}\\,, \\\\\n        length(d)=\\min \\{length(a)+7, length(c)+2\\}\\,, \\\\\n        length(e)=length(b)+7\\,.\n\\end{matrix}\n$$\n\nПриведём рекуррентные соотношения для $a$ и $b$:\n\n$$\\begin{matrix}\n        length(a)=length(s)+4\\,,\\\\\n        length(b)=length(s)+5\\,.\n\\end{matrix}\n$$\n\nНаконец, базовый случай — это $length(s)=0$. С его помощью можно найти расстояние до всех узлов сети, включая наш узел $t$. Для этого нужно использовать вышеприведённые рекуррентные соотношения, которые можно записать в компактной форме:\n\n$$        length(v)= \\min_{\\text{все предшествующие $w$ от $v$}}\n        \\{length(w) + length(w, v) \\}.\n$$\n\nДля модельной ситуации удобно записывать результаты по мере того, как мы выполняем вычисления, прямо на изображении. Мы получаем следующие результаты.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_8_1_10_d448bcee07_419f976eca_0ebe4def15.svg)\n\n💡  Остановитесь и подумайте:\\\n*Минимальная длина пути от* $s$ до $t$ составляет $12$. Можете понять, как находится путь такой длины?\n\nВ алгоритме динамического программирования для этого выполняется бэктрекинг («поиск с возвратом») решений, которые привели к оптимальному результату. В особенности отметим один из трёх выборов, который приводит нас к значению $length(t)$.\n\n$$length(t) = \\min \\{length(c)+6, length(d)+8, length(e)+4\\} = \\min\\{12,16,16\\}=12.\n$$\n\nИсходя из этого, мы можем заключить, что последнее ребро оптимального пути — это $c \\to t$. Аналогично,\n\n$$length(c) = \\min \\{length(a)+4, length(b)+1\\} = \\min\\{8,6\\}=6 \\,\n$$\n\nтак мы приходим от $b$ к $c$. Таким образом, путь от $s$ до $t$ длиной $12$ составляет\n\n$$s \\to b \\to c \\to t  .\n$$\n\nУ вышеприведённой сети есть удобное свойство. Оно заключается в том, что мы можем определять порядок её узлов, что обеспечивает следующее: каждый узел идет после всех *предшествующих* — то есть узлы, которые указывают на текущий узел (например, $c$, $d$ и $e$ предшествуют $t$). Сети с таким свойством называются *ориентированные ациклические графы*. Мы увидим, что многие алгоритмы динамического программирования используют ориентированные ациклические графы — явно или неявно.\n\n## Проектирование алгоритмов динамического программирования\n\nТеперь, когда вы познакомились с несколькими алгоритмами динамического программирования, подведём итог и повторим основные шаги для проектирования таких алгоритмов.\n\n— **Определить подпроблемы.** Первый и самый важный шаг — это идентифицировать подпроблемы и записать рекуррентное соотношение (с базовым случаем). Как правило, это делается через анализ структуры оптимального решения или через оптимизацию решения, использующего исчерпывающий поиск.\n\n— **Спроектировать рекурсивный алгоритм.** Сделать из рекуррентного соотношения рекурсивный алгоритм:\n—  сохранить решение каждой подзадачи в таблице;\n—  перед решением подзадачи проверить, нет ли уже в таблице её решения (мемоизация).\n\n— **Спроектировать итерационный алгоритм.** Сделать из рекурсивного алгоритма итерационный алгоритм:\n—  инициализировать таблицу;\n—  продвигаться от мелких подзадач к большим.\n\n— **Оценить время выполнения.** Доказать верхнее ограничение времени выполнения. Обычно произведение количества подпроблем и времени, необходимого для решения подзадачи, предоставляет верхнее ограничение времени выполнения.\n\n— **Обнаружить решение.** Обнаружить оптимальное решение, используя бэктрекинг рекуррентного соотношения.\n\n— **Экономить место.** Использовать обычную структуру таблицы, чтобы проверить, можно ли сэкономить место по сравнению с более прямым решением.",
        "handbook": "Основы алгоритмов",
        "title": "Принципы построения алгоритмов - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-razmen-2",
        "content": "## Сдача\n\nКак нам уже известно, естественный «жадный» подход к этой задаче работает неправильно при любом наборе номиналов. Например, при номиналах $1$, $3$ и $4$ «жадный» алгоритм разменяет $6$ центов тремя монетами ($4+1+1$), хотя это возможно сделать всего лишь двумя ($3+3$). Ваша цель — использовать динамическое программирование для решения задачи «Сдача» с номиналами $1$, $3$ и $4$.\n\n* Входные данные: Целое число $money$.\n* Выходные данные: Минимальное количество монет номиналами $1$, $3$, $4$, чтобы выдать сдачу с $money$.\n* Ограничения: $1 \\le money \\le 10^3$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n34\n\n|\n\n9\n\n||\n|#\n\n* $34=3+3+4+4+4+4+4+4+4$.\n\nДля оптимального варианта сдачи с $26$ необходимо семь монет. Рассмотрим произвольный поднабор оптимального решения — например, если сложить четыре монеты из приведённого ниже прямоугольника, то получится $15$.\n\n\n💡  Остановитесь и подумайте:   \n*Сможете разменять $15$ центов тремя монетами?*\n\nОтвет на этот вопрос: «Нет». Если бы размен $15$ был возможен тремя монетами, то можно было бы заменить выделенные четыре монеты и получить сдачу с $26$ шестью монетами, а не семью.\n\nТакая ситуация показывает нам важную особенность динамического программирования — *решение задачи содержит решения всех её мелких подзадач*.\n\nЭта особенность позволяет найти решение задачи, сначала выполняя мелкие подзадачи.\n\nПусть $change(money)$ — это минимальное количество монет номиналами $1$, $3$ и $4$, которые нужны для сдачи с $money$, а $(c_1,\\dotsc,c_k)$ — оптимальная сдача с $money$. В таком случае\n\n$$\nc_1+\\dotsb+c_k=money .\n$$\n\nТогда \n\n$$\nc_1+\\dotsb+c_{k-1}=money-c_k.\n$$\n\nСледовательно, $change(money-c_k)=k-1$. Таким образом, для решения задачи при $money$ достаточно решить её при $money-c_k$ и добавить единицу.\n\n💡  Остановитесь и подумайте:   \n*Мы закончили?*\n\nПроблема в том, что мы не знаем значение $c_k$. Тем не менее мы знаем, что $c_k$ равняется или $1$, или $3$, или $4$. Так $change(money)$ равно одному из следующих вариантов: $change(money-1)+1$, $change(money-3)+1$ и $change(money-4)+1$.\n\nТак как мы ищем оптимальный способ выдать сдачу, $money$ равно минимальному из этих трёх выражений. В итоге мы получаем следующее рекуррентное соотношение:\n\n$$\nchange(money)=1+\\min(change(money-c) \\colon c \\in {1, 3, 4},\\, c \\le money).\n$$\n\nПри небольших аргументах это соотношение выражает значение $change$ рекурсивным образом через собственные значения. Для такой нисходящей рекурсии нам необходимо указать базовый случай. У нас это будет $money=0$: $change(0)=0$.\n\nУравнение выше — *самая важная часть алгоритма динамического программирования*, так как из него легко сделать рекурсивный алгоритм.\n\n```cpp\nChange(money):\n    if money=0:\n        return 0\n    else:\n        result = +infinity\n        for c=1,3,4:\n        if c <= money:\n            result = min(result,1+Change(money-c))\n        return result\n```\n\nУ этого алгоритма есть серьёзная проблема: он становится крайне медленным, потому что вызывает ``Change(money)`` снова и снова для одного и того же значения $money$.\n\n*Мемоизация* — стандартный способ избежать этого: при вычислении ``Change(money)`` мы можем использовать сохранение в таблице и тогда нам не придётся делать перевычисление.\n\n```cpp\ntable=associative array\n    \nChange(money):\n    if table[money] is not yet computed:\n    if money=0:\n        table[money]←0\n    else:\n        result = +infinity\n        for c=1,3,4:\n        if c <= money:\n            result = min(result,1+Change(money-c))\n        table[money] = result\n    return table[money]\n```\n\nНа практике такой алгоритм уже достаточно хорош, хотя у него есть проблемы с эффективностью: рекурсивные вызовы и уточняющие запросы для ассоциативного массива приводят к замедлению. Заметив, что все вычисляемые значения — это последовательные целые числа, мы можем реализовать улучшенный подход, в котором используется массив для хранения решений всех задач.\n\n```cpp\nChange(money):\n    table[0..money] = [+infinity,…,+infinity]\n    table[0] = 0\n    \n    for m from 1 to money:\n        for c=1,3,4:\n        if c <= m:\n            table[m] = min(table[m],1+table[m-c])\n    return table[money]\n```\n\nВремя выполнения этого алгоритма составляет $O(money)$, так как каждая итерация внешнего цикла **for** проходит за постоянное время.\n    \n💡  Остановитесь и подумайте:     \n*Обратите внимание, что описанный выше алгоритм неявно находит кратчайший путь в ориентированном ациклическом графе, приведённом ниже (при $money=12$). Рассчитайте время выполнения алгоритма для самого короткого пути в аналогичном графе при произвольном значении $money$.*",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Размен 2» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-prostoj-kalkulyator",
        "content": "У вас есть калькулятор, который выполняет с целым числом $x$ только следующие операции: сложить $x$ и $1$, умножить $x$ на $2$ или умножить $x$ на $3$. Имея положительное целое число $n$, вы должны найти минимальное количество операций, необходимых для получения числа $n$ из числа $1$. \n\nПопробуем решить эту задачу с помощью «жадной» стратегии: если текущее число не превышает $\\frac{n}{3}$, то умножим его на 3; если оно больше $\\frac{n}{3}$, но не больше $\\frac{n}{2}$, то умножим его на 2; в остальных случаях добавим к нему 1. Это приводит к следующему псевдокоду.\n\n```cpp\nGreedyCalculator(n):\n    numOperations = 0\n    currentNumber = 1\n    while currentNumber<n:\n        if currentNumber <= n/3:\n            currentNumber = 3*currentNumber\n        else if currentNumber <= n/2:\n            currentNumber = 2*currentNumber\n        else: \n            currentNumber = 1+currentNumber\n        numOperations = numOperations+1\n    return numOperations\n```\n\n\n💡  Остановитесь и подумайте:   \n*Сможете ли вы найти такое число $n$, при котором ``GreedyCalculator(n)`` приводит к неправильному ответу?*\n\n* Входные данные: Целое число $n$.\n\n* Выходные данные: В первой строке: $k$ — минимальное число необходимых операций для получения $n$ из $1$. Во второй строке: последовательность промежуточных чисел. Так, вторая строка должна содержать положительные целые числа $a_0, a_1, \\dotsc, a_{k}$, при которых $a_0=1$, $a_{k}=n$, и для всех $1 \\le i \\le k$ $a_{i}$ равно $a_{i-1}+1$, $2 a_{i-1}$ или $3a_{i-1}$. Если таких последовательностей много, то можно вывести любую из них.\n\n* Ограничения: $1 \\le n \\le 10^6$.\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1\n\n|\n\n0<br>1\n\n||\n|#\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n96234\n\n|\n\n14<br>1 3 9 10 11 22 66 198 594 1782 5346 16038 16039 32078 96234\n\n||\n|#\n\n\n* Ещё один корректный вывод в этом случае — это «1 3 9 10 11 33 99 297 891 2673 8019 16038 16039 48117 96234».\n\nРассмотрим решение задачи. Пусть $calculator(n)$ — минимальное количество операций, необходимых для получения числа $n$ из числа $1$. Так как последняя операция в оптимальной последовательности — это «$+1$», «$\\times 2$» или «$\\times 3$», мы получаем следующее рекуррентное соотношение для $n \\ge 1$:\n\n$$calculator(n)=1+\\min\n\\begin{cases}\n    calculator(n-1), &\\\\\n    calculator(n/2), & \\text{если $n$ кратно $2$,}\\\\\n    calculator(n/3), & \\text{если $n$ кратно $3$.}\\\\\n\\end{cases}$$\n\n\nДанное рекуррентное соотношение, вместе с базовым случаем $calculator(1)=1$, можно трансформировать в рекурсивный, а затем в итерационный алгоритм.\n\n```cpp\nCalculator(n):\n    table[1..n]←[+infinity,…,+infinity]\n    table[1] = 0\n    \n    for k from 2 to n:\n        table[k]=1+table[k−1]\n        if k is divisible by 2:\n            table[k]=min(table[k],1+table[k/2])\n        if k is divisible by 3:\n            table[k]=min(table[k],1+table[k/3])\n    return table[n]\n```\n\nПомните, что помимо оптимального значения необходимо вывести оптимальную последовательность операций. Для этого обратим внимание на то, что мы можем найти последнюю операцию следующим образом:\n\n* это «$+1$», если $calculator(n)=1+calculator(n-1)$;\n* это «$\\times 2$», если $n$ можно разделить на $2$ и $calculator(n)=1+calculator(n/2)$;\n* это «$\\times 3$», если $n$ можно разделить на $3$ и $calculator(n)=1+calculator(n/3)$.\n\n\nЭти действия позволяют нам выявить оптимальную последовательность:\n\n* найти последнюю операцию;\n* заменить $n$ на $n-1$, $\\frac{n}{2}$ или $\\frac{n}{3}$ (в зависимости от того, какой это из трёх случаев выше);\n* повторить (пока $n>1$).\n\n```cpp\nCalculator(n):\n    table[1..n]←[+infinity,…,+infinity]\n    table[1] = 0\n    \n    for k from 2 to n:\n        table[k]=1+table[k−1]\n        if k is divisible by 2:\n            table[k]=min(table[k],1+table[k/2])\n        if k is divisible by 3:\n            table[k]=min(table[k],1+table[k/3])\n    \n    operations = empty list\n    while n > 1:\n        append n to operations\n        if table[n]=1+table[n−1]:\n            n = n - 1\n        else if n is divisible by 2 and table[n]=1+table[n/2]:\n            n = n/2\n        else if n is divisible by 3 and table[n]=1+table[n/3]:\n            n = n/3\n    return operations\n```\n\nВремя выполнения алгоритма составляет $O(n)$.\n",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Простой калькулятор» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-rasstoyanie-redaktirovaniya",
        "content": "![Algoritmy_23_cdebc68684.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_23_cdebc68684_1003b863b1.svg)\n\nЕсть множество вариантов, как применить задачу «Расстояние редактирования». Она подойдёт для обработки текстов на естественном языке, проверки правописания и других направлений. К примеру, биологи зачастую вычисляют редакционное расстояние, когда ищут мутации, вызывающие болезни.\n\nРедакционное расстояние между двумя строками определяется как минимальное число односимвольных вставок, удалений и замен, необходимых для преобразования одной строки в другую.\n\n* Входные данные: Две строки, состоящие из строчных букв латинского алфавита.\n* Выходные данные: Редакционное расстояние между строками.\n* Ограничения: Длина обеих строк не меньше $1$ и не больше $100$.\n\n#### Пример 1\n\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nshort<br>ports\n\n|\n\n3\n\n||\n|#\n\n* Вторую строку можно получить из первой, удалив s, заменив h на p и вставив s. Это можно компактно продемонстрировать следующим *выравниванием*.\n\n![11_070b2ec127.webp](https://yastatic.net/s3/education-portal/media/11_070b2ec127_fa36a0a031.webp)\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nediting<br>distance\n\n|\n\n5\n\n||\n|#\n\n* Удалить e, вставить s после i, заменить i на a, заменить g на c, вставить e в конце.\n\n![12_57f900c730.webp](https://yastatic.net/s3/education-portal/media/12_57f900c730_22ce824c60.webp)\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\nab<br>ab\n\n|\n\n0\n\n||\n|#\n\n* Совет: будьте осторожны с рекурсией.\n\nРассмотрим решение задачи. *Выравнивание* двух строк в двухрядной матрице осуществляется таким образом, чтобы первый (второй) ряд содержал упорядоченные символы первой (второй) строки, которые перемежаются пробелами («$-$»).\nВ колонке не может быть два пробела одновременно в обеих строках.\n\n✒️  Упражнение:  \n*Вычислите количество разных пар выравненных строк длиной $n$ и $m$*.\n\nМы классифицируем колонки выравнивания следующим образом (первый символ из верхней строки, второй — из нижней):\n\n— колонка с символом и пробелом\n\n    — это удаление;\n    \n— колонка с пробелом и символом\n\n    — вставка;\n    \n— колонка с двумя одинаковыми символами \n\n\t— совпадение;\n\n— колонка с двумя разными символами\n\n    — это несоответствие.\n\nМы ищем выравнивание, при котором минимизируется общее количество несоответствий, удалений и вставок.\n\nВыравнивание считается *оптимальным* по сравнению со всеми другими возможными вариантами, если оно содержит минимум несоответствий, удалений и вставок.\nСтоит обратить внимание, что может быть несколько различных *оптимальных* выравниваний.\n\n✒️  Упражнение:  \n*Докажите, что задача на редакционное расстояние может быть сведена к поиску оптимального выравнивания двух строк.*\n\n\nВ примере выше последняя колонка — это вставка. Отбросив эту колонку, мы получаем оптимальное выравнивание первой строки и префикса второй.\n\nРассмотрим идею: рассчитать редакционное расстояние между каждой парой префиксов двух строк. Это более общая постановка задачи, но важно отметить, что, решив ее, мы найдем ответ и на интересующий нас вопрос.\n\nИмея строки $A[1\\dotsc n]$ и $B[1 \\dotsc m]$, мы рассмотрим их префиксы $A[1\\dotsc i]$ и $B[1 \\dotsc j]$ длиной $i$ и $j$ и обозначим их редакционное расстояние $EditDistance(i,j)$.\n\nТак как последняя колонка оптимального выравнивания $A[1 \\dotsc i]$ и $B[1 \\dotsc j]$ — это или вставка, или удаление, или несоответствие, или совпадение, имеем,\n\n$$\n    EditDistance(i,j) = \\min \\begin{cases}\n    {EditDistance(i,j-1)+1}\\\\\n    {EditDistance(i-1,j)+1}\\\\\n    {EditDistance(i-1,j-1)+1}  &\\text{if }A[i]\\neq B[j]\\\\\n    {EditDistance(i-1,j-1)}  &\\text{if }A[i]=B[j]\\\\\n\\end{cases}\n$$\n\n\nБазовый случай для этого рекуррентного соотношения — $i=0$ и $j=0$:\n\n$$\nEditDistance(0,j)=j \\quad \\text{и} \\quad EditDistance(i,0)=i \\, .\n$$\n\nЭто можно выразить более кратко: если $i=0$ или $j=0$, тогда\n\n$$\nEditDistance(i,j)=\\max\\{i,j\\}.\n$$\n\nПсевдокод ниже делает из этого рекуррентного соотношения рекурсивный алгоритм и использует мемоизацию для избежания перевычислений.\n\n```cpp\ntable = associative array\n    \nEditDistance(A,B,i,j):\n    if table[i,j] is not yet computed:\n        if i=0 or j=0:\n            table[i,j] = max(i,j)\n        else:\n            insertion = EditDistance(A,B,i,j−1)+1\n            deletion = EditDistance(A,B,i−1,j)+1\n            match = EditDistance(A,B,i−1,j−1)\n            mismatch = EditDistance(A,B,i−1,j−1)+1\n            if A[i]=B[j]:\n                table[i,j] = min(insertion,deletion,match)\n            else:\n                table[i,j] = min(insertion,deletion,mismatch)\n    return table[i,j]\n```\n\nВремя выполнения этого алгоритма составляет $O(nm)$, так как выполняется не больше $nm$ рекурсивных вызовов, которые добавляют значения в `table`.\n\nРекурсивный алгоритм вычисляет $EditDistance(i,j)$ для всех $0 \\le i \\le n$ и $0 \\le j \\le m$. Из рекурсивного алгоритма можно сделать итерационный, который будет сохранять решения всех подзадач в двумерной таблице. Таблица заполняется по рядам проходами. Это гарантирует, что когда мы вычислим значение клетки $(i,j)$, значения клеток $(i,j-1)$, $(i-1,j)$ и $(i-1,j-1)$ будут уже готовы.\n\n```cpp\nEditDistance(A[1…n],B[1…m]):\n    table = 2d array of size (n+1) * (m+1)\n    table[0][j] = j for all i,j\n    for i from 1 to n:\n        for j from 1 to m:\n            insertion = table[i][j−1]+1\n            deletion = table[i−1][j]+1\n            match = table[i−1][j−1]\n            mismatch = table[i−1][j−1]+1\n            if A[i]=B[j]:\n                table[i][j] = min(insertion,deletion,match)\n            else:\n                table[i][j] = min(insertion,deletion,mismatch)\n    return table[n][m]\n```\n\nИтоговая таблица для нашего примера изображена на рисунке ниже. Значение каждой клетки вычисляется, исходя из значений соседних клеток сверху, слева и слева-сверху. У каждой клетки входящие стрелки указывают на один или несколько случаев (вставка, удаление, несоответствие, или совпадение), которые приводят к значению этой клетки.\n\n![Algoritmy_23_1_8bb73d2284.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_23_1_8bb73d2284_71ce9becfb.svg)\n\n\nТаблица соответствует ориентированному ациклическому графу, в котором все рёбра, за исключением красных, имеют длину $1$. А красные ребра соответствуют совпадающим символам и имеют длину $0$. Алгоритм находит на графе самый короткий путь от узла слева сверху до узла справа снизу.\n\nВремя выполнения алгоритма составляет $O(nm)$. Ему требуется $O(nm)$ ячеек памяти для хранения двумерного массива ``table``. Расход места может быть снижен до $O(m)$ (и даже до $O(\\min\\{n,m\\})$), если мы обратим внимание на то, что при заполнении текущего ряда таблицы нам нужны только клетки из текущего и предыдущего. Таким образом, вместо хранения всей таблицы достаточно сохранить текущий и предыдущие ряды.\n\n💡  Остановитесь и подумайте:   \n*Вы рассчитали редакционное расстояние между editing и distance. Но как найти пять операций для того, чтобы преобразовать editing в distance?*\n\nОтметим, что любой путь от $(0, 0)$ до $(n,m)$ на рисунке образовывает оптимальное выравнивание строк $A$ и $B$.\n\n✒️  Упражнение:  \n*Путь, изображённый на рисунке ниже, соответствует оптимальному выравниванию editing и distance. Сколько в этом выравнивании вставок, удалений, совпадений и несоответствий? Постройте оптимальное выравнивание, соответствующее этому пути.*\n\n\n![Algoritmy_23_1_8bb73d2284.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_23_1_8bb73d2284_f02c835d25.svg)\n\nОптимальное выравнивание можно обнаружить с помощью перехода по стрелкам в обратную сторону от нижнего правого угла вдоль любого пути, приводящего к верхнему левому углу.\n",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Расстояние редактирования» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-lcs",
        "content": "## Наибольшая общая подпоследовательность из двух последовательностей\n\n![Algoritmy_24_463cd84be9.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_24_463cd84be9_a7dc9e730b.svg)\n\nМы имеем две последовательности $A=(a_1, a_2, \\dotsc, a_n)$ и $B=(b_1, b_2, \\dotsc, b_m)$, их общая подпоследовательность длиной $p$ — это набор $p$ индексов\n\n$$\n \\begin{matrix}\n1 \\leq i_1 < i_2 <  \\dotsb <  i_p \\leq n \\,,\\\\\n1 \\leq j_1 < j_2 <  \\dotsb <  j_p \\leq m \\,.\n  \\end{matrix} \n$$\n\nпри котором\n\n$$\n \\begin{matrix}\na_{i_1} =~b_{j_1}\\,, \\\\\na_{i_2} =~b_{j_2}\\,, \\\\\n\\vdots  \\\\\na_{i_p} =~b_{j_p}\\, .\\\\\n  \\end{matrix} \n$$\n\nНаибольшая общая подпоследовательность — общая подпоследовательность, которая обладает наибольшей длиной из всех подпоследовательностей.\n\nТакая задача может применяться, например:\n— в сопоставлении данных — утилита diff, операция слияния в разных системах управления версиями;\n— в биоинформатике — поиск сходств в генах разных видов;\n— в проверке орфографии.\n\n* Входные данные: Первая строка: количество элементов первой подпоследовательности $n$. Вторая строка: $a_1, a_2, \\dotsc, a_n$. Третья строка: количество элементов второй подпоследовательности $m$. Четвёртая строка: $b_1, b_2, \\dotsc, b_m$.\n* Выходные данные: $p$.\n* Ограничения: $1 \\le n, m \\le 100$; $-10^9 \\le a_i,b_i  \\le 10^9$ для всех $i$.\n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br>2 7 5 <br>2<br>2 5\n\n|\n\n2\n\n||\n|#\n\n* Общая подпоследовательность длиной 2 — это $(2,5)$.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1<br>7 <br>4<br>1 2 3 4\n\n|\n\n0\n\n||\n|#\n\n* У двух последовательностей нет общих элементов.\n\n#### Пример 3\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4<br>2 7 8 3 <br>4<br>5 2 8 7\n\n|\n\n2\n\n||\n|#\n\n* Одна общая подпоследовательность — $(2,7)$. Ещё одна — $(2,8)$.\n\n### Решение\n\nРассмотрим наибольшую общую подпоследовательность $C=(c_1,\\dotsc,c_p)$, определённую индексами $1 \\le i_1 < i_2 < \\dotsb < i_p \\le n$ и $1 \\le j_1 < j_2 < \\dotsb < j_p \\le m$ (так, для каждого $1 \\le q \\le p$, $a_{i_q}=b_{j_q}=c_q$):\n— Последние символы $A$ и $B$ приводятся в $C$. В этом случае $i_p=n$ и $j_p=m$. Тогда $(c_1,\\dotsc, c_{p-1})$ — это наибольшая общая подпоследовательность от $(a_1, \\dotsc, a_{n-1})$ и $(b_1, \\dotsc, b_{m-1})$.\n— Как минимум один из последних символов $A$ и $B$ не приводится в $C$. В этом случае или $i_p<n$, или $j_p<m$. Тогда $(c_1,\\dotsc, c_{p-1})$ находится полностью в $(a_1, \\dotsc, a_{n-1})$ или $(b_1, \\dotsc, b_{m-1})$.\n\nТаким образом, мы сводим задачу с изначальными строками $A$ и $B$ до такой же задачи с их префиксами. Пусть $LCS(i,j)$ — длина наибольшей общей подпоследовательности $A[1\\dotsc i]$ и $B[1 \\dotsc j]$. Выходит, что эта функция удовлетворяет следующее рекуррентное соотношение:\n\n$$\nLCS(i,j) = \\max \\begin{cases}\n    LCS(i-1,j)\\\\\n    LCS(i,j-1)\\\\\n    LCS(i-1,j-1)+1  &\\text{if }A[i]= B[j]\\\\\n\\end{cases}\n$$\n\nБазовый случай для этого рекуррентного соотношения — $i=0$ или $j=0$:\n\n$$\nLCS(0,j)=LCS(i,0)=0 \\, .\n$$\n\nПолученный алгоритм приведён ниже. Его время выполнения составляет $O(nm)$.\n\n```cpp\nLCS(A[1…n],B[1…m]):\n    table = 2d array of size (n+1)×(m+1)\n    table[i][0] = 0 and table[0][j] = 0 for all i,j\n    for i from 1 to n:\n        for j from 1 to m:\n            table[i][j] = table[i−1][j]\n            table[i][j] = max(table[i][j], table[i][j−1])\n            if A[i]=B[j]:\n                table[i][j] = max(table[i][j], table[i−1][j−1]+1)\n    return table[n][m]\n```\n\n💡  Остановитесь и подумайте:   \n*Получится ли у вас свести задачу «Наибольшая общая подпоследовательность» до задачи «Редакционное расстояние»?*\n\n**Подсказка:** Наибольшая общая подпоследовательность $A=(7,2,9,3,1,5,9,4)$ и $B=(2,8,1,3,9,7)$ получается путём удаления определённых символов из $A$ и $B$.\n\nТак задача «Наибольшая общая подпоследовательность» — всего лишь задача «Редакционное расстояние», в которой запрещены операции «замены».\n\n## Наибольшая общая подпоследовательность из трёх последовательностей\n\n![Algoritmy_27_d705fc05eb.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_27_d705fc05eb_26be911d40.svg)\n\nИмея три последовательности: $A=(a_1, a_2, \\dotsc, a_n)$, $B=(b_1, b_2, \\dotsc, b_m)$ и $C=(c_1, c_2, \\dotsc, c_l)$ — нужно найти длину наибольшей общей подпоследовательности для них, то есть наибольшее неотрицательное целое число $p$, при котором существуют индексы\n\n$$\n \\begin{matrix}\n1 \\leq i_1 < i_2 <  \\dotsb <  i_p \\leq n \\,,\\\\\n1 \\leq j_1 < j_2 <  \\dotsb <  j_p \\leq m \\,,\\\\\n1 \\leq k_1 < k_2 <  \\dotsb <  k_p \\leq l\\\\\n  \\end{matrix} \n$$\n\nпри котором\n\n$$\n \\begin{matrix}\na_{i_1} =~b_{j_1} = c_{k_1}\\,, \\\\\na_{i_2} =~b_{j_2} = c_{k_2}\\,, \\\\\n ~~\\vdots\\\\\na_{i_p} =~b_{j_p} = c_{k_p} \\, .\\\\\n  \\end{matrix} \n$$\n\n* Входные данные: Первая строка: $n$. Вторая строка: $a_1, a_2, \\dotsc, a_n$. Третья строка: $m$. Четвёртая строка: $b_1, b_2, \\dotsc, b_m$. Пятая строка: $l$. Шестая строка: $c_1, c_2, \\dotsc, c_l$.\n* Выходные данные: $p$.\n* Ограничения: $1 \\le n,m,l \\le 100$; $-10^9 \\le a_i,b_i,c_i \\le 10^9$.  \n\n#### Пример 1\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n3<br>1 2 3<br>3<br>2 1 3<br>3<br>1 3 5\n\n|\n\n2\n\n||\n|#\n* Общая подпоследовательность длиной 2 — это $(1,3)$.\n\n#### Пример 2\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5<br>8 3 2 1 7<br>7<br>8 2 1 3 8 10 7<br>6<br>6 8 3 1 4 7\n\n|\n\n3\n\n||\n|#\n\n* В этом случае одна общая подпоследовательность длиной 3 — это $(8, 3, 7)$. Ещё одна — $(8, 1, 7)$.\n\n### Решение\n\nПусть $LCS(i,j,k)$ — это максимальная длина общей подпоследовательности от $A[1\\dotsc i]$, $B[1 \\dotsc j]$ и $C[1 \\dotsc k]$. \n\nТогда\n\n$$\n        LCS(i,j,k) = \\max \\begin{cases}\n                                      LCS(i-1,j,k)\\\\\n                                      LCS(i,j-1,k)\\\\\n                                      LCS(i,j,k-1)\\\\\n                                      LCS(i-1,j-1,k-1)+1  &\\text{if }A[i]= B[j]=C[k]\\\\\n        \\end{cases}\n$$\n\nБазовый случай:\n\n$$\nLCS(0,j,k)=LCS(i,0,k)=LCS(i,j,0)=0 .\n$$\n\nВремя выполнения соответствующего алгоритма составляет $O(nmk)$.",
        "handbook": "Основы алгоритмов",
        "title": "Задача LCS - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-o-ryukzake",
        "content": "![Algoritmy_28_cebcfecefe.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_28_cebcfecefe_43d09b8dcd.svg)\n\nВы нашли несколько золотых слитков. Ваша цель — положить как можно больше золота в рюкзак вместимостью $W$ фунтов. Каждый слиток существует только в одном экземпляре. При этом можно либо взять слиток целиком, либо не брать его вовсе. И хотя все слитки на рисунке выше выглядят одинаково, они обладают разным весом — он приведён ниже.\n\n![Algoritmy_29_0092f2020e.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_29_0092f2020e_77a5300b7b.svg)\n\nЕстественная «жадная» стратегия — взять самый тяжелый слиток, на который хватает вместимости рюкзака, и повторно проверить, а осталось ли место на ещё один слиток. \n\nПри наборе слитков, приведённом выше, и рюкзаке вместимостью $20$ «жадный» алгоритм выбирает слитки весом $10$ и $9$. Однако оптимальное решение — использовать слитки весом 4, 6 и 10!\n\n* Входные данные: Первая строка ввода содержит целое число $W$ (вместимость рюкзака) и количество золотых слитков $n$. В следующей строке приведены $n$ целых чисел $w_1,\\dotsc,w_{n}$, которые определяют вес золотых слитков.\n* Выходные данные: Максимальный вес золотых слитков, который можно уместить в рюкзак вместимостью $W$.\n* Ограничения: $1 \\le W \\le 10^4$; $1 \\le n \\le 300$; $0 \\le w_1,\\dotsc,w_{n} \\le 10^5$.  \n  \n#### Пример 1  \n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n10 3<br>1 4 8\n\n|\n\n9\n\n||\n|#\n\nСумма веса первого и последнего слитков равна $9$.  \n  \nВместо решения изначальной задачи проверим, можно ли выбрать поднабор слитков с общим весом $W$, если имеем $n$ слитков весом $w_0, \\dotsc, w_{n-1}$ (мы перешли на отсчёт с нуля)?\n\n✒️  Упражнение:  \n*Продемонстрируйте, как можно использовать это решение для выполнения задачи «Максимальное количество золота».*\n\nПредположим, что заполнить рюкзак до конца действительно возможно: существует набор $S \\subseteq \\{w_0, \\dotsc, w_{n-1}\\}$ с общим весом $W$. Включает ли он в себя последний слиток с весом $w_{n-1}$?\n\n* Случай 1: Если $w_{n-1} \\not \\in S$, тогда рюкзак вместимостью $W$ может быть заполнен первыми $n-1$ слитками.\n* Случай 2: Если $w_{n-1} \\in S$, тогда мы можем убрать слиток с весом $w_{n-1}$ из рюкзака, и вес оставшихся слитков составит $W-w_{n-1}$. Таким образом, рюкзак с вместимостью $W-w_{n-1}$ можно полностью заполнить первыми $n-1$ слитками.\n\nВ обоих случаях мы свели задачу к практически такой же, но с меньшим количеством слитков и меньшей вместимостью рюкзака. Так, переменная $pack(w, i)$ будет иметь значение ${\\tt true}$, если существует возможность заполнить рюкзак с вместимостью $w$ первыми $i$ слитками, и значение ${\\tt false}$ в остальных случаях. Анализ двух вышеприведённых случаев приводит нас к следующему рекуррентному соотношению для $i>0$:\n\n$$\npack(w,i)=pack(w,i-1) \\text{ или } pack(w-w_{i-1},i-1) .\n$$\n\nОбратите внимание, что при $w_{i-1} > w$ второе выражение не имеет смысла.\n\nКроме того, $pack(0, 0) = {\\tt true}$ и $pack(0,w) = {\\tt false}$ для любого $w > 0$.\n\nВ целом\n\n$$\npack(w,i)=\n\\begin{cases}\n{\\tt true} &\\text{если $i=0$ и $w=0$}\\\\\n{\\tt false} &\\text{если $i=0$ и $w>0$}\\\\\npack(w,i-1) &\\text{если $i>0$ и $w_{i-1} > w$}\\\\\npack(w,i-1) \\text{ или } pack(w-w_{i-1},i-1) &\\text{в остальных случаях}\n\\end{cases}\n$$\n\nТак как значения $i$ варьируются между 0 и $n$, а значения $w$ — между 0 и $W$, мы имеем $O(nW)$ переменных. Так как $pack(w,i)$ зависит от $pack(w,i-1)$, мы обрабатываем все переменные в возрастающем порядке $i$. В приведённом ниже псевдокоде мы используем двумерный массив pack размера $(W+1) \\times (n+1)$, а $pack[w][i]$ сохраняет значение $pack(w,i)$. Время выполнения данного решения составляет $O(nW)$.\n\n```cpp\nKnapsack([w[0],…,w[n−1]],W):\n    pack = two-dimensional array of size (W+1)×(n+1)\n    initialize all elements of pack to false\n    pack[0][0] = true\n    for i from 1 to n:\n        for w from 0 to W:\n            if w[i-1] > w:\n                pack[w][i] = pack[w][i−1]\n            else:\n                pack[w][i]←pack[w][i−1] OR pack[w−w[i−1]][i−1]\n    return pack[W][n]\n```\n\nВ приведённой ниже двумерной таблице представлены результаты вызова ``Knapsack([1,3,4], 8``. F и T означают значения **false** и **true**.\n\n![13_47974a9fe4.webp](https://yastatic.net/s3/education-portal/media/13_47974a9fe4_cbf58db48f.webp)\n\nДругое решение будет заключаться в анализе поднаборов всех слитков. Наша цель — найти поднабор из $n$ слитков с общим весом $W$. Простой подход к такой задаче —  просматривать все поднаборы и проверять, есть ли поднабор с весом $W$. Так как каждый слиток можно или пропустить, или взять, каждый поднабор из трёх слитков, который мы анализируем ($w_0 = 1$, $w_1 = 3$, $w_2 = 4$), можно представить сине-красным бинарным вектором:\n\n![Algoritmy_30_4d1d347fa5.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_30_4d1d347fa5_f2e0b20bb0.svg)\n\nТеперь мы представим каждый поднабор слитков как путь, начинающийся от узла $(0,0)$ сетки $(n+1)\\times (W+1)$. Если первый бит — синий, то он соответствует синему горизонтальному сегменту сетки, связывающему $(0,0)$ с $(0,1)$. Если первый бит — красный, то он соответствует красному сегменту сетки, связывающему $(0,0)$ с $(1,w_0)$. Обработав первые $i$ битов, мы получаем сине-красный путь от $(0,0)$ до некого узла $(i,w)$ на сетке. Если следующий бит — синий, мы связываем $(i,w)$ с $(i+1,w)$. Если следующий бит — красный, мы связываем $(i,w)$ с $(i+1,w+w_i)$, как показано ниже для вектора 101:\n\n![Algoritmy_32_8e2e80c810.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_32_8e2e80c810_d844841e0c.svg)\n\nРисунок ниже демонстрирует пути, которые соответствуют всем восьми бинарным векторам с длиной 3.\n\n![Algoritmy_33_bb172459e6.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_33_bb172459e6_20a4840070.svg)\n\nТеперь мы накладываем все эти восемь путей на одну сетку:\n\n![Algoritmy_31_e25d17d7a3.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_31_e25d17d7a3_a2e4fa2a0d.svg)\n\nМы классифицируем узел $(i,w)$ на сетке как истинный («true») при наличии пути от $(0,0)$ к $(i,w)$ на рисунке выше. В других случаях — ложный («false»). Теперь мы можем полностью заполнить рюкзак с вместимостью $w$ поднабором из первых $i$ слитков, если узел $(i,w)$ — истинный («true»). Узел будет истинным в случаях, если в него проходит или синее, или красное ребро. То есть, если $(i-1,w)$ или $(i-1,w-w_{i-1})$ истинны. Это наблюдение приводит нас к предыдущему рекуррентному соотношению и к такому же решению с динамическим программированием.\n\nА вот ещё один вариант решения, который основан на мемоизации. Приведённый ниже псевдокод рекурсивно вычисляет рекуррентное соотношение из решения 1:\n\n```cpp\nRecursiveKnapsack([w[0],…,w[n−1]],w,i):\n    if i=0 and w=0:\n        return true\n    else if i=0 and w>0:\n        return false\n    else if i>0 and w_[i-1]>w:\n        return RecursiveKnapsack([w[0],…,w[n−1]],w,i−1)\n    else:\n        return RecursiveKnapsack([w[0],…,w[n−1]],w,i−1) OR   RecursiveKnapsack([w[0],…,w[n−1]],w−w[i−1],i−1)\n```\n\nВызов ``RecursiveKnapsack([w_0, ..., w_{n-1}],W, n)`` решает задачу, но он сильно замедлен из-за необходимости перевычислять одни и те же значения снова и снова. Чтобы это продемонстрировать, рассмотрим рюкзак с вместимостью $W=4$ и $n=3$ слитков с весом $w_0=1$, $w_2=1$, $w_3=1$. Вызов ``RecursiveKnapsack([1, 1, 1], 4, 3)`` создаёт рекурсивное дерево, приведённое ниже — каждый узел показывает значения $(w,i)$.\n\nДаже в этом простом примере значение $(w,i)=(3,1)$ вычисляется дважды. С 20 слитками рекурсивное дерево может достичь гигантских размеров — одно и то же значение может вычисляться миллионы раз.\n\n![Algoritmy_25_20b8bc84b8.svg](https://yastatic.net/s3/education-portal/media/Algoritmy_25_20b8bc84b8_22aacaeb40.svg)\n\nВо избежание такого рекурсивного взрыва мы «оборачиваем» код мемоизацией с помощью ассоциативного массива $pack$, который изначально пуст. Ассоциативный массив — это абстрактный тип данных, в котором хранятся пары $key, value$. Он поддерживается многими языками программирования и, как правило, реализуется как хеш-таблица или дерево поиска. К примеру, в **C++** и **Java** ассоциативный массив называется *картой («map»)*, а в **Python** — *словарём («dictionary»)*. В реализации, приведённой ниже, ассоциативный массив $pack$ используется для хранения логических значений для пар $(w, i)$.\n\n```cpp\nMemoizedKnapsack([w[0],…,w[n−1]],pack,w,i):\n    if (w,i) is not in pack:\n        if i=0 and w=0:\n            pack[(w,i)] = true\n        else if i=0 and w>0:\n            pack[(w,i)] = false\n        else if i>0 and w_[i-1]>w:\n            pack[(w,i)] = MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i−1)\n        else: \n            pack[(w,i)] = MemoizedKnapsack([w[0],…,w[n−1]],pack,w,i−1) OR MemoizedKnapsack([w[0],…,w[n−1]],pack,w−w[i−1],i−1)\n    return pack[(w,i)]\n```\n\nВремя выполнения итогового решения составляет $O(nW)$, так как количество рекурсивных вызовов, не являющихся уточняющими запросами в ассоциативный массив, не превышает это число. Следовательно, это такое же время выполнения, как и у соответствующего итерационного алгоритма. На практике же итерационное решение, как правило, быстрее, потому что в нём нет рекурсивных издержек и оно использует более простые структуры данных. Например, массив вместо хеш-таблицы. Тем не менее с рассматриваемой задачей ситуация иная: при некоторых наборах данных, рекурсивная версия быстрее итерационной. К примеру, если мы умножим все весовые значения на $10$, то время выполнения итерационного алгоритма также умножится на $10$, в то время как время выполнения рекурсивного останется таким же. В целом, если необходимо решить все возможные подзадачи, итерационный вариант обычно быстрее.",
        "handbook": "Основы алгоритмов",
        "title": "Задача о рюкзаке - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-suveniry",
        "content": "![Algoritmy](https://yastatic.net/s3/education-portal/media/Algoritmy_26_1_417706f2c4_79ce29bc0e.svg)\n\nТри пирата делят свою добычу, в которую входят $n$ предметов разной ценности. Получится у вас помочь разделить добычу поровну?\n\n* Входные данные: Первая строка содержит целое число $n$. Вторая строка содержит целые числа $v_1, v_2, \\dotsc, v_n$, разделённые пробелами.\n* Выходные данные: Вывести 1, если $v_1, v_2, \\dotsc, v_n$ можно разделить на три поднабора с одинаковыми суммами; в противном случае — вывести 0.\n* Ограничения: $1 \\le n \\le 20$, $1 \\le v_i \\le 30$ для всех $i$.\n\n**Пример 1**\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n4<br>3 3 3 3\n\n|\n\n0\n\n||\n|#\n\n**Пример 2**\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n1<br>30\n\n|\n\n0\n\n||\n|#\n\n**Пример 3**\n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n13<br>1 2 3 4 5 5 7 7 8 10 12 19 25\n\n|\n\n1\n\n||\n|#\n\n* $1+3+7+25=2+4+5+7+8+10=5+12+19$.\n\nРассмотрим решение задачи. Обозначим $v_1+v_2+\\dotsb+v_i$ как $\\operatorname{sum}(i)$. Разделить набор из $n$ предметов на три части возможно, только если их общая ценность делится на три. То есть $\\operatorname{sum}(n)=3V$, где $V$ — это целое число. Так, нам необходимо разделить $n$ чисел на три части, где сумма чисел в каждой части равна $V$. Одна из этих частей содержит $n$-й трофей (с ценностью $v_n$). Если мы его уберём, то получим разделение первых $n-1$ трофеев на три части таким образом, что ценность двух из них будет равна $V$, а сумма оставшейся части — $V-v_n$.\n\nВместо разделения всех $n$ предметов, попробуем решить более мелкую задачу, состоящую в делении первых $i$ предметов на части с ценностью $s_1$, $s_2$ и $\\operatorname{sum}(i)-s_1 - s_2$. Если такое разделение возможно, мы присваиваем $split(i,s_1,s_2)={\\tt true}$ (в противном случае — ${\\tt false}$) и отмечаем, что пираты могут разделить добычу честно, только если $split(n,V,V)={\\tt true}$.\n\n💡  Остановитесь и подумайте:\\\n*Учитывая первые пять предметов,* $split(5,4,13)={\\tt true}$. Найдите все значения $split(5,s_1,s_2)$, равные ${\\tt true}$.\n\n💡  Остановитесь и подумайте:\\\n*Представьте, что вы уже составили двоичный двумерный массив* $split(i-1,s_1,s_2)$ для всевозможных значений $0 \\le s_1 \\le V$ и $0 \\le s_2 \\le V$. Сможете ли вы использовать этот массив, чтобы составить массив $split(i,s_1,s_2)$?\n\nПредположим, что $split(i,s_1,s_2) = {\\tt true}$. Тогда первые $i$ чисел можно разделить на три части таким образом, чтобы сумма чисел в первой части составляла $s_1$, а сумма чисел во второй части — $s_2$.\n\n* $i$-й предмет принадлежит первой части. Тогда $v_i \\le s_1$. Убрав его из первой части, мы разделим первые $i-1$ чисел на три части так, что сумма первых двух частей составит $s_1-v_i$ и $s_2$, то есть $split(i-1,s_1-v_i,s_2)={\\tt true}$.\n* $i$-й предмет принадлежит второй части. Как и в предыдущем случае, $v_i \\le s_2$ и $split(i-1,s_1,s_2-v_i)={\\tt true}$.\n* $i$-й предмет принадлежит третьей части. Тогда $split(i-1,s_1,s_2)= {\\tt true}$.\n\nТак, значение $split(i,s_1,s_2)$ можно вычислить, посмотрев на\n\n$$split(i-1,s_1-v_i,s_2),\\,\nsplit(i-1,s_1,s_2-v_i),\\,\nsplit(i-1,s_1,s_2).\n$$\n\nБазовый случай для этого рекуррентного соотношения: $split(0,0,0)={\\tt true}$ и $split(0,s_1,s_2)={\\tt false}$, если $s_1+s_2>0$.\n\n```cpp\nSplit(v[1],…,v[n]):\n    if v[1] + … + v[n] не делится целочисленно на 3:\n        return false\n    V = (v[1] + … + v[n]) / 3\n    split = ... // массив размера (n+1) × (V+1) × (V+1)\n    // заполнить массив split значениями false\n    split[0][0][0] = true\n    for i from 1 to n:\n        for s1 from 0 to V:\n            for s2 from 0 to V:\n                split[i][s1][s2] = split[i−1][s1][s2]\n                if s1 >= v[i]:\n                    split[i][s1][s2] = split[i][s1][s2] OR split[i - 1][s1 - v[i]][s2]\n                if s2 >= v[i]:\n                    split[i][s1][s2] = split[i][s1][s2] OR split[i - 1][s1][s2 - v[i]]\n    return split[n][V][V]\n```\n\nВремя выполнения составляет $O(nV^2)$.",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Сувениры» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-rasstavit-skobki",
        "content": "Для выражения $(3+2\\times 4)$ существуют два способа расставить скобки: $(3+(2\\times4))=11$ и $((3+2) \\times 4)=20$.\n\n✒️  Упражнение:  \n*Для максимального значения нужно поставить в скобки выражение $(5-8+7\\times4-8+9)$.*\n\n* Входные данные: Ввод содержит только строку $s$ длиной $2n+1$ для некого $n$ с символами $s_0,s_1, \\dotsc, s_{2n}$. Каждый символ на чётной позиции $s$ — это цифра (то есть целое число от 0 до 9), а на нечетной позиции — одна из трёх операций из ${\\tt \\{+,-,*\\}}$.\n* Выходные данные: Максимальное значение данного арифметического выражения из всех возможных порядков арифметических операций.\n* Ограничения: $0 \\le n \\le 14$ — таким образом, строка содержит максимум $29$ символов.  \n\n**Пример 1**  \n\n#|\n||\n\nВвод\n\n|\n\nВывод\n\n||\n||\n\n5-8\\+7\\*4-8\\+9\n\n|\n\n200\n\n||\n|#\n\n* $200=(5-((8+7)\\times(4-(8+9))))$\n\nРассмотрим решение задачи. Каждая из пяти операций в выражении\n\n$$\n(5-8+7\\times4-8+9) \n$$\n\nможет быть последней — внешней. Рассмотрим случай, в котором последняя операция — «$\\times$», то есть умножение. В этой ситуации нам необходимо поместить два *подвыражения* в скобки\n\n$$\n(5-8+7) \\text{ и } (4-8+9)\\, \n$$\n\nтаким образом, чтобы произведение значений было максимальным. Чтобы это выяснить, мы находим минимальные и максимальные значения данных двух подвыражений:\n\n$$\n\\begin{aligned}\n        \\min(5-8+7)&=(5-(8+7))=&-10,\\\\\n        \\max(5-8+7)&=((5-8)+7)=&4,\\\\\n        \\min(4-8+9)&=(4-(8+9))=&-13,\\\\\n        \\max(4-8+9)&=((4-8)+9)=&5.\\\\\n\\end{aligned}\n$$\n\nНа основании этих значений мы заключаем, что общее значение произведения составляет $130$.\n\nПредположим, что вводный набор данных имеет форму\n\n$$\nd_0\\quad op_0 \\quad d_1 \\quad op_1 \\quad \\dotsb \\quad op_{n-1} \\quad d_n\\, ,\n$$\n\nгде каждая $d_i$ — это цифра, а каждая $op_j \\in \\{+,-,\\times\\}$ — базовая арифметическая операция. Сказанное выше предполагает, что мы вычисляем минимальное и максимальное значение каждого подвыражения в форме\n\n$$\nE_{l,r}=d_l\\quad op_l\\quad d_{l+1}\\quad op_{l+1}\\quad \\dotsb \\quad op_{r-1}\\quad  d_r\\, ,\n$$\n\nгде $0 \\le l \\le r \\le n$. Пусть $minValue(l,r)$ и $maxValue(l,r)$ — минимальное и максимальное значение $E_{l,r}$ соответственно. Тогда\n\n$$\n\\begin{align*}\n    minValue(l,r)=\\min\\limits_{l \\le m < r}\n    &\\begin{cases}\n            minValue(l,m) & op_m\\quad  minValue(m+1,r)\\\\\n            minValue(l,m) & op_m\\quad  maxValue(m+1,r)\\\\\n            maxValue(l,m) & op_m\\quad  minValue(m+1,r)\\\\\n            maxValue(l,m) & op_m\\quad  maxValue(m+1,r)\\\\\n    \\end{cases}\\\\\n    maxValue(l,r)=\\max\\limits_{l \\le m < r}\n    &\\begin{cases}\n            minValue(l,m) & op_m\\quad  minValue(m+1,r)\\\\\n            minValue(l,m) & op_m\\quad  maxValue(m+1,r)\\\\\n            maxValue(l,m) & op_m\\quad  minValue(m+1,r)\\\\\n            maxValue(l,m) & op_m\\quad  maxValue(m+1,r)\\\\\n    \\end{cases}\\\\\n\\end{align*}\n$$\n\nБазовый случай — это $l=r$:\n\n$$\nminValue(l,l)=maxValue(l,l)=d_l .\n$$\n\nЭти два рекуррентных соотношения позволяют нам вычислить оптимальные значения $E_{l,r}$, изучив все возможные варианты разделения $E_{l,r}$ на два подвыражения $E_{l,m}$ и $E_{m+1,r}$.\n\nТогда наше рекуррентное соотношение говорит о том, что дерево состоит из корня и двух поддеревьев. Для нахождения оптимальной формы дерева мы анализируем все возможные корни (за это отвечает параметр $m$), а затем составляем дерево из двух оптимальных поддеревьев.\n\nКак обычно, сделать из рекуррентного соотношения рекурсивный алгоритм довольно просто. Рекурсивная процедура берёт индексы $l$ и $r$ в качестве параметров и использует их для вычисления минимального и максимального значения подвыражения $E_{l,r}$. Перед тем, как начать вычисления, проверяется, не сохранены ли уже эти значения в $table[l,r]$, где $table$ — это ассоциативный массив, хранящий уже вычисленные результаты. Если запись $table[l,r]$ отсутствует, рекурсивная процедура вычисляет два значения, используя рекуррентное соотношение, сохраняет их в таблицу и выдаёт их. Конечный ответ соответствует $l=0$ и $r=n$. Время выполнения составляет $O(n^3)$: есть $O(n^2)$ возможных пар $(l,r)$, для каждой из которых рекурсивная процедура проверяет возможные значения для $l \\le m < r$.\n\nДля переведения рекурсивного алгоритма в итерационный используются двумерные таблицы $mins[0..n][0..n]$ и $maxs[0..n][0..n]$, в которых хранятся минимальные и максимальные значения всех подвыражений. Заполняя данные таблицы, нам нужно убедиться, что к окончанию вычислений оптимальных значений для $E_{l,r}$ оптимальные значения $E_{l,m}$ и $E_{m+1,r}$ для всех $m$ уже вычислены. Один из способов сделать это — перечислить все пары $(l,r)$ в порядке возрастания значения $r-l$. Чтобы это сделать, в псевдокоде ниже используется параметр $s=r-l$.\n\n```cpp\nMaxValue(d[0],op[0],d[1],op[1],…d[n]):\n    mins, maxs = 2d-arrays of size (n+1)×(n+1)\n    fill mins with +infinity, fill maxs with -infinity\n    for i from 0 to n:\n        mins[i][i]=d[i], maxs[i][i]←d[i]​\n    for s from 1 to n:\n        for l from 1 to n-s:\n            r = l+s\n            for m from l to r-1:\n                a = mins[l][m] op[m] mins[m+1][r]\n                b = mins[l][m] op[m] maxs[m+1][r]\n                c = maxs[l][m] op[m] mins[m+1][r]\n                d = maxs[l][m] op[m] maxs[m+1][r]\n                mins[l][r] = min(mins[l][r],a,b,c,d)\n                maxs[l][r] = max(maxs[l][r],a,b,c,d)\n    return maxs[0][n]\n```",
        "handbook": "Основы алгоритмов",
        "title": "Задача «Расставить скобки» - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/odnosvyaznyj-spisok",
        "content": "Односвязный список (иногда «связный список») — базовая структура данных, представляющая собой соединённые узлы с однотипными данными. Каждый узел состоит из элемента и ссылки на следующий элемент (см. рисунок).\n\nСамый первый элемент списка называют головой (head) односвязного списка, а последний — хвостом (tail). Последний элемент односвязного списка в качестве ссылки содержит null-значение.\n\n![algosy_9_1_682a724c58.svg](https://yastatic.net/s3/education-portal/media/algosy_9_1_682a724c58_02386a3b42.svg)\n  \n💡  Остановитесь и подумайте:  \n*Какие достоинства и недостатки по сравнению с обычным массивом у односвязного списка?*\n\nВ отличие от классического массива, где данные в памяти расположены строго последовательно, в односвязном списке, наоборот, данные расположены хаотично и связывание узлов списка происходит посредством ссылок. За счёт этой особенности в односвязный список можно добавлять произвольное число элементов, однако, доступ будет осуществляться только последовательно. Произвольного доступа к элементам в односвязном списке нет. \n\nСо списком можно производить ряд операций:\n* Добавить элемент (add).\n* Удалить элемент (remove).\n* Найти элемент (find).\n* Посчитать количество элементов по условию (count).\n\nОперация добавления элемента (add) может быть представлена в нескольких вариантах. Элемент можно добавить в начало списка, можно добавить в конец списка или после определённого элемента. Перед добавлением элемента необходимо создать узел, положив в него заданное значение, затем связать ссылку со списком. В случае добавления в начало списка ссылка нового узла будет указывать на голову списка, а голова списка должна быть перемещена на новый узел. Если добавление идёт в конце списка, то ссылка хвоста списка должна указывать на новый узел, а после должна быть перемещена на новый узел. Сложность этих операций — $O(1)$.\n\nУдаление элемента (remove) предполагает, что будет найден заданный элемент и следом он будет удалён. Нахождения узла требует прохода по односвязному списку, после чего необходимо ссылку с элемента перед удаляемым перенаправить на элемент после удаляемого. Сложность операции — $O(n)$, где $n$ — число элементов в списке.\n\nНахождение элемента (find) предполагает простой однократный проход по списку с нахождением ссылки на заданный элемент. Сложность операции — $O(n)$, где $n$ — число элементов в списке.\n\nПодсчёт числа элементов по условию (count) предполагает проход по списку и сравнение всех элементов с заданным с подсчётом количества удовлетворяющих условию элементов. Сложность операции — $O(n)$, где $n$ — число элементов в списке.",
        "handbook": "Основы алгоритмов",
        "title": "Односвязный список - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/mnozhestvo",
        "content": "Следующей структурой данных, которую мы рассмотрим, будет множество ($set$). Множество представляет собой контейнер, содержащий неповторяющиеся элементы в произвольном порядке. Обратите внимание, в стандартной библиотеке С++ реализовано упорядоченное множество, что накладывает свои особенности на вычислительную сложность некоторых операций. Далее в данном параграфе мы будем разграничивать упорядоченные и неупорядоченные множества.\n\nКроме того, существует такое понятие, как мультимножество ($multiset$), которое может включать в себя несколько одинаковых элементов.\n\nВы можете посмотреть на различия между множеством и мультимножеством на рисунке ниже.\n\n![algosy_9_2_59961e6818.svg](https://yastatic.net/s3/education-portal/media/algosy_9_2_59961e6818_49f28c2278.svg)\n\nВнутренняя реализация множества осуществляется различными способами, включая использование хэш-таблицы, бинарного дерева поиска и других алгоритмов. В данном параграфе мы сосредоточимся на функциях, которые можно производить со множеством, а не на внутренней его реализации.\n\nОсновные операции со множеством:\n* Добавление элемента в множество.\n* Удаление элемента из множества.\n* Проверка наличия элемента в множестве. \n* Объединение двух множеств.\n* Пересечение двух множеств. \n* Разность двух множеств.\n\nРассмотрим основные операции со множеством на примере двух языков С++ и Python. В STL языка С++ реализовано упорядоченное множество, в то время как в Python — неупорядоченное множество.\n\nДобавление элемента в множество можно произвести следующим образом.\n\n```cpp\n    my_set = {1, 2, 3}\n    my_set.add(2)\n    print(my_set)\n    my_set.add(4)\n    print(my_set)\n```\n\nВ результате исполнения фрагмента кода выше на экран будет выведено две строки: 1 2 3 и 1 2 3 4. Сложность операции добавления элемента во множество в Python — $O(1)$, так как множество не упорядочено и не нужно искать позиции для его вставки.\n\nВ языке С++ добавление элемента может быть осуществлено следующим образом (не забудьте добавить #include\\<set> в начало вашего кода).\n\n```cpp\n    set<int> val = {6, 10, 5, 1};\n    val.insert(6);\n    val.insert(10);\n    val.insert(2);\n    cout << val.size();\n```\nВ итоге на экран будет выведено 5. В случае реализации на С++ мы имеем дело с упорядоченным множеством, что накладывает дополнительные временные издержки. Асимптотическая сложность добавления элемента – $O(logn)$.\n\nНе менее важной операцией является операция удаления элемента из множества. \n\n```cpp\n    set<int> val = {6, 10, 5, 1};\n    val.erase(6)\n    cout << val.size();\n```\n\nБлагодаря фрагменту кода выше произошло удаление элемента, поэтому на экране появится число 3. Сложность операции удаления в упорядоченном множестве — $O(logn)$.\n\nРассмотрим удаление элемента из множества в Python:\n\n```cpp\n    my_set = {1, 2, 3}\n    my_set.remove(1);\n    print(len(my_set))\n```\n\nРазмер множества после удаления элемента становится равным двум. Сложность операции удаления в неупорядоченном множестве — $O(1)$.\n\n\nПроверка наличия элемента в множестве предполагает просмотр элементов в нём. В случае неупорядоченного множества, реализованного на хэш-таблицах, сложность — О(1). Однако, при использовании упорядоченного множества сложность становится O(logn).\n\nОбъединение множеств предполагает их слияние в единое множество. Например, пусть было два множества. Первое содержало элементы 1, 2 и 3, а второе 2, 3 и 4. В результате объединения получится множество, содержащее четыре элемента 1, 2, 3 и 4.\n\nПересечение множеств представляет из себя поиск в двух множествах одинаковых элементов. Пусть первое множество содержит элементы 1, 2 и 3, а второе — 2, 3 и 4. Тогда пересечением множеств будут являться элементы 2 и 3.\n \nРазность двух множеств предполагает нахождение всех элементов из первого множества, за исключением тех, которые находятся во втором множестве. Пусть первое множество содержит элементы 1, 2 и 3, а второе — 2, 3 и 4. Тогда разностью множеств будет элемент 1.\n\n💡  Упражнение:   \n*Поработайте с двумя множествами А = {1, 3, 4, 5, 6}, B = {1, 2, 4, 6, 8, 9}. Для данных множеств найдите объединение, пересечение и разность.*\n",
        "handbook": "Основы алгоритмов",
        "title": "Множество - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/slovar",
        "content": "Следующей структурой данных, которую мы рассмотрим, будет словарь (map, dictionary) или, так называемый ассоциативный массив, позволяющий хранить пары вида «ключ — значение». Ключ — уникальный идентификатор, а значение может быть любой объектной переменной, включая другие структуры данных. Например, списки или другие словари. Ключи и значения могут выводиться в различном порядке, потому что словари не упорядочены.\n\nАналогично множеству, у словаря существует мультисловарь (multimap), который позволяет хранить несколько элементов с одинаковым ключом. Посмотрите на примеры ниже.\n\n![algosy_9_3_4a162ebdc9.svg](https://yastatic.net/s3/education-portal/media/algosy_9_3_4a162ebdc9_5dcc04ac1f.svg)\n\nДовольно часто словари реализуют с использованием хэш-таблиц. Говоря об асимптотической сложности операций со словарем, будем иметь ввиду реализацию на хэш-таблицах.\n\nОсновные операции со словарем и их асимптотическая сложность:\n1. Добавление нового элемента с уникальным ключом — O(1).\n2. Удаление элемента по ключу — O(1).\n3. Изменение значения по ключу — O(1).\n4. Получение значения по ключу — O(1).",
        "handbook": "Основы алгоритмов",
        "title": "Словарь - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/stek",
        "content": "Стек (stack) — структура данных, которая работает по принципу «последним пришёл, первым ушёл» (LIFO — last in, first out). Стек можно представить как некий контейнер, в котором элементы (например, числа, символы и так далее) могут быть добавлены в вершину, а затем извлечены только из вершины. В бытовом плане стек напоминает стопку тарелок. Тогда тарелка, которую положили первой, в самый низ, будет использована последней.\n\nСуществуют различные реализации стека. Например, стек может быть реализован на массиве, на односвязном списке, на двусвязном списке и так далее. В параграфе будем говорить о реализации стека на односвязном списке.\n\nОсновные операции, которые можно производить со стеком, включают: \n* Добавление элемента в вершину стека (push) — $O(1)$.\n* Удаление элемента из вершины стека (pop) — $O(1)$.\n* Возврат верхнего элемента без его удаления (peek) — $O(1)$.\n* Проверка стека на пустоту (isEmpty) — $O(1)$.\n\nСтоит отметить, что стек представляет собой список с элементами и указателя на вершину стека, указывающего на последний элемент, добавленный в стек.\n\nКаждый раз, когда в стек добавляется новый элемент, указатель на вершину смещается на следующий элемент. Когда элемент удаляется из вершины стека, указатель смещается на предыдущий элемент. Если указатель находится в конце стека, то стек пуст.",
        "handbook": "Основы алгоритмов",
        "title": "Стек - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/ochered-s-prioritetom",
        "content": "Очередь с приоритетом — коллекция элементов, где каждый элемент имеет связанный с ним приоритет. Элемент с высшим приоритетом будет обрабатываться раньше, чем элементы с более низким приоритетом.\n\nОчередь с приоритетом можно реализовать различными способами, но обычно главные операции над ними:\n\n1. Вставка элемента с приоритетом — добавление элемента в очередь с учётом его приоритета. В зависимости от реализации, элемент может быть добавлен в начало, в середину очереди или конец.\n2. Извлечение элемента с наивысшим приоритетом — удаление элемента из очереди с наивысшим приоритетом. В зависимости от реализации, удаление может происходить из начала, середины очереди или конца.\n3. Просмотр элемента с наивысшим приоритетом — просмотр элемента с наивысшим приоритетом без его удаления.\n4. Поиск элемента с определенным приоритетом — поиск элемента в очереди с опредёленным приоритетом.\n\nОсновные способы реализации очереди с приоритетом включают в себя использование массивов, связанных списков, бинарных куч и древовидных структур. В зависимости от реализации, каждый из этих способов имеет свои преимущества и недостатки в терминах времени выполнения операций.\n\n![algosy_9_5_68368001dc.svg](https://yastatic.net/s3/education-portal/media/algosy_9_5_68368001dc_e61e72b895.svg)",
        "handbook": "Основы алгоритмов",
        "title": "Очередь с приоритетом - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/dek-(veque-double-ended-queue)",
        "content": "Дэк (deque, double-ended queue) — универсальная структура данных, которая представляет собой последовательность элементов, у которой есть два конца. Причём добавление и удаление элементов может происходить как в начало, так и в конец структуры.\n\nСтруктура дэк обладает следующими особенностями:\n* Вставка элемента возможна как в начало, так и в конец.\n* Удаление элемента так же возможно как в начале, так и в конце.\n* Доступ к первому и последнему элементу производится за константное время O(1).\n* Доступ к элементам в середине дэка осуществляется за линейное время O(n), так как элементы хранятся последовательно.\n\nВ целом, дэк представляет собой смесь стека и очереди.\n\nСтруктура дэк может реализовываться различными способами, например, с использованием двух стэков или двусвязного списка.\n\n![algosy_9_6_3f25b95c24.svg](https://yastatic.net/s3/education-portal/media/algosy_9_6_3f25b95c24_81bf28239d.svg)",
        "handbook": "Основы алгоритмов",
        "title": "Дэк (deque, double-ended queue) - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/priroda-grafa",
        "content": "В данном параграфе мы разберём основные понятия и определения теории графов — раздела математики, который изучает графы, их природу, структуры и алгоритмы. Также посмотрим, где можно встретить графы в реальной жизни.\n\nГраф состоит из множества вершин, соединённых ребрами. По сути, рёбра и вершины — базовые понятия. Обычно граф обозначают $G(V, E)$, где $V$ — множество вершин, $E$ — множество рёбер/дуг. Проведём аналогию с картой метро, которую можно рассматривать как граф, где станции — вершины, а перегоны — рёбра. Другим примером может служить обычная карта, где населенные пункты — вершины графа, а рёбра — соединяющие их дороги. Генеалогические деревья, блок-схемы, схемы авиалиний и железных дорог — всё это примеры графов.\n\nРёбра и вершины графа могут иметь свои имена. Посмотрим на пример графа на рисунке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_1_929d242645_397ff32e01.svg)\n\nГраф может быть ориентированным или неориентированным. В неориентированном графе рёбра не имеют направления, то есть движение по ним возможно в двух направлениях. В ориентированном графе рёбра обычно называют дугами. Пройти по дуге можно только в заданном направлении. Пример ориентированного графа приведён на рисунке ниже. В дальнейшем под понятием граф мы будем понимать именно неориентированный граф.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_2_56c529e672_4601754748.svg)\n\nВ графе могут быть рёбра и дуги особого типа, которые входят и выходят из одной вершины. Такие рёбра и дуги называются петлями.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_3_83ebd64d58_e810adbeea.svg)\n\nМежду рёбрами и вершинами в графах существуют отношения смежности и инцидентности. Термин смежность применяется к объектам одного вида — смежными между собой могут быть вершины и рёбра. Одна вершина смежна другой, если они соединены дугой или ребром. Одно ребро смежно другому ребру, если у них есть общая вершина, из которой они выходят.\n\nПонятие инцидентности применяется к рёбрам и вершинам. Ребро инцидентно вершине, если это ребро выходит из вершины.\n\nПомимо обычных графов, существуют ещё графы особого вида. Например, мультиграф — граф, у которого может быть несколько кратных рёбер или дуг. Пример ориентированного и неориентированного мультиграфа приведён на рисунке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_4_8d7007e6ab_2ef79d12ca.svg)\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_5_c95ba83afd_42ec3b65d7.svg)\n\nРёбрам графа, при необходимости, можно задать веса. В таком случае граф становится взвешенным или нагруженным. В качестве веса может выступать, например, расстояние между городами. На рисунке ниже показан пример взвешенного графа.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_6_eef5b3c93b_b1706499af.svg)\n\nВ рамках данного параграфа нам также понадобится знать определение двудольного графа. Как следует из названия, граф состоит из двух долей, в каждой из которых никакие две вершины не смежны. На рисунке ниже можно увидеть, что вершины 1, 2 и 3 принадлежат одной доле, а вершины 4 и 5 другой.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_7_550cd04177_3c88a0fd8c.svg)\n\nКак вы думаете, а может ли граф вообще не содержать ребер? Да, такое бывает. В этом случае говорят о нуль-графе.\n\nА может быть и обратная ситуация, когда граф содержит все возможные ребра или дуги. Такие графы называются полными. Посмотрите на пример полного графа ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_8_0f210dab43_00486211b8.svg)\n\n💡  Остановитесь и подумайте:\n*Сколько рёбер может быть в полном неориентированном графе? А в ориентированном?*\n\nДвудольный граф также может быть полным. Полный двудольный граф — граф, содержащий все возможные рёбра или дуги. Пример полного двудольного графа изображён ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_9_222b6935b0_e259a9995e.svg)\n\nВ графе можно построить путь — последовательность связанных рёбер, которые соединяют вершины графа. Цикл — путь, который начинается и заканчивается в одной и той же вершине.\n\nА может ли в графе отсутствовать цикл? Да, может, и в этом случае речь о таком графе как дерево. Дерево — граф без циклов.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_10_ea6aa4dd51_9c5c630afb.svg)\n\nГрафы могут быть связными и не связными. Связный граф тот, в котором от всех вершин до каждой существует путь. Пример несвязного графа приведён на рисунке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_1_11_956f3dce3c_3e980b9985.svg)\n\nПри этом в ориентированном графе говорят о сильной и слабой связности. Ориентированный граф называется:\n\n* слабо связным - если его неориентированный аналог является связным;\n* сильно связным - если всякая вершина v достижима из любой вершины u.\n\nОчевидно, что любой сильно связный граф, также является и слабо связным.\n\nВажно отметить, что графы имеют свои характеристики. Например, для вершин графа существует понятие степени. Степень вершины — число инцидентных этой вершине рёбер. Обычно степень вершины обозначают функцией $d(v)$. На рисунке ниже, $d(1)=1$, $d(2)=3$, $d(3)=2$, $d(4)=2$.\n\n![algosy_10_1_7_550cd04177_3c88a0fd8c.2.svg](https://yastatic.net/s3/education-portal/media/algosy_10_1_7_550cd04177_3c88a0fd8c_2_9953b925b1.svg)\n\nВ ориентированном графе говорят про полустепени исхода и захода. Под полустепенью исхода понимается количество дуг, выходящих из вершины. Под полустепенью захода понимают число дуг, заходящих в вершину. Обычно, полустепень исхода обозначают $d-(v)$, а полустепень захода — $d+(v)$.\n\nЕсли речь про петли, то в случае неориентированного графа она учитывается как два ребра, а в случае ориентированного для вершины эта дуга учитывается и в полустепени исхода, и в полустепени захода.\n\n✒️  Упражнение:\n*Для ориентированного графа, изображенного на рисунке 2 посчитайте полустепени исхода и захода.*",
        "handbook": "Основы алгоритмов",
        "title": "Природа графа - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/predstavlenie-grafa-v-pamyati-kompyutera",
        "content": "В прошлом параграфе мы обсудили основные определения теории графов. Однако, чтобы работать с графами, необходимо их как-то хранить в памяти компьютера. К сожалению, не существует универсального способа хранения графов, потому что каждый имеет свои достоинства и недостатки.\n\nРассмотрим такой способ хранения графа, как матрица смежности. Матрица смежности представляет собой матрицу, где по строкам и столбцам располагаются номера вершин. Если рёбра между вершинами отсутствует, то на пересечении $i$-ой строки и $j$-ого столбца ставится 0. Если ребро есть, то ставят 1. Пример графа и его матрицы смежности приведён на рисунке ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_2_1_f4710a0482_2c28e98d02.svg)\n\n💡  Остановитесь и подумайте:\\\nВсегда ли матрица смежности для неориентированного графа симметрична?\n\nРассмотрим пример матрицы смежности для ориентированного графа. В целом, отличий не так много, кроме того, что матрица смежности перестала быть симметричной. Подумайте, почему.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_2_2_c1e62c2a12_79aa8c3ecd.svg)\n\nТакже при работе с графами применяется и матрица инцидентности. По столбцам располагаются рёбра, а по строкам номера вершин. На пересечении $i$-ой вершины и $j$-ого ребра ставится 1, если одним из концов ребра $j$ была вершина $i$. Пример приведён ниже.\n\n![algosy_10_2_3_c6a515c37f_144bf8e17b.svg](https://yastatic.net/s3/education-portal/media/algosy_10_2_3_c6a515c37f_144bf8e17b_8b466e21be.svg)\n\nВ случае ориентированного графа матрица инцидентности не сильно меняется, за исключением того, что на пересечении $i$-ой вершины и $j$-ого ребра ставится 1, когда дуга $j$ входит в вершину $i$ и -1, когда выходит.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_2_4_cf97227b9c_618ff911e8.svg)\n\nДля экономии памяти может использоваться список смежности, который представляет из себя набор списков по числу вершин в графе. Каждый список представляет из себя перечисление всех смежных данной вершине.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_2_5_ea1ec52f35_b5fb1caeb3.svg)\n\nВ случае ориентированного графа список смежности выглядит аналогичным образом.\n\n![algosy_10_2_6_28c8c705eb_452d4f7e6c (1).svg](https://yastatic.net/s3/education-portal/media/algosy_10_2_6_28c8c705eb_452d4f7e6c_1_2508de17dc.svg)\n\nВ некоторых случаях удобнее использовать список рёбер. Он представляет собой перечисление всех рёбер графа. Пример приведен ниже.\n\n![algosy](https://yastatic.net/s3/education-portal/media/algosy_10_2_7_20b70e0ab8_362c96719f.svg)\n\n✒️  Упражнение:\\\n*Подумайте, а какой вариант хранения графа в памяти компьютера самый оптимальный. Почему?*",
        "handbook": "Основы алгоритмов",
        "title": "Представление графа в памяти компьютера - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/obhody-grafa",
        "content": "Пришла пора рассмотреть первые алгоритмы на графах. К классическим алгоритмам относятся обходы графов. Под обходом графа обычно понимают процесс систематического просмотра всех вершин или рёбер графа, чтобы найти некоторые вершины, удовлетворяющие определённым условиям. Мы рассмотрим обход в ширину и обход в глубину.\n\nОбход в глубину заключается в систематическом просмотре вершин графа и прохождении его ветвями. Иными словами, идея поиска в глубину — когда возможные пути по рёбрам, выходящим из вершин, разветвляются, нужно сначала полностью исследовать одну ветку и только потом переходить к другим веткам (если они останутся нерассмотренными).\n\nОпишем алгоритм поиска в глубину:\n  - Шаг 1. Все вершины графа отмечаем, как не посещенные. Выбирается первая вершина и помечается как посещённая.\n  - Шаг 2. Для последней помеченной как посещённой вершины выбирается смежная вершина, которая первая помеченная как не посещенная, и ей присваивается значение посещённой. Если таких вершин нет, то берётся предыдущая помеченная вершина.\n  - Шаг 3. Повторяем шаг 2 до тех пор, пока все вершины не будут помечены как посещённые.\n\nПример реализации приведён ниже.\n\n```cpp\nDFS(graph, v, used):\n    used[v] = 1\n    for (var u : graph[v])\n        if (!used[u])\n           DFS(graph, u, used)\n```\n    \n✒️  Упражнение:    \nПопробуйте выполнить алгоритм поиска в глубину пошагово для графа.\n\n\nОбратите внимание, сейчас мы посмотрели на рекурсивную реализацию. Конечно, преимущество использования рекурсивного подхода заключается в простоте его написания, однако, рекурсивный подход имеет свои ограничения.\n\nМожно переписать алгоритм поиска в глубину с использованием особых структур данных. Например, стека.\n\nОпишем алгоритм поиска в глубину в нерекурсивной форме:\n  - Шаг 1. Все вершины графа отмечаем, как не посещённые. Выбирается первая вершина и помечается как посещённая. Эту вершину кладем в контейнер — стек.\n  - Шаг 2. Пока стек не пустой:\n    - Извлекаем последнюю добавленную вершину.\n    - Просматриваем все смежные с ней не посещённые вершины и помещаем их в стек.\nПорядок выхода вершин из стека и будет порядком обхода вершин графа.\n\nПример работы не рекурсивного алгоритма можно посмотреть на анимации.\n\n![algosy_10_3_1_obhod_v_glubinu_1ccda4e3e8.gif](https://yastatic.net/s3/education-portal/media/algosy_10_3_1_obhod_v_glubinu_1ccda4e3e8_5a7296ac85.gif)\n\nПример реализации приведён ниже.\n```cpp\nDFS(graph, v, used):\n    stack q\n    q.push(v)\n    used[v] = 1\n    while(!q.empty())\n      v = q.front()\n      q.pop()\n      for (var to : graph[v]):\n        if (!used[to]):\n          used[to] = true\n          q.push(to)\n```\n\nЕщё один способ обхода графа — обход в ширину. Основное его отличие в том, что сначала исследуются смежные вершины, а уже потом вершины на следующем уровне. Иначе говоря, сначала исследуются все вершины, смежные с начальной вершиной (вершина с которой начинается обход). Эти вершины находятся на расстоянии 1 от начальной. Затем исследуются все вершины на расстоянии 2 от начальной, затем все на расстоянии 3 и так далее. Обратим внимание, что при этом для каждой вершины сразу находятся длина кратчайшего маршрута от начальной вершины. \n\nОпишем алгоритм поиска в ширину:\n  - Шаг 1. Всем вершинам графа присваивается значение не посещённой. Выбирается первая вершина и помечается как посещённая и заносится в очередь.\n  - Шаг 2. Посещается первая вершина из очереди (если она не помечена как посещённая). Все её соседние вершины заносятся в очередь. После этого она удаляется из очереди.\n  - Шаг 3. Повторяется шаг 2 до тех пор, пока очередь не станет пустой.\n\nПример реализации алгоритма можно посмотреть на анимации\n\n![algosy_10_3_2_obhod_v_shirinu_2b1ad1c070.gif](https://yastatic.net/s3/education-portal/media/algosy_10_3_2_obhod_v_shirinu_2b1ad1c070_ca75fd6fb5.gif)\n\nПример реализации приведён ниже.\n\n```cpp\nBFS(graph, v, used):\n    queue q\n    q.push(v)\n    used[v] = 1\n    while(!q.empty())\n      v = q.front()\n      q.pop()\n      for (var to : graph[v]):\n        if (!used[to]):\n          used[to] = true\n          q.push(to)\n```\n  \n✒️  Упражнение:    \nПодумайте, какое отличие алгоритма поиска в ширину от алгоритма поиска в глубину?\n\nАсимптотическая сложность алгоритма поиска в глубину и ширину — $O(V+E)$, где $V$ — число вершин, а $E$ — число рёбер и дуг. Обходы графов могут применяться для решения задач, связанных с теорией графов:\n  - Волновой алгоритм поиска пути в лабиринте.\n  - Волновая трассировка печатных плат.\n  - Поиск компонент связности в графе.\n  - Поиск кратчайшего пути между двумя узлами невзвешенного графа.\n  - Поиск в пространстве состояний: нахождение решения задачи с наименьшим числом ходов, если каждое состояние системы можно представить вершиной графа, а переходы из одного состояния в другое — рёбрами графа.\n  - Нахождение кратчайшего цикла в ориентированном невзвешенном графе.\n  - Нахождение всех вершин и рёбер, лежащих на каком-либо кратчайшем пути между двумя вершинами.\n  - Поиск увеличивающего пути в алгоритме Форда-Фалкерсона (алгоритм Эдмондса-Карпа).",
        "handbook": "Основы алгоритмов",
        "title": "Обходы графа - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/algoritm-nahozhdeniya-komponent-svyaznosti-v-grafe",
        "content": "Алгоритмы поиска в глубину и ширину находят широкое применение и могут использоваться в других алгоритмах. Рассмотрим один из таких алгоритмов для поиска компонент связности в графе. Под компонентой связности в графе понимают множество вершин графа достижимых попарно и рёбра их связывающие. Для поиска компонент связности необходимо из каждой не посещённой вершины запускать алгоритм обхода, накапливая результаты каждого в отдельный контейнер. Пример ниже поможет понять алгоритм.\n\n![algosy_10_4_d79d964028.gif](https://yastatic.net/s3/education-portal/media/algosy_10_4_d79d964028_9947900ea3.gif)\n\nАсимптотическая сложность нахождения компонент связности в графе — O(V+E), где V — число вершин, а E — число рёбер и дуг.\n    \n✒️  Упражнение:    \n*Попробуйте реализовать данный алгоритм.*",
        "handbook": "Основы алгоритмов",
        "title": "Алгоритм нахождения компонент связности в графе - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/zadacha-poiska-kratchajshego-puti-v-grafe",
        "content": "Зачастую в графах требуется находить между вершинами кратчайшие пути. Один из алгоритмов нахождения кратчайших путей от заданной вершины до любой другой — алгоритм Дейкстры. Алгоритм работает только для графов без рёбер отрицательного веса.\n\nАсимптотическая сложность нахождения компонент связности в графе — O(V+E), где V — число вершин, а E — число рёбер и дуг.\n\nОпишем принцип работы алгоритма Дейкстры:\n  - Шаг 1. Всем вершинам, за исключением первой, присваивается вес равный бесконечности, а первой вершине — 0.\n  - Шаг 2. Все вершины не посещены.\n  - Шаг 3. Первая вершина объявляется текущей.\n  - Шаг 4. Вес всех невыделенных вершин пересчитывается по формуле: вес невыделенной вершины есть минимальное число из старого веса данной вершины, суммы веса текущей вершины и веса ребра, соединяющего текущую вершину с невыделенной.\n  - Шаг 5. Среди невыделенных вершин ищется вершина с минимальным весом. Если такова не найдена, то есть вес всех вершин равен бесконечности, то маршрута не существует. Следовательно, выход. Иначе, текущей становится найденная вершина. Она же выделяется.\n  - Шаг 6. Если текущей вершиной оказывается конечная, то путь найден, и его вес есть вес конечной вершины.\n  - Шаг 7. Переход на шаг 4.\n\nПример работы алгоритма показан на картинке ниже.\n\n![algosy_10_5_30980ce781.gif](https://yastatic.net/s3/education-portal/media/algosy_10_5_30980ce781_bfed21e61d.gif)\n\nПосмотрим на реализацию.\n\n```cpp\nDijkstra(graph, start, finish, used):\n    vector d(n, inf), p(n, -1)\n    n = len(graph)\n    graph[v] = 1\n    for (int i = 0; i < n; ++i)\n      int v = -1\n      for (int j = 0; j < n; ++j)\n        if (!used[j] and (v == -1 or d[j] < d[v]))\n          v = j\n      used[v] = true\n      for (int j = 0; j < len(graph[v]); ++j)\n        to = graph[v][i].vertex\n        len = graph[v][i].edge\n        if (d[v] + len < d[to])\n          d[to] = d[v] + len\n          p[to] = v\n```\n\nАсимптотическая сложность алгоритма Дейкстры — $O(V^2+E)$, где $V$ — число вершин, а $E$ — число рёбер и дуг.\n     \n✒️  Упражнение:      \nПодумайте, как восстановить путь используя введённый массив p?\n\n✒️  Упражнение:      \nКак изменится кратчайший путь, если все веса рёбер увеличить на какое-то число?\n\n✒️  Упражнение:      \nКак изменится кратчайший путь, если все веса рёбер увеличить в какое-то число раз?\n\n✒️  Упражнение:      \nПодумайте, почему алгоритм работает только для графов без рёбер отрицательного веса?\n",
        "handbook": "Основы алгоритмов",
        "title": "Задача поиска кратчайшего пути в графе - Основы алгоритмов",
        "description": null
    },
    {
        "path": "/handbook/algorithms/article/algo-kak-rabotat-s-sistemoi-proverki-zadanii",
        "content": "В конце некоторых параграфов вы можете встретить задачи, которые помогут вам лучше разобраться в теме. В этом приложении мы расскажем, как работать с системой их проверки. Спойлер: это не сложно, но есть нюансы. \n\nДавайте разбираться! \n\n## Интерфейс\n\nСамое главное: мы рекомендуем решать задачи с десктопных устройств. Это удобнее, плюс в мобильной версии некоторые элементы могут отображаться некорректно.\n\nДалее — поговорим об интерфейсе. При переходе внутрь задачи вы увидите в левой части экрана описание, а в правой — поле редактора, в котором можно писать код решения.\n\n![Python](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_6_fcc14cc482.webp)\n\nОписание задачи включает:\n\n- Условие.\n\n- Формат ввода/вывода. В этом блоке описаны данные, аналогичные тем, что будут переданы в вашу программу при автоматической проверке задания. Конкретный пример входных данных можно посмотреть в блоке «Пример» (о нём далее).\n\n- Пример. Здесь показаны результаты, которые должна выдать программа при правильной обработке данных.\n\n- Ограничения по памяти и времени, в которые должна уложиться ваша программа.\n\n![Python_hb_screenshot_7.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_7_ca72f38eb8.webp)\n\nОтправить решение можно через поле редактора, либо загрузив файл с вашей программой.\n\n![Python_hb_screenshot_8.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_8_86d233ea2b.webp)\n\nПосле отправки решения система обработает ваш код и начнёт тестировать его на различных вариантах входных данных, сопоставляя ожидаемый эталонный вывод с результатами работы вашего кода.\n\nПары входных и выходных тестовых данных называются тестами.\n\nПроверка решения может занять некоторое время, отследить прогресс проверки вы можете на вкладке «Отправленные решения».\n\n![Python_hb_screenshot_9.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_9_9d96765712.webp)\n\nВ зависимости от результата проверки вы увидите статус:\n\n- Решена полностью — ваше решение успешно скомпилировалось и прошло все тесты.\n- Решена неверно — код не компилируется или не проходит тестирование.\n\n## Как понять в чем ошибка?\nЧтобы узнать детали проверки, нужно перейти внутрь теста:\n\n![Python_hb_screenshot_10.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_10_faa5910cbc.webp)\n\nЗдесь вы увидите вердикт по решению. Вот некоторые варианты вердиктов:\n\n1. **OK** — решение прошло все тесты.\n\n2. **CE (Compilation Error)** — ошибка компиляции, в программе допущена синтаксическая или семантическая ошибка.\n\nВ этом случае разобраться поможет отчёт об ошибке в блоке «Лог компиляции»:\n\n![Python_hb_screenshot_11.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_11_3a9498dc89.webp)\n\nСистема подскажет, какого рода ошибка присутствует в коде, и в какой строке она находится.\n\n3. **WA (Wrong Answer)** — ваша программа выдала неправильный результат на одном из тестов.\n\nДля тестов из примеров отображается ввод, вывод вашей программы, вывод системы проверки ответа и правильный ответ. Это поможет с отладкой вашей программы.\n\n![Python_hb_screenshot_12.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_12_d37061f9ad.webp)\n\nМы не раскрываем другие тестовые данные. Попробуйте самостоятельно рассмотреть различные нетривиальные варианты входных данных и проверить, как на них отрабатывает ваше решение. Это поможет вам научиться тестировать свой код самостоятельно.\n\n4. **RE (Runtime Error)** — ошибка выполнения. Например, это может быть ошибка выхода за границы массива или необработанные исключения.\n\n5. **TL (Time Limit)** — на одном из тестов решение работает слишком долго.\n\n6. **ML (Memory Limit)** — на одном из тестов решение потребляет слишком много памяти.\n\nПодробный список ответов проверяющей системы можно посмотреть [здесь](https://contest.yandex.ru/errors).\n\nВ случае, если вы чувствуете, что вам необходима поддержка и взгляд со стороны, попробуйте обсудить задачу с участниками [комьюнити](https://t.me/handbook_algorithms) хендбука.\n\nВот и всё! Надеемся, что эти советы помогут разобраться с системой проверки заданий. Желаем успехов в учёбе!",
        "handbook": "Основы алгоритмов",
        "title": "Основы алгоритмов: Работа с системой проверки заданий",
        "description": "Изучите методы работы с системой проверки заданий хендбука Основы алгоритмов. Советы по подготовке и успешному прохождению проверок."
    },
    {
        "path": "/handbook/algorithms/article/algo-kak-polzovatsia-khendbukom",
        "content": "Если вы хотите вернуться к параграфу попозже, то можете оставить закладку на том месте, где вы остановились.\n\nДля этого можно отметить главы как прочитанные. Плюс из этого же меню можно перейти к задачам хендбука:\n\n![Python_hb_screenshot_1 (1).webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_1_1_1b00eb0564.webp)\n\nИзменение статуса главы отразится на странице содержания и в прогресс-баре хендбука:\n\n![Python_hb_screenshot_2 (3).webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_2_3_a94219c466.webp)\n\nДля перемещения по хендбуку вы можете воспользоваться навигацией внутри страниц:\n\n![Python_hb_screenshot_4.webp](https://yastatic.net/s3/education-portal/media/Python_hb_screenshot_4_e01772afef.webp)\n\nВот и всё! Как видите, это не сложно. Надеемся, у вас всё получится. А если нет — вступайте в [коммьюнити](https://t.me/handbook_algorithms)  хендбука: там вам обязательно придут на помощь.",
        "handbook": "Основы алгоритмов",
        "title": "Основы алгоритмов: Как пользоваться Хендбуком",
        "description": "Узнайте, как эффективно использовать хендбук Основы алгоритмов для решения алгоритмических задач. Советы и инструкции."
    }
]