[
    {
        "path": "/handbook/ml/article/about",
        "content": "## Об этой книге\nЭта книга написана коллективом добрых людей, состоящим из преподавателей и выпускников Школы анализа данных. Своим появлением она обязана двум замечательным курсам. Во-первых, это [курс Константина Вячеславовича Воронцова](http://www.machinelearning.ru/wiki/index.php?title=%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%28%D0%BA%D1%83%D1%80%D1%81_%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9%2C_%D0%9A.%D0%92.%D0%92%D0%BE%D1%80%D0%BE%D0%BD%D1%86%D0%BE%D0%B2%29), на котором выросло подавляющее большинство авторов книги, да и вообще ML-специалистов в России. Во-вторых, это курс [NLP Course | For You](https://lena-voita.github.io/nlp_course.html) Лены Войта, благодаря которому мы поняли, как должен выглядеть современный учебник, и на который мы будем регулярно ссылаться в частях, связанных с анализом текстов.\n\nИдея была такая: записать сложившийся в ШАДе курс машинного обучения в виде книги, при этом избежав каких-либо компромиссов: нигде ничего не упрощать чрезмерно, дать необходимую теорию, описать и исторически важные алгоритмы, и применяющиеся сегодня, вместе с теорией рассказывать и практические вопросы о реализации алгоритмов и работе с данными. \n\nМатематика — это один из языков, на котором написан учебник. Мы будем стараться давать необходимые пояснения, но всё же уверенное владение линейной алгеброй, математическим анализом и теорией вероятностей будет большим плюсом. Знания статистики и методов выпуклой оптимизации не обязательны, хотя сделают чтение комфортнее.\n\nЧитая книгу, вы, возможно, заметите в ней ошибки, неточности и плохо объяснённые детали. В таком случае, пожалуйста, дайте нам знать об этом, написав ([сюда](https://forms.yandex.ru/surveys/academy/?proekt=handbooks)) — так вы поможете и другим читателям. \n\nИтак, приступим. \n",
        "handbook": "Учебник по машинному обучению",
        "title": "Об этой книге",
        "description": "Эта книга написана коллективом добрых людей, состоящим из преподавателей и выпускников Школы анализа данных"
    },
    {
        "path": "/handbook/ml/article/mashinnoye-obucheniye",
        "content": "**Машинное обучение** — это наука, изучающая алгоритмы, автоматически улучшающиеся благодаря опыту.\n\nКогда Алан Тьюринг работал над первыми ([компьютерами](https://ru.wikipedia.org/wiki/Bombe)), он пытался расшифровать сообщения немецких военных, закодированные машиной Энигма. Поиск расшифровки требовал перебора массы вариантов. Люди с этой задачей справлялись плохо, зато машина могла решить её сравнительно быстро. Очевидно, далеко не для каждой задачи, с которой люди справляются с трудом, можно написать программу для эффективного поиска решения. Более того, есть целый класс задач (так называемые NP-трудные задачи), которые нельзя решить за разумное время. Можно даже явно доказать, что никакой компьютер здесь чуда тоже не совершит. Самое интересное это то, что бывают и задачи, которые для людей особенного труда не составляют, но которые почему-то крайне трудно запрограммировать, например:\n\n* перевести текст с одного языка на другой;\n\n* диагностировать болезнь по симптомам;\n\n* сравнить, какой из двух документов в интернете лучше подходит под данный поисковый запрос;\n\n* сказать, что изображено на картинке;\n\n* оценить, по какой цене удастся продать квартиру.\n\nУ всех этих задач есть много общего. Во-первых, их решение можно записать как функцию, которая отображает **объекты** или **примеры** (**samples**) в **предсказания** (**targets**). Например, больных надо отобразить в диагнозы, а документы в оценку релевантности. Во-вторых, вряд ли у этих задач есть единственно верное, идеальное решение. Даже профессиональные переводчики могут по-разному перевести один и тот же текст, и оба перевода будут верными. Так что лучшее в этих задачах — враг хорошего. В конце концов, и доктора иногда делают ошибки в диагнозах, и вы не всегда можете сказать, что же именно изображено на картинке. В-третьих, у нас есть много примеров правильных ответов (скажем, переводов предложения на другой язык или подписей к заданной картинке), а примеры неправильных ответов (если они нужны), как правило, не составляет труда сконструировать. Мы назовём функцию, отображающую объекты в предсказания, — **моделью**, а имеющийся у нас набор примеров — **обучающей выборкой** или **датасетом**. Обучающая выборка состоит из:\n\n* **объектов** (к примеру, скачанные из интернета картинки, истории больных, активность пользователей сервиса и так далее);\n\n* и **ответов** (подписи к картинкам, диагнозы, информация об уходе пользователей с сервиса), которые мы также будем иногда называть **таргетами**.\n\n### Постановка задачи\n\nОписанные выше задачи являются примерами задач **обучения с учителем** (**supervised learning**), так как правильные ответы для каждого объекта обучающей выборки заранее известны. Задачи обучения с учителем делятся на следующие виды в зависимости от того, каким может быть множество $\\mathbb{Y}$ всех возможных ответов (таргетов):\n\n1. $\\mathbb{Y} = \\mathbb{R}$ или $\\mathbb{Y} = \\mathbb{R}^M$ — **регрессия**. Примерами задач регрессии является предсказание продолжительности поездки на каршеринге, спрос на конкретный товар в конкретный день или погода в вашем городе на завтра (температура, влажность и давление — это несколько вещественных чисел, которые формируют вектор нашего предсказания).\n2. $\\mathbb{Y} = {0, 1}$ — **бинарная классификация**. Например, мы можем предсказывать, кликнет ли пользователь по рекламному объявлению, вернёт ли клиент кредит в установленный срок, сдаст ли студент сессию, случится ли определённое заболевание у пациента, есть ли на картинке банан.\n3. $\\mathbb{Y} = {1, \\dots, K}$ — **многоклассовая (multiclass) классификация**. Например, определение предметной области для научной статьи (математика, биология, психология и т. д.).\n4. $\\mathbb{Y} = {0, 1}^K$ — **многоклассовая классификация с пересекающимися классами (multilabel classification)**. Например, задача автоматического проставления тегов для ресторанов (логично, что ресторан может одновременно иметь несколько тегов).\n5. $\\mathbb{Y}$ — конечное упорядоченное множество — **ранжирование**. Основным примером является задача ранжирования поисковой выдачи, где для любого запроса нужно отсортировать все возможные документы по релевантности этому запросу; при этом оценка релевантности имеет смысл только в контексте сравнения двух документов между собой, её абсолютное значение информации не несёт.\n\nОтвет может быть и более сложным. Так, в задаче сегментации изображения требуется для каждого пикселя предсказать, к какому объекту или типу объектов он относится, а в задаче машинного перевода мы должны сгенерировать предложение (или целый текст), являющееся переводом исходного. Интерес представляют и задачи **порождения новых объектов**, то есть генерации правдоподобных объектов, из ничего или на основе уже существующих. С помощью такой модели также можно научиться увеличивать разрешение изображения и применять любимые всеми маски в Snapchat или Instagram.\n\nЕсть и относительно небольшой класс задач, относящихся к **обучению без учителя** (**unsupervised learning**), — это задачи, для которых нам известны только данные, а ответы неизвестны или вообще не существуют. Более того, часто поиск \"правильных\" ответов не является самоцелью. Классическим примером обучения без учителя является кластеризация — задача разделения объектов на группы, обладающие некоторыми неизвестными нам, но, как мы в глубине души надеемся, интерпретируемыми свойствами. Примером может служить кластеризация документов из электронной библиотеки по темам или кластеризация новостей с целью выделения крупных сюжетов.\n\nБывают и другие виды (и даже парадигмы) машинного обучения, так что если вы встретите задачу, которую никак не получается отнести к одному из перечисленных выше типов, не расстраивайтесь и знайте, что где-то дальше в учебнике вас ждёт рассказ про такие задачи.\n\n**Вопрос на подумать.** Определите тип следующих задач. По возможности попробуйте отнести их к более узким видам задач.\n\n1. Предсказание курса евро к доллару на следующий день.\n\n2. Стилизация текста. Например, перевод на бюрократический язык: «Пиппина и Мерри похитили!» $\\mapsto$ «Граждане Тук, Перегрин Паладинович, 2990 года рождения, и Брендибак, Мериадок Сарадокович, 2982 года рождения, были похищены неустановленными лицами».\n\n3. Детектирование котиков на изображении.\n\n4. Обучение робокота запрыгивать на стол из произвольной позы.\n\n5. Поиск наборов товаров, которые посетители супермаркета часто покупают вместе.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\n1. Это задача регрессии. Модель предсказывает вещественное число, пусть и с небольшим количеством знаков после запятой.\n\n2. Это задача генерации новых объектов на основе уже существующих.\n\n3. В зависимости от того, для чего мы детектируем котиков, это может быть задача регрессии (предсказание координат вершин прямоугольника, в котором находится котик) или классификации (если нас просто интересует, есть котик или нет).\n\n4. Эту задачу можно решать по-разному. Например, создав физическую модель движения робокота и рассчитав оптимальную последовательность движений. Если мы всё-таки хотим решать её с помощью машинного обучения, то можно поступить следующим образом. Создадим компьютерную симуляцию (чтобы не ломать настоящего робота) и модель, которая будет в каждый момент на основе конфигурации сочленений, высоты от пола, расстояния до стола, фазы Луны и других важных параметров предсказывать, как нужно дальше поворачивать лапы, изгибать спину кота и так далее. Эту модель будем прогонять в симуляции, так или иначе меняя её в зависимости от того, насколько удачно робот справляется со своей задачей. Такая парадигма называется **обучением с подкреплением** (**reinforcement learning**), и о ней мы поговорим в [отдельном параграфе](https://academy.yandex.ru/handbook/ml/article/obuchenie-s-podkrepleniem).\n\nВы можете спросить: а почему это не обучение с учителем? Ведь у нас есть объекты — последовательности движений и ответы — запрыгнул кот на стол или нет. Проблема в том, что перебрать кучу траекторий (ввиду сложности задачи — действительно огромную кучу) и для каждой получить ответ — это очень долго и сложно; кроме того, нам хотелось бы иметь фреймворк, в котором можно было бы относительно легко адаптироваться, скажем, к изменению высоты стола.\n\n5. Это задача обучения без учителя.\n\n{% endcut %}\n\n**Вопрос на подумать.** Ранжирование — это задача с таргетом из конечного упорядоченного множества $(1,\\ldots,K)$. Казалось бы, её запросто можно было бы рассматривать как задачу классификации на $K$ классов или задачу регрессии. В чём же проблема? Почему так не делают?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nДля решения задач ранжирования обычно строят модель, предсказывающую некоторое вещественное число, по которому затем сортируют объекты, — так почему бы не считать её регрессией? Дело в том, что функции потерь и метрики в этой задаче совсем другие. Нам неважно, какие именно вещественные числа мы предсказываем. Мы просто хотим, чтобы более релевантным объектам сопоставлялись числа побольше.\n\nЗадача «предскажите 10 самых релевантных объектов» не похожа на задачу классификации. Мир меняется, появляются новые объекты, и если к нам в руки попадёт объект более релевантный, чем текущий топ-1, все номера позиций поедут, и выученное нами соответствие объектов и номеров можно будет выкидывать на помойку.\n\n{% endcut %}\n\n## Критерии качества\n\nПо обучающей выборке мы хотим построить модель, предсказания которой достаточно хороши. Что вообще значит «достаточно хороши»? Не понимая, чего мы хотим добиться, мы не предложим хорошего решения, поэтому нужно внимательно отнестись к выбору **метрик качества**.\n\nВозможно, вы уже участвовали в соревнованиях по анализу данных. На таких соревнованиях метрику организатор выбирает за вас, и она, как правило, непосредственным образом связана с результатами предсказаний. Но на практике всё бывает намного сложнее.\n\nНапример, мы хотим:\n\n* решить, сколько коробок с бананами нужно завтра привезти в конкретный магазин, чтобы минимизировать количество товара, который не будет выкуплен, и минимизировать вероятность того, что покупатель к концу дня не найдёт желаемый продукт на полке;\n* увеличить счастье пользователей от работы с нашим сервисом, чтобы пользователи стали лояльнее, а сервис мог получать стабильный прогнозируемый доход;\n* решить, нужно ли направить пациента на дополнительное медицинское обследование.\n\nВ каждом конкретном случае может возникать целая иерархия метрик.\n\n1. Самый верхний уровень – это **бизнес-метрики**, например, будущий доход сервиса. Их трудно измерить в моменте, они сложным образом зависят от совокупности всех наших усилий, не только связанных с машинным обучением.\n\n2. **Онлайн** (**online**) **метрики** – это характеристики работающей системы, с помощью которых мы надеемся оценить, что будет с бизнес-метриками. Например, это может быть:\n   – Медианная длина сессии в онлайн-игре. Можно предположить, что пользователь, который долго сидит в игре – это довольный пользователь.\n   – Среднее количество бананов на полках во всех магазинах торговой сети в конце дня.\n\n3. Не всегда плоды наших трудов оцениваются числами. Многое может зависеть от субъективного восприятия людей, и для того, чтобы оценить их реакцию до выпуска в продакшен, применяется оценка специально нанятыми людьми – асессорами. Например, так можно оценивать, получилось ли у нас улучшить качество машинного перевода или релевантность выдачи в поисковой системе.\n\n4. **Офлайн** (**offline**) **метрики** могут быть измерены до введения модели в эксплуатацию, например, по историческим данным. В задачах, в которых нужно предсказывать какой-то конкретный таргет, офлайн метрики обычно оценивают отклонение предсказаний модели от истинных значений таргета. Например, это может быть точность предсказания, то есть число верно угаданных значений, или среднеквадратичное отклонение.\n\nАсессорскую оценку тоже можно считать офлайн-метрикой\n\nВ этой книге речь в основном пойдёт об офлайновых метриках и о функциях потерь. И прежде, чем вы начнёте знакомиться с методами решения задач обучения с учителем, полезно посмотреть, какими бывают метрики качества. Вот несколько примеров:\n\n* для задачи постановки диагноза хорошими метриками могут быть, например, доля правильно поставленных диагнозов или доля больных, которым удалось поставить правильный диагноз (а вы поняли разницу?);\n\n* для задачи предсказания цены квартиры метрикой качества может быть доля квартир, для которых разница между предсказанным и истинным значением цены не превысила какого-то порога, или средний модуль разницы между предсказанным и истинным значением;\n\n* для задачи ранжирования поисковых документов по запросу — доля пар документов, которые мы упорядочили неправильно.\n\nЦель обычно в том, чтобы найти модель, для которой значение метрики будет оптимальным.\n\n**Вопрос на подумать.** Важно помнить, что разные нужды заказчика могут диктовать самые разные метрики. Вернёмся к задаче постановки диагноза пациентам больницы. Какие метрики вы предложили бы использовать в каждом из следующих случаев:\n\n* обычный год в обычном терапевтическом отделении обычной больницы;\n\n* определение очень неприятной болезни, которая жутким клеймом падёт на каждого, кому поставили такой диагноз;\n\n* определение опасной и очень заразной болезни.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nКонечно, даже в каждом из этих довольно частных случаев могут быть разные ситуации и разные метрики, но вот как, например, можно было бы ответить:\n\n* Обычный год в обычном терапевтическом отделении обычной больницы — тогда главного врача вполне устроит, если доля правильно поставленных диагнозов будет высокой (эта метрика называется **accuracy**).\n\n* Определение очень неприятной болезни, которая жутким клеймом падёт на каждого, кому поставили такой диагноз, — тогда нам важно максимизировать долю действительно больных среди тех, кому мы имели несчастье поставить этот диагноз (эта метрика называется точностью, или **precision**).\n\n* Определение опасной и очень заразной болезни — тогда нам важно не пропустить ни одного заражённого, и метрика будет иметь вид доли правильно определённых носителей (эта метрика называется полнотой, или **recall**).\n\nРазумеется, это самые простые метрики, и в реальной жизни вам придётся работать с более сложной иерархией метрик; немного подробнее мы поговорим об этом в параграфе про измерение качества моделей.\n\n{% endcut %}\n\n**Вопрос на подумать.** Рассмотрим задачу детектирования людей на изображении. Чаще всего под детектированием понимают указание местоположения человека на картинке. Например, модель пытается выделить прямоугольник, в котором, по её мнению, есть человеческая фигура. Подумайте, какие метрики можно было бы использовать в различных ситуациях для измерения качества решения этой задачи. Не забудьте, что метрики — это способ численно измерить то, насколько модель помогает нам в жизни, так что важно думать о том, зачем нам вообще детектировать людей.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nВот несколько вариантов, которые можно было бы придумать:\n\n* Мы разрабатываем программу для проведения видеоконференций и хотим добавить эффект, который облачает участника в рыцарские доспехи, — в этом случае нам важно корректно определять местоположение и в качестве метрики мы могли бы брать среднеквадратичное отклонение координат каких-нибудь опорных точек тела от истинных.\n\n* Мы строим систему безопасности вокруг какого-то важного объекта, и нам важно обнаруживать вторжение — в этом случае нам не очень принципиально, насколько точно отмечено местоположение человека в кадре, но все люди должны быть обнаружены. Таким образом, в качестве метрики можно рассмотреть полноту: на какой доле кадров, где действительно были люди, наша модель отметила их наличие.\n\n* Мы строим систему, определяющую, не превышает ли количество людей в помещении некоторый порог (например, в рамках борьбы с пандемией), — в этом случае метрикой может быть, скажем, среднеквадратичное отклонение числа детектированных моделью людей от истинного их количества.\n\n{% endcut %}\n\nКритерии качества не всегда сводятся к метрикам. Бизнес или общество могут накладывать и другие требования, например:\n\n* Модель может выдавать предсказания в режиме реального времени. Заметим, что это требование не только к модели, но и к её реализации, а также к тому железу или к тем серверам, на которых она работает.\n\n* Модель достаточно компактна, чтобы помещаться на мобильном телефоне или другом устройстве.\n\n* Можно объяснить, на основании чего модель сделала то или иное предсказание для конкретного объекта. Это может быть важным в случае, если модель решает что-то важное в жизни человека, например, дадут ли кредит или будет ли согласовано дорогостоящее лечение. Такое требование является частным случаем более общего понятия интерпретируемости модели.\n\n* Предсказания модели не дискриминируют какую-либо категорию пользователей. Например, если двум людям с одинаковой и достаточно длинной историей просмотров онлайн-кинотеатр рекомендует разные фильмы только из-за того, что у них разный пол, то это не здорово.\n\n## Данные\n\nМашинное обучение начинается с данных. Важно, чтобы их было достаточно много и чтобы они были достаточно качественными. Некоторые проекты приходится откладывать на неопределённый срок из-за того, что просто невозможно собрать данные.\n\nЧем сложнее задача, тем больше данных нужно, чтобы её решить. Например, существенные успехи в задачах распознавания изображений были достигнуты лишь с появлением очень больших датасетов (и, стоит добавить, вычислительных мощностей). Вычислительные ресурсы продолжают совершенствовать, но во многих ситуациях размеченных данных (то есть объектов, которым кто-то сопоставил ответ) было бы по-прежнему слишком мало: например, для решения задачи аннотирования изображений (image captioning) потребовалось бы огромное количество пар (изображение, описание). В некоторых случаях можно воспользоваться открытыми датасетами. Сейчас их доступно довольно много и некоторые весьма велики, но чаще всего они создаются для довольно простых задач, например, для задачи классификации изображений. Иногда датасет можно купить. Но для каких-то задач вы нигде не найдёте данных. Скажем, авторам неизвестно больших и качественных корпусов телефонных разговоров с расшифровками – в том числе и по причинам конфиденциальности таких данных.\n\nБороться с проблемой нехватки данных можно двумя способами.\n\nПервый – использование **краудсорсинга**, то есть привлечение людей, готовых разметить много данных. Во многих ситуациях (например, когда речь заходит об оценке поисковой выдачи) без дополнительной разметки никак не обойтись. Мы расскажем про краудсорсинг подробнее в соответствующем параграфе. Некоторые проекты, в первую очередь научные и социальные, используют также **citizen science** – разметку данных волонтёрами без какого-либо вознаграждения, просто за чувство причастности к доброму делу исследования животных Африки или формы галактик.\n\nВторой же способ состоит в использовании неразмеченных данных. К примеру, в задаче аннотирования изображений у нас есть огромное количество никак не связанных друг с другом изображений и текстов. Однако, мы можем использовать их для того, чтобы помочь компьютеру понять, какие слова в принципе могут стоять рядом в предложении. Подходы, связанные с использованием неразмеченных данных для решения задач обучения с учителем, объединяются термином **self-supervised learning** и очень активно используются сейчас. Важной составляющей является **обучение представлений** (**representation learning**) — задача построения компактных векторов небольшой размерности из сложных по структуре данных, например, изображений, звука, текстов, графов, так, чтобы близкие по структуре или семантике данные получали метрически близкие представления. Делать это можно разными способами — например, используя фрагменты моделей, обученных для решения какой-либо другой задачи, или строя модель, предсказывающую скрытую часть объекта по оставшейся его части — например, пропущенное слово в предложении. Этому будет посвящен [отдельный параграф](https://academy.yandex.ru/handbook/ml/article/obuchenie-predstavlenij) нашего учебника.\n\nНо кроме количества данных важно ещё и то, насколько они хороши и удобны для анализа. Давайте разберёмся, что это значит и какие с этим бывают проблемы.\n\nДля работы с объектом модель должна опираться на какие-то его свойства, например, доход человека, цвет левого верхнего пикселя на изображении или частоту встречаемости слова «интеграл» в тексте. Эти свойства обычно называются **признаками**, а совокупность свойств, которые мы выделили у объекта – его **признаковым описанием**.\n\nВот несколько простых и распространённых разновидностей признаков:\n\n* **Численные** – например, рост или доход. Иногда отдельно выделяют вещественные и целочисленные признаки.\n\n* **Категориальные** признаки принимают значения из некоторого дискретного множества. Например, профессия человека или день недели.\n\n* **Бинарные признаки** принимают два значения: $0$ и $1$ или «да» и «нет». С ними можно работать и как с численными, и как с категориальными.\n\n* Среди категориальных признаков иногда выделяют **ординальные**. Они принимают значения из некоторого *упорядоченного* дискретного множества. Например, класс опасности химического вещества (бывает от 1-го до 4-го) или год обучения для студента являются ординальными.\n\nПриходится иметь дело и с более сложно устроенными признаками. Например, описание ресторана может содержать тексты отзывов или фотографии, а профиль человека в социальной сети – список его друзей. Для многих однородных типов данных, таких как изображения, видео, тексты, звук, графы, разработано большое количество методов извлечения признаков – сейчас в первую очередь нейросетевых. О них вы сможете прочитать в разделах про нейросетевые архитектуры для соответствующих типов данных. Если же попадаются какие-то более сложно устроенные данные, могут потребоваться дополнительные усилия для извлечения из них признаков – этот процесс называют **feature engineering**.\n\nУдобно бывает записать данные в виде таблицы, строки которой соответствуют объектам, а столбцы – признакам. Например:\n\n#|\n||\n\n**Объекты**\n\n|\n\nВозраст\n\n|\n\nОценка по ML\n\n||\n||\n\n**Наташа**\n\n|\n\n21\n\n|\n\nотл\n\n||\n||\n\n**Вася**\n\n|\n\nN/A\n\n|\n\nудовл\n\n||\n||\n\n**Игорь**\n\n|\n\n47\n\n|\n\nхор\n\n||\n|#\n\nДанные, представленные в таком виде, называются **табличными**. Табличные данные – один из самых удобных для анализа форматов. Свои успешные пайплайны работы есть также для уже упомянутых текстов, звука, изображений, видео, графов.\n\nЛучше всего, если все признаки являются численными. Тогда с таблицей можно работать как с объектом линейной алгебры – **матрицей объекты-признаки**.\n\nСоздание информативного признакового описания очень важно для дальнейшего анализа. Но нужно также следить за качеством полученных данных. Вам могут встретиться, например, следующие проблемы:\n\n* **Пропуски** (пропущенные значения). Так, в примере табличных данных выше нам неизвестен возраст Васи. Объекты или признаки, в которых есть пропуски, можно удалять из выборки, но если пропусков довольно много, мы можем потерять таким образом слишком много информации. Кроме того, наличие пропуска само по себе может нести информацию: скажем, это может говорить о систематической проблеме в сборе данных для того или иного сегмента выборки. Некоторые модели, например, решающие деревья, обладают собственными средствами для работы с пропусками, другие же – например, линейные модели или нейросети – требуют, чтобы пропуски были вычищены или заменены на что-то.\n\n* **Выбросы**, то есть объекты, которые резко отличаются от большинства остальных. Например, в датасете с информацией о клиентах банка 140-летний человек, очевидно, будет весьма нетипичным. Выбросы могут возникать из-за ошибок при сборе данных или представлять собой реально существующие аномалии. Обычно выбросы лучше удалять, но в некоторых случаях выбросами могут быть важные объекты (например, очень богатые клиенты банка), и тогда их, возможно, стоит отлавливать и обрабатывать отдельно.\n\n* **Ошибки разметки**. Если, например, вы собираете данные с помощью разметчиков-людей, то вы должны быть готовы к тому, что часть таргетов будет отмечена неправильно. Даже если не думать о том, что не все из разметчиков совершенно честные и старательные, задача может оказаться для них сложной.\n\n* **Data drift**. С течением времени данные могут меняться. Например, может измениться схема сбора данных, и они начнут приходить в формате, который вообще не обрабатывается моделью. Или же может поменяться распределение данных: скажем, если вы делали образовательный сервис для студентов, а к вам стали приходить и более зрелые люди. Data drift – это суровая реальность для любой системы, которая решает не сиюминутную задачу, поэтому нужно уметь мониторить распределение данных и, если нужно, обновлять модель.\n\nВстречаются и другие проблемы. Нередко существенную часть данных приходится выкидывать, потому что в процессе сбора что-нибудь сломалось или потому, что полгода назад в сервисе изменили систему логирования и более старые данные невозможно склеить с более новыми.\n\n## Модель и алгоритм обучения\n\nМодель — это некоторый способ описания мира. Например, «Земля плоская» — это модель, и не такая плохая, как вам может показаться. Ей активно пользуются, когда всё происходит в масштабах одного города и кривизной поверхности можно пренебрегать. С другой стороны, если мы попробуем рассчитать кратчайший путь из Парижа в Лос-Анджелес, модель плоской Земли выдаст неадекватный ответ, она войдёт в противоречие с имеющимися данными, и её придётся заменить на «Земля круглая», «Земля имеет форму эллипсоида» и так далее — в той мере, в которой нам важна точность и в какой нам это позволяет (не)совершенство измерительной техники. Так, модель «Земля — это похожая на геоид с шершавостями на месте горных хребтов» очень точная и замечательная, но, возможно, будет избыточно сложной для большинства практических задач и при этом слишком тяжёлой в плане вычислений.\n\nВ первых параграфах мы будем рассматривать в основном предсказательные модели, то есть модели вида $y = f(x)$, которые пытаются уловить зависимость между признаковым описанием $x$ объекта и таргетом $y$. Но порой мы будем иметь дело и с моделями данных: например, «такой-то признак имеет нормальное распределение».\n\nЧаще всего предсказательные модели мы будем брать из некоторого параметрического семейства $y = f_w(x)$, где $w$ — параметры, которые мы будем подбирать по данным.\n\nДля примера давайте возьмём задачу предсказания цены квартиры. В качестве класса моделей выберем константные функции $f(x) = c$ (то есть будем для всех квартир предсказывать одно и то же значение цены). Поскольку значение не зависит от $x$, нам не очень важно, в каком виде получено признаковое описание: это может быть набор совершенно любых сведений о квартире. Не забудем зафиксировать метрику качества — **среднее абсолютное отклонение** (mean absolute error, она же **MAE**).\n\n$$MAE(f, X, y) = L(f, X, y) = \\frac1N\\sum\\limits_{i=1}^N \\vert f(x_i) - y_i\\vert \\rightarrow \\min\\limits_f,\n$$\n\nгде $f$ — это модель (та самая, $f(x) = c$), $X = (x_1,\\ldots,x_N)$ — обучающие примеры (данные о квартирах, которые мы смогли достать), $y = (y_1,\\ldots,y_N)$ — правильные ответы (то есть цены на известные нам квартиры). Чтобы найти минимум MAE, возьмём производную от выражения\n\n$$\\frac1N\\sum\\limits_{i=1}^N \\vert c - y_i\\vert \\rightarrow \\min\\limits_f,\n$$\n\nи приравняем её к нулю:\n\n$$\\nabla_cL(f, X, y) = \\frac1N\\sum\\limits_{i=1}^N sign(c - y_i) = 0\n$$\n\n$$\\#\\left\\{i\\mid y_i < c\\right\\} - \\#\\left\\{i\\mid y_i > c\\right\\} = 0\n$$\n\nНам подходят точки $c$, для которых число $y_i$, строго меньших $c$, равно числу $y_i$, строго больших $c$. Таким образом, нам подходит [медиана](https://en.wikipedia.org/wiki/Median) набора $(y_1,\\ldots,y_N)$:\n\n$$f(x) = \\mathrm{median}(y).\n$$\n\n**Вопрос на подумать.** Давайте теперь в задаче предсказания цены квартиры рассмотрим метрику **среднеквадратичное отклонение** (**MSE**):\n\n$$MSE(f, X, y) = \\frac1N\\sum_{i=1}^N(f(x_i) - y_i)^2\n$$\n\nКаким будет оптимальное значение параметра $c$ для константной модели $f(x) = c$?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nЭто будет среднее значение:\n\n$$\\overline{y} = \\frac1N\\sum_{i=1}^Ny_i\n$$\n\n{% endcut %}\n\nПрекрасно, значит, в классе константных функций мы можем найти оптимальную модель. Может быть, это можно сделать и в каком-нибудь более интересном классе? Этому вопросу и будет посвящена большая часть нашей книги. Классический курс ML состоит из описания классов моделей и способов работы с ними. Несмотря на то что для решения большинства практических задач на сегодня достаточно знать только два типа моделей — **градиентный бустинг на решающих деревьях** и **нейросетевые модели** — мы постараемся рассказать и про другие, чтобы развить у вас глубинное понимание предмета и дать возможность не только использовать лучшие сложившиеся практики, но и, при вашем желании, участвовать в проработке новых идей и поиске новых методов — уже в роли исследователя, а не просто инженера.\n\nКроме выбора модели важен также выбор **алгоритма обучения**. Алгоритм обучения — это процедура, которая превращает обучающую выборку в обученную модель. Скажем, в примере выше для константной модели мы в качестве алгоритма обучения использовали поиск нуля градиента. Как мы увидим дальше, градиентные методы используются для обучения многих моделей, и это очень богатый класс методов оптимизации, из которого порой не так просто выбрать лучший.\n\nВ качестве примера рассмотрим задачу бинарной классификации точек на плоскости, для которой выберем линейную модель:\n\n![linear2](https://yastatic.net/s3/education-portal/media/linear2_9f742c7f00_ab782a0d4d.webp)\n\nМетрикой будет accuracy, то есть доля верных предсказаний.\n\nТеперь нам нужно по обучающей выборке подобрать оптимальную разделяющую прямую $y = w_1x + w_0$. Числа $w_1$ и $w_0$ являются **настраиваемыми** (**обучаемыми**) **параметрами** модели, именно их будет по выборке восстанавливать алгоритм обучения. Но есть проблема: метрика accuracy не дифференцируема. Поэтому мы должны подобрать другую дифференцируемую функцию $\\mathcal{L}(X, y, w)$, минимизация которой будет более или менее соответствовать оптимизации вероятности. Такая функция называется **функцией потерь**, **лоссом** (от слова **loss**) или **лосс-функцией**. О том, как могут выглядеть лосс-функции для бинарной линейной классификации, вы можете почитать в параграфе про [линейные модели](https://education.yandex.ru/handbook/ml/article/linear-models).\n\nВ качестве алгоритма обучения мы можем взять теперь градиентный спуск:\n\n$$w_{t+1} = w_t - \\alpha\\nabla_w\\mathcal{L},\n$$\n\nгде $\\alpha$ — шаг оптимизации — коэффициент, влияющий на скорость и устойчивость алгоритма. Отметим, что разный выбор коэффициента $\\alpha$, вообще говоря, даёт разные алгоритмы обучения, которые могут приводить к разным результатам: если $\\alpha$ слишком мал, то спуск может не дойти до оптимума, а если слишком велик, то алгоритм будет «скакать» вокруг оптимума и никогда туда не попадёт. Мы видим, что важен не только выбор модели, но и выбор алгоритма обучения.\n\nЧисло $\\alpha$ является **гиперпараметром** алгоритма, то есть задаётся до начала обучения — но его тоже можно подбирать по данным. Более подробно о подборе гиперпараметров вы можете узнать в соответствующем [параграфе](https://academy.yandex.ru/handbook/ml/article/podbor-giperparametrov).\n\n### Выбор модели, переобучение\n\nМожет показаться, что мы вас обманули, когда пугали сложностями: очевидно, что для любой задачи машинного обучения можно построить идеальную модель, надо всего лишь запомнить всю обучающую выборку с ответами. Такая модель может достичь идеального качества по любой метрике, но радости от неё довольно мало, ведь мы хотим, чтобы она выявила какие-то закономерности в данных и помогла нам с ответами там, где мы их не знаем. Важно понимать, какая у построенной модели **обобщающая способность**, то есть насколько она способна выучить общие закономерности, присущие не только обучающей выборке, и давать адекватные предсказания на новых данных. Для того чтобы предохранить себя от конфуза, поступают обычно так: делят выборку с данными на две части: **обучающую выборку** и **тестовую выборку** (**train** и **test**). Обучающую выборку используют для собственно обучения модели, а метрики считают на тестовой.\n\nТакой подход позволяет отделить модели, которые просто удачно подстроились к обучающим данным, от моделей, в которых произошла **генерализация** (**generalization**), то есть от таких, которые на самом деле кое-что поняли о том, как устроены данные, и могут выдавать полезные предсказания для объектов, которых не видели.\n\nНапример, рассмотрим три модели регрессионной зависимости, построенные на одном и том же синтетическом датасете с одним-единственным признаком. Жёлтым нарисованы точки обучающей выборки. Здесь мы представим, что есть «истинная» закономерность (пунктир), которая искажена шумом (погрешности измерения, влияние других факторов и т.д.).\n\n![three](https://yastatic.net/s3/education-portal/media/three_regression_models_b2744f22fb_0183cd8b68.webp)\n\nЛевая, линейная модель недостаточно хороша: она сделала, что могла, но плохо приближает зависимость, особенно при маленьких и при больших $x$. Правая «запомнила» всю обучающую выборку (и в самом деле, чтобы вычислить значение этой функции, нам надо знать координаты всех исходных точек) вместо того, чтобы моделировать исходную зависимость. Наконец, центральная, хоть и не проходит через точки обучающей выборки, довольно неплохо моделирует истинную зависимость.\n\nАлгоритм, избыточно подстроившийся под данные, называют **переобученным**.\n\nС увеличением сложности модели ошибка на обучающей выборке падает. Во многих задачах очень сложная модель будет работать примерно так же, как модель, «просто запомнившая всю обучающую выборку», но с генерализацией всё будет плохо: ведь выученные закономерности будут слишком специфическими, подогнанными под то, что происходит на обучающей выборке. Мы видим это на трёх графиках сверху: линейная функция очень проста, но и закономерность приближает лишь очень грубо; на правом же графике мы видим довольно хитрую функцию, которая точно подобрана под значения из обучающей выборки, но явно слишком эксцентрична, чтобы соответствовать какой-то природной зависимости. Оптимальная же генерализация достигается на модели не слишком сложной и не слишком простой.\n\nВ качестве иллюстрации для того же самого датасета рассмотрим модели вида\n\n$$y\\ =\\ \\text{ многочлен степени }D\n$$\n\nЯсно, что с ростом $D$ сложность модели растёт, и она достигает всё лучшего качества на обучающей выборке. А что, если у нас есть ещё тестовая выборка? Каким будет качество на ней? Вот так могут выглядеть графики среднеквадратичного отклонения (MSE) для обучающей и тестовой выборок:\n\n![train](https://yastatic.net/s3/education-portal/media/train_vs_test_095bd91e5c_b09bf85938.webp)\n\nМы видим здесь типичную для классических моделей картину: MSE на обучающей выборке падает (может быть, даже до нуля), а на тестовой сперва падает, а затем начинает снова расти.\n\n**Замечание**. Для моделей глубинного обучения всё немного интереснее: в некоторых ситуациях есть грань, за которой метрика на тестовой выборке снова начинает падать. Но об этом в своё время. Пока давайте запомним, что слишком сложная модель — это вредно, а переобучение — боль.\n\nТочный способ выбрать алгоритм оптимальной сложности по данной задаче нам пока неизвестен, хотя какую-то теоретическую базу имеющимся философским наблюдениям мы дадим в главе про теорию обучения; при этом есть хорошо продуманная методология сравнения разных моделей и выбора среди них оптимальной — об этом мы обязательно расскажем вам в следующих главах. А пока дадим самый простой и неизменно ценный совет: не забывайте считать метрики на тестовой выборке и никогда не смешивайте её с обучающей!\n\n**Вопрос на подумать.** Обсуждая переобучение, мы упоминали про сложность модели, но не сказали, что это такое. Как бы вы её определили? Как описать / сравнить сложность моделей для двух приведённых ниже задач? Почему, кстати, мы решили, что средняя модель ОК, а правая переобученная?\n\n![regression](https://yastatic.net/s3/education-portal/media/regression_48dddf92a9_72b138a079.webp)\n\n![classification](https://yastatic.net/s3/education-portal/media/classification_ee0f2f481d_9f063ccac1.webp)\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nСложность модели можно очень грубо охарактеризовать числом настраиваемых параметров модели, то есть тех, которые мы можем определить по данным в процессе обучения. Это не имеет никакого математического смысла, и о каких-то более серьёзных оценках мы поговорим в главе про теорию машинного обучения, но никто не бросит в вас камень, если вы скажете, что модель с 10 тысячами параметров сложнее, чем модель с 1000 параметров.\n\nВ первой задаче левая модель — это, судя по всему, линейная функция, у неё два параметра, вторая — наверное, квадратичная с тремя параметрами, а правая — многочлен какой-то высокой степени (на самом деле 11-й), у неё параметров намного больше. Центральная модель явно лучше, чем левая, справляется с тем, чтобы приблизить истинную закономерность; правая тоже вроде неплохо справляется с тем, чтобы приблизить её для обучающих данных, но вот два резких провала и крутое пике слева никак не объясняются имеющимися данными, и на двух тестовых точках в районе $0,5$ модель отчаянно врёт — так что есть причины считать, что она переобучилась.\n\nСо второй задачей ситуация во многом похожая. Центральная модель явно лучше разделяет жёлтые и серые точки. На правой же картинке мы видим довольно неестественные выпячивания жёлтой и серой областей: например, к серой точке в центре картинки (которая наверняка была выбросом) протянулось серое «щупальце», захватившее и несколько тестовых (и даже обучающих) точек другого класса. В целом можно поспорить о том, плох ли правый классификатор, но он явно рисует слишком сложные границы, чтобы можно было поверить, что они отражают что-то из реальной жизни.\n\n{% endcut %}\n\n### После обучения\n\nВ момент, когда подобраны все обучаемые параметры и гиперпараметры модели, работа специалиста по машинному обучению не заканчивается.\n\nВо-первых, модель чаще всего создают для того, чтобы она работала в некотором продакшене. И чтобы она там оказалась, нужно эффективно её закодить, научить работать параллельно и подружить с используемыми вами фреймворками. Процесс выкатки в продакшен называется словом **деплой** или **деплоймент** (от **deploy**). После деплоя можно посчитать онлайн-метрики. Также имеет смысл провести **АБ-тестирование**, то есть сравнение с предыдущей версией модели на случайно выбранных подмножествах пользователей или сессий. Более подробно об АБ-тестировании вы сможете почитать в соответствующем параграфе. Если новая модель работает не очень здорово, должна быть возможность откатиться к старой.\n\nПосле деплоймента модели важно продолжать дообучать или переобучать её при поступлении новых данных, а также мониторить качество. Мы уже обсуждали data drift, но бывает также и **concept drift** — изменение зависимости между признаками и таргетом. Например, если вы делаете музыкальные рекомендации, вам нужно будет учитывать и появление новых треков, и изменение вкусов аудитории. О мониторинге качества моделей мы подробнее расскажем в соответствующем параграфе.\n\n--------\n\nТеперь предлагаем вам потренировать изученный материал на практике. Скачайте [ноутбук](https://yastatic.net/s3/ml-handbook/admin/autohw_intro_ML_92e1d33a4d.ipynb?updated_at=2024-03-07T13:21:15.515Z) с лабораторной работой. В нём вы найдете описания заданий и дополнительные материалы. Задания из лабораторной прикреплены к этому параграфу в виде задач в системе Яндекс Контест. Чтобы проверить себя, отправляйте решения по соответствующим задачам в систему. Успехов в практике!",
        "handbook": "Учебник по машинному обучению",
        "title": "Машинное обучение",
        "description": "Что такое машинное обучение и каким оно бывает. Основные понятия машинного обучения: признаки, таргеты, метрики, переобучение\n"
    },
    {
        "path": "/handbook/ml/article/linear-models",
        "content": "Мы начнем с самых простых и понятных моделей машинного обучения: линейных. В этом параграфе мы разберёмся, что это такое, почему они работают и в каких случаях их стоит использовать. Так как это первый класс моделей, с которым вы столкнётесь, мы постараемся подробно проговорить все важные моменты. Заодно объясним, как работает машинное обучение, на сравнительно простых примерах.\n\n## Почему модели линейные?\n\nПредставьте, что у вас есть множество объектов $\\mathbb{X}$, а вы хотели бы каждому объекту сопоставить какое-то значение. К примеру, у вас есть набор операций по банковской карте, а вы бы хотели, понять, какие из этих операций сделали мошенники. Если вы разделите все операции на два класса и нулём обозначите законные действия, а единицей мошеннические, то у вас получится простейшая задача классификации. Представьте другую ситуацию: у вас есть данные геологоразведки, по которым вы хотели бы оценить перспективы разных месторождений. В данном случае по набору геологических данных ваша модель будет, к примеру, оценивать потенциальную годовую доходность шахты. Это пример задачи регрессии. Числа, которым мы хотим сопоставить объекты из нашего множества иногда называют таргетами (от английского **target**).\n\nТаким образом, задачи классификации и регрессии можно сформулировать как поиск отображения из множества объектов $\\mathbb{X}$ в множество возможных таргетов.\n\nМатематически задачи можно описать так:\n\n- **классификация**: $\\mathbb{X}  \\to \\{0,1,\\ldots,K\\}$, где $0, \\ldots, K$ – номера классов,\n- **регрессия**: $\\mathbb{X} \\to \\mathbb{R}$.\n\nОчевидно, что просто сопоставить какие-то объекты каким-то числам — дело довольно бессмысленное. Мы же хотим быстро обнаруживать мошенников или принимать решение, где строить шахту. Значит нам нужен какой-то критерий качества. Мы бы хотели найти такое отображение, которое лучше всего приближает истинное соответствие между объектами и таргетами. Что значит «лучше всего» – вопрос сложный. Мы к нему будем много раз возвращаться. Однако, есть более простой вопрос: среди каких отображений мы будем искать самое лучшее? Возможных отображений может быть много, но мы можем упростить себе задачу и договориться, что хотим искать решение только в каком-то заранее заданном параметризированном семействе функций. Весь этот параграф будет посвящен самому простому такому семейству — линейным функциям вида\n\n$$y = w_1 x_1 + \\ldots + w_D x_D + w_0,\n$$\n\nгде $y$ – целевая переменная (**таргет**), $(x_1, \\ldots, x_D)$ – вектор, соответствующий объекту выборки (**вектор признаков**), а $w_1, \\ldots, w_D, w_0$ – параметры модели. Признаки ещё называют **фичами** (от английского **features**). Вектор $w = (w_1,\\ldots,w_D)$ часто называют вектором весов, так как на предсказание модели можно смотреть как на взвешенную сумму признаков объекта, а число $w_0$ – свободным коэффициентом, или **сдвигом** (**bias**). Более компактно линейную модель можно записать в виде\n\n$$y = \\langle x, w\\rangle + w_0\n$$\n\nТеперь, когда мы выбрали семейство функций, в котором будем искать решение, задача стала существенно проще. Мы теперь ищем не какое-то абстрактное отображение, а конкретный вектор $(w_0,w_1,\\ldots,w_D)\\in\\mathbb{R}^{D+1}$.\n\n**Замечание**. Чтобы применять линейную модель, нужно, чтобы каждый объект уже был представлен вектором численных признаков $x_1,\\ldots,x_D$. Конечно, просто текст или граф в линейную модель не положить, придётся сначала придумать для него численные фичи. Модель называют линейной, если она является линейной по этим численным признакам.\n\nРазберёмся, как будет работать такая модель в случае, если $D = 1$. То есть у наших объектов есть ровно один численный признак, по которому они отличаются. Теперь наша линейная модель будет выглядеть совсем просто: $y = w_1 x_1 + w_0$. Для задачи регрессии мы теперь пытаемся приблизить значение игрек какой-то линейной функцией от переменной икс. А что будет значить линейность для задачи классификации? Давайте вспомним про пример с поиском мошеннических транзакций по картам. Допустим, нам известна ровно одна численная переменная — объём транзакции. Для бинарной классификации транзакций на законные и потенциально мошеннические мы будем искать так называемое **разделяющее правило**: там, где значение функции положительно, мы будем предсказывать один класс, где отрицательно – другой. В нашем примере простейшим правилом будет какое-то пороговое значение объёма транзакций, после которого есть смысл пометить транзакцию как подозрительную.\n\n![1](https://yastatic.net/s3/education-portal/media/1_1_02255c591c_b62e3f69e1.webp)\n\nВ случае более высоких размерностей вместо прямой будет гиперплоскость с аналогичным смыслом.\n\n**Вопрос на подумать**. Если вы посмотрите содержание учебника, то не найдёте в нём ни «полиномиальных» моделей, ни каких-нибудь «логарифмических», хотя, казалось бы, зависимости бывают довольно сложными. Почему так?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nЛинейные зависимости не так просты, как кажется. Пусть мы решаем задачу регрессии. Если мы подозреваем, что целевая переменная $y$ не выражается через $x_1, x_2$ как линейная функция, а зависит ещё от логарифма $x_1$ и ещё как-нибудь от того, разные ли знаки у признаков, то мы можем ввести дополнительные слагаемые в нашу линейную зависимость, просто объявим эти слагаемые новыми переменными и добавив перед ними соответствующие регрессионные коэффициенты\n\n$$y \\approx w_1 x_1 + w_2 x_2 + w_3\\log{x_1} + w_4\\text{sgn}(x_1x_2) + w_0,\n$$\n\nи в итоге из двумерной нелинейной задачи мы получили четырёхмерную линейную регрессию.\n\n{% endcut %}\n\n**Вопрос на подумать**. А как быть, если одна из фичей является *категориальной*, то есть принимает значения из (обычно конечного числа) значений, не являющихся числами? Например, это может быть время года, уровень образования, марка машины и так далее. Как правило, с такими значениями невозможно производить арифметические операции или же результаты их применения не имеют смысла.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nВ линейную модель можно подать только численные признаки, так что категориальную фичу придётся как-то закодировать. Рассмотрим для примера вот такой датасет\n\n![1](https://yastatic.net/s3/education-portal/media/1_2_db8db4914e_a9b7006dcb.webp)\n\nЗдесь два категориальных признака – `pet_type` и `color`. Первый принимает четыре различных значения, второй – пять.\n\nСамый простой способ – использовать **one-hot кодирование** (**one-hot encoding**). Пусть исходный признак мог принимать $M$ значений $c_1,\\ldots, c_M$. Давайте заменим категориальный признак на $M$ признаков, которые принимают значения $0$ и $1$: $i$-й будет отвечать на вопрос «принимает ли признак значение $c_i$?». Иными словами, вместо ячейки со значением $c_i$ у объекта появляется строка нулей и единиц, в которой единица стоит только на $i$-м месте.\n\nВ нашем примере получится вот такая табличка:\n\n![1](https://yastatic.net/s3/education-portal/media/1_3_e1e9cb25e4_2f97300934.webp)\n\nМожно было бы на этом остановиться, но добавленные признаки обладают одним неприятным свойством: в каждом из них ровно одна единица, так что сумма соответствующих столбцов равна столбцу из единиц. А это уже плохо. Представьте, что у нас есть линейная модель\n\n$$y \\sim w_1x_1 + \\ldots + w_{D-1}x_{d-1} + w_{c_1}x_{c_1} + \\ldots + w_{c_M}x_{c_M} + w_0\n$$\n\nПреобразуем немного правую часть:\n\n$$y\\sim w_1x_1 + \\ldots + w_{D-1}x_{d-1} + \\underbrace{(w_{c_1} - w_{c_M})}_{=:w'_{c_1}}x_{c_1} + \\ldots + \\underbrace{(w_{c_{M-1}} - w_{c_M})}_{=:w'_{C_{M-1}}}x_{c_{M-1}} + w_{c_M}\\underbrace{(x_{c_1} + \\ldots + x_{c_M})}_{=1} + w_0 =\n$$\n\n$$= w_1x_1 + \\ldots + w_{D-1}x_{d-1} + w'_{c_1}x_{c_1} + \\ldots + w'_{c_{M-1}}x_{c_{M-1}} + \\underbrace{(w_{c_M} + w_0)}_{=w'_{0}}\n$$\n\nКак видим, от одного из новых признаков можно избавиться, не меняя модель. Более того, это стоит сделать, потому что наличие «лишних» признаков ведёт к переобучению или вовсе ломает модель – подробнее об этом мы поговорим в разделе про регуляризацию. Поэтому при использовании one-hot-encoding обычно выкидывают признак, соответствующий одному из значений. Например, в нашем примере итоговая матрица объекты-признаки будет иметь вид:\n\n![1](https://yastatic.net/s3/education-portal/media/1_4_c3df35f737_7f968599c9.webp)\n\nКонечно, one-hot кодирование – это самый наивный способ работы с категориальными признаками, и для более сложных фичей или фичей с большим количеством значений оно плохо подходит. С рядом более продвинутых техник вы познакомитесь в разделе про обучение представлений.\n\n{% endcut %}\n\nПомимо простоты, у линейных моделей есть несколько других достоинств. К примеру, мы можем достаточно легко судить, как влияют на результат те или иные признаки. Скажем, если вес $w_i$ положителен, то с ростом $i$-го признака таргет в случае регрессии будет увеличиваться, а в случае классификации наш выбор будет сдвигаться в пользу одного из классов. Значение весов тоже имеет прозрачную интерпретацию: чем вес $w_i$ больше, тем «важнее» $i$-й признак для итогового предсказания. То есть, если вы построили линейную модель, вы неплохо можете объяснить заказчику те или иные её результаты. Это качество моделей называют **интерпретируемостью**. Оно особенно ценится в индустриальных задачах, цена ошибки в которых высока. Если от работы вашей модели может зависеть жизнь человека, то очень важно понимать, как модель принимает те или иные решения и какими принципами руководствуется. При этом не все методы машинного обучения хорошо интерпретируемы, к примеру, поведение искусственных нейронных сетей или градиентного бустинга интерпретировать довольно сложно.\n\nВ то же время слепо доверять весам линейных моделей тоже не стоит по целому ряду причин:\n\n- Линейные модели всё-таки довольно узкий класс функций, они неплохо работают для небольших датасетов и простых задач. Однако, если вы решаете линейной моделью более сложную задачу, то вам, скорее всего, придётся выдумывать дополнительные признаки, являющиеся сложными функциями от исходных. Поиск таких дополнительных признаков называется **feature engineering**, технически он устроен примерно так, как мы описали в вопросе про \"полиномиальные модели\". Вот только поиском таких искусственных фичей можно сильно увлечься, так что осмысленность интерпретации будет сильно зависеть от здравого смысла эксперта, строившего модель.\n- Если между признаками есть приближённая линейная зависимость, коэффициенты в линейной модели могут совершенно потерять физический смысл (об этой проблеме и о том, как с ней бороться, мы поговорим дальше, когда будем обсуждать регуляризацию).\n- Особенно осторожно стоит верить в утверждения вида «этот коэффициент маленький, значит, этот признак не важен». Во-первых, всё зависит от масштаба признака: вдруг коэффициент мал, чтобы скомпенсировать его. Во-вторых, зависимость действительно может быть слабой, но кто знает, в какой ситуации она окажется важна. Такие решения принимаются на основе данных, например, путём проверки статистического критерия (об этом мы коротко упомянем в разделе про вероятностные модели).\n- Конкретные значения весов могут меняться в зависимости от обучающей выборки, хотя с ростом её размера они будут потихоньку сходиться к весам «наилучшей» линейной модели, которую можно было бы построить по всем-всем-всем данным на свете.\n\nОбсудив немного общие свойства линейных моделей, перейдём к тому, как их всё-таки обучать. Сначала разберёмся с регрессией, а затем настанет черёд классификации.\n\n## Линейная регрессия и метод наименьших квадратов (МНК)\n\nМы начнём с использования линейных моделей для решения задачи регрессии. Простейшим примером постановки задачи линейной регрессии является **метод наименьших квадратов** (Ordinary least squares).\n\nПусть у нас задан датасет $(X, y)$, где $y=(y_i)_{i=1}^N \\in \\mathbb{R}^N$ – вектор значений целевой переменной, а $X=(x_i)_{i = 1}^N \\in \\mathbb{R}^{N \\times D}, x_i \\in \\mathbb{R}^D$ – матрица объекты-признаки, в которой $i$-я строка – это вектор признаков $i$-го объекта выборки. Мы хотим моделировать зависимость $y_i$ от $x_i$ как линейную функцию со свободным членом. Общий вид такой функции из $\\mathbb{R}^D$ в $\\mathbb{R}$ выглядит следующим образом:\n\n$$\\color{#348FEA}{f_w(x_i) = \\langle w, x_i \\rangle + w_0}\n$$\n\nСвободный член $w_0$ часто опускают, потому что такого же результата можно добиться, добавив ко всем $x_i$ признак, тождественно равный единице; тогда роль свободного члена будет играть соответствующий ему вес:\n\n$$\\begin{pmatrix}x_{i1} & \\ldots & x_{iD} \\end{pmatrix}\\cdot\\begin{pmatrix}w_1\\\\ \\vdots \\\\ w_D\\end{pmatrix} + w_0 =\n\\begin{pmatrix}1 &  x_{i1} & \\ldots & x_{iD} \\end{pmatrix}\\cdot\\begin{pmatrix}w_0 \\\\ w_1\\\\ \\vdots \\\\ w_D \\end{pmatrix}\n$$\n\nПоскольку это сильно упрощает запись, в дальнейшем мы будем считать, что это уже сделано и зависимость имеет вид просто $f_w(x_i) = \\langle w, x_i \\rangle$.\n\n### Сведение к задаче оптимизации\n\nМы хотим, чтобы на нашем датасете (то есть на парах $(x_i, y_i)$ из обучающей выборки) функция $f_w$ как можно лучше приближала нашу зависимость.\n\n![1](https://yastatic.net/s3/education-portal/media/1_5_66d8287b36_26d8e60f74.webp)\n\nДля того, чтобы чётко сформулировать задачу, нам осталось только одно: на математическом языке выразить желание «приблизить $f_w(x)$ к $y$». Говоря простым языком, мы должны научиться измерять качество модели и минимизировать её ошибку, как-то меняя обучаемые параметры. В нашем примере обучаемые параметры — это веса $w$. Функция, оценивающая то, как часто модель ошибается, традиционно называется **функцией потерь**, **функционалом качества** или просто **лоссом** (**loss function**). Важно, чтобы её было легко оптимизировать: скажем, гладкая функция потерь – это хорошо, а кусочно постоянная – просто ужасно.\n\nФункции потерь бывают разными. От их выбора зависит то, насколько задачу в дальнейшем легко решать, и то, в каком смысле у нас получится приблизить предсказание модели к целевым значениям. Интуитивно понятно, что для нашей текущей задачи нам нужно взять вектор $y$ и вектор предсказаний модели и как-то сравнить, насколько они похожи. Так как эти вектора «живут» в одном векторном пространстве, расстояние между ними вполне может быть функцией потерь. Более того, положительная непрерывная функция от этого расстояния тоже подойдёт в качестве функции потерь. При этом способов задать расстояние между векторами тоже довольно много. От всего этого разнообразия глаза разбегаются, но мы обязательно поговорим про это позже. Сейчас давайте в качестве лосса возьмём квадрат $L^2$-нормы вектора разницы предсказаний модели и $y$. Во-первых, как мы увидим дальше, так задачу будет нетрудно решить, а во-вторых, у этого лосса есть ещё несколько дополнительных свойств:\n\n- $L^2$-норма разницы – это евклидово расстояние $\\|y - f_w(x)\\|_2$ между вектором таргетов и вектором ответов модели, то есть мы их приближаем в смысле самого простого и понятного «расстояния».\n\n- Как мы увидим в разделе про вероятностные модели, с точки зрения статистики это соответствует гипотезе о том, что наши данные состоят из линейного «сигнала» и нормально распределенного «шума».\n\nТак вот, наша функция потерь выглядит так:\n\n$$L(f, X, y) = \\|y - f(X)\\|_2^2 =\n$$\n\n$$= \\|y - Xw\\|_2^2 = \\sum_{i=1}^N(y_i - \\langle x_i, w \\rangle)^2\n$$\n\nТакой функционал ошибки не очень хорош для сравнения поведения моделей на выборках разного размера. Представьте, что вы хотите понять, насколько качество модели на тестовой выборке из $2500$ объектов хуже, чем на обучающей из $5000$ объектов. Вы измерили $L^2$-норму ошибки и получили в одном случае $300$, а в другом $500$. Эти числа не очень интерпретируемы. Гораздо лучше посмотреть на среднеквадратичное отклонение\n\n$$L(f, X, y) = \\frac1N\\sum_{i=1}^N(y_i - \\langle x_i, w \\rangle)^2\n$$\n\nПо этой метрике на тестовой выборке получаем $0,12$, а на обучающей $0,1$.\n\nФункция потерь $\\frac1N\\sum_{i=1}^N(y_i - \\langle x_i, w \\rangle)^2$ называется **Mean Squared Error**, **MSE** или **среднеквадратическим отклонением**. Разница с $L^2$-нормой чисто косметическая, на алгоритм решения задачи она не влияет:\n\n$$\\color{#348FEA}{\\text{MSE}(f, X, y) =  \\frac{1}{N}\\|y - X w\\|_2^2}\n$$\n\nВ самом широком смысле, функции работают с объектами множеств: берут какой-то входящий объект из одного множества и выдают на выходе соответствующий ему объект из другого. Если мы имеем дело с отображением, которое на вход принимает функции, а на выходе выдаёт число, то такое отображение называют **функционалом**. Если вы посмотрите на нашу функцию потерь, то увидите, что это именно функционал. Для каждой конкретной линейной функции, которую задают веса $w_i$, мы получаем число, которое оценивает, насколько точно эта функция приближает наши значения $y$. Чем меньше это число, тем точнее наше решение, значит для того, чтобы найти лучшую модель, этот функционал нам надо минимизировать по $w$:\n\n$$\\color{#348FEA}{\\|y - Xw\\|_2^2 \\longrightarrow \\min_w}\n$$\n\nЭту задачу можно решать разными способами. В этом параграфе мы сначала решим эту задачу аналитически, а потом приближенно. Сравнение двух этих решений позволит нам проиллюстрировать преимущества того подхода, которому посвящена эта книга. На наш взгляд, это самый простой способ \"на пальцах\" показать суть машинного обучения.\n\n### МНК: точный аналитический метод\n\nТочку минимума можно найти разными способами. Если вам интересно аналитическое решение, вы можете найти его в параграфе про матричные дифференцирования (раздел «[Примеры вычисления производных сложных функций](https://education.yandex.ru/handbook/ml/article/matrichnoe-differencirovanie#primery-vychisleniya-proizvodnyh-slozhnyh-funkczij)»). Здесь же мы воспользуемся геометрическим подходом.\n\nПусть $x^{(1)},\\ldots,x^{(D)}$ – столбцы матрицы $X$, то есть столбцы признаков. Тогда\n\n$$Xw = w_1x^{(1)}+\\ldots+w_Dx^{(D)},\n$$\n\nи задачу регрессии можно сформулировать следующим образом: *найти линейную комбинацию столбцов* $x^{(1)},\\ldots,x^{(D)}$, которая наилучшим способом приближает столбец $y$ по евклидовой норме – то есть *найти **проекцию** вектора* $y$ на подпространство, образованное векторами $x^{(1)},\\ldots,x^{(D)}$.\n\nРазложим $y = y_{\\parallel} + y_{\\perp}$, где $y_{\\parallel} = Xw$ – та самая проекция, а $y_{\\perp}$ – ортогональная составляющая, то есть $y_{\\perp} = y - Xw\\perp x^{(1)},\\ldots,x^{(D)}$. Как это можно выразить в матричном виде? Оказывается, очень просто:\n\n$$X^T(y - Xw) = 0\n$$\n\nВ самом деле, каждый элемент столбца $X^T(y - Xw)$ – это скалярное произведение строки $X^T$ (=столбца $X$ = одного из $x^{(i)}$) на $y - Xw$. Из уравнения $X^T(y - Xw) = 0$ уже очень легко выразить $w$:\n\n$$w = (X^TX)^{-1}X^Ty\n$$\n\n**Вопрос на подумать** Для вычисления $w_{\\ast}$ нам приходится обращать (квадратную) матрицу $X^TX$, что возможно, только если она невырождена. Что это значит с точки зрения анализа данных? Почему мы верим, что это выполняется во всех разумных ситуациях?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nКак известно из линейной алгебры, для вещественной матрицы $X$ ранги матриц $X$ и $X^TX$ совпадают. Матрица $X^TX$ невырождена тогда и только тогда, когда её ранг равен числу её столбцов, что равно числу столбцов матрицы $X$. Иными словами, формула регрессии поломается, только если столбцы матрицы $X$ линейно зависимы. Столбцы матрицы $X$ – это признаки. А если наши признаки линейно зависимы, то, наверное, что-то идёт не так и мы должны выкинуть часть из них, чтобы остались только линейно независимые.\n\nДругое дело, что зачастую признаки могут быть *приближённо* линейно зависимы, особенно если их много. Тогда матрица $X^TX$ будет близка к вырожденной, и это, как мы дальше увидим, будет вести к разным, в том числе вычислительным проблемам.\n\n{% endcut %}\n\nВычислительная сложность аналитического решения — $O(D^2N + D^3)$, где $N$ — длина выборки, $D$ — число признаков у одного объекта. Слагаемое $ND^2$ отвечает за сложность перемножения матриц $X^T$ и $X$, а слагаемое $D^3$ — за сложность обращения их произведения. Перемножать матрицы $(X^TX)^{-1}$ и $X^T$ не стоит. Гораздо лучше сначала умножить $y$ на $X^T$, а затем полученный вектор на $(X^TX)^{-1}$: так будет быстрее и, кроме того, не нужно будет хранить матрицу $(X^TX)^{-1}X^T$.\n\nВычисление можно ускорить, используя продвинутые алгоритмы перемножения матриц или итерационные методы поиска обратной матрицы.\n\n#### Проблемы «точного» решения\n\nЗаметим, что для получения ответа нам нужно обратить матрицу $X^TX$. Это создает множество проблем:\n\n1. Основная проблема в обращении матрицы — это то, что вычислительно обращать большие матрицы дело сложное, а мы бы хотели работать с датасетами, в которых у нас могут быть миллионы точек,\n2. Матрица $X^TX$, хотя почти всегда обратима в разумных задачах машинного обучения, зачастую плохо обусловлена. Особенно если признаков много, между ними может появляться приближённая линейная зависимость, которую мы можем упустить на этапе формулировки задачи. В подобных случаях погрешность нахождения $w$ будет зависеть от квадрата [числа обусловленности](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%BE%D0%B1%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8) матрицы $X$, что очень плохо. Это делает полученное таким образом решение численно неустойчивым: малые возмущения $y$ могут приводить к катастрофическим изменениям $w$.\n\n{% cut \"Пара слов про число обусловленности.\" %}\n\nПожертвовав математической строгостью, мы можем считать, что число обусловленности матрицы $X$ – это корень из отношения наибольшего и наименьшего из собственных чисел матрицы $X^TX$. Грубо говоря, оно показывает, насколько разного масштаба бывают собственные значения $X^TX$. Если рассмотреть $L^2$-норму ошибки предсказания, как функцию от $w$, то её линии уровня будут эллипсоидами, форма которых определяется квадратичной формой с матрицей $X^TX$ (проверьте это!). Таким образом, число обусловленности говорит о том, насколько вытянутыми являются эти эллипсоиды.\n\n{% endcut %}\n\n{% cut \"Подробнее\" %}\n\nДанные проблемы не являются поводом выбросить решение на помойку. Существует как минимум два способа улучшить его численные свойства, однако если вы не знаете про сингулярное разложение, то лучше вернитесь сюда, когда узнаете.\n\n1. Построим $QR$-разложение матрицы $X$. Напомним, что это разложение, в котором матрица $Q$ ортогональна по столбцам (то есть её столбцы ортогональны и имеют длину 1; в частности, $Q^TQ=E$), а $R$ квадратная и верхнетреугольная. Подставив его в формулу, получим\n\n$$w = ((QR)^TQR)^{-1}(QR)^T y = (R^T\\underbrace{Q^TQ}_{=E}R)^{-1}R^TQ^Ty = R^{-1}R^{-T}R^TQ^Ty = R^{-1}Q^Ty\n$$\n\nОтметим, что написать $(R^TR)^{-1} = R^{-1}R^{-T}$ мы имеем право благодаря тому, что $R$ квадратная. Полученная формула намного проще, обращение верхнетреугольной матрицы (=решение системы с верхнетреугольной левой частью) производится быстро и хорошо, погрешность вычисления $w$ будет зависеть просто от числа обусловленности матрицы $X$, а поскольку нахождение $QR$-разложения является достаточно стабильной операцией, мы получаем решение с более хорошими, чем у исходной формулы, численными свойствами.\n\n2. Также можно использовать псевдообратную матрицу, построенную с помощью сингулярного разложения, о котором подробно написано в разделе про матричные разложения. А именно, пусть\n\n$$A = U\\underbrace{\\mathrm{diag}(\\sigma_1,\\ldots,\\sigma_r)}_{=\\Sigma}V^T\n$$\n\n– это усечённое сингулярное разложение, где $r$ – это ранг $A$. В таком случае диагональная матрица посередине является квадратной, $U$ и $V$ ортогональны по столбцам: $U^TU = E$, $V^TV = E$. Тогда\n\n$$w = (V\\Sigma \\underbrace{U^TU}_{=E}\\Sigma V^T)^{-1}V\\Sigma U^Ty\n$$\n\nЗаметим, что $V\\Sigma^{-2}V^T\\cdot V\\Sigma^2V^T = E = V\\Sigma^2V^T\\cdot V\\Sigma^{-2}V^T$, так что $(V\\Sigma^2 V^T)^{-1} = V\\Sigma^{-2}V^T$, откуда\n\n$$w = V\\Sigma^{-2}\\underbrace{V^TV}_{=E}\\Sigma U^Ty = V\\Sigma^{-1}Uy\n$$\n\nХорошие численные свойства сингулярного разложения позволяют утверждать, что и это решение ведёт себя довольно неплохо.\n\nТем не менее, вычисление всё равно остаётся довольно долгим и будет по-прежнему страдать (хоть и не так сильно) в случае плохой обусловленности матрицы $X$.\n\n{% endcut %}\n\nПолностью вылечить проблемы мы не сможем, но никто и не обязывает нас останавливаться на «точном» решении (которое всё равно никогда не будет вполне точным). Поэтому ниже мы познакомим вас с совершенно другим методом.\n\n### МНК: приближенный численный метод\n\nМинимизируемый функционал является гладким и выпуклым, а это значит, что можно эффективно искать точку его минимума с помощью итеративных градиентных методов. Более подробно вы можете прочитать о них в разделе про методы оптимизации, а здесь мы лишь коротко расскажем об одном самом базовом подходе.\n\nКак известно, градиент функции в точке направлен в сторону её наискорейшего роста, а антиградиент (противоположный градиенту вектор) в сторону наискорейшего убывания. То есть имея какое-то приближение оптимального значения параметра $w$, мы можем его улучшить, посчитав градиент функции потерь в точке и немного сдвинув вектор весов в направлении антиградиента:\n\n$$w_j \\mapsto w_j - \\alpha \\frac{d}{d{w_j}} L(f_w, X, y)\n$$\n\nгде $\\alpha$ – это параметр алгоритма (**«темп обучения»**), который контролирует величину шага в направлении антиградиента. Описанный алгоритм называется **градиентным спуском**.\n\nПосмотрим, как будет выглядеть градиентный спуск для функции потерь $L(f_w, X, y) = \\frac1N\\vert\\vert Xw - y\\vert\\vert^2$. Градиент квадрата евклидовой нормы мы уже считали; соответственно,\n\n$$\\nabla_wL = \\frac2{N} X^T (Xw - y)\n$$\n\nСледовательно, стартовав из какого-то начального приближения, мы можем итеративно уменьшать значение функции, пока не сойдёмся (по крайней мере в теории) к минимуму (вообще говоря, локальному, но в данном случае глобальному).\n\n**Алгоритм градиентного спуска**\n\n```python\nw = random_normal()             # можно пробовать и другие виды инициализации\nrepeat S times:                 # другой вариант: while abs(err) > tolerance\n   f = X.dot(w)                 # посчитать предсказание\n   err = f - y                  # посчитать ошибку\n   grad = 2 * X.T.dot(err) / N  # посчитать градиент\n   w -= alpha * grad            # обновить веса\n```\n\nС теоретическими результатами о скорости и гарантиях сходимости градиентного спуска вы можете познакомиться в параграфе про [методы оптимизации](https://education.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning). Мы позволим себе лишь несколько общих замечаний:\n\n- Поскольку задача выпуклая, выбор начальной точки влияет на скорость сходимости, но не настолько сильно, чтобы на практике нельзя было стартовать всегда из нуля или из любой другой приятной вам точки;\n- Число обусловленности матрицы $X$ существенно влияет на скорость сходимости градиентного спуска: чем более вытянуты эллипсоиды уровня функции потерь, тем хуже;\n- Темп обучения $\\alpha$ тоже сильно влияет на поведение градиентного спуска; вообще говоря, он является гиперпараметром алгоритма, и его, возможно, придётся подбирать отдельно. Другими гиперпараметрами являются максимальное число итераций $S$ и/или порог tolerance.\n\n{% cut \"Иллюстрация.\" %}\n\nРассмотрим три задачи регрессии, для которых матрица $X$ имеет соответственно маленькое, среднее и большое числа обусловленности. Будем строить для них модели вида $y=w_1x_1 + w_2x_2$. Раскрасим плоскость $(w_1, w_2)$ в соответствии со значениями $\\|X_{\\text{train}}w - y_{\\text{train}}\\|^2$. Тёмная область содержит минимум этой функции – оптимальное значение $w_{\\ast}$. Также запустим из двух точек градиентный спуск с разными значениями темпа обучения $\\alpha$ и посмотрим, что получится:\n\n![1](https://yastatic.net/s3/education-portal/media/1_6_becfd30d9a_03ada551b4.webp)\n\nЗаголовки графиков (\"Round\", \"Elliptic\", \"Stripe-like\") относятся к форме линий уровня потерь (чем более они вытянуты, тем хуже обусловлена задача и тем хуже может вести себя градиентный спуск).\n\nИтог: при неудачном выборе $\\alpha$ алгоритм не сходится или идёт вразнос, а для плохо обусловленной задачи он сходится абы куда.\n\n{% endcut %}\n\nВычислительная сложность градиентного спуска – $O(NDS)$, где, как и выше, $N$ – длина выборки, $D$ – число признаков у одного объекта. Сравните с оценкой $O(D^2N+D^3)$ для «наивного» вычисления аналитического решения.\n\nСложность по памяти – $O(ND)$ на хранение выборки. В памяти мы держим и выборку, и градиент, но в большинстве реалистичных сценариев доминирует выборка.\n\n### Стохастический градиентный спуск\n\nНа каждом шаге градиентного спуска нам требуется выполнить потенциально дорогую операцию вычисления градиента по всей выборке (сложность $O(ND)$). Возникает идея заменить градиент его оценкой на подвыборке (в английской литературе такую подвыборку обычно именуют **batch** или **mini-batch**; в русской разговорной терминологии тоже часто встречается слово **батч** или **мини-батч**).\n\nА именно, если функция потерь имеет вид суммы по отдельным парам объект-таргет\n\n$$L(w, X, y) = \\frac1N\\sum_{i=1}^NL(w, x_i, y_i),\n$$\n\nа градиент, соответственно, записывается в виде\n\n$$\\nabla_wL(w, X, y) = \\frac1N\\sum_{i=1}^N\\nabla_wL(w, x_i, y_i),\n$$\n\nто предлагается брать оценку\n\n$$\\nabla_wL(w, X, y) \\approx \\frac1B\\sum_{t=1}^B\\nabla_wL(w, x_{i_t}, y_{i_t})\n$$\n\nдля некоторого подмножества этих пар $(x_{i_t}, y_{i_t})_{t=1}^B$. Обратите внимание на множители $\\frac1N$ и $\\frac1B$ перед суммами. Почему они нужны? Полный градиент $\\nabla_wL(w, X, y)$ можно воспринимать как среднее градиентов по всем объектам, то есть как оценку матожидания $\\mathbb{E}\\nabla_wL(w, x, y)$; тогда, конечно, оценка матожидания по меньшей подвыборке тоже будет иметь вид среднего градиентов по объектам этой подвыборки.\n\nКак делить выборку на батчи? Ясно, что можно было бы случайным образом сэмплировать их из полного датасета, но даже если использовать быстрый алгоритм вроде резервуарного сэмплирования, сложность этой операции не самая оптимальная. Поэтому используют линейный проход по выборке (которую перед этим лучше всё-таки случайным образом перемешать). Давайте введём ещё один параметр нашего алгоритма: размер батча, который мы обозначим $B$. Теперь на $B$ очередных примерах вычислим градиент и обновим веса модели. При этом вместо количества шагов алгоритма обычно задают количество **эпох** $E$. Это ещё один гиперпараметр. Одна эпоха – это один полный проход нашего сэмплера по выборке. Заметим, что если выборка очень большая, а модель компактная, то даже первый проход бывает можно не заканчивать.\n\n**Алгоритм:**\n\n```python\n w = normal(0, 1)\n repeat E times:\n   for i = B, i <= n, i += B\n      X_batch = X[i-B : i]\n      y_batch = y[i-B : i]\n      f = X_batch.dot(w)                 # посчитать предсказание\n      err = f - y_batch                  # посчитать ошибку\n      grad = 2 * X_batch.T.dot(err) / B  # посчитать градиент\n      w -= alpha * grad\n\n```\n\nСложность по времени – $O(NDE)$. На первый взгляд, она такая же, как и у обычного градиентного спуска, но заметим, что мы сделали в $N / B$ раз больше шагов, то есть веса модели претерпели намного больше обновлений.\n\nСложность по памяти можно довести до $O(BD)$: ведь теперь всю выборку не надо держать в памяти, а достаточно загружать лишь текущий батч (а остальная выборка может лежать на диске, что удобно, так как в реальности задачи, в которых выборка целиком не влезает в оперативную память, встречаются сплошь и рядом). Заметим, впрочем, что при этом лучше бы $B$ взять побольше: ведь чтение с диска – намного более затратная по времени операция, чем чтение из оперативной памяти.\n\nВ целом, разницу между алгоритмами можно представлять как-то так:\n\n![1](https://yastatic.net/s3/education-portal/media/1_7_4b8031112e_852be73f9d.webp)\n\nШаги стохастического градиентного спуска заметно более шумные, но считать их получается значительно быстрее. В итоге они тоже сходятся к оптимальному значению из-за того, что матожидание оценки градиента на батче равно самому градиенту. По крайней мере, сходимость можно получить при хорошо подобранных коэффициентах темпа обучения в случае выпуклого функционала качества. Подробнее мы об этом поговорим в [параграфе про оптимизацию](https://education.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning). Для сложных моделей и лоссов стохастический градиентный спуск может сходиться плохо или застревать в локальных минимумах, поэтому придумано множество его улучшений. О некоторых из них также рассказано в [параграфе про оптимизацию](https://education.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning).\n\nСуществует определённая терминологическая путаница, иногда стохастическим градиентным спуском называют версию алгоритма, в которой размер батча равен единице (то есть максимально шумная и быстрая версия алгоритма), а версии с бОльшим размером батча называют **batch gradient descent**. В книгах, которые, возможно, старше вас, такая процедура иногда ещё называется incremental gradient descent. Это не очень принципиально, но вы будьте готовы, если что.\n\n**Вопрос на подумать**. Вообще говоря, если объём данных не слишком велик и позволяет это сделать, объекты лучше случайным образом перемешивать перед тем, как подавать их в алгоритм стохастического градиентного спуска. Как вам кажется, почему?\n\nТакже можно использовать различные стратегии отбора объектов. Например, чаще брать объекты, на которых ошибка больше. Какие ещё стратегии вы могли бы придумать?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nЛегко представить себе ситуацию, в которой объекты как-нибудь неудачно упорядочены, скажем, по возрастанию таргета. Тогда модель будет попеременно то запоминать, что все таргеты маленькие, то – что все таргеты большие. Это может и не повлиять на качество итоговой модели, но может привести и к довольно печальным последствиям. И вообще, чем более разнообразные батчи модель увидит в процессе обучения, тем лучше.\n\nСтратегий можно придумать много. Например, не брать объекты, на которых ошибка слишком большая (возможно, это выбросы – зачем на них учиться), или вообще не брать те, на которых ошибка достаточно мала (они «ничему не учат»). Рекомендуем, впрочем, прибегать к этим эвристикам, только если вы понимаете, зачем они вам нужны и почему есть надежда, что они помогут.\n\n{% endcut %}\n\n### Неградиентные методы\n\nПосле прочтения этой главы у вас может сложиться ощущение, что приближённые способы решения ML задач и градиентные методы – это одно и тоже, но вы будете правы в этом только на 98%. В принципе, существуют и другие способы численно решать эти задачи, но в общем случае они работают гораздо хуже, чем градиентный спуск, и не обладают таким хорошим теоретическим обоснованием. Мы не будем рассказывать про них подробно, но можете на досуге почитать, скажем, про Stepwise regression, Orthogonal matching pursuit или LARS. У LARS, кстати, есть довольно интересное свойство: он может эффективно работать на выборках, в которых число признаков больше числа примеров. С алгоритмом LARS вы можете познакомиться в [параграфе про оптимизацию](https://education.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning).\n\n## Регуляризация\n\nВсегда ли решение задачи регрессии единственно? Вообще говоря, нет. Так, если в выборке два признака будут линейно зависимы (и следовательно, ранг матрицы будет меньше $D$), то гарантировано найдётся такой вектор весов $\\nu$ что $\\langle\\nu, x_i\\rangle = 0\\ \\ \\forall x_i$. В этом случае, если какой-то $w$ является решением оптимизационной задачи, то и $w + \\alpha \\nu$ тоже является решением для любого $\\alpha$. То есть решение не только не обязано быть уникальным, так ещё может быть сколь угодно большим по модулю. Это создаёт вычислительные трудности. Малые погрешности признаков сильно возрастают при предсказании ответа, а в градиентном спуске накапливается погрешность из-за операций со слишком большими числами.\n\nКонечно, в жизни редко бывает так, что признаки строго линейно зависимы, а вот быть приближённо линейно зависимыми они вполне могут быть. Такая ситуация называется **мультиколлинеарностью**. В этом случае у нас, всё равно, возникают проблемы, близкие к описанным выше. Дело в том, что $X\\nu\\sim 0$ для вектора $\\nu$, состоящего из коэффициентов приближённой линейной зависимости, и, соответственно, $X^TX\\nu\\approx 0$, то есть матрица $X^TX$ снова будет близка к вырожденной. Как и любая симметричная матрица, она диагонализуется в некотором ортонормированном базисе, и некоторые из собственных значений $\\lambda_i$ близки к нулю. Если вектор $X^Ty$ в выражении $(X^TX)^{-1}X^Ty$ будет близким к соответствующему собственному вектору, то он будет умножаться на $1 /{\\lambda_i}$, что опять же приведёт к появлению у $w$ очень больших по модулю компонент (при этом $w$ ещё и будет вычислен с большой погрешностью из-за деления на маленькое число). И, конечно же, все ошибки и весь шум, которые имелись в матрице $X$, при вычислении $y\\sim Xw$ будут умножаться на эти большие и неточные числа и возрастать во много-много раз, что приведёт к проблемам, от которых нас не спасёт никакое сингулярное разложение.\n\nВажно ещё отметить, что в случае, когда несколько признаков линейно зависимы, веса $w_i$ при них теряют физический смысл. Может даже оказаться, что вес признака, с ростом которого таргет, казалось бы, должен увеличиваться, станет отрицательным. Это делает модель не только неточной, но и принципиально не интерпретируемой. Вообще, неадекватность знаков или величины весов – хорошее указание на мультиколлинеарность.\n\nДля того, чтобы справиться с этой проблемой, задачу обычно **регуляризуют**, то есть добавляют к ней дополнительное ограничение на вектор весов. Это ограничение можно, как и исходный лосс, задавать по-разному, но, как правило, ничего сложнее, чем $L^1$- и $L^2$-нормы, не требуется.\n\nВместо исходной задачи теперь предлагается решить такую:\n\n$$\\color{#348FEA}{\\min_w L(f, X, y) = \\min_w(\\|X w - y\\|_2^2 + \\lambda \\|w\\|^k_k )}\n$$\n\n$\\lambda$ – это очередной параметр, а $\\|w\\|\\^k_k$ – это один из двух вариантов:\n\n$$\\color{#348FEA}{\\|w\\|^2_2 = w^2_1 + \\ldots + w^2_D}\n$$\n\nили\n\n$$\\color{#348FEA}{\\|w\\|_1^1 = \\vert w_1 \\vert + \\ldots + \\vert w_D \\vert}\n$$\n\nДобавка $\\lambda\\|w\\|^k_k$ называется **регуляризационным членом** или **регуляризатором**, а число $\\lambda$ – **коэффициентом регуляризации**.\n\nКоэффициент $\\lambda$ является гиперпараметром модели и достаточно сильно влияет на качество итогового решения. Его подбирают по логарифмической шкале (скажем, от `1e-2` до `1e+2`), используя для сравнения моделей с разными значениями $\\lambda$ дополнительную валидационную выборку. При этом качество модели с подобранным коэффициентом регуляризации уже проверяют на тестовой выборке, чтобы исключить переобучение. Более подробно о том, как нужно подбирать гиперпараметры, вы можете почитать в [соответствующем параграфе](https://education.yandex.ru/handbook/ml/article/podbor-giperparametrov).\n\nОтдельно надо договориться о том, что вес $w_0$, соответствующий отступу от начала координат (то есть признаку из всех единичек), мы регуляризовать не будем, потому что это не имеет смысла: если даже все значения $y$ равномерно велики, это не должно портить качество обучения. Обычно это не отображают в формулах, но если придираться к деталям, то стоило бы написать сумму по всем весам, кроме $w_0$:\n\n$$\\|w\\|^2_2 = \\sum_{\\color{red}{j=1}}^{D}w_j^2,\n$$\n\n$$\\|w\\|_1 = \\sum_{\\color{red}{j=1}}^{D} \\vert w_j \\vert\n$$\n\nВ случае $L^2$-регуляризации решение задачи изменяется не очень сильно. Например, продифференцировав новый лосс по $w$, легко получить, что «точное» решение имеет вид:\n\n$$w = (X^TX + \\lambda I)^{-1}X^Ty\n$$\n\nОтметим, что за этой формулой стоит и понятная численная интуиция: раз матрица $X^TX$ близка к вырожденной, то обращать её сродни самоубийству. Мы лучше слегка исказим её добавкой $\\lambda I$, которая увеличит все собственные значения на $\\lambda$, отодвинув их от нуля. Да, аналитическое решение перестаёт быть «точным», но за счёт снижения численных проблем мы получим более качественное решение, чем при использовании «точной» формулы.\n\nВ свою очередь, градиент функции потерь\n\n$$L(f_w, X, y) = \\|Xw - y\\|^2 + \\lambda\\|w\\|^2\n$$\n\nпо весам теперь выглядит так:\n\n$$\\nabla_wL(f_w, X, y) = 2X^T(Xw - y) + 2\\lambda w\n$$\n\nПодставив этот градиент в алгоритм стохастического градиентного спуска, мы получаем обновлённую версию приближенного алгоритма, отличающуюся от старой только наличием дополнительного слагаемого.\n\n**Вопрос на подумать**. Рассмотрим стохастический градиентный спуск для $L^2$-регуляризованной линейной регрессии с батчами размера $1$. Выберите правильный вариант шага SGD:\n\n(а) $w_i\\mapsto w_i - 2\\alpha(\\langle w, x_j\\rangle - y_j)x_{ji} - \\frac{2\\alpha\\lambda}N w_i,\\quad i=1,\\ldots,D$;\n\n(б) $w_i\\mapsto w_i - 2\\alpha(\\langle w, x_j\\rangle - y_j)x_{ji} - 2\\alpha\\lambda w_i,\\quad i=1,\\ldots,D$;\n\n(в) $w_i\\mapsto w_i - 2\\alpha(\\langle w, x_j\\rangle - y_j)x_{ji} - 2\\lambda N w_i,\\quad i=1,\\ldots D$.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nНе регуляризованная функция потерь имеет вид $\\mathcal{L}(X, y, w) = \\frac1N\\sum_{i=1}^N\\mathcal{L}(x_i, y_i, w)$, и её можно воспринимать, как оценку по выборке $(x_i, y_i)_{i=1}^N$ идеальной функции потерь\n\n$$\\mathcal{L}(w) = \\mathbb{E}_{x, y}\\mathcal{L}(x, y, w)\n$$\n\nРегуляризационный член не зависит от выборки и добавляется отдельно:\n\n$$\\mathcal{L}_{\\text{reg}}(w) = \\mathbb{E}_{x, y}\\mathcal{L}(x, y, w) + \\lambda\\|w\\|^2\n$$\n\nСоответственно, идеальный градиент регуляризованной функции потерь имеет вид\n\n$$\\nabla_w\\mathcal{L}_{\\text{reg}}(w) = \\mathbb{E}_{x, y}\\nabla_w\\mathcal{L}(x, y, w) + 2\\lambda w,\n$$\n\nГрадиент по батчу – это тоже оценка градиента идеальной функции потерь, только не на выборке $(X, y)$, а на батче $(x_{t_i}, y_{t_i})_{i=1}^B$ размера $B$. Он будет выглядеть так:\n\n$$\\nabla_w\\mathcal{L}_{\\text{reg}}(w) = \\frac1B\\sum_{i=1}^B\\nabla_w\\mathcal{L}(x_{t_i}, y_{t_i}, w) + 2\\lambda w.\n$$\n\nКак видите, коэффициентов, связанных с числом объектов в батче или в исходной выборке, во втором слагаемом нет. Так что верным является второй вариант. Кстати, обратите внимание, что в третьем ещё и нет коэффициента $\\alpha$ перед производной регуляризационного слагаемого, это тоже ошибка.\n\n{% endcut %}\n\n**Вопрос на подумать**. Распишите процедуру стохастического градиентного спуска для $L^1$-регуляризованной линейной регрессии. Как вам кажется, почему никого не волнует, что функция потерь, строго говоря, не дифференцируема?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nРаспишем для случая батча размера 1:\n\n$$w_i\\mapsto w_i - \\alpha(\\langle w, x_j\\rangle - y_j)x_{ji} - \\frac{\\lambda}N \\text{sign}(w_i),\\quad i=1,\\ldots,D\n$$\n\nФункция потерь не дифференцируема лишь в одной точке. Так как в машинном обучении чаще всего мы имеем дело с данными вероятностного характера, это не влечёт каких-то особых проблем. Дело в том, что попадание прямо в ноль очень маловероятно из-за численных погрешностей в данных, так что мы можем просто доопределить производную в одной точке, а если даже пару раз попадём в неё за время обучения, это не приведёт к каким-то значительным изменениям результатов.\n\n{% endcut %}\n\nОтметим, что $L^1$- и $L^2$-регуляризацию можно определять для любой функции потерь $L(w, X, y)$ (и не только в задаче регрессии, а и, например, в задаче классификации тоже). Новая функция потерь будет соответственно равна\n\n$$\\widetilde{L}(w, X, y) = L(w, X, y) + \\lambda\\|w\\|_1\n$$\n\nили\n\n$$\\widetilde{L}(w, X, y) = L(w, X, y) + \\lambda\\|w\\|_2^2\n$$\n\n### Разреживание весов в $L^1$-регуляризации\n\n$L^2$-регуляризация работает прекрасно и используется в большинстве случаев, но есть одна полезная особенность $L^1$-регуляризации: её применение приводит к тому, что у признаков, которые не оказывают большого влияния на ответ, вес в результате оптимизации получается равным $0$. Это позволяет удобным образом удалять признаки, слабо влияющие на таргет. Кроме того, это даёт возможность автоматически избавляться от признаков, которые участвуют в соотношениях приближённой линейной зависимости, соответственно, спасает от проблем, связанных с мультиколлинеарностью, о которых мы писали выше.\n\nНе очень строгим, но довольно интуитивным образом это можно объяснить так:\n\n1. В точке оптимума линии уровня регуляризационного члена касаются линий уровня основного лосса, потому что, во-первых, и те, и другие выпуклые, а во-вторых, если они пересекаются трансверсально, то существует более оптимальная точка:\n\n![1](https://yastatic.net/s3/education-portal/media/1_8_bb012dea47_1dd4105626.webp)\n\n2. Линии уровня $L^1$-нормы – это $N$-мерные октаэдры. Точки их касания с линиями уровня лосса, скорее всего, лежат на грани размерности, меньшей $N-1$, то есть как раз в области, где часть координат равна нулю:\n\n![1](https://yastatic.net/s3/education-portal/media/1_9_c157936d62_f29bca1e43.webp)\n\nЗаметим, что данное построение говорит о том, как выглядит оптимальное решение задачи, но ничего не говорит о способе, которым это решение можно найти. На самом деле, найти такой оптимум непросто: у $L^1$ меры довольно плохая производная. Однако, способы есть. Можете на досуге прочитать, например, [вот эту статью](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41159.pdf) о том, как работало предсказание CTR в google в 2012 году. Там этой теме посвящается довольно много места. Кроме того, рекомендуем посмотреть про проксимальные методы в разделе этой книги про оптимизацию в ML.\n\nЗаметим также, что вообще-то оптимизация любой нормы $L_x, \\ 0  < x \\leq 1$, приведёт к появлению разреженных векторов весов, просто если c $L^1$ ещё хоть как-то можно работать, то с остальными всё будет ещё сложнее.\n\n## Другие лоссы\n\nСтохастический градиентный спуск можно очевидным образом обобщить для решения задачи линейной регрессии с любой другой функцией потерь, не только квадратичной: ведь всё, что нам нужно от неё, – это чтобы у функции потерь был градиент. На практике это делают редко, но тем не менее рассмотрим ещё пару вариантов.\n\n### MAE\n\n**Mean absolute error**, абсолютная ошибка, появляется при замене $L^2$ нормы в MSE на $L^1$:\n\n$$\\color{#348FEA}{MAE(y, \\widehat{y}) = \\frac1N\\sum_{i=1}^N \\vert y_i - \\widehat{y}_i\\vert}\n$$\n\nМожно заметить, что в MAE по сравнению с MSE существенно меньший вклад в ошибку будут вносить примеры, сильно удалённые от ответов модели. Дело тут в том, что в MAE мы считаем модуль расстояния, а не квадрат, соответственно, вклад больших ошибок в MSE получается существенно больше. Такая функция потерь уместна в случаях, когда вы пытаетесь обучить регрессию на данных с большим количеством выбросов в таргете.\n\nИначе на эту разницу можно посмотреть так: MSE приближает матожидание условного распределения $y \\mid x$, а MAE – медиану.\n\n### MAPE\n\n**Mean absolute percentage error**, относительная ошибка.\n\n$$MAPE(y, \\widehat{y}) = \\frac1N\\sum_{i=1}^N \\left|\\frac{\\widehat{y}_i-y_i}{y_i}\\right|\n$$\n\nЧасто используется в задачах прогнозирования (например, погоды, загруженности дорог, кассовых сборов фильмов, цен), когда ответы могут быть различными по порядку величины, и при этом мы бы хотели верно угадать порядок, то есть мы не хотим штрафовать модель за предсказание 2000 вместо 1000 в разы сильней, чем за предсказание 2 вместо 1.\n\n**Вопрос на подумать**. Кроме описанных выше в задаче линейной регрессии можно использовать и другие функции потерь, например, **Huber loss**:\n\n$$\\mathcal{L}(f, X, y)=\\sum_{i=1}^N h_\\delta\\left(y_i-\\left\\langle w_i, x\\right\\rangle\\right), \\text { где } h_\\delta(z)=\\left\\{\\begin{array}{l}\n\\frac{1}{2} z^2,|z| \\leqslant \\delta \\\\\n\\delta\\left(|z|-\\frac{1}{2} \\delta\\right),|z|>\\delta\n\\end{array}\\right.\n$$\n\nЧисло $\\delta$ является гиперпараметром. Сложная формула при $\\vert z\\vert > \\delta$ нужна, чтобы функция $h_{\\delta}(z)$ была непрерывной. Попробуйте объяснить, зачем может быть нужна такая функция потерь.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nЧасто требования формулируют в духе «функция потерь должна слабее штрафовать то-то и сильней штрафовать вот это». Например, $L^2$-регуляризованный лосс штрафует за большие по модулю веса. В данном случае можно заметить, что при небольших значениях ошибки берётся просто MSE, а при больших мы начинаем штрафовать нашу модель менее сурово. Например, это может быть полезно для того, чтобы выбросы не так сильно влияли на результат обучения.\n\n{% endcut %}\n\n## Линейная классификация\n\nТеперь давайте поговорим про задачу классификации. Для начала будем говорить про бинарную классификацию на два класса. Обобщить эту задачу до задачи классификации на $K$ классов не составит большого труда. Пусть теперь наши таргеты $y$ кодируют принадлежность к положительному или отрицательному классу, то есть принадлежность множеству $\\{-1,1\\}$ (в этом параграфе договоримся именно так обозначать классы, хотя в жизни вам будут нередко встречаться и метки $\\{0,1\\}$), а $x$ – по-прежнему векторы из $\\mathbb{R}^D$. Мы хотим обучить линейную модель так, чтобы плоскость, которую она задаёт, как можно лучше отделяла объекты одного класса от другого.\n\n![1](https://yastatic.net/s3/education-portal/media/1_10_22eb9c5128_115a8caa4e.webp)\n\nВ идеальной ситуации найдётся плоскость, которая разделит классы: положительный окажется с одной стороны от неё, а отрицательный с другой. Выборка, для которой это возможно, называется **линейно разделимой**. Увы, в реальной жизни такое встречается крайне редко.\n\nКак обучить линейную модель классификации, нам ещё предстоит понять, но уже ясно, что итоговое предсказание можно будет вычислить по формуле\n\n$$y = \\text{sign} \\langle w, x_i\\rangle\n$$\n\n{% cut \"Почему бы не решать, как задачу регрессии?\" %}\n\nМы можем попробовать предсказывать числа $-1$ и $1$, минимизируя для этого, например, MSE с последующим взятием знака, но ничего хорошего не получится. Во-первых, регрессия почти не штрафует за ошибки на объектах, которые лежат близко к *разделяющей плоскости*, но не с той стороны. Во вторых, ошибкой будет считаться предсказание, например, $5$ вместо $1$, хотя нам-то на самом деле не важно, какой у числа модуль, лишь бы знак был правильным. Если визуализировать такое решение, то проблемы тоже вполне заметны:\n\n![1](https://yastatic.net/s3/education-portal/media/1_11_0fe41ca811_dca2d9e4b3.webp)\n\nНам нужна прямая, которая разделяет эти точки, а не проходит через них!\n\n{% endcut %}\n\nСконструируем теперь функционал ошибки так, чтобы он вышеперечисленными проблемами не обладал. Мы хотим минимизировать число ошибок классификатора, то есть\n\n$$\\sum_i \\mathbb{I}[y_i \\neq sign \\langle w, x_i\\rangle]\\longrightarrow \\min_w\n$$\n\nДомножим обе части на $y_i$ и немного упростим\n\n$$\\sum_i \\mathbb{I}[y_i \\langle w, x_i\\rangle < 0]\\longrightarrow \\min_w\n$$\n\nВеличина $M = y_i \\langle w, x_i\\rangle$ называется **отступом** (**margin**) классификатора. Такая фунция потерь называется **misclassification loss**. Легко видеть, что\n\n- отступ положителен, когда $sign(y_i) = sign(\\langle w, x_i\\rangle)$, то есть класс угадан верно; при этом чем больше отступ, тем больше расстояние от $x_i$ до разделяющей гиперплоскости, то есть «уверенность классификатора»;\n\n- отступ отрицателен, когда $sign(y_i) \\ne sign(\\langle w, x_i\\rangle)$, то есть класс угадан неверно; при этом чем больше по модулю отступ, тем более сокрушительно ошибается классификатор.\n\nОт каждого из отступов мы вычисляем функцию\n\n$$F(M) = \\mathbb{I}[M < 0] = \\begin{cases}1,\\ M < 0,\\\\ 0,\\ M\\geqslant 0\\end{cases}\n$$\n\nОна кусочно-постоянная, и из-за этого всю сумму невозможно оптимизировать градиентными методами: ведь её производная равна нулю во всех точках, где она существует. Но мы можем мажорировать её какой-нибудь более гладкой функцией, и тогда задачу можно будет решить. Функции можно использовать разные, у них свои достоинства и недостатки, давайте рассмотрим несколько примеров:\n\n![1](https://yastatic.net/s3/education-portal/media/1_12_7fddcb49c6_ff86ee2509.webp)\n\n**Вопрос на подумать**. Допустим, мы как-то обучили классификатор, и подавляющее большинство отступов оказались отрицательными. Правда ли нас постигла катастрофа?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nНаверное, мы что-то сделали не так, но ситуацию можно локально выправить, если предсказывать классы, противоположные тем, которые выдаёт наша модель.\n\n{% endcut %}\n\n**Вопрос на подумать**. Предположим, что у нас есть два классификатора с примерно одинаковыми и достаточно приемлемыми значениями интересующей нас метрики. При этом одна почти всегда выдаёт предсказания с большими по модулю отступами, а вторая – с относительно маленькими. Верно ли, что первая модель лучше, чем вторая?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nНа первый взгляд кажется, что первая модель действительно лучше: ведь она предсказывает «увереннее», но на самом деле всё не так однозначно: во многих случаях модель, которая умеет «честно признать, что не очень уверена в ответе», может быть предпочтительней модели, которая врёт с той же непотопляемой уверенностью, что и говорит правду. В некоторых случаях лучше может оказаться модель, которая, по сути, просто отказывается от классификации на каких-то объектах.\n\n{% endcut %}\n\n### Ошибка перцептрона\n\nРеализуем простейшую идею: давайте считать отступы только на неправильно классифицированных объектах и учитывать их не бинарно, а линейно, пропорционально их размеру. Получается такая функция:\n\n$$F(M) = \\max(0, -M)\n$$\n\nДавайте запишем такой лосс с $L^2$-регуляризацией:\n\n$$L(w, x, y) = \\lambda\\vert\\vert w\\vert\\vert^2_2 + \\sum_i \\max(0, -y_i \\langle w, x_i\\rangle)\n$$\n\nНайдём градиент:\n\n$$\\nabla_w L(w, x, y) = 2 \\lambda w + \\sum_i\n\\begin{cases}\n0,            & y_i \\langle w, x_i \\rangle > 0 \\\\\n- y_i x_i,  & y_i \\langle w, x_i \\rangle \\leq 0\n\\end{cases}\n$$\n\nИмея аналитическую формулу для градиента, мы теперь можем так же, как и раньше, применить стохастический градиентный спуск, и задача будет решена.\n\nДанная функция потерь впервые была предложена для перцептрона Розенблатта, первой вычислительной модели нейросети, которая в итоге привела к появлению глубокого обучения.\n\nОна решает задачу линейной классификации, но у неё есть одна особенность: её решение не единственно и сильно зависит от начальных параметров. Например, все изображённые ниже классификаторы имеют одинаковый нулевой лосс:\n\n![1](https://yastatic.net/s3/education-portal/media/1_13_ef3e9fca2c_6eb38e5a25.webp)\n\n### Hinge loss, SVM\n\nДля таких случаев, как на картинке выше, возникает логичное желание не только найти разделяющую прямую, но и постараться провести её на одинаковом удалении от обоих классов, то есть максимизировать минимальный отступ:\n\n![1](https://yastatic.net/s3/education-portal/media/1_14_34f6185216_69b91a68a8.webp)\n\nЭто можно сделать, слегка поменяв функцию ошибки, а именно положив её равной:\n\n$$F(M) = \\max(0, 1-M)\n$$\n\n$$L(w, x, y) = \\lambda\\||w\\||^2_2 + \\sum_i \\max(0, 1-y_i \\langle w, x_i\\rangle)\n$$\n\n$$\\nabla_w L(w, x, y) = 2 \\lambda w + \\sum_i\n        \\begin{cases}\n            0,           & 1 - y_i \\langle w, x_i \\rangle \\leq 0 \\\\\n            - y_i x_i,   & 1 - y_i \\langle w, x_i \\rangle > 0\n        \\end{cases}\n$$\n\nПочему же добавленная единичка приводит к желаемому результату?\n\nИнтуитивно это можно объяснить так: объекты, которые проклассифицированы правильно, но не очень \"уверенно\" (то есть $0 \\leq y_i \\langle w, x_i\\rangle < 1$), продолжают вносить свой вклад в градиент и пытаются \"отодвинуть\" от себя разделяющую плоскость как можно дальше.\n\nК данному выводу можно прийти и чуть более строго; для этого надо совершенно по-другому взглянуть на выражение, которое мы минимизируем. Поможет вот эта картинка:\n\n![1](https://yastatic.net/s3/education-portal/media/1_15_583bd074b0_283e6ecbec.webp)\n\nЕсли мы максимизируем минимальный отступ, то надо максимизировать $\\frac{2}{\\|w\\|_2}$, то есть ширину полосы при условии того, что большинство объектов лежат с правильной стороны, что эквивалентно решению нашей исходной задачи:\n\n$$\\lambda\\|w\\|^2_2 + \\sum_i \\max(0, 1-y_i \\langle w, x_i\\rangle) \\longrightarrow\\min\\limits_{w}\n$$\n\nОтметим, что первое слагаемое у нас обратно пропорционально ширине полосы, но мы и максимизацию заменили на минимизацию, так что тут всё в порядке. Второе слагаемое – это штраф за то, что некоторые объекты неправильно расположены относительно разделительной полосы. В конце концов, никто нам не обещал, что классы наши линейно разделимы и можно провести оптимальную плоскость вообще без ошибок.\n\nИтоговое положение плоскости задаётся всего несколькими обучающими примерами. Это ближайшие к плоскости правильно классифицированные объекты, которые называют **опорными векторами** или **support vectors**. Весь метод, соответственно, зовётся методом **опорных векторов**, или **support vector machine**, или сокращённо **SVM**. Начиная с шестидесятых годов это был сильнейший из известных методов машинного обучения. В девяностые его сменили методы, основанные на деревьях решений, которые, в свою очередь, недавно передали «пальму первенства» нейросетям.\n\nПочему же SVM был столь популярен? Из-за небольшого количества параметров и доказуемой оптимальности. Сейчас для нас нормально выбирать специальный алгоритм под задачу и подбирать оптимальные гиперпараметры для этого алгоритма перебором, а когда-то трава была зеленее, а компьютеры медленнее, и такой роскоши у людей не было. Поэтому им нужны были модели, которые гарантированно неплохо работали бы в любой ситуации. Такой моделью и был SVM.\n\nДругие замечательные свойства SVM: существование уникального решения и доказуемо минимальная склонность к переобучению среди всех популярных классов линейных классификаторов. Кроме того, несложная модификация алгоритма, ядровый SVM, позволяет проводить нелинейные разделяющие поверхности.\n\nСтрогий вывод постановки задачи SVM можно прочитать [тут](https://www.mit.edu/~9.520/spring08/Classes/class05.pdf) или [в лекции К.В. Воронцова](http://machinelearning.ru/wiki/images/archive/a/a0/20150316112120!Voron-ML-Lin-SVM.pdf).\n\n### Логистическая регрессия\n\nВ этом параграфе мы будем обозначать классы нулём и единицей.\n\nЕщё один интересный метод появляется из желания посмотреть на классификацию как на задачу предсказания вероятностей. Хороший пример – предсказание кликов в интернете (например, в рекламе и поиске). Наличие клика в обучающем логе не означает, что, если повторить полностью условия эксперимента, пользователь обязательно кликнет по объекту опять. Скорее у объектов есть какая-то \"кликабельность\", то есть истинная вероятность клика по данному объекту. Клик на каждом обучающем примере является реализацией этой случайной величины, и мы считаем, что в пределе в каждой точке отношение положительных и отрицательных примеров должно сходиться к этой вероятности.\n\nПроблема состоит в том, что вероятность, по определению, величина от 0 до 1, а простого способа обучить линейную модель так, чтобы это ограничение соблюдалось, нет. Из этой ситуации можно выйти так: научить линейную модель правильно предсказывать какой-то объект, связанный с вероятностью, но с диапазоном значений $(-\\infty,\\infty)$, и преобразовать ответы модели в вероятность. Таким объектом является **logit** или **log odds** – логарифм отношения вероятности положительного события к отрицательному $\\log\\left(\\frac{p}{1-p}\\right)$.\n\nЕсли ответом нашей модели является $\\log\\left(\\frac{p}{1-p}\\right)$, то искомую вероятность посчитать не трудно:\n\n$$\\langle w, x_i\\rangle = \\log\\left(\\frac{p}{1-p}\\right)\n$$\n\n$$e^{\\langle w, x_i\\rangle} = \\frac{p}{1-p}\n$$\n\n$$p=\\frac{1}{1 + e^{-\\langle w, x_i\\rangle}}\n$$\n\nФункция в правой части называется **сигмоидой** и обозначается\n\n$$\\color{#348FEA}{\\sigma(z) = \\frac1{1 + e^{-z}}}\n$$\n\nТаким образом, $p = \\sigma(\\langle w, x_i\\rangle)$\n\nКак теперь научиться оптимизировать $w$ так, чтобы модель как можно лучше предсказывала логиты? Нужно применить метод максимума правдоподобия для распределения Бернулли. Это самое простое распределение, которое возникает, к примеру, при бросках монетки, которая орлом выпадает с вероятностью $p$. У нас только событием будет не орёл, а то, что пользователь кликнул на объект с такой вероятностью. Если хотите больше подробностей, почитайте про распределение Бернулли в теоретическом минимуме.\n\nПравдоподобие позволяет понять, насколько вероятно получить данные значения таргета $y$ при данных $X$ и весах $w$. Оно имеет вид\n\n$$p(y\\mid X, w) =\\prod_i p(y_i\\mid x_i, w)\n$$\n\nи для распределения Бернулли его можно выписать следующим образом:\n\n$$p(y\\mid X, w) =\\prod_i p_i^{y_i} (1-p_i)^{1-y_i}\n$$\n\nгде $p_i$ – это вероятность, посчитанная из ответов модели. Оптимизировать произведение неудобно, хочется иметь дело с суммой, так что мы перейдём к логарифмическому правдоподобию и подставим формулу для вероятности, которую мы получили выше:\n\n$$\\ell(w, X, y) = \\sum_i \\big( y_i \\log(p_i) + (1-y_i)\\log(1-p_i) \\big) =\n$$\n\n$$=\\sum_i \\big( y_i \\log(\\sigma(\\langle w, x_i \\rangle)) + (1-y_i)\\log(1 - \\sigma(\\langle w, x_i \\rangle)) \\big)\n$$\n\nЕсли заметить, что\n\n$$\\sigma(-z) = \\frac{1}{1 + e^z} = \\frac{e^{-z}}{e^{-z} + 1} = 1 - \\sigma(z),\n$$\n\nто выражение можно переписать проще:\n\n$$\\ell(w, X, y)=\\sum_i \\big( y_i \\log(\\sigma(\\langle w, x_i \\rangle)) + (1 - y_i) \\log(\\sigma(-\\langle w, x_i \\rangle)) \\big)\n$$\n\nНас интересует $w$, для которого правдоподобие максимально. Чтобы получить функцию потерь, которую мы будем *минимизировать*, умножим его на минус один:\n\n$$\\color{#348FEA}{L(w, X, y) = -\\sum_i \\big( y_i \\log(\\sigma(\\langle w, x_i \\rangle)) + (1 - y_i) \\log(\\sigma(-\\langle w, x_i \\rangle)) \\big)}\n$$\n\nВ отличие от линейной регрессии, для логистической нет явной формулы решения. Деваться некуда, будем использовать градиентный спуск. К счастью, градиент устроен очень просто:\n\n$$\\nabla_w L(y, X, w) = -\\sum_i x_i \\big( y_i - \\sigma(\\langle w, x_i \\rangle) \\big)\n$$\n\n{% cut \"Вывод формулы градиента\" %}\n\nНам окажется полезным ещё одно свойство сигмоиды:\n\n$$\\frac{d \\log \\sigma(z)}{d z} = \\left( \\log \\left( \\frac{1}{1 + e^{-z}} \\right)  \\right)' = \\frac{e^{-z}}{1 + e^{-z}} = \\sigma(-z) \\\\\n$$\n\n$$\\frac{d \\log \\sigma(-z)}{d z} =  -\\sigma(z)\n$$\n\nОтсюда:\n\n$$\\nabla_w \\log \\sigma(\\langle w, x_i \\rangle) =  \\sigma(-\\langle w, x_i \\rangle) x_i \\\\\n$$\n\n$$\\nabla_w \\log \\sigma(-\\langle w, x_i \\rangle) =  -\\sigma(\\langle w, x_i \\rangle) x_i\n$$\n\nи градиент оказывается равным\n\n$$\\nabla_w L(y, X, w) = -\\sum_i \\big( y_i x_i \\sigma(-\\langle w, x_i \\rangle) - (1 - y_i) x_i \\sigma(\\langle w, x_i \\rangle) \\big) = \\\\\n$$\n\n$$= -\\sum_i \\big( y_i x_i (1 - \\sigma(\\langle w, x_i \\rangle)) - (1 - y_i) x_i \\sigma(\\langle w, x_i \\rangle)\\big) = \\\\\n$$\n\n$$= -\\sum_i \\big( y_i x_i - y_i x_i \\sigma(\\langle w, x_i \\rangle) - x_i \\sigma(\\langle w, x_i \\rangle) + y_i x_i \\sigma(\\langle w, x_i \\rangle) \\big) = \\\\\n$$\n\n$$= -\\sum_i \\big( y_i x_i - x_i \\sigma(\\langle w, x_i \\rangle) \\big)\n$$\n\n{% endcut %}\n\nПредсказание модели будет вычисляться, как мы договаривались, следующим образом:\n\n$$p=\\sigma(\\langle w, x_i\\rangle)\n$$\n\nЭто вероятность положительного класса, а как от неё перейти к предсказанию самого класса? В других методах нам достаточно было посчитать знак предсказания, но теперь все наши предсказания положительные и находятся в диапазоне от 0 до 1. Что же делать? Интуитивным и не совсем (и даже совсем не) правильным является ответ «взять порог 0.5». Более корректным будет подобрать этот порог отдельно, для уже построенной регрессии минимизируя нужную вам метрику на отложенной тестовой выборке. Например, сделать так, чтобы доля положительных и отрицательных классов примерно совпадала с реальной.\n\nОтдельно заметим, что метод называется логистической *регрессией*, а не логистической *классификацией* именно потому, что предсказываем мы не классы, а вещественные числа – логиты.\n\n**Вопрос на подумать**. Проверьте, что, если метки классов – это $\\pm1$, а не $0$ и $1$, то функцию потерь для логистической регрессии можно записать в более компактном виде:\n\n$$\\mathcal{L}(w, X, y) = \\sum_{i=1}^N\\log(1 + e^{-y_i\\langle w, x_i\\rangle})\n$$\n\n**Вопрос на подумать**. Правда ли разделяющая поверхность модели логистической регрессии является гиперплоскостью?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nРазделяющая поверхность отделяет множество точек, которым мы присваиваем класс $0$ (или $-1$), и множество точек, которым мы присваиваем класс $1$. Представляется логичным провести отсечку по какому-либо значению предсказанной вероятности. Однако, выбор этого значения — дело не очевидное. Как мы увидим в параграфе про калибровку классификаторов, это может быть не настоящая вероятность. Допустим, мы решили провести границу по значению $\\frac12$. Тогда разделяющая поверхность как раз задаётся равенством $p = \\frac12$, что равносильно $\\langle w, x\\rangle = 0$. А это гиперплоскость.\n\n{% endcut %}\n\n**Вопрос на подумать**. Допустим, что матрица объекты-признаки $X$ имеет полный ранг по столбцам (то есть все её столбцы линейно независимы). Верно ли, что решение задачи восстановления логистической регрессии единственно?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nВ этот раз хорошего геометрического доказательства, как было для линейной регрессии, пожалуй, нет; нам придётся честно посчитать вторую производную и доказать, что она является положительно определённой. Сделаем это для случая, когда метки классов – это $\\pm1$. Формулы так получатся немного попроще. Напомним, что в этом случае\n\n$$L(w, X, y) = \\sum_{i=1}^N\\log(1 + e^{-y_i\\langle w, x_i\\rangle})\n$$\n\nСледовательно,\n\n$$\\frac{\\partial}{\\partial w_{j}}L(w, X, y) = \\sum_{i=1}^N\\frac{y_ix_{ij}e^{-y_i\\langle w, x_i\\rangle}}{1 + e^{-y_i\\langle w, x_i\\rangle}} = \\sum_{i=1}^Ny_ix_{ij}\\left(1 - \\frac1{1 + e^{-y_i\\langle w, x_i\\rangle}}\\right)\n$$\n\n$$\\frac{\\partial^2L}{\\partial w_j\\partial w_k}(w, X, y) = \\sum_{i=1}^Ny^2_ix_{ij}x_{ik}\\frac{e^{-y_i\\langle w, x_i\\rangle}}{(1 + e^{-y_i\\langle w, x_i\\rangle})^2} =\n$$\n\n$$= \\sum_{i=1}^Ny^2_ix_{ij}x_{ik}\\sigma(y_i\\langle w, x_i\\rangle)(1 - \\sigma(y_i\\langle w, x_i\\rangle))\n$$\n\nТеперь заметим, что $y_i^2 = 1$ и что, если обозначить через $D$ диагональную матрицу с элементами $\\sigma(y_i\\langle w, x_i\\rangle)(1 - \\sigma(y_i\\langle w, x_i\\rangle))$ на диагонали, матрицу вторых производных можно представить в виде:\n\n$$\\nabla^2L = \\left(\\frac{\\partial^2\\mathcal{L}}{\\partial w_j\\partial w_k}\\right) = X^TDX\n$$\n\nТак как $0 < \\sigma(y_i\\langle w, x_i\\rangle) < 1$, у матрицы $D$ на диагонали стоят положительные числа, из которых можно извлечь квадратные корни, представив $D$ в виде $D = D^{1/2}D^{1/2}$. В свою очередь, матрица $X$ имеет полный ранг по столбцам. Стало быть, для любого вектора приращения $u\\ne 0$ имеем\n\n$$u^TX^TDXu = u^TX^T(D^{1/2})^TD^{1/2}Xu = \\vert D^{1/2}Xu \\vert^2 > 0\n$$\n\nТаким образом, функция $L$ выпукла вниз как функция от $w$, и, соответственно, точка её экстремума непременно будет точкой минимума.\n\nА теперь – **почему это не совсем правда**. Дело в том, что, говоря «*точка её экстремума непременно будет точкой минимума*», мы уже подразумеваем существование этой самой точки экстремума. Только вот существует этот экстремум не всегда. Можно показать, что для линейно разделимой выборки функция потерь логистической регрессии не ограничена снизу, и, соответственно, никакого экстремума нет. Доказательство мы оставляем читателю.\n\n{% endcut %}\n\n**Вопрос на подумать**. На картинке ниже представлены результаты работы на одном и том же датасете трёх моделей логистической регрессии с разными коэффициентами $L^2$-регуляризации:\n\n![1](https://yastatic.net/s3/education-portal/media/1_16_f62fbdcf08_ef212cc69a.webp)\n\nНаверху показаны предсказанные вероятности положительного класса, внизу – вид разделяющей поверхности.\n\nКак вам кажется, какие картинки соответствуют самому большому коэффициенту регуляризации, а какие – самому маленькому? Почему?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nКоэффициент регуляризации максимален у левой модели. На это нас могут натолкнуть два соображения. Во-первых, разделяющая прямая проведена достаточно странно, то есть можно заподозрить, что регуляризационный член в лосс-функции перевесил функцию потерь исходной задачи. Во-вторых, модель предсказывает довольно близкие к $\\frac12$ вероятности – это значит, что значения $\\langle w, x\\rangle$ близки к нулю, то есть сам вектор $w$ близок к нулевому. Это также свидетельствует о том, что регуляризационный член играет слишком важную роль при оптимизации.\n\nНаименьший коэффициент регуляризации у правой модели. Её предсказания достаточно «уверенные» (цвета на верхнем графике сочные, то есть вероятности быстро приближаются к $0$ или $1$). Это может свидетельствовать о том, что числа $\\langle w, x\\rangle$ достаточно велики по модулю, то есть $\\vert\\vert w \\vert\\vert$ достаточно велик.\n\n{% endcut %}\n\n## Многоклассовая классификация\n\nВ этом разделе мы будем следовать изложению [из лекций Евгения Соколова](https://github.com/esokolov/ml-course-hse/blob/master/2020-fall/lecture-notes/lecture06-linclass.pdf).\n\nПусть каждый объект нашей выборки относится к одному из $K$ классов: $\\mathbb{Y} = \\{1, \\ldots, K\\}$. Чтобы предсказывать эти классы с помощью линейных моделей, нам придётся свести задачу многоклассовой классификации к набору бинарных, которые мы уже хорошо умеем решать. Мы разберём два самых популярных способа это сделать – one-vs-all и all-vs-all, а проиллюстрировать их нам поможет вот такой игрушечный датасет\n\n![1](https://yastatic.net/s3/education-portal/media/1_17_ac366ff85b_9b4b97df40.webp)\n\n### Один против всех (one-versus-all)\n\nОбучим $K$ линейных классификаторов $b_1(x), \\ldots, b_K(x)$, выдающих оценки принадлежности классам $1, \\ldots, K$ соответственно. В случае с линейными моделями эти классификаторы будут иметь вид\n\n$$b_k(x) = \\text{sgn}\\left(\\langle w_k, x \\rangle + w_{0k}\\right)\n$$\n\nКлассификатор с номером $k$ будем обучать по выборке $\\left(x_i, 2\\mathbb{I}[y_i = k] - 1\\right)_{i = 1}^{N}$; иными словами, мы учим классификатор отличать $k$-й класс от всех остальных.\n\nЛогично, чтобы итоговый классификатор выдавал класс, соответствующий самому уверенному из бинарных алгоритмов. Уверенность можно в каком-то смысле измерить с помощью значений линейных функций:\n\n$$a(x) = \\text{argmax}_k \\left(\\langle w_k, x \\rangle + w_{0k}\\right)\n$$\n\nДавайте посмотрим, что даст этот подход применительно к нашему датасету. Обучим три линейных модели, отличающих один класс от остальных:\n\n![1](https://yastatic.net/s3/education-portal/media/1_18_4d5acf1fb3_8679340170.webp)\n\nТеперь сравним значения линейных функций\n\n![1](https://yastatic.net/s3/education-portal/media/1_19_324b7eedcf_aad79d81c8.webp)\n\nи для каждой точки выберем тот класс, которому соответствует большее значение, то есть самый «уверенный» классификатор:\n\n![1](https://yastatic.net/s3/education-portal/media/1_20_8164bb85e4_1e60894484.webp)\n\nХочется сказать, что самый маленький класс «обидели».\n\nПроблема данного подхода заключается в том, что каждый из классификаторов $b_1(x), \\dots, b_K(x)$ обучается на своей выборке, и значения линейных функций $\\langle w_k, x \\rangle + w_{0k}$ или, проще говоря, \"выходы\" классификаторов могут иметь разные масштабы. Из-за этого сравнивать их будет неправильно. Нормировать вектора весов, чтобы они выдавали ответы в одной и той же шкале, не всегда может быть разумным решением: так, в случае с SVM веса перестанут являться решением задачи, поскольку нормировка изменит норму весов.\n\n### Все против всех (all-versus-all)\n\nОбучим $C_K^2$ классификаторов $a_{ij}(x)$, $i, j = 1, \\dots, K$, $i \\neq j$. Например, в случае с линейными моделями эти модели будут иметь вид\n\n$$b_{ij}(x) = \\text{sgn}\\left( \\langle w_{ij}, x \\rangle + w_{0,ij} \\right)\n$$\n\nКлассификатор $a_{ij}(x)$ будем настраивать по подвыборке $X_{ij} \\subset X$, содержащей только объекты классов $i$ и $j$. Соответственно, классификатор $a_{ij}(x)$ будет выдавать для любого объекта либо класс $i$, либо класс $j$. Проиллюстрируем это для нашей выборки:\n\n![1](https://yastatic.net/s3/education-portal/media/1_21_6cebfcb75d_cba1fb93c0.webp)\n\nЧтобы классифицировать новый объект, подадим его на вход каждого из построенных бинарных классификаторов. Каждый из них проголосует за свой класс; в качестве ответа выберем тот класс, за который наберется больше всего голосов:\n\n$$a(x) = \\text{argmax}_k\\sum_{i = 1}^{K} \\sum_{j \\neq i}\\mathbb{I}[a_{ij}(x) = k]\n$$\n\nДля нашего датасета получается следующая картинка:\n\n![1](https://yastatic.net/s3/education-portal/media/1_22_3d30a2271f_9c28114951.webp)\n\nОбратите внимание на серый треугольник на стыке областей. Это точки, для которых голоса разделились (в данном случае каждый классификатор выдал какой-то свой класс, то есть у каждого класса было по одному голосу). Для этих точек нет явного способа выдать обоснованное предсказание.\n\n### Многоклассовая логистическая регрессия\n\nНекоторые методы бинарной классификации можно напрямую обобщить на случай многих классов. Выясним, как это можно проделать с логистической регрессией.\n\nВ логистической регрессии для двух классов мы строили линейную модель\n\n$$b(x) = \\langle w, x \\rangle + w_0,\n$$\n\nа затем переводили её прогноз в вероятность с помощью сигмоидной функции $\\sigma(z) = \\frac{1}{1 + \\exp(-z)}$. Допустим, что мы теперь решаем многоклассовую задачу и построили $K$ линейных моделей\n\n$$b_k(x) = \\langle w_k, x \\rangle + w_{0k},\n$$\n\nкаждая из которых даёт оценку принадлежности объекта одному из классов. Как преобразовать вектор оценок $(b_1(x), \\ldots, b_K(x))$ в вероятности? Для этого можно воспользоваться оператором $\\text{softmax}(z_1, \\ldots, z_K)$, который производит «нормировку» вектора:\n\n$$\\text{softmax}(z_1, \\ldots, z_K) = \\left(\\frac{\\exp(z_1)}{\\sum_{k = 1}^{K} \\exp(z_k)},\n\\dots, \\frac{\\exp(z_K)}{\\sum_{k = 1}^{K} \\exp(z_k)}\\right).\n$$\n\nВ этом случае вероятность $k$-го класса будет выражаться как\n\n$$P(y = k \\vert x, w) = \\frac{\n\\exp{(\\langle w_k, x \\rangle + w_{0k})}}{ \\sum_{j = 1}^{K} \\exp{(\\langle w_j, x \\rangle + w_{0j})}}.\n$$\n\nОбучать эти веса предлагается с помощью метода максимального правдоподобия: так же, как и в случае с двухклассовой логистической регрессией:\n\n$$\\sum_{i = 1}^{N} \\log P(y = y_i \\vert x_i, w) \\to \\max_{w_1, \\dots, w_K}\n$$\n\n## Масштабируемость линейных моделей\n\nМы уже обсуждали, что SGD позволяет обучению хорошо масштабироваться по числу объектов, так как мы можем не загружать их целиком в оперативную память. А что делать, если признаков очень много, или мы не знаем заранее, сколько их будет? Такое может быть актуально, например, в следующих ситуациях:\n\n- Классификация текстов: мы можем представить текст в формате «мешка слов», то есть неупорядоченного набора слов, встретившихся в данном тексте, и обучить на нём, например, определение тональности отзыва в интернете. Наличие каждого слова из языка в тексте у нас будет кодироваться отдельной фичой. Тогда размерность каждого элемента обучающей выборки будет порядка нескольких сотен тысяч.\n- В задаче предсказания кликов по рекламе можно получить выборку любой размерности, например, так: в качестве фичи закодируем индикатор того, что пользователь X побывал на веб-странице Y. Суммарная размерность тогда будет порядка $10^9 \\cdot 10^7 = 10^{16}$. Кроме того, всё время появляются новые пользователи и веб-страницы, так что на этапе применения нас ждут сюрпризы.\n\nЕсть несколько хаков, которые позволяют бороться с такими проблемами:\n\n- Несмотря на то, что полная размерность объекта в выборке огромна, количество ненулевых элементов в нём невелико. Значит, можно использовать разреженное кодирование, то есть вместо плотного вектора хранить словарь, в котором будут перечислены индексы и значения ненулевых элементов вектора.\n- Даже хранить все веса не обязательно! Можно хранить их в хэш-таблице и вычислять индекс по формуле `hash(feature) %  tablesize`. Хэш может вычисляться прямо от слова или id пользователя. Таким образом, несколько фичей будут иметь общий вес, который тем не менее обучится оптимальным образом. Такой подход называется **hashing trick**. Ясно, что сжатие вектора весов приводит к потерям в качестве, но, как правило, ценой совсем небольших потерь можно сжать этот вектор на много порядков.\n\nПримером открытой библиотеки, в которой реализованы эти возможности, является [vowpal wabbit](https://vowpalwabbit.org/).\n\n### Parameter server\n\nЕсли при решении задачи ставки столь высоки, что мы не можем разменивать качество на сжатие вектора весов, а признаков всё-таки очень много, то задачу можно решать распределённо, храня все признаки в шардированной хеш-таблице\n\n![1](https://yastatic.net/s3/education-portal/media/1_23_2a619a4168_e576bac717.webp)\n\nКружки здесь означают отдельные сервера. Жёлтые загружают данные, а серые хранят части модели. Для обучения жёлтый кружок запрашивает у серого нужные ему для предсказания веса, считает градиент и отправляет его обратно, где тот потом применяется. Схема обладает бесконечной масштабируемостью, но задач, где это оправдано, не очень много.\n\n## Подытожим\n\nНа линейную модель можно смотреть как на однослойную нейросеть, поэтому многие методы, которые были изначально разработаны для них, сейчас переиспользуются в задачах глубокого обучения, а базовые подходы к регрессии, классификации и оптимизации вообще выглядят абсолютно так же. Так что несмотря на то, что в целом линейные модели на сегодня применяются редко, то, из чего они состоят и как строятся, знать очень и очень полезно.\n\nНадеемся также, что главным итогом прочтения этого параграфа для вас будет осознание того, что решение любой ML-задачи состоит из выбора функции потерь, параметризованного класса моделей и способа оптимизации. В следующих параграфах мы познакомимся с другими моделями и оптимизаторами, но эти базовые принципы не изменятся.\n\n---\n\nТеперь предлагаем вам потренировать изученный материал на практике. Скачайте [ноутбук](https://yastatic.net/s3/ml-handbook/admin/autohw_linear_models_dabd6b0378.ipynb?updated_at=2024-03-07T13:21:15.517Z) с лабораторной работой. В нём вы найдете описания заданий и дополнительные материалы. Задания из лабораторной прикреплены к этому параграфу в виде задач в системе Яндекс Контест. Чтобы проверить себя, отправляйте решения по соответствующим задачам в систему. Успехов в практике!",
        "handbook": "Учебник по машинному обучению",
        "title": "Линейные модели",
        "description": "Линейные модели от линейной до логистической регрессии. Регуляризация, работа с категориальными признаками, многоклассовая классификация"
    },
    {
        "path": "/handbook/ml/article/metricheskiye-metody",
        "content": "Смысл метрических методов очень хорошо раскрывает фраза «Скажи мне, кто твой друг, и я скажу, кто ты». Алгоритмы этого класса почти не имеют фазы обучения. Вместо этого они просто запоминают всю обучающую выборку, а на этапе предсказания просто ищут объекты, похожие на целевой. \n\nТакой процесс называют **lazy learning**, потому что никакого обучения, по сути, не происходит. Также метрические модели являются непараметрическими, потому что они не делают явных допущений о глобальных законах, которым подчиняются данные. Так, линейная регрессия основывается на предположении о том, что изучаемая закономерность линейная (с неизвестными коэффициентами, которые восстанавливаются по выборке), а линейная бинарная классификация — что существует гиперплоскость, неплохо разделяющая классы. Метрические методы же локальны: они исходят из допущения, что свойства объекта можно узнать, имея представление о его соседях.\n \nУказанные выше свойства могут быть полезными, особенно в случае сложно устроенных данных, для которых мы не можем придумать глобальную модель. Однако с другой стороны, из-за lazy learning алгоритм становится абсолютно неприменимым при большом количестве данных. Несмотря на то, что эти алгоритмы очень просты для понимания, они довольно точны и хорошо интерпретируемы — и часто используются как минимум в качестве бейзлайнов в разных задачах.\n \nВ первой части параграфа мы расскажем об одном из самых известных метрических алгоритмов — методе **k-ближайших соседей** (**k-nearest neighbors, KNN**). Этот подход в основном чисто инженерный из-за отсутствия фазы обучения — в настоящее время уже почти нигде не применяется. Однако многие техники, на которых основан алгоритм, используются и в других методах.\n\nНапример, у алгоритмов поиска ближайших соседей, — неотъемлемой часть метода, — намного более широкая область применения. Плюс ко всему KNN — очень простой и легко интерпретируемый алгоритм, поэтому изучить его всё равно полезно. Мы обсудим подробнее его преимущества, недостатки, область его применения, а также возможные обобщения.\n\nДля метрических методов очень важно уметь эффективно находить ближайшие объекты, поэтому задача их поиска неизбежно возникает при применении любого такого алгоритма. Поэтому во второй части параграфа мы рассмотрим возможные подходы к быстрому поиску ближайших соседей.\n \n \n## Метод k-ближайших соседей (KNN)\n \nПредставим, что мы проводим классификацию объектов на два класса — красный или жёлтый. Нам дана некоторая обучающая выборка и целевой объект (серый):\n \n![2_1_b7525e2dd2.webp](https://yastatic.net/s3/education-portal/media/2_1_b7525e2dd2_5d0a4ba929.webp)\n \nМы хотим определить, к какому классу относится серый объект. Интуитивно очевидно, что он должен быть жёлтым, потому что все его соседи жёлтые. Эта интуиция и отражает суть метода KNN — классифицировать целевой объект, исходя из того, какие классы у объектов, которые максимально похожи на него.\n \nПерейдём теперь к более формальному описанию алгоритма. Рассмотрим сначала задачу многоклассовой классификации, а регрессией займёмся позже.\n \nПусть дана обучающая выборка $X = (x_i, y_i)_{i=1}^N$, где $x_i \\in \\mathbb{X}, \\ y_i \\in \\mathbb{Y}=\\\\{1,\\ldots,C\\\\}$. Пусть также задана некоторая симметричная по своим аргументам функция расстояния $\\color{#E06A27}{\\rho : \\mathbb{X} \\times \\mathbb{X} \\to [0, +\\infty)}$. Предположим, что требуется классифицировать новый объект $\\color{#97C804}{u}$. Для этого найдём $k$ наиболее близких к $\\color{#97C804}{u}$ в смысле расстояния $\\color{#E06A27}{\\rho}$ объектов обучающей выборки $X_k(\\color{#97C804}{u}) = \\\\{\\color{#FFC100}{x^{(1)}_u},\\ldots,\\color{#FFC100}{x^{(k)}_u}\\\\}$:\n\n$$\\forall \\color{#FFC100}{x_{\\rm in}}\\in X_k(\\color{#97C804}{u}) \\ \\forall x_{\\rm out} \\in X \\setminus X_k(\\color{#97C804}{u}) \\quad \\color{#E06A27}{\\rho}(\\color{#97C804}{u}, \\color{#FFC100}{x_{\\rm in}}) \\leqslant \\color{#E06A27}{\\rho}(\\color{#97C804}{u}, x_{\\rm out}). \\tag{1}$$\n \nМетку класса объекта $\\color{#FFC100}{x^{(i)}_u}$ будем обозначать $\\color{#FFC100}{y_u^{(i)}}$. Класс нового объекта тогда естественным образом определим как наиболее часто встречающийся класс среди объектов из $X_k(\\color{#97C804}{u})$:\n \n$$a(\\color{#97C804}{u}) = \\underset{y\\in \\mathbb{Y}}{\\operatorname{arg max}} \\sum_{i=1}^k \\mathbb{I}[\\color{#FFC100}{y_u^{(i)}} = y] \\tag{2}$$\n \nФормула может показаться страшной, но на самом деле всё довольно просто: для каждой метки класса $y \\in \\mathbb{Y}$ количество соседей $\\color{#97C804}{u}$ с такой меткой можно посчитать, просто просуммировав по всем соседям индикаторы событий, соответствующих тому, что метка соседа равна $y$.\n \nЛегко заметить, что этот алгоритм позволяет также оценивать вероятности классов. Для этого достаточно просто посчитать частоты классов соседей:\n \n$$\\mathbb{P}(\\color{#97C804}{u}\\sim y) = \\frac{\\sum_{i=1}^k \\mathbb{I}[\\color{#FFC100}{y_u^{(i)}} = y]}k$$\n \nСтоит, однако, понимать, что, хоть такая функция и удовлетворяет свойствам вероятности (она неотрицательна, аддитивна и ограничена единицей), это не более чем эвристика.\n  \nНесмотря на то что формально фаза обучения отсутствует, алгоритм может легко переобучиться. Вы можете убедиться в этом сами, использовав маленькое количество соседей (например, одного или двух), — границы классов оказываются довольно сложными. Происходит это из-за того, что параметрами алгоритма можно считать всю обучающую выборку, довольно большую по размеру. Из-за этого алгоритму легко подстроиться под конкретные данные.\n\n<p style=\"color:darkslategrey;font-size:14px\">По <a href=\"https://yastatic.net/s3/academy/ml/knn_clf/knn_clf.html\">ссылке</a> вы можете увидеть интерактивный пример работы алгоритма. Автор примера - <a href=\"mailto:Aechirikova@edu.hse.ru\">Анастасия Чирикова.</a></p>\n \n### Выбор метрики\n \nМожет возникнуть закономерный вопрос, как же правильно выбрать функцию расстояния $\\color{#E06A27}{\\rho}$. В подавляющем большинстве случаев обычное евклидово расстояние $\\rho(x, y) = \\sqrt{\\sum_i (x_i - y_i)^2}$ будет хорошим выбором. Однако в некоторых случаях другие функции будут подходить лучше, поэтому давайте разберём ещё несколько функций, наиболее используемых на практике.\n \n![2_2_8440e10f60.webp](https://yastatic.net/s3/education-portal/media/2_2_8440e10f60_6a35a4f1bc.webp)\n \n<br/>\n \n#### Манхэттенская метрика\n \n$$\\rho(x, y) = \\sum_i \\vert x_i - y_i \\vert$$\n \nЧасто используется в высокоразмерных пространствах из-за лучшей устойчивости к выбросам. Представим, что два объекта в 1000-размерном пространстве почти идентичны, но сильно отличаются по одному из признаков. Это почти наверняка свидетельствует о выбросе в этом признаке, и объекты, скорее всего, очень близки. Однако евклидово расстояние усилит различие в единственном признаке и сделает их более далёкими друг от друга. Этого недостатка лишена манхэттенская метрика — в ней вместо квадрата используется модуль. \n \n#### Метрика Минковского\n \n$$\\rho(x, y) = \\left(\\sum_i \\vert x_i - y_i\\vert^p\\right)^{1/p}$$\n \nЯвляется обобщением евклидовой ($p=2$) и манхэттенской ($p=1$) метрик.\n \n#### Косинусное расстояние\n \n$$\\rho(x,y) = 1 - \\cos \\theta = 1 - \\frac{x \\cdot y}{\\|x\\| \\|y\\|}$$\n \nЭта метрика хороша тем, что не зависит от норм векторов. Такое поведение бывает полезно в некоторых задачах, например при поиске похожих документов. В качестве признаков там часто используются количества слов. При этом интуитивно кажется, что если в тексте использовать каждое слово в два раза больше, то тема этого текста поменяться не должна. Поэтому как раз в этом случае нам не важна норма вектор-признака, и в задачах, связанных с текстами, часто применяется именно косинусное расстояние.\n \n#### Расстояние Жаккара\n \n$$\\rho(A, B) = 1 - \\frac{|A\\cap B|}{|A\\cup B|}$$\n \nЕго стоит использовать, если исследуемые объекты — это некоторые множества. Это полезно тем, что нет нужды придумывать векторные представления для этих множеств, чтобы использовать традиционные метрики.\n \nВообще говоря, несмотря на некоторые эвристические соображения по выбору метрики, её можно считать гиперпараметром и подбирать соответствующими способами. Часто качество модели сильно зависит от выбора метрики, а иногда выбрать правильную метрику очень тяжело. Например, в случае когда данные имеют сильно разный масштаб, выбрать подходящую метрику почти невозможно, и нужно сперва проводить нормализацию.\n\n**Замечание**. Упомянутые в этом параграфе функции мы называем «метриками», но, конечно же, они не обязаны быть метриками в строгом математическом смысле. Они неотрицательны и симметричны, но могут не удовлетворять неравенству треугольника.\n \n \n### Обобщения алгоритма\n \n#### Взвешенный KNN\n \nУ оригинального алгоритма есть один большой недостаток: он никак не учитывает расстояния до соседних объектов, хотя эта информация может быть полезной.\n \nДавайте попробуем придумать, как исправить этот недостаток. Нам нужно каким-то образом увеличивать вклад близких объектов и уменьшать вклад далёких. Можно заметить, что все индикаторы в формуле $(2)$ учитываются в сумме с одинаковыми коэффициентами. Возникает идея — назначить этим индикаторам веса, которые тем больше, чем ближе объект к целевому. Таким образом, получаем следующую формулу:\n \n$$a(\\color{#97C804}{u}) = \\underset{y\\in \\mathbb{Y}}{\\operatorname{arg max}} \\sum_{i=1}^k w_i\\mathbb{I}[\\color{#FFC100}{y_u^{(i)}} = y]. \\tag{3}$$\n \nТакой алгоритм называется **взвешенным KNN** (**weighted KNN**).\n \nЕсть множество вариантов выбора весов для объектов, которые можно поделить на две большие группы. В первой группе веса зависят лишь от порядкового номера объекта в отсортированном по близости к $u$ массиве $X_k(\\color{#97C804}{u})$. Чаще всего затухающие веса берутся линейно $\\left( w_i = \\frac{k+1-i}{k} \\right)$ или экспоненциально $\\left( w_i = q^i, \\ 0 < q < 1\\right)$ .\n \nОднако здесь мы также не используем всю информацию, которая нам доступна. Зачем использовать порядок соседей, порождаемый расстояниями, если можно использовать сами расстояния? \n\nВо второй группе методов вес — это некоторая функция от расстояния. Давайте подумаем, какие должны быть свойства у этой функции. \n- Очевидно, она должна быть положительной на своей области определения, иначе модель будет поощрять несовпадение с некоторыми ближайшими соседями. \n- Также необходимо, чтобы функция монотонно не возрастала, чтобы вес близких соседей был больше, чем далёких. \n\nТаким образом вводится так называемая *ядерная функция* (*kernel function*) $K : \\mathbb{R} \\to \\mathbb{R}$, обладающая перечисленными выше свойствами, с помощью которой и высчитывается вес каждого соседа:\n \n$$a(\\color{#97C804}{u}) = \\underset{y\\in \\mathbb{Y}}{\\operatorname{arg max}} \\sum_{i=1}^k K\\left(\\frac{\\color{#E06A27}{\\rho}(\\color{#97C804}{u}, \\color{#FFC100}{x_u^{(i)}})}{h}\\right)\\mathbb{I}[\\color{#FFC100}{y_u^{(i)}} = y], \\tag{4}$$\n \nгде $h$ — некое положительное число, которое называется *шириной окна*.\n \nОт выбора ядра зависит гладкость аппроксимации, но на её качество этот выбор почти не влияет. Примеры ядерных функций в порядке увеличения их гладкости:\n \n- $K(x) = \\frac12 \\mathbb{I} \\left[ \\vert x \\vert \\leqslant 1\\right]$ — прямоугольное ядро;\n- $K(x) = \\left(1 - \\vert x \\vert \\right)\\mathbb{I}\\left[\\vert x \\vert \\leqslant 1\\right]$ — треугольное ядро (непрерывное);\n- $K(x) = \\frac34\\left(1 - x^2\\right) \\mathbb{I}\\left[ \\vert x \\vert \\leqslant 1\\right]$ — ядро Епанечникова (гладкое везде, кроме –1 и 1);\n- $K(x) = \\frac{15}{16}\\left(1 - x^2\\right)^2\\mathbb{I}\\left[\\vert x \\vert \\leqslant 1\\right]$ — биквадратное ядро (гладкое везде);\n- $K(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-2x^2}$ — гауссовское ядро (бесконечно гладкое везде).\n \nНа практике чаще всего используют либо прямоугольное для простоты, либо гауссовское, в случае когда важна гладкость модели (немного забегая вперёд — это особенно важно в регрессии).\n \nШирина окна, в свою очередь, сильно влияет как раз на качество модели. При слишком маленькой ширине модель сильно подстраивается под обучающую выборку и теряет свою обобщающую способность. При слишком большой ширине, напротив, модель становится слишком простой. Универсальной ширины окна не существует, поэтому для каждой задачи её приходится подбирать отдельно.\n\n#### Kernel regression\n \nАлгоритм KNN можно довольно легко обобщить и на задачу регрессии. Самые очевидные способы — брать для некоторого ядра $K$ либо обычное среднее:\n \n$$a(\\color{#97C804}{u}) = \\frac1k \\sum_{i=1}^k \\color{#FFC100}{y_u^{(i)}}, \\tag{5}$$\n \nлибо взвешенный вариант:\n \n$$a(\\color{#97C804}{u}) = \\frac{\\sum_{i=1}^k K\\left(\\frac{\\color{#E06A27}{\\rho}(\\color{#97C804}{u}, \\color{#FFC100}{x_u^{(i)}})}{h}\\right) \\color{#FFC100}{y_u^{(i)}}}{\\sum_{i=1}^k K\\left(\\frac{\\color{#E06A27}{\\rho}(\\color{#97C804}{u}, \\color{#FFC100}{x_u^{(i)}})}{h}\\right)} \\tag{6}$$\n\nПоследняя формула называется *формулой Надарая — Ватсона*. Она — один из непараметрических методов восстановления регрессии, объединённых названием *ядерная регрессия* (*kernel regression*).\n \nВыписать ответ, конечно, просто, но возникает интересный вопрос: можно ли использовать оптимизационные формулы из задачи классификации? Сначала давайте подумаем, что выдаст алгоритм, если формулу $(4)$ применить без изменений. \n\nВ задаче регрессии почти наверняка все значения $y_u^{(i)}$ будут различными. Поэтому для любого $y$ сумма в формуле $(4)$ будет состоять из не более чем одного слагаемого, а значит, максимум будет достигаться на соседе с наибольшим весом, то есть на ближайшем соседе. Это означает, что метод всегда вырождается в 1-NN. Это не совсем то, чего мы добиваемся, поэтому давайте немного модифицируем алгоритм.\n \nДавайте сперва подумаем, а для чего вообще в формуле $(4)$ используется индикатор. В задаче классификации индикатор — естественная мера близости двух объектов: если объекты совпадают, то значение $1$, если различаются, то $0$. Проблема в том, что в задаче регрессии объекты являются действительными числами, и для них функция, которая выдаёт отличное от нуля значение лишь в одной точке $y=y_i$, — плохая мера близости. \n\nВ случае непрерывных значений $y$ естественно использовать более гладкие функции для выражения близости. Таким образом, для обобщения формулы $(4)$ на задачу регрессии нам необходимо всего лишь заменить индикатор на некоторую более гладкую функцию. При этом для действительных чисел чаще всего рассматривают не близость, а расстояние между ними, то есть некоторую метрику. Например, в качестве такой метрики можно взять квадрат евклидова расстояния $(y- y_u^{(i)})^2$. Отметим, что максимизация близости эквивалентна минимизации расстояния, и получим следующую формулу:\n  \n$$a(\\color{#97C804}{u}) = \\underset{y\\in \\mathbb{R}}{\\operatorname{arg min}} \\sum_{i=1}^k K\\left(\\frac{\\color{#E06A27}{\\rho}(\\color{#97C804}{u}, \\color{#FFC100}{x_u^{(i)}})}{h}\\right)(y- \\color{#FFC100}{y_u^{(i)}})^2. \\tag{7}$$\n \nВыбор именно этой функции хорош тем, что у этой оптимизационной задачи есть точное решение, и оно записывается как раз формулой $(6)$.\n \nДля ядерной регрессии справедливы те же рассуждения про выбор ядра и ширины окна, которые были приведены в прошлом разделе про классификацию.\n \nВлияние ширины окна и вида ядра на вид функции:  \n![2_3_b71a476ace.webp](https://yastatic.net/s3/education-portal/media/2_3_b71a476ace_8ba7ceac1d.webp)\n![2_4_1f3e8fb8d7.webp](https://yastatic.net/s3/education-portal/media/2_4_1f3e8fb8d7_4b5dfc48b1.webp)\n![2_5_a94e8cc0dd.webp](https://yastatic.net/s3/education-portal/media/2_5_a94e8cc0dd_1d30dce7e4.webp)\n  \n### Преимущества и недостатки\n \nСперва поговорим о преимуществах алгоритма.\n- Непараметрический, то есть не делает явных предположений о распределении данных.\n- Очень простой в объяснении и интерпретации.\n- Достаточно точный, хоть и чаще всего уступает градиентному бустингу и случайному лесу в accuracy.\n- Может быть использован как для классификации, так и для регрессии.\n \nНесмотря на большие преимущества, алгоритм не лишён и минусов.\n- Неэффективный по памяти, поскольку нужно хранить всю обучающую выборку.\n- Вычислительно дорогой по той же причине.\n- Чувствителен к масштабу данных, а также к неинформативным признакам.\n- Для применения алгоритма необходимо, чтобы метрическая близость объектов совпадала с их семантической близостью, чего не всегда просто добиться. Представим, например, что мы решаем задачу нахождения похожих изображений. Мы хотим, чтобы картинки с лесом находились близко друг к другу, однако, если взять любую попиксельную метрику, такие картинки могут быть очень далеки друг от друга. Зачастую для решения этой проблемы вначале обучают представления.\n\n### Применение\n \nИз-за своих недостатков алгоритм очень неэффективен в задачах с большим количеством данных. Однако у него всё равно есть много применений в реальном мире. Приведём лишь некоторые из них:\n \n- Рекомендательные системы. Если посмотреть на саму формулировку задачи «предложить пользователю что-то похожее на то, что он любит», то KNN прямо напрашивается в качестве решения. Несмотря на то что сейчас часто используются более совершенные алгоритмы, метод ближайших соседей всё равно применяется в качестве хорошего бейзлайна.\n- Поиск семантически похожих документов. Если векторные представления близки друг к другу, то темы документов схожи.\n- Поиск аномалий и выбросов. Из-за того что алгоритм запоминает обучающую выборку полностью, ему легко посмотреть, насколько целевой объект похож на все данные, которые он видел.\n- Задача кредитного скоринга. Рейтинги двух людей, у которых примерно одинаковая зарплата, схожие должности и кредитные истории, не должны сильно отличаться, поэтому KNN отлично подходит для решения такой задачи.\n \nВопрос сложности алгоритма неочевиден и требует детального анализа, который будет частично проведён в следующем разделе.\n\n## Поиск ближайших соседей\n \nДля того чтобы применять метод ближайших соседей, нужно уметь как-то находить этих самых соседей. С первого взгляда может показаться, что никакой проблемы нет: действительно, можно ведь просто перебрать все объекты из обучающей выборки $X = (x_i, y_i)_{i=1}^{N}$, посчитать для каждого из них расстояние до тестового объекта и затем найти минимум.\n\nОднако несмотря на то что сложность такого поиска линейная по $N$, она также зависит и от размерности пространства признаков. Если $x \\in \\mathbb{R}^D$, то сложность такого алгоритма поиска $O(N D)$. Если вспомнить, что в типичной задаче машинного обучения количество признаков $D$ может быть порядка $100$, а размер выборки и вовсе может исчисляться десятками и сотнями тысяч объектов, то становится ясно, что такая сложность никуда не годится. Проблема осложняется ещё и тем, что данный поиск необходимо выполнять на этапе применения модели, который должен быть быстрым. Всё это означает, что возникает необходимость в более быстрых методах поиска ближайших соседей, чем простой перебор.\n \nВсе такие методы можно поделить на две основные группы: точные и приближённые. Последние, как следует из их названия, находят соседей лишь приближённо, то есть найденные объекты хоть и будут действительно близки, но не обязательно будут самыми близкими. В этом разделе мы подробнее рассмотрим методы из каждой группы. \n \nПеред началом обзора стоит сказать, что хоть мы и рассматриваем алгоритмы поиска соседей именно в контексте их использования в KNN, область их применения значительно шире, и она не ограничивается исключительно машинным обучением. Например, на их основе работает любая информационно-поисковая система, от поиска в «Гугле» или «Яндексе» до всем известных алгоритмов «Ютьюба». \n\n## Поиск ближайших соседей: точные методы\n \nТочных методов существует довольно мало. Можно сказать, что их, по сути, два. \n- Первый — полный перебор с различными эвристиками. Например, можно выбрать подмножество признаков и считать расстояние только по ним. Оно будет оценкой снизу на реальное расстояние, поэтому если оно уже больше, чем до текущего ближайшего объекта, то можно сразу отбросить этот объект и переходить к следующему. Такие эвристики хоть и могут давать некоторый выигрыш по времени, но не улучшат асимптотическую сложность. \n- Второй — k-d-деревья, о которых стоит поговорить подробнее.\n\n### K-d-деревья\n \nПредставим на секунду, что у нас есть всего лишь один признак, то есть объекты выражаются вещественными числами, а не векторами. В этом случае для поиска ближайшего соседа напрашивается всем вам известное бинарное дерево поиска, которое позволяет находить элементы за логарифмическое время. Оказывается, существует аналог данной структуры в многомерном пространстве, который называется **k-d-дерево** (**k-d tree**, сокращение от k-dimensional tree).\n \nКак и в обычном дереве поиска, в k-d-дереве каждый узел является объектом обучающей выборки, который особым образом делит пространство на два полупространства. Таким образом, всё пространство оказывается поделено на множество малых областей, и такое деление оказывается очень полезным при поиске ближайших соседей.\n \nРассмотрим подробнее, как строится такое дерево. Трудность в применении обычного дерева поиска состоит в том, что мы не можем напрямую сравнить два вектора так же, как два вещественных числа. Чтобы эту проблему преодолеть, узлы дерева будут делить пространство лишь по одной оси. При движении вниз по дереву оси, по которым точки делят пространство, циклически сменяют друг друга. Например, в двумерном пространстве корень будет отвечать за деление по x-координате, его сыновья — за деление по y-координате, а внуки — снова за x-координату, и т. д. Посмотрим, как это работает на примере:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_6_e762398494_7d10925856.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf\">Источник</a>\n  </figcaption>\n</figure>\n \nНа картинке выше корень $(30, 40)$ делит все точки по оси х: слева оказываются точки, у которых $x < 30$, а справа — те, у которых $x\\geqslant 30$. Аналогично левый сын корня $(5, 25)$ делит своё поддерево по оси y: слева оказываются точки, у которых $y < 25$, а справа — те, у которых $y\\geqslant 25$.\n \nОстаётся вопрос — как выбирать точки, которые будут делить пространство пополам? Чтобы дерево было сбалансированным, нужно находить точку с медианой, соответствующей уровню поддерева координаты. На практике часто ограничиваются выбором случайной точки или любой эвристикой по приближённому поиску медианы (например, медиана некоторого подмножества точек). Это позволяет ускорить построение дерева, но убирает все гарантии на его сбалансированность.\n \nДобавлять новые точки можно так же, как и в одномерном дереве поиска. Спускаясь по дереву, можно однозначно определить лист, к которому нужно подвесить новую точку, чтобы не нарушить все свойства дерева. При добавлении большого количества точек, однако, дерево может перестать быть сбалансированным, и нужно проводить ребалансировку. Также существуют варианты k-d-деревьев, которые сохраняют сбалансированность при добавлении / удалении точек.\n \nПоговорим теперь про то, как же находить ближайших соседей с помощью такого дерева. Будем производить обход дерева в глубину с двумя модификациями. \n- Во-первых, будем запоминать наиболее близкую точку. Это позволит не заходить в поддеревья, задающие области, которые заведомо дальше, чем текущая наиболее близкая точка, поэтому не имеет смысла искать в них ближайших соседей. \n- Во-вторых, будем прежде всего обходить те поддеревья, которые задают наиболее близкие области, а значит, с большей вероятностью содержат ближайшего соседа.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_7_2f24c2823e_0c7218aef4.gif\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://commons.wikimedia.org/\">Источник</a>\n  </figcaption>\n</figure>\n \nСложность метода по размеру обучающей выборки в среднем равна $O(\\log N)$ при равномерном распределении точек. При большой размерности пространства, однако, алгоритму приходится посещать больше ветвей дерева, чтобы найти ближайших соседей. Например, если $N \\approx D$, то сложность становится примерно такой же, как и в случае полного перебора. В общем случае считается, что для того чтобы асимптотика действительно была логарифмической, нужно, чтобы $N \\gtrsim 2^D$. Поэтому уже при количестве признаков порядка сотни алгоритм не даёт существенных преимуществ перед полным перебором.\n  \nПочитать по теме:  \n \n- [Хорошая презентация](https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf), объясняющая структуру и поиск соседей.\n- [Балансировка деревьев](https://en.wikipedia.org/wiki/K-d_tree#Balancing).\n\n## Поиск ближайших соседей: приближённые методы\n \nПочти всегда находить именно самых близких соседей необязательно. Например, в задаче подбора рекомендаций фильмов пользователю чаще всего не нужны наиболее похожие картины, достаточно, к примеру, 10 из 15 наиболее близких. Поэтому, чтобы ускорить процесс поиска соседей, используют приближённые методы. Разберём основные идеи, которые применяются в таких методах.\n\n### Random projection trees\n \nАлгоритмы, основанные на деревьях, очень часто применяются в задачах поиска соседей. Идея всех таких методов заключается в итеративном разделении пространства случайными гиперплоскостями и построении на базе этого разделения дерева, в листах которого содержится малое число объектов.\n  \nОдним из наиболее ярких представителей этого семейства является **Annoy** — алгоритм, который используется Spotify для рекомендаций музыки. Задача подобных рекомендательных систем довольно простая — нужно посоветовать пользователю композиции, которые он ещё не слушал, но которые при этом с высокой вероятностью ему понравятся. Простая и рабочая идея — предлагать композиции, похожие на те, которые он уже слушает. Здесь на помощь как раз и приходят методы поиска ближайших соседей.\n \nAnnoy в какой-то степени похож на k-d-деревья. Сначала выбираются два случайных объекта обучающей выборки и проводится гиперплоскость, симметрично их разделяющая. Затем для каждого полученного полупространства итеративно запускается такая же процедура, которая продолжается до тех пор, пока в каждой области будет не более $M$ объектов ($M$ — гиперпараметр).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_8_b3d0c30be0_effe148382.gif\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://erikbern.com/2015/10/01/nearest-neighbors-and-vector-models-part-2-how-to-search-in-high-dimensional-spaces.html\">Источник</a>\n  </figcaption>\n</figure>\n \nТаким образом задаётся бинарное дерево с глубиной порядка $O(\\log N)$ в среднем.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_9_4597f51b7a_904febbc64.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://erikbern.com/2015/10/01/nearest-neighbors-and-vector-models-part-2-how-to-search-in-high-dimensional-spaces.html\">Источник</a>\n  </figcaption>\n</figure>\n \nСпускаясь по этому дереву, можно найти область, в которой лежит целевой объект и некоторое количество близких к нему элементов обучающей выборки. Проблема в том, что это не обязательно будут самые близкие объекты, поэтому для увеличения точности составляется лес из таких деревьев и берётся объединение соответствующих целевому объекту областей.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_10_f78d4d0f93_507b116847.gif\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://erikbern.com/2015/10/01/nearest-neighbors-and-vector-models-part-2-how-to-search-in-high-dimensional-spaces.html\">Источник</a>\n  </figcaption>\n</figure>\n \nЧем больше таких деревьев берётся, тем более точным будет результат, но придётся тратить большее время на его поиск.\n \nПреимущество алгоритма — простота нахождения компромисса между скоростью работы и точностью с помощью тюнинга гиперпараметров. К минусам можно отнести то, что алгоритм плохо параллелится и переносится на GPU, не работает эффективно с батчами, а также то, что для добавления новой точки в обучающую выборку придётся перезапускать процедуру с самого начала.\n\nПочитать по теме:\n \n- [Отличная статья](https://erikbern.com/2015/10/01/nearest-neighbors-and-vector-models-part-2-how-to-search-in-high-dimensional-spaces.html) с иллюстрациями и подробным описанием алгоритма.\n\n### Locality-sensitive hashing (LSH)\n \nПредположим, что мы можем построить такую хеш-функцию, которая переводит близкие объекты в один бакет. Тогда близких соседей целевого объекта можно найти, посчитав его хеш и посмотрев на коллизии. Оказывается, такие хеш-функции существуют, и на этой идее основано несколько алгоритмов, которые объединяются названием **Locality-sensitive hashing** (**LSH**). К этому классу алгоритмов относится, например, *FAISS*, используемый Facebook.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_11_f49c854d34_1d90f2d70c.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://brc7.github.io/2019/09/19/Visual-LSH.html\">Источник</a>\n  </figcaption>\n</figure>\n \nОпределим формально семейство хеш-функций, которое мы хотим использовать. Нам нужно, чтобы вероятность коллизии на близких объектах была высокая, а на далёких — низкая. Назовём семейство хеш-функций $\\mathcal{H}$ $(R, cR, p_1, p_2)$-чувствительным, если для любой $h(x)\\in\\mathcal{H}$:\n \n- для $\\rho(x, y) < R$ вероятность коллизии $\\Pr\\left[h(x)=h(y)\\right] > p_1$;\n- для $\\rho(x, y) > cR$ вероятность коллизии $\\Pr\\left[h(x)=h(y)\\right] < p_2$.\n \nФормулы могут выглядеть сложными, но это всего лишь формализация нашей интуиции. Картинка ниже поясняет определение: для близких красных объектов в шаре радиусом $R$ вероятность коллизии больше $p_1$, для далёких синих объектов на расстоянии больше $cR$ вероятность коллизии меньше $p_2$, а про серые объекты в слое между $R$ и $cR$ мы ничего не знаем.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_12_534a4903df_dc87df5f0f.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://brc7.github.io/2019/09/19/Visual-LSH.html\">Источник</a>\n  </figcaption>\n</figure>\n \nДля каждой функции расстояния, используемой в задаче, существует своё подходящее семейство хеш-функций. Например, для евклидовой и манхэттенской метрик используются *случайные проекции*, где хеш-функция имеет следующий вид:\n \n$$ h_{\\boldsymbol{w}, b}(\\boldsymbol{x}) = \\left\\lfloor \\frac{\\boldsymbol{w}^T\\boldsymbol{x} + b}{r}\\right\\rfloor, $$\n\nгде $\\boldsymbol{w}$ и $b$ — случайные параметры, а $r$ выбирается пользователем. $b$ выбирается равномерно из отрезка $[0, r]$, а $\\boldsymbol{w}$ генерируется либо из нормального распределения, что соответствует евклидовой метрике, либо из распределения Коши — для манхэттенской метрики.\n \nПо сути, такая функция разбивает всё пространство на слои в направлении вектора $\\boldsymbol{w}$. Параметр $r$ при этом задаёт ширину слоя.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/2_13_d8675103b9_df1b8e3563.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://brc7.github.io/2019/09/19/Visual-LSH.html\">Источник</a>\n  </figcaption>\n</figure>\n \nНа практике при использовании лишь одной хеш-функции разница между $p_1$ и $p_2$ оказывается очень маленькой, поэтому применяют различные методы для её увеличения. \n- Первый способ — уменьшать размер бакетов в хеш-таблице путём использования композиции разных хеш-функций из одного семейства $g(x) = (h_1(x),\\ldots,h_m(x))$. Преимущество этого способа как раз хорошо видно на примере случайных проекций. При использовании лишь одной хеш-функции бакетами являются слои бесконечного объёма. Однако при использовании композиции размером, как минимум равным количеству признаков $D$, из-за случайности выбора вектора $\\boldsymbol{w}$ бакеты почти наверное станут замкнутыми фигурами с конечным объёмом.\n- Второй способ повышения эффективности алгоритма — использовать несколько хеш-таблиц и искать соседей среди коллизий в каждой из них. На практике используют оба метода сразу, подбирая $m$ и $L$ — количество хеш-таблиц как гиперпараметры.\n \nК плюсам алгоритма можно отнести хорошие теоретические гарантии на сублинейное время и, как и в Annoy, простой поиск компромисса между точностью и скоростью работы. Минусами можно назвать высокую потребность в памяти, плохую адаптируемость под GPU, а также тот факт, что, несмотря на теоретические гарантии в среднем, на практике алгоритм может работать даже чуть дольше полного перебора из-за того, что, помимо самого поиска, требуется искать хеши объектов.\n\nПочитать по теме:\n \n- [Отличная статья](https://randorithms.com/2019/09/19/Visual-LSH.html) с объяснением в иллюстрациях и примерами хеш-функций для других метрик.\n- [Ещё одна статья](https://towardsdatascience.com/understanding-locality-sensitive-hashing-49f6d1f6134), в которой шаг за шагом выводится алгоритм на примере расстояния Жаккара.\n \n \n### Proximity graphs & Hierarchical navigable small world (HNSW)\n \nСледующий класс алгоритмов основан на построении специального **графа близости** (**proximity graph**) на объектах выборки и дальнейшем жадном поиске по этому графу. Алгоритмы этого семейства сейчас считаются state-of-the-art (SotA) для многих задач.\n \nРассмотрим подробнее этот класс алгоритмов на примере одного из наиболее популярных из них под названием **Navigable small world (NSW)**. Идея его в следующем: на данных строится граф (он также называется NSW), который удовлетворяет двум следующим свойствам:\n \n1. Между любыми двумя точками существует короткий путь, или, более формально, матожидание числа кратчайшего пути между двумя случайно выбранными вершинами растёт как $O(\\log N)$.\n2. Средняя степень вершины мала.\n \nНа первый взгляд может показаться, что тяжело выполнить одновременно оба свойства, но на самом деле большая часть графов в реальном мире являются NSW-графами. Самый простой пример — это известное правило шести рукопожатий: любые два случайных человека соединены короткой последовательностью личных контактов длиной не более шести, несмотря на то, что количество знакомых у среднего человека ($100$–$1000$) мало по сравнению с населением Земли.\n \nВ таких графах существует очень простой метод поиска соседей. Нужно выбрать случайную точку, среди её соседей выбрать того, который ближе всего к целевому объекту, и повторить процедуру уже для него. Показано, что такой жадный поиск имеет полилогарифмическую асимптотику.\n \n<figure>\n <img src=\"https://yastatic.net/s3/education-portal/media/2_14_cd25cae35d_694f7dd8db.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://opendistro.github.io/for-elasticsearch/blog/odfe-updates/2020/04/Building-k-Nearest-Neighbor-%28k-NN%29-Similarity-Search-Engine-with-Elasticsearch/\">Источник</a>\n  </figcaption>\n</figure>\n\n \nПроблема такого подхода в том, что можно попасть в плотный кластер и очень долго оттуда выбираться. Для решения этой проблемы используется иерархия NSW, или *Hierarchical navigable small world (HNSW)*. Исходный граф является нулевым слоем. Каждый следующий слой строится в два шага:\n \n1. Каждая вершина текущего слоя попадает в следующий с некоторой вероятностью $p$.\n2. На всех вершинах, попавших в новый слой, строится NSW.\n \nПо построению количество слоёв будет $O(\\log N)$.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/hnsw_layers_5571069c2e_a7a4d44708.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1603.09320\">Источник</a>\n  </figcaption>\n</figure>\n \nПоиск начинается в самом верхнем слое. После нахождения ближайшей к целевому объекту вершины спускаемся на слой ниже и начинаем поиск из этой вершины. Повторяем процедуру, пока не спустимся до нулевого слоя. Таким образом, на каждом слое мы всё больше уточняем наш ответ. Стоит отметить, что для ускорения работы иногда поиск останавливают не при нахождении ближайшей вершины, а раньше, используя критерии остановки.\n \nИнтуитивно легко понять, почему такая иерархическая структура решает проблему плотных кластеров: в верхних слоях вершин мало, а расстояния между ними в среднем большие, а значит, таких кластеров там почти нет. Поэтому, попадая в нижний слой, мы чаще всего оказываемся уже в нужном кластере и просто уточняем результат работы алгоритма.\n \nHNSW, так же как и рассмотренные ранее приближённые методы, позволяет искать трейд-офф между точностью и скоростью работы. Плюс ко всему на реальных данных он часто работает лучше других методов и сейчас считается SotA. Однако этот способ поиска не лишён и недостатков. Главный заключается в том, что нельзя добавлять точки в обучающую выборку без перестройки структуры. Помимо этого, он довольно требователен по памяти из-за того, что для каждого слоя приходится хранить как вершины, которые в него входят, так и связи между этими вершинами.\n \nПодробнее — в [оригинальной статье](https://arxiv.org/abs/1603.09320).  \n \nВ завершение стоит сказать, что не существует универсального метода поиска соседей — каждый из описанных методов может быть лучше других в определённой задаче. К тому же, несмотря на то что приближённые методы имеют лучшую асимптотику, многие из них плохо переносятся на GPU. Из-за этого на практике полный перебор бывает быстрее любого из таких приближённых методов.",
        "handbook": "Учебник по машинному обучению",
        "title": "Метрические методы",
        "description": "Алгоритмы KNN. Быстрый поиск ближайших соседей"
    },
    {
        "path": "/handbook/ml/article/reshayushchiye-derevya",
        "content": "В этом параграфе мы рассмотрим ещё одно семейство моделей машинного обучения — **решающие деревья (decision trees)**.\n\nРешающее дерево предсказывает значение целевой переменной с помощью применения последовательности простых решающих правил (которые называются предикатами). Этот процесс в некотором смысле согласуется с естественным для человека процессом принятия решений.\n\nХотя обобщающая способность решающих деревьев невысока, их предсказания вычисляются довольно просто, из-за чего решающие деревья часто используют как кирпичики для построения [ансамблей](https://academy.yandex.ru/handbook/ml/article/ansambli-v-mashinnom-obuchenii) — моделей, делающих предсказания на основе агрегации предсказаний других моделей. О них мы поговорим в следующем параграфе.\n\n### Пример решающего дерева\n\nНачнём с небольшого примера. На картинке ниже изображено дерево, построенное для задачи классификации на пять классов:\n\n![3](https://yastatic.net/s3/education-portal/media/3_1_c0e800569a_0dd86f2ea8.webp)\n\nОбъекты в этом примере имеют два признака с вещественными значениями: $X$ и $Y$. Решение о том, к какому классу будет отнесён текущий объект выборки, будет приниматься с помощью прохода от корня дерева к некоторому листу.\n\nВ каждом узле этого дерева находится предикат. Если предикат верен для текущего примера из выборки, мы переходим в правого потомка, если нет — в левого. В данном примере все предикаты — это просто взятие порога по значению какого-то признака:\n\n$$    B(x, j, t) = [ x_j \\le t ] \n$$\n\nВ листьях записаны предсказания (например, метки классов). Как только мы дошли до листа, мы присваиваем объекту ответ, записанный в вершине.\n\nНа картинке ниже визуализирован процесс построения решающих поверхностей, порождаемых деревом (правая часть картинки):\n\n![3](https://yastatic.net/s3/education-portal/media/3_2_41c1793bef_fda82166a3.webp)\n\nКаждый предикат порождает разделение текущего подмножества пространства признаков на две части. На первом этапе, когда происходило деление по $[ X \\le X_1 ]$, вся плоскость была поделена на две соответствующие части. На следующем уровне часть плоскости, для которой выполняется $X \\le X_1$, была поделена на две части по значению второго признака $Y \\le Y_1$ — так образовались области 1 и 2. То же самое повторяется для правой части дерева — и так далее до листовых вершин: получится пять областей на плоскости. Теперь любому объекту выборки будет присваиваться один из пяти классов в зависимости от того, в какую из образовавшихся областей он попадает.\n\nЭтот пример хорошо демонстрирует, в частности, то, что дерево осуществляет кусочно-постоянную аппроксимацию целевой зависимости. Ниже приведён пример визуализации решающей поверхности, которая соответствует дереву глубины 4, построенному для объектов данных из [Ames Housing Dataset](https://www.openml.org/d/41211), где из всех признаков, описывающих объекты недвижимости, были выбраны ширина фасада (`Lot_Frontage`) и площадь (`Lot_Area`), а предсказать нужно стоимость.\n\nДля более понятной визуализации перед построением дерева из датасета были выкинуты объекты с `Lot_Frontage > 150` и с `Lot_Area > 20000`. Вот что получилось — в каждой из прямоугольных областей предсказывается одна и та же стоимость:\n\n![3](https://yastatic.net/s3/education-portal/media/3_3_64f47eb4c8_29f1b64e0b.webp)\n\nВ каждой из прямоугольных областей предсказывается одна и та же стоимость.\n\n## Определение решающего дерева\n\nРазобравшись с приведёнными выше примерами, мы можем дать определение решающего дерева. Пусть задано бинарное дерево, в котором:\n\n* каждой внутренней вершине $v$ приписан предикат $B_v: \\mathbb{X} \\to \\{ 0, 1 \\}$;\n* каждой листовой вершине $v$ приписан прогноз $c_v \\in \\mathbb{Y}$, где $\\mathbb{Y}$ — область значений целевой переменной (в случае классификации листу может быть также приписан вектор вероятностей классов).\n\nВ ходе предсказания осуществляется проход по этому дереву к некоторому листу. Для каждого объекта выборки $x$ движение начинается из корня. В очередной внутренней вершине $v$ проход продолжится вправо, если $B_v(x) = 1$, и влево, если $B_v(x) = 0$. Проход продолжается до момента, пока не будет достигнут некоторый лист, и ответом алгоритма на объекте $x$ считается прогноз $c_v$, приписанный этому листу.\n\nВообще, предикат $B_v$ может иметь, произвольную структуру, но на практике чаще используют просто сравнение с порогом $t \\in \\mathbb{R}$ по какому-то $j$-му признаку:\n\n$$    B_v(x, j, t) = [ x_j \\le t ] \n$$\n\nПри проходе через узел дерева с данным предикатом объекты будут отправлены в правое поддерево, если значение $j$-го признака у них меньше либо равно $t$, и в левое — если больше. В дальнейшем рассказе мы будем по умолчанию использовать именно такие предикаты.\n\nИз структуры дерева решений следует несколько интересных свойств:\n\n* выученная функция — кусочно-постоянная, из-за чего производная равна нулю везде, где задана. Следовательно, о градиентных методах при поиске оптимального решения можно забыть;\n* дерево решений (в отличие от, например, линейной модели) не сможет экстраполировать зависимости за границы области значений обучающей выборки;\n* дерево решений способно идеально приблизить обучающую выборку и ничего не выучить (то есть такой классификатор будет обладать низкой обобщающей способностью): для этого достаточно построить такое дерево, в каждый лист которого будет попадать только один объект. Следовательно, при обучении нам надо не просто приближать обучающую выборку как можно лучше, но и стремиться оставлять дерево как можно более простым, чтобы результат обладал хорошей обобщающей способностью.\n\n{% cut \"Под катом — несколько иллюстраций для закрепления\" %}\n\nСгенерируем для начала небольшой синтетический датасет для задачи классификации и обучим на нём решающее дерево, не ограничивая его потенциальную высоту.\n\n![3](https://yastatic.net/s3/education-portal/media/3_5_74f1de3be9_47d76b6fce.webp)\n\nВыученная закономерность очень сложная: иногда она выделяет прямоугольником одну точку. И действительно, как мы увидим дальше, деревья умеют идеально подстраиваться под обучающую выборку. Это чемпионы переобучения. Помешать этому может лишь ограничение на высоту дерева. Вот как будет выглядеть дерево высоты 3, построенное на том же датасете:\n\n![3](https://yastatic.net/s3/education-portal/media/3_4_aa20f33d21_69007b9474.webp)\n\nНе всё идеально, но классификатор уже не такой безумный. Теперь обратимся к задаче регрессии. Обучим решающее дерево, не ограничивая его высоту.\n\n![3](https://yastatic.net/s3/education-portal/media/3_6_d1cba63f26_bcb1e57992.webp)\n\nФиолетовая ступенчатая пунктирная линия — это восстановленная деревом зависимость. На графике она мечется между точками, идеально следуя за обучающей выборкой. Кроме того (и это не лечится ограничением глубины дерева) за пределами обучающей выборки дерево делает константные предсказания. Это и имеют в виду, когда говорят, что древесные модели неспособны к экстраполяции.\n\n{% endcut %}\n\n## Почему построение оптимального решающего дерева — сложная задача?\n\nПусть, как обычно, у нас задан датасет $(X, y)$, где $y=\\{y_i\\}_{i=1}^N \\subset \\mathbb{R}^N$ — вектор таргетов, а $X=\\{x_i\\}_{i = 1}^N \\in \\mathbb{R}^{N \\times D}, x_i \\in \\mathbb{R}^D$ — матрица признаков, в которой $i$-я строка — это вектор признаков $i$-го объекта выборки. Пусть у нас также задана функция потерь $L(f, X, y)$, которую мы бы хотели минимизировать.\n\nНаша задача — построить решающее дерево, наилучшим образом предсказывающее целевую зависимость. Однако, как уже было замечено выше, оптимизировать структуру дерева с помощью градиентного спуска не представляется возможным. Как ещё можно было бы решить эту задачу? Давайте начнём с простого — научимся строить **решающие пни**, то есть решающие деревья глубины 1.\n\nКак и раньше, мы будем рассматривать только самые простые предикаты:\n\n$$    B_{j, t}(x_i) = [ x_{ij} \\le t ] \n$$\n\nЯсно, что задачу можно решить полным перебором: существует не более $(N - 1) D$ предикатов такого вида. Действительно, индекс $j$ (номер признака) пробегает значения от $1$ до $D$, а всего значений порога $t$, при которых меняется значение предиката, может быть не более $N - 1$:\n\n![3](https://yastatic.net/s3/education-portal/media/3_7_f51986c1ae_056137fc2e.webp)\n\nРешение, которое мы ищем, будет иметь вид:\n\n$$    (j_{opt}, t_{opt}) = \\arg \\min_{j, t} L(B_{j, t}, X, y)\n$$\n\nДля каждого из предикатов $B_{j, t}$ нам нужно посчитать значение функции потерь на всей выборке, что, в свою очередь, тоже занимает $O(N)$.\nСледовательно, полный алгоритм выглядит так:\n\n```python\nmin_loss = inf\noptimal_border = None\n\nfor j in range(D):\n    for t in X[:, j]:     # Можно брать сами значения признаков в качестве порогов\n        loss = calculate_loss(t, j, X, y)\n        if loss < min_loss:\n           min_loss, optimal_border = loss, (j, t)\n```\n\nСложность алгоритма — $O(N^2 D)$. Это не заоблачная сложность, хотя, конечно, не идеальная. Но это была схема возможного алгоритма поиска оптимального дерева высоты 1.\n\nКак обобщить алгоритм для дерева произвольной глубины? Мы можем сделать наш алгоритм поиска решающего пня рекурсивным и в теле цикла вызывать исходную функцию для всех возможных разбиений. Как мы упоминали выше, так можно построить дерево, идеально запоминающее всю выборку, однако на тестовых данных такой алгоритм вряд ли покажет высокое качество.\n\nМожно поставить другую задачу: построить оптимальное с точки зрения качества на обучающей выборке дерево минимальной глубины (чтобы снизить переобучение). Проблема в том, что поиск такого дерева — [NP-полная](https://people.csail.mit.edu/rivest/pubs/HR76.pdf) задача, то есть человечеству пока неизвестны способы решить её за полиномиальное время. Как быть?\n\nИдеального ответа на этот вопрос нет, но до некоторой степени ситуацию можно улучшить двумя не исключающими друг друга способами:\n\n1. Разрешить себе искать не оптимальное решение, а просто достаточно хорошее. Начать можно с того, чтобы строить дерево с помощью *жадного алгоритма*, то есть не искать всю структуру сразу, а строить дерево этаж за этажом. Тогда в каждой внутренней вершине дерева будет решаться задача, схожая с задачей построения решающего пня. Для того чтобы этот подход хоть как-то работал, его придётся прокачать внушительным набором эвристик.\n2. Заняться оптимизацией с точки зрения computer science — наивную версию алгоритма (перебор наборов возможных предикатов и порогов) можно ускорить и асимптотически, и в константу раз.\n\nЭти две идеи мы и будем обсуждать в дальнейшем. Сначала попытаемся подробно разобраться с первой — как использовать жадный алгоритм.\n\n## Жадный алгоритм построения решающего дерева\n\nПусть $X$ — исходное множество объектов обучающей выборки, а $X_m$ — множество объектов, попавших в текущий лист (в самом начале $X_m = X$). Тогда жадный алгоритм можно верхнеуровнево описать следующим образом:\n\n1. Создаём вершину $v$.\n2. Если выполнен *критерий остановки* $Stop(X_m)$, то останавливаемся, объявляем эту вершину листом и ставим ей в соответствие ответ $Ans(X_m)$, после чего возвращаем её.\n3. Иначе: находим предикат (иногда ещё говорят *сплит*) $B_{j, t}$, который определит наилучшее разбиение текущего множества объектов $X_m$ на две подвыборки $X_{\\ell}$ и $X_r$, максимизируя *критерий ветвления* $Branch(X_m, j, t)$.\n4. Для $X_\\ell$ и $X_r$ рекурсивно повторим процедуру.\n\nДанный алгоритм содержит в себе несколько вспомогательных функций, которые надо выбрать так, чтобы итоговое дерево было способно минимизировать $L$:\n$Ans(X_m)$, вычисляющая ответ для листа по попавшим в него объектам из обучающей выборки, может быть, например:\n\n* в случае задачи классификации — меткой самого частого класса или оценкой дискретного распределения вероятностей классов для объектов, попавших в этот лист;\n* в случае задачи регрессии — средним, медианой или другой статистикой;\n* простой моделью. К примеру, листы в дереве, задающем регрессию, могут быть линейными функциями или синусоидами, обученными на данных, попавших в лист. Впрочем, везде ниже мы будем предполагать, что в каждом листе просто предсказывается константа.\n\nКритерий остановки $Stop(X_m)$ — функция, которая решает, нужно ли продолжать ветвление или пора остановиться. Это может быть какое-то тривиальное правило: например, остановиться только в тот момент, когда объекты в листе получились достаточно однородными и/или их не слишком много. Более детально мы поговорим о критериях остановки в параграфе про регуляризацию деревьев.\n\nКритерий ветвления $Branch(X_m, feature, value)$ — пожалуй, самая интересная компонента алгоритма. Это функция, измеряющая, насколько хорош предлагаемый сплит. Чаще всего эта функция оценивает, насколько улучшится некоторая финальная метрика качества дерева в случае, если получившиеся два листа будут терминальными, по сравнению с ситуацией, когда сама исходная вершина — это лист. Выбирается такой сплит, который даёт наиболее существенное улучшение.\n\nВпрочем, есть и другие подходы. При этом строгой теории, которая бы связывала оптимальность выбора разных вариантов этих функций и разных метрик классификации и регрессии, в общем случае не существует. Однако есть набор интуитивных и хорошо себя зарекомендовавших соображений, с которыми мы вас сейчас познакомим.\n\n### Критерии ветвления: общая идея\n\nДавайте теперь по очереди посмотрим на популярные постановки задач ML и под каждую подберём свой критерий.\n\nОтветы дерева будем кодировать так: $c \\in \\mathbb{R}$ — для ответов регрессии и меток класса. Для случаев, когда надо ответить дискретным распределением на классах, $c \\in \\mathbb{R}^K$ будет вектором вероятностей:\n\n$$c = (c_1, \\ldots, c_K), \\quad \\sum_{i = 1}^K c_i = 1 \n$$\n\nПредположим также, что задана некоторая функция потерь $L(y_i, c)$. О том, что это может быть за функция, мы поговорим ниже.\n\nВ момент, когда мы ищем оптимальный сплит $X_m = X_l\\sqcup X_r$, мы можем вычислить для объектов из $X_m$ тот константный таргет $c$, которые предсказало бы дерево, будь текущая вершина терминальной, и связанное с ними значение исходного функционала качества $L$. А именно — константа $c$ должна минимизировать среднее значение функции потерь:\n\n$$    \\frac{1}{\\vert X_m\\vert}\\sum\\limits_{(x_i, y_i) \\in X_m} L(y_i, c)\n$$\n\nОптимальное значение этой величины\n\n$$    H(X_m) = \\min\\limits_{c \\in Y} \\frac{1}{\\vert X_m\\vert}\\sum\\limits_{(x_i, y_i) \\in X_m} L(y_i, c)\n$$\n\nобычно называют **информативностью**, или **impurity**. Чем она ниже, тем лучше объекты в листе можно приблизить константным значением.\n\nПохожим образом можно определить информативность решающего пня. Пусть, как и выше, $X_l$ — множество объектов, попавших в левую вершину, а $X_r$ — в правую; пусть также $c_l$ и $c_r$ — константы, которые предсказываются в этих вершинах. Тогда функция потерь для всего пня в целом будет равна\n\n$$    \\frac1{|X_m|}\\left(\\sum_{x_i\\in X_l}L(y_i, c_l) + \\sum_{x_i\\in X_r}L(y_i, c_r)\\right)\n$$\n\n**Вопрос на подумать**. Как информативность решающего пня связана с информативностью его двух листьев?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nПреобразуем выражение:\n\n$$\\frac1{|X_m|}\\left(\\sum_{x_i\\in X_l}L(y_i, c_l) + \\sum_{x_i\\in X_r}L(y_i, c_r)\\right) =\n$$\n\n$$= \\frac1{|X_m|}\\left(|X_l|\\cdot\\frac{1}{|X_l|}\\sum_{x_i\\in X_l}L(y_i, c_l) + |X_r|\\cdot\\frac1{|X_r|}\\sum_{x_i\\in X_r}L(y_i, c_r)\\right)\n$$\n\nЭта сумма будет минимальна при оптимальном выборе констант $c_l$ и $c_r$, и информативность пня будет равна\n\n$$\\frac{|X_l|}{|X_m|}H(X_l) + \\frac{|X_r|}{|X_m|}H(X_r)\n$$\n\n{% endcut %}\n\nТеперь для того чтобы принять решение о разделении, мы можем сравнить значение информативности для исходного листа и для получившегося после разделения решающего пня.\n\nРазность информативности исходной вершины и решающего пня равна\n\n$$H(X_m) - \\frac{|X_l|}{|X_m|}H(X_l) - \\frac{|X_r|}{|X_m|}H(X_r)\n$$\n\nДля симметрии её принято умножить на $\\vert X_m\\vert$; тогда получится следующий критерий ветвления:\n\n$$\\color{#348FEA}{Branch (X_m, j, t) = |X_m| \\cdot H(X_m) -  |X_l| \\cdot H(X_l) -  |X_r| \\cdot H(X_r)}\n$$\n\nПолучившаяся величина неотрицательна: ведь, разделив объекты на две кучки и подобрав ответ для каждой, мы точно не сделаем хуже. Кроме того, она тем больше, чем лучше предлагаемый сплит.\n\nТеперь посмотрим, какими будут критерии ветвления для типичных задач.\n\n### Информативность в задаче регрессии: MSE\n\nПосмотрим на простой пример — регрессию с минимизацией среднеквадратичной ошибки:\n\n$$    L(y_i, c) = (y_i -c)^2\n$$\n\nИнформативность листа будет выглядеть следующим образом:\n\n$$    H(X_m) = \\frac{1}{\\vert X_m\\vert} \\min\\limits_{c \\in Y} \\sum\\limits_{(x_i, y_i) \\in X_m} (y_i - c)^2\n$$\n\nКак мы уже знаем, оптимальным предсказанием константного классификатора для задачи минимизации MSE является среднее значение, то есть\n\n$$    c = \\frac{\\sum y_i}{|X_m|}\n$$\n\nПодставив в формулу информативности сплита, получаем:\n\n$$\\color{#348FEA}{H(X_m) = \\sum\\limits_{(x_i, y_i) \\in X_m}\\frac{\\left(y_i - \\overline{y} \\right)^2}{|X_m|}, ~ \\text{где} ~ \\overline{y} = \\frac{1}{\\vert X_m \\vert} \\sum_i y_i}\n$$\n\nТо есть при жадной минимизации MSE информативность — это оценка дисперсии таргетов для объектов, попавших в лист. Получается очень стройная картинка: оценка значения в каждом листе — это среднее, а выбирать сплиты надо так, чтобы сумма дисперсий в листьях была как можно меньше.\n\n### Информативность в задаче регрессии: MAE\n\n$$    L(y_i, c) = |y_i -c|\n$$\n\nСлучай средней абсолютной ошибки так же прост: в листе надо предсказывать медиану, ведь именно медиана таргетов для обучающих примеров минимизирует MAE констатного предсказателя (мы это обсуждали в параграфе про [линейные модели](https://education.yandex.ru/handbook/ml/article/linear-models)).\n\nВ качестве информативности выступает абсолютное отклонение от медианы:\n\n$$H(X_m) = \\sum\\limits_{(x_i, y_i) \\in X_m}\\frac{|y_i - MEDIAN(Y)|}{|X_m|}\n$$\n\n### Критерий информативности в задаче классификации: misclassification error\n\nПусть в нашей задаче $K$ классов, а $p_k$ — доля объектов класса $k$ в текущей вершине $X_m$:\n\n$$    p_k = \\frac{1}{|X_m|} \\sum_{(x_i, y_i) \\in X_m} \\mathbb{I}[ y_i = k ]\n$$\n\nДопустим, мы заботимся о доле верно угаданных классов, то есть функция потерь — это индикатор ошибки:\n\n$$    L(y_i, c) = \\mathbb{I}[y_i \\ne c]\n$$\n\nПусть также предсказание модели в листе — один какой-то класс. Информативность для такой функции потерь выглядит так:\n\n$$    H(X_m) = \\min_{c \\in Y} \\frac{1}{|X_m|} \\sum_{(x_i, y_i) \\in X_m} \\mathbb{I}[y_i \\ne c]\n$$\n\nЯсно, что оптимальным предсказанием в листе будет наиболее частотный класс $k_{\\ast}$, а выражение для информативности упростится следующим образом:\n\n$$    H(X_m) = \\frac{1}{|X_m|} \\sum_{(x_i, y_i) \\in X_m} \\mathbb{I}[y_i \\ne k_{\\ast}] = 1 - p_{k_{\\ast}}\n$$\n\n### Информативность в задаче классификации: энтропия\n\nЕсли же мы собрались предсказывать вероятностное распределение классов $(c_1, \\ldots, c_K)$, то к этому вопросу можно подойти так же, как мы поступали при выводе логистической регрессии: через максимизацию логарифма правдоподобия (= минимизацию минус логарифма) распределения Бернулли. А именно, пусть в вершине дерева предсказывается фиксированное распределение $c$ (не зависящее от $x_i$), тогда правдоподобие имеет вид\n\n$$    P(y\\vert x, c) = P(y\\vert c) = \\prod\\limits_{(x_i, y_i) \\in X_m}P(y_i\\vert c) = \\prod\\limits_{(x_i, y_i) \\in X_m}\n    \\prod\\limits_{k = 1}^K c_k^{\\mathbb{I}[ y_i = k ]},\n$$\n\nоткуда\n\n$$    H(X_m) = \\min\\limits_{\\sum\\limits_{k} c_k = 1} \n    \\left( \n        -\\frac{1}{|X_m|} \\sum\\limits_{(x_i, y_i) \\in X_m} \\sum\\limits_{k = 1}^K \\mathbb{I}[ y_i = k ] \\log c_k\n    \\right)\n$$\n\nТо, что оценка вероятностей в листе $c_k$, минимизирующая $H(X_m)$, должна быть равна $p_k$, то есть доле попавших в лист объектов этого класса, до некоторой степени очевидно, но это можно вывести и строго.\n\n{% cut \"Доказательство для любопытных\" %}\n\nИз-за наличия условия на $\\sum_k c_k = 1$ нам придётся минимизировать лагранжиан\n\n$$L(c, \\lambda) = \\min_{c, \\lambda} \\left( \n\\left( \n    -\\frac{1}{|X_m|} \\sum\\limits_{(x_i, y_i) \\in X_m} \\sum\\limits_{k = 1}^K \\mathbb{I}[ y_i = k ] \\log c_k\n\\right) + \\lambda \\sum\\limits_{k = 1}^K c_k \\right) \n$$\n\nКак обычно, возьмём частную производную и решим уравнение:\n\n$$    0 = \\frac{\\partial }{\\partial c_j}L(c, \\lambda) = \n$$\n\n$$= \\frac{\\partial }{\\partial c_j} \\left( \n\\left( \n    -\\frac{1}{|X_m|} \\sum\\limits_{(x_i, y_i) \\in X_m} \\sum\\limits_{k = 1}^K \\mathbb{I}[ y_i = k ] \\log c_k\n\\right) + \\lambda \\sum\\limits_{k = 1}^K c_k \\right) =\n$$\n\n$$= \\left( \n\\left( \n    -\\frac{1}{|X_m|} \\sum\\limits_{(x_i, y_i) \\in X_m} \\mathbb{I}[ y_i = j ] \\frac{1}{c_j}\n\\right) + \\lambda \\right) = - \\frac{p_j}{c_j} + \\lambda,\n$$\n\nоткуда выражаем $c_j = \\frac{p_j}{\\lambda}$. Суммируя эти равенства, получим:\n\n$$1 = \\sum_{k = 1}^K c_k = \\frac{1}{\\lambda} \\sum_{k = 1}^K p_k = \\frac{1}{\\lambda},\n$$\n\nоткуда $\\lambda = 1$, а значит, $c_k = p_k$.\n\n{% endcut %}\n\nПодставляя вектор $c = (p_1,\\ldots,p_K)$ в выражение выше, мы в качестве информативности получим энтропию распределения классов:\n\n$$\\color{#348FEA}{H(X_m) = -\\sum_{k = 1}^K p_k \\log p_k}\n$$\n\n{% cut \"Немного подробнее об энтропии\" %}\n\nВеличина\n\n$$H(X_m) = -\\sum_k p_k \\log p_k\n$$\n\nназывается **информационной энтропией Шеннона** и измеряет непредсказуемость реализации случайной величины. В оригинальном определении, правда, речь шла не о значениях случайной величины, а о символах (первичного) алфавита, так как Шеннон придумал эту величину, занимаясь вопросами кодирования строк. Для данной задачи энтропия имеет вполне практический смысл — среднее количество битов, которое необходимо для кодирования одного символа сообщения при заданной частоте символов алфавита.\n\nТак как $p_k\\in[0,1]$, энтропия неотрицательна. Если случайная величина принимает только одно значение, то она абсолютно предсказуема и её энтропия равна \n$$- 1\\log(1) = 0$$\n\nНаибольшего значения энтропия достигает для равномерно распределённой случайной величины — и это отражает тот факт, что среди всех величин с данной областью значений она наиболее «непредсказуема». Для равномерно распределённой на множестве $\\{1,\\ldots,K\\}$ случайной величины значение энтропии будет равно:\n\n$-\\sum_{k = 1}^K \\frac{1}{K}\\log\\frac{1}{K} = \\log K$\n\nНа следующем графике приведены три дискретных распределения на множестве $\\{0, 1, \\ldots, 20\\}$ с их энтропиями. Как и указано выше, максимальную энтропию будет иметь равномерное распределение; у двух других проявляются пики разной степени остроты — и тем самым реализации этих величин обладают меньшей неопределённостью: мы можем с большей уверенностью говорить, что будет сгенерировано.\n\n![3](https://yastatic.net/s3/education-portal/media/3_8_a886025a7e_b68fdb9638.webp)\n\nРазберём на примере игрушечной задачи классификации то, как энтропия может выступать в роли impurity. Рассмотрим три разбиения синтетического датасета и посмотрим, какие значения энтропии они дают. В подписях указано, каким становится соотношение классов в половинках.\n\n![3](https://yastatic.net/s3/education-portal/media/3_9_7bef1a9609_6d707963b8.webp)\n\nВ изначальном датасете по 25 точек каждого класса; энтропия состояния равна\n\n$$S_0 = -\\frac{25}{50}\\log_2{\\frac{25}{50}}-\\frac{25}{50}\\log_2{\\frac{25}{50}} = 1\n$$\n\nДля первого разбиения, по $[X_1 \\leqslant 3]$ в левую часть попадают $25$ точек класса 0 и $12$ точек класса 1, а в правую — $0$ точек класса 0 и $13$ точек класса 1. Энтропия левой группы равна\n\n$$S_l = -\\frac{25}{37}\\log_2{\\frac{25}{37}}-\\frac{12}{37}\\log_2{\\frac{12}{37}}\\approx 0.9\n$$\n\nЭнтропия правой группы, строго говоря, не определена (под логарифмом ноль), но если заменить несуществующее значение на $\\lim_{t\\rightarrow 0+}t\\log_2{t} = 0$, то получится\n\n$$S_r = - 0 - 1\\log_2{1}=0\n$$\n\nЧто, в принципе, логично: с вероятностью 1 выпадает единица, мы всегда уверены в результате, и энтропия у такого, вырожденного распределения тоже минимальная, равная нулю.\n\nКак можно заметить, энтропия в обеих группах уменьшилась по сравнению с изначальной. Получается, что, разделив шарики по значению координаты, равному 3, мы уменьшили общую неопределённость системы. Но какое из разбиений даёт самое радикальное уменьшение? После несложных вычислений, мы получаем для нарисованных выше разбиений:\n\n$$Branch^{(1)} \\approx 16.4\n$$\n\n$$Branch^{(2)} \\approx 30.5\n$$\n\n$$Branch^{(3)} \\approx 7\n$$\n\nОжидаемо, не так ли? Второе разбиение практически идеально разделяет классы, делая из исходного, почти равномерного распределения, два почти вырожденных. При остальных разбиениях в каждой из половинок неопределённость тоже падает, но не так сильно.\n\nКстати, Шеннон изначально собирался назвать информационную энтропию или «информацией», или «неопределённостью», но в итоге выбрал название «энтропия», потому что концепция со схожим смыслом в статистической механике уже была названа энтропией. Употребление термина из другой научной области выглядело убедительным преимуществом при ведении научных споров.\n\n{% endcut %}\n\n### Информативность в задаче классификации: критерий Джини\n\nПусть предсказание модели — это распределение вероятностей классов $(c_1, \\ldots, c_k)$. Вместо логарифма правдоподобия в качестве критерия можно выбрать, например, [метрику Бриера](https://en.wikipedia.org/wiki/Brier_score#:~:text=The%20Brier%20Score%20is%20a,as%20applied%20to%20predicted%20probabilities) (за которой стоит всего лишь идея посчитать MSE от вероятностей). Тогда информативность получится равной\n\n$$H(X_m) = \\min_{\\sum_k c_k = 1} \\frac{1}{|X_m|} \\sum_{(x_i, y_i) \\in X_m} \\sum_{k = 1}^K (c_k - \\mathbb{I}[ y_i = k ] )^2\n$$\n\nМожно показать, что оптимальное значение этой метрики, как и в случае энтропии, достигается на векторе $c$, состоящем из выборочных оценок частот классов $(p_1, \\ldots, p_k)$, $p_i = \\frac{1}{\\vert X_m\\vert}\\sum_i \\mathbb{I}[ y_i = k ]$. Если подставить $(p_1, \\ldots, p_k)$ в выражение выше и упростить его, получится **критерий Джини**:\n\n$$\\color{#348FEA}{H(X_m) = \\sum_{k = 1}^K p_k (1 - p_k)}\n$$\n\nКритерий Джини допускает и следующую интерпретацию: $H(X_m)$ равно математическому ожиданию числа неправильно классифицированных объектов в случае, если мы будем приписывать им случайные метки из дискретного распределения, заданного вероятностями $(p_1, \\ldots, p_k)$.\n\n### Неоптимальность полученных критериев\n\nКазалось бы, мы вывели критерии информативности для всех популярных задач, и они довольно логично следуют из их постановок, но получилось ли у нас обмануть NP-полноту и научиться строить оптимальные деревья легко и быстро?\n\nКонечно, нет. Простейший пример — решение задачи XOR с помощью жадного алгоритма и любого критерия, который мы построили выше:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/3_10_08f8ee6402_84665bc716.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://www.machinelearning.ru/wiki/images/archive/9/97/20140227072517!Voron-ML-Logic-slides.pdf\">Источник</a>\n  </figcaption>\n</figure>\n\nВне зависимости от того, что вы оптимизируете, жадный алгоритм не даст оптимального решения задачи XOR. Но этим примером проблемы не исчерпываются. Скажем, бывают ситуации, когда оптимальное с точки зрения выбранной метрики дерево вы получите с критерием ветвления, построенным по другой метрике (например, MSE-критерий для MAE-задачи или Джини для misclassification error).\n\n## Особенности данных\n\n### Категориальные признаки\n\nНа первый взгляд, деревья прекрасно могут работать с категориальными переменными. А именно, если признак $x^i$ принимает значения из множества $C = \\\\{c_1,\\ldots,c_M\\\\}$, то при очередном разбиении мы можем рассматривать по этому признаку произвольные сплиты вида $C = C_l\\sqcup C_r$ (предикат будет иметь вид $[x^i\\in C_r]$). Это очень логично и естественно, но проблема в том, что при больших $M$ у нас будет $2^{M-1}-1$ сплитов, и перебирать их будет слишком долго. Было бы здорово уметь каким-то образом *упорядочивать* значения $c_m$, чтобы работать с ними так же, как с обычными числами: разделяя на значения, «не превосходящие» и «большие» определённого порога.\n\nОказывается, что для некоторых задач такое упорядочение можно построить вполне естественным образом.\n\nТак, для задачи бинарной классификации значения $c_m$ можно упорядочить по неубыванию доли объектов класса 1 с $x^i = c_m$, после чего работать с ними, как со значениями вещественного признака. Показано, что в случае, если мы выбираем таким образом сплит, оптимальный с точки зрения энтропийного критерия или критерия Джини, то он будет оптимальным среди всех $2^{M-1}-1$ сплитов.\n\nДля задачи регрессии с функцией потерь MSE значения $c_m$ можно упорядочивать по среднему значению таргета на подмножестве $\\\\{X\\mid x^i = c_m\\\\}$. Полученный таким образом сплит тоже будет оптимальным.\n\n### Работа с пропусками\n\nОдна из приятных особенностей деревьев — это способность обрабатывать пропуски в данных. Разберёмся, что при этом происходит на этапе обучения и на этапе применения дерева.\n\nПусть у нас есть некоторый признак $x^i$, значение которого пропущено у некоторых объектов. Как обычно, обозначим через $X_m$ множество объектов, пришедших в рассматриваемую вершину, а через $V_m$ — подмножество $X_m$, состоящее из объектов с пропущенным значением $x^i$. В момент выбора сплитов по этому признаку мы будем просто игнорировать объекты из $V_m$, а когда сплит выбран, мы отправим их в оба поддерева. При этом логично присвоить им веса: $\\frac{\\vert X_l\\vert}{\\vert X_m\\vert}$ для левого поддерева и $\\frac{\\vert X_r\\vert}{\\vert X_m\\vert}$ для правого. Веса будут учитываться как коэффициенты при $L(y_i, c)$ в формуле информативности.\n\n**Вопрос на подумать**. Во всех критериях ветвления участвуют мощности множеств $X_m$, $X_l$ и $X_r$. Нужно ли уменьшение размера выборки учитывать в формулах для информативности? Если нужно, то как?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nЧтобы ответить на этот вопрос, вспомним, как работают критерии ветвления. Их суть в сравнении информативности $H(X_m)$ для исходной вершины с информативностью для решающего пня, порождённого рассматриваемым сплитом. Величина $H(X_m)$ никак не меняется, надо понять, что будет с пнём. Для него можно посчитать информативность так, словно объектов с пропущенными значениями нет:\n\n$$\\frac1{|X_m\\setminus V_m|}\\left(\\sum_{x_i\\in X_l\\setminus V_m}L(y_i, c_l) + \\sum_{x_i\\in X_r\\setminus V_m}L(y_i, c_r)\\right)\n$$\n\nТогда в критерии ветвления нужно поменять коэффициенты, иначе мы не будем адекватным образом сравнивать такой сплит со сплитами по другим признакам:\n\n$$Branch = |X_m\\setminus V_m|\\cdot H(X_m) - |X_l\\setminus V_m|\\cdot H(X_l\\setminus V_m) - |X_r\\setminus V_m|\\cdot H(X_r\\setminus V_m)\n$$\n\nЕсли же мы предполагаем, что объекты из $V_m$ отправляются в новые листья с весами, как описано выше, то формула оказывается другой, и коэффициенты можно не менять:\n\n$$\\frac1{|X_m|}\\left(\\underbrace{\\sum_{x_i\\in X_l\\setminus V_m}L(y_i, c_l) + \\frac{|X_l|}{|X_m|}\\sum_{x_i\\in V_m}L(y_i, c_l)}_{\\text{Левый лист}} + \\underbrace{\\sum_{x_i\\in X_r\\setminus V_m}L(y_i, c_r) + \\frac{|X_r|}{|X_m|}\\sum_{x_i\\in V_m}L(y_i, c_r)}_{\\text{Правый лист}}\\right)\n$$\n\n{% endcut %}\n\nТеперь рассмотрим этап применения дерева. Допустим, в вершину, где сплит идёт по $i$-му признаку, пришёл объект $x_0$ с пропущенным значением этого признака. Предлагается отправить его в каждую из дальнейших веток и получить по ним предсказания $\\widehat{y}_l$ и $\\widehat{y}_r$. Эти предсказания мы усредним с весами $\\frac{\\vert X_l\\vert}{\\vert X_m\\vert}$ и $\\frac{\\vert X_r\\vert}{\\vert X_m\\vert}$ (которые мы запомнили в ходе обучения):\n\n$$\\widehat{y} = \\frac{\\vert X_l\\vert}{\\vert X_m\\vert}\\widehat{y}_l + \\frac{\\vert X_r\\vert}{\\vert X_m\\vert}\\widehat{y}_r\n$$\n\nДля задачи регрессии это сразу даст нам таргет, а в задаче бинарной классификации — оценку вероятности класса 1.\n\n**Замечание**. Если речь идёт о категориальном признаке, может оказаться хорошей идеей ввести дополнительное значение «пропущено» для категориального признака и дальше работать с пропусками, как с обычным значением. Особенно это актуально в ситуациях, когда пропуски имеют системный характер и их наличие несёт в себе определённую информацию.\n\n## Методы регуляризации решающих деревьев\n\nМы уже упоминали выше, что деревья легко переобучаются и процесс ветвления надо в какой-то момент останавливать.\n\nДля этого есть разные критерии, обычно используются все сразу:\n\n* ограничение по максимальной глубине дерева;\n* ограничение на минимальное количество объектов в листе;\n* ограничение на максимальное количество листьев в дереве;\n* требование, чтобы функционал качества $Branch$ при делении текущей подвыборки на две улучшался не менее чем на $s$ процентов.\n\nДелать это можно на разных этапах работы алгоритма, что не меняет сути, но имеет разные устоявшиеся названия:\n\n* можно проверять критерии прямо во время построения дерева, такой способ называется **pre-pruning** или **early stopping**;\n* а можно построить дерево жадно без ограничений, а затем провести **стрижку** (**pruning**), то есть удалить некоторые вершины из дерева так, чтобы итоговое качество упало не сильно, но дерево начало подходить под условия регуляризации. При этом качество стоит измерять на отдельной, отложенной выборке.\n\n## Алгоритмические трюки\n\nТеперь временно снимем шапочку ML-аналитика, наденем шапочку разработчика и специалиста по computer science и посмотрим, как можно сделать полученный алгоритм более вычислительно эффективным.\n\nВ базовом алгоритме мы в каждой вершине дерева для всех возможных значений сплитов вычисляем информативность. Если в вершину пришло $q$ объектов, то мы рассматриваем $qD$ сплитов и для каждого тратим $O(q)$ операций на подсчёт информативности. Отметим, что в разных вершинах, находящихся в нашем дереве на одном уровне, оказываются разные объекты, то есть сумма этих $q$ по всем вершинам заданного уровня не превосходит $N$, а значит, выбор сплитов во всех вершинах уровня потребует $O(N^2 D)$ операций.\n\nТаким образом, общая сложность построения дерева — $O(hN^2 D)$ (где $h$ — высота дерева), и доминирует в ней перебор всех возможных предикатов на каждом уровне построения дерева. Посмотрим, что с этим можно сделать.\n\n### Динамическое программирование\n\nПостараемся оптимизировать процесс выбора сплита в одной конкретной вершине.\n\nВместо того чтобы рассматривать все $O(ND)$ возможных сплитов, для каждого тратя $O(N)$ на вычисление информативности, можно использовать одномерную динамику. Для этого заметим, что если отсортировать объекты по какому-то признаку, то, проходя по отсортированному массиву, можно одновременно и перебирать все значения предикатов, и поддерживать все необходимые статистики для пересчёта значений информативности за $O(1)$ для каждого следующего варианта сплита (против изначальных $O(N)$).\n\nДавайте разберём, как это работает, на примере построения дерева для MSE. Чтобы оценить информативность для листа, нам нужно знать несколько вещей:\n\n* дисперсию и среднее значение таргета в текущем листе;\n* дисперсию и среднее значение таргета в обоих потомках для каждого потенциального значения сплита.\n\nДисперсию и среднее текущего листа легко посчитать за $O(n)$.\n\nС дисперсией и средним для всех значений сплитов чуть сложнее, но помогут следующие оценки математического ожидания и дисперсии:\n\n$$\\overline{Y} = \\frac1N\\sum y_i,\n$$\n\n$$\\sigma^2 (Y) = \\overline{Y^2} - (\\overline{Y})^2 = \\frac1N\\sum y_i^2 - \\frac{1}{N^2}(\\sum y_i)^2 \n$$\n\nСледовательно, нам достаточно для каждого потенциального значения сплита знать количество элементов в правом и левом поддеревьях, их сумму и сумму их квадратов. Впрочем, всё это необходимо знать только для одной из половинок сплита, а для второй это можно получить, вычитая значения для первой из полных сумм. Это можно сделать за один проход по массиву, просто накапливая значения частичных сумм.\n\nЕсли в вершину дерева пришло $q$ объектов, сложность построения одного сплита складывается из $D$ сортировок каждая по $O(q\\log q)$ и одного линейного прохода с динамикой, всего $O(qD\\log q + qD) = O(qD\\log q)$, что лучше исходного $O(q^2D)$. Итоговая сложность алгоритма построения дерева — $O(hND\\log N)$ (где $h$ – высота дерева) против $hN^2D$ в наивной его версии.\n\nКакие именно статистики накапливать (средние, медианы, частоты), зависит от критерия, который вы используете.\n\n### Гистограммный метод\n\nЕсли бы мощность множества значений признаков была ограничена какой-то разумной константой $b \\ll N$, то сортировку в предыдущем способе можно было бы заменить [сортировкой подсчётом](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82%D0%BE%D0%BC) и за счёт этого существенно ускорить алгоритм: ведь сложность такой сортировки — $O(N)$.\n\nЧтобы провернуть это с любой выборкой, мы можем искусственно дискретизировать значения всех признаков. Это приведёт к локально менее оптимальным значениям сплитов, но, учитывая, что наш алгоритм и без этого был весьма приблизительным, это не ухудшит ничего драматически, а вот ускорение получается очень неплохое.\n\nСамый популярный и простой способ дискретизации основан на частотах значений признаков: отрезок между максимальным и минимальным значением признака разбивается на $b$ подотрезков, длины которых выбираются так, чтобы в каждый попадало примерно равное число обучающих примеров. После чего значения признака заменяются на номера отрезков, на которые они попали.\n\n![3](https://yastatic.net/s3/education-portal/media/3_11_4c8cfe50d7_2cd574536f.webp)\n\nАналогичная процедура проводится для всех признаков выборки. Полная сложность предобработки — $O(DN\\log N)$ — сортировка за $O(N\\log N)$ для каждого из $D$ признаков.\n\nТеперь в процедуре динамического алгоритма поиска оптимального сплита нам надо перебирать не все $N$ объектов выборки, а всего лишь $b$ подготовленных заранее границ подотрезков. Частичные суммы статистик тоже придётся поддерживать не для исходного массива данных, а для списка из $b$ возможных сплитов. А для того чтобы делать это эффективно, необходим объект, называемый *гистограммой*: упорядоченный словарь, сопоставляющий каждому значению дискретизированного признака сумму необходимой статистики от таргета на отрезке \\[B\\[i-1\\], B\\[i\\]\\].\n\nФинальный вид алгоритма таков:\n\n1. Дискретизируем каждый из признаков на $b$ значений. Сложность $O(DN\\log N)$.\n2. Создаём корневую вершину `root`.\n3. Вызываем `build_tree_recursive(root, data)`.\n\nФункция `build_tree_recursive` выглядит следующим образом:\n\n1. Проверяем, не пора ли остановиться. Если пора — считаем значение в листе.\n2. Теперь мы снова используем динамический алгоритм, но объекты будем сортировать не по исходным значениям признаков, а по их дискретизированным версиям, упорядочивая их с помощью сортировки подсчётом (для вершины, в которую попало $q$ объектов, сложность будет равна $O(qD)$ против $O(q\\log q\\cdot D)$ в стандартной динамике).\n3. Находим оптимальный сплит за $O(qD)$.\n4. Делим данные, запускаем процедуру рекурсивно для обоих поддеревьев.\n\n**Общая сложность:** $O(DN\\log N + hND)$\n\n{% cut \"Гистограммный метод на примере\" %}\n\nДавайте посчитаем информативность сплита для MSE на данных с одним признаком, по которому мы уже отсортировали данные:\n\n#|||x | -3 | -2 | -0.05 | 1 | 1 | 2 | 6 | 8 ||\n||y | 0 | 0.5 | -1 | 0 | 1 | 2 | 1 | 4 |||#\n\nДискретизируем на три отрезка с границами $B = [-1, 1.5]$\n\n#|||discretized_x | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 ||\n|| y | 0 | 0.5 | -1 | 0 | 1 | 2 | 1 | 4 |||#\n\nСтроим гистограмму частичных сумм, сумм квадратов и количества объектов для двух отрезков (для третьего можно посчитать, используя общую сумму):\n\n#||| b | 0 | 1 ||\n|| cnt | 2 | 3 ||\n|| sum_y | 0.5 | 0 ||\n|| sum_y_sq | 0.25 | 2 |||#\n\nВсего объектов восемь, сумма таргетов — $\\text { sum\\_total }=7.5$, сумма квадратов — $\\text { sum\\_sq\\_total }=23.25$.\n\nИнформативность текущего листа:\n\n$$D\\left[X_d\\right]=\\frac{\\text { sum\\_sq\\_total }}{\\text { cnt\\_total }}-\\left(\\frac{\\text { sum\\_total }}{\\text { cnt\\_total }}\\right)^2=\n$$\n\n$$= \\frac{23.25}{8} - \\left( \\frac{7.5}{8} \\right)^{2} = 2.0273\n$$\n\nПосчитаем значение критерия ветвления для $b=-1$. Информативность левого листа, то есть дисперсия в нём, равна:\n\n$$D[X_l] = E[X_l^2] - E^2[X_l] = \\\\ \n$$\n\n$$=\\frac{s_u \\_y_{\\_} s_1[0]}{\\operatorname{cnt}[0]}-\\left(\\frac{\\text { sum } \\_y}{\\operatorname{cnt}[0]}\\right)^2=\n$$\n\n$$= 0.125 - 0.25 ^ 2 = 0.0625\n$$\n\nИнформативность правого листа, то есть дисперсия в нём, равна:\n\n$$D[X_r] = E[X_r^2] - E^2[X_r] = \\\\ \n$$\n\n$$=\\frac{\\text { sum } \\_ \\text {sq\\_total }- \\text { sum } \\_y \\_s q[0]}{\\text { cnt\\_total }-\\operatorname{cnt}[0]}-\\left(\\frac{\\text { sum\\_total }-\\operatorname{sum} \\_y}{\\text { cnt\\_total }- \\text { cnt }[0]}\\right)^2 \\approx 2.47\n$$\n\nПолное значение критерия для разбиения по $b=-1$:\n\n$$  Branch(b = -1) = 8 \\cdot D[X_d] - 2 \\cdot D[X_l] - 6 \\cdot D[X_r] = \\\\ \n$$\n\n$$  = 6.555\n$$\n\n{% endcut %}\n\n### Mixed integer optimization\n\nЕсли вам действительно хочется построить *оптимальное* (или хотя бы очень близкое к оптимальному) дерево, то на сегодня для решения этой проблемы не нужно придумывать кучу эвристик самостоятельно, а можно воспользоваться специальными солверами, которые решают NP-полные задачи приближённо, но всё-таки почти точно. Так что единственной (и вполне решаемой) проблемой будет представить исходную задачу в понятном для солвера виде. По ссылке — [пример](https://arxiv.org/abs/1907.02211) построения оптимального дерева с помощью решения задачи целочисленного программирования.\n\n## Историческая справка\n\nКак вы, может быть, уже заметили, решающие деревья — это одна большая эвристика для решения NP-полной задачи, практически лишённая какой-либо стройной теоретической подоплёки. В 1970–1990-e годы интерес к ним был весьма велик как в индустрии, где был полезен хорошо интерпретируемый классификатор, так и в науке, где учёные интересовались способами приближённого решения NP-полных задач.\n\nВ связи с этим сложилось много хорошо работающих наборов эвристик, у которых даже были имена: например, [ID3](https://en.wikipedia.org/wiki/ID3_algorithm) был первой реализацией дерева, минимизирующего энтропию, а [CART](https://en.wikipedia.org/wiki/Predictive_analytics#Classification_and_regression_trees_.28CART.29) — первым деревом для регрессии. Некоторые из них были запатентованы и распространялись коммерчески.\n\nНа сегодня это всё потеряло актуальность в связи с тем, что существуют хорошо написанные библиотеки (например, [sklearn](https://scikit-learn.org/stable/modules/tree.html), в которой реализована оптимизированная версия CART).",
        "handbook": "Учебник по машинному обучению",
        "title": "Решающие деревья",
        "description": "Обучение древесных моделей для классификации и регрессии. Эффективное построение решающих деревьев"
    },
    {
        "path": "/handbook/ml/article/ansambli-v-mashinnom-obuchenii",
        "content": "Представим, что у вас есть несколько моделей, обученных на ваших данных. Можно ли придумать процедуру, которая позволит использовать все имеющиеся модели и при этом получить на тестовых данных качество выше, чем могла показать каждая из этих моделей в отдельности?\n\nДа. И в этом параграфе мы расскажем, как именно.\n\n## Смещение и разброс\n\nПредположим, мы решаем задачу регрессии с квадратичной функцией потерь. При использовании квадратичной функции потерь для оценки качества работы алгоритма $a$ можно воспользоваться следующим функционалом:\n\n$$Q(a) = \\mathbb{E}_x \\mathbb{E}_{X, \\epsilon} [y(x, \\epsilon) - a(x, X)]^2,\n$$\n\nгде\n\n* $X$ — обучающая выборка\n* $x$ — точка из тестового множества\n* $y = f(x) + \\epsilon$ — целевая зависимость, которую мы можем измерить с точностью до случайного шума $\\epsilon$\n* $a(x, X)$ — значение алгоритма, обученного на выборке $X$, в точке $x$\n* $\\mathbb{E}_x$ — среднее по всем тестовым точкам и $\\mathbb{E}_{X, \\epsilon}$ — среднее по всем обучающим выборкам $X$ и случайному шуму $\\epsilon$\n\nДля $Q(a)$ существует разложение на три компоненты — шум, смещение и разброс. Это разложение называется **bias-variance decomposition**, оно — одно из мощных средств для анализа работы ансамблей. О том, как его вывести, вы узнаете в соответствующем [параграфе](https://education.yandex.ru/handbook/ml/article/bias-variance-decomposition), а здесь мы приведём его формулировку.\n\nСуществует представление $Q(a)$ в виде трёх компонент:\n\n$$    Q(a) = \\mathbb{E}_x \\text{bias}_X^2 a(x, X) + \\mathbb{E}_x \\mathbb{V}_X[a(x, X)] + \\sigma^2,\n$$\n\nгде\n\n$$    \\text{bias}_X a(x, X) = f(x) - \\mathbb{E}_X[a(x, X)]\n$$\n\n* это **смещение** предсказания алгоритма в точке $x$, усреднённого по всем возможным обучающим выборкам, относительно истинной зависимости $f$,\n\n$$    \\mathbb{V}_X[a(x, X)] = \\mathbb{E}_X \\left[ a(x, X) - \\mathbb{E}_X[a(x, X)] \\right]^2\n$$\n\n* это **дисперсия (разброс)** предсказаний алгоритма в зависимости от обучающей выборки $X$,\n\n$$    \\sigma^2 = \\mathbb{E}_x \\mathbb{E}_\\epsilon[y(x, \\epsilon) - f(x)]^2\n$$\n\n* это неустранимый **шум** в данных.\n\nРаз нам известно, что ошибка алгоритма раскладывается на шум, смещение и разброс, можно подумать над способом сократить ошибку. Будет разумно попытаться сначала уменьшить одну из составляющих. Понятно, что с шумом уже ничего не сделать — это минимально возможная ошибка. Какую можно придумать процедуру, чтобы, например, сократить разброс, не увеличивая смещение?\n\nПример приходит из жизни древних греков: если много человек проголосуют независимо друг от друга, то вместе они придут к разумному решению несмотря на то, что опыт каждого из них субъективен. Аналогом голосования в мире машинного обучения является бэггинг.\n\n## Бэггинг\n\nИдея **бэггинга** (**bagging**, **bootstrap aggregation**) заключается в следующем. Пусть обучающая выборка состояла из $n$ объектов. Выберем из неё $n$ примеров равновероятно, с возвращением. Получим новую выборку $X^1$, в которой некоторых элементов исходной выборки не будет, а какие-то могут войти несколько раз. С помощью некоторого алгоритма $b$ обучим на этой выборке модель $b_1(x) = b(x, X^1)$. Повторим процедуру: сформируем вторую выборку $X^2$ из $n$ элементов с возвращением и с помощью того же алгоритма обучим на ней модель $b_2(x) = b(x, X^2)$. Повторив процедуру $k$ раз, получим $k$ моделей, обученных на $k$ выборках. Чтобы получить одно предсказание, усредним предсказания всех моделей:\n\n$$a(x) = \\frac{1}{k}(b_1(x) + \\dots + b_k(x)).\n$$\n\nПроцесс генерации подвыборок с помощью семплирования с возвращением называется **бутстрепом** (**bootstrap**), а модели $b_1(x), \\ldots, b_k(x)$ часто называют **базовыми алгоритмами** (хотя, наверное, лучше было бы назвать их базовыми моделями). Модель $a(x)$ называется ансамблем этих моделей.\n\nПосмотрим, что происходит с качеством предсказания при переходе от одной модели к ансамблю. Сначала убедимся, что смещение ансамбля не изменилось по сравнению со средним смещением отдельных моделей. Будем считать, что когда мы берём матожидание по всем обучающим выборкам $X$, то в эти выборки включены также все подвыборки, полученные бутстрепом.\n\n$$    \\color{#348FEA}{\\text{bias}_X a(x, X) =} f(x) - \\mathbb{E}_X[a(x, X)] = f(x) - \\mathbb{E}_X \\left[ \\frac{1}{k} \\sum_{i = 1}^k b(x, X^i) \\right] =  \n$$\n\n$$    = f(x) - \\frac{1}{k} \\sum_{i = 1}^k \\mathbb{E}_X \\left[ b(x, X^i) \\right] = f(x) - \\frac{1}{k} \\sum_{i = 1}^k \\mathbb{E}_X \\left[ b(x, X) \\right] = f(x) - \\mathbb{E}_X b(x, X)\n$$\n\n$$    = f(x) - \\mathbb{E}_X b(x, X) \\color{#348FEA}{= \\text{bias}_X b(x, X)}\n$$\n\nПолучили, что смещение композиции равно смещению одного алгоритма. Теперь посмотрим, что происходит с разбросом.\n\n$$\\mathbb{V}_X[a(x, X)] = \\mathbb{E}_X \\left[ a(x, X) - \\mathbb{E}_X[a(x, X)] \\right]^2 = \n$$\n\n$$= \\mathbb{E}_X \\left[ \\frac{1}{k} \\sum_{i = 1}^k b(x, X^i)- \\mathbb{E}_X \\left[ \\frac{1}{k} \\sum_{i = 1}^k b(x, X^i) \\right] \\right]^2 = \n$$\n\n$$= \\frac{1}{k^2} \\mathbb{E}_X \\left[ \\sum_{i = 1}^k \\left( b(x, X^i) - \\mathbb{E}_X b(x, X^i) \\right) \\right]^2 = \n$$\n\n$$= \\frac{1}{k^2} \\sum_{i = 1}^k \\mathbb{E}_X (b(x, X^i) - \\mathbb{E}_X b(x, X^i))^2 + \n$$\n\n$$+ \\frac{1}{k^2} \\sum_{k_1 \\ne k_2} \\mathbb{E}_X \\left[ \\left( b(x, X^{k_1}) - \\mathbb{E}_X b(x, X^{k_1}) \\right) \\left( b(x, X^{k_2}) - \\mathbb{E}_X b(x, X^{k_2}) \\right) \\right] = \n$$\n\n$$= \\frac{1}{k^2} \\sum_{i = 1}^k \\mathbb{V}_X b(x, X^i) + \\frac{1}{k^2} \\sum_{k_1 \\ne k_2} \\text{cov} \\left( b(x, X^{k_1}), b(x, X^{k_2}) \\right)\n$$\n\nЕсли предположить, что базовые алгоритмы некоррелированы, то:\n\n$$\\color{#348FEA}{\\mathbb{V}_X[a(x, X)] =} \\frac{1}{k^2} \\sum_{i = 1}^k \\mathbb{V}_X b(x, X^i) = \n$$\n\n$$= \\frac{1}{k^2} \\sum_{i = 1}^k \\mathbb{V}_X b(x, X) \\color{#348FEA}{= \\frac{1}{k} \\mathbb{V}_X b(x, X)}\n$$\n\nПолучилось, что в этом случае дисперсия композиции в $k$ раз меньше дисперсии отдельного алгоритма.\n\n### Пример: бэггинг над решающими деревьями\n\nПусть наша целевая зависимость $f(x)$ задаётся как\n\n$$    f(x) = x \\sin x,\n$$\n\nи к ней добавляется нормальный шум $\\epsilon \\sim \\mathcal{N}(0, 9)$.  Пример семпла из таких данных:\n\n![4](https://yastatic.net/s3/education-portal/media/4_1_13d3070da7_1e530dd10e.webp)\n\nПопробуем посмотреть, как выглядят предсказания решающих деревьев глубины 7 и бэггинга над такими деревьями в зависимости от обучающей выборки. Обучим решающие деревья 100 раз на различных случайных семплах размера 20. Возьмём также бэггинг над 10 решающими деревьями глубины 7 в качестве базовых классификаторов и тоже 100 раз обучим его на случайных выборках размера 20. Если изобразить предсказания обученных моделей на каждой из 100 итераций, то можно увидеть примерно такую картину:\n\n![4](https://yastatic.net/s3/education-portal/media/4_2_72c446c0e9_3e3d1f70cc.webp)\n\nПо этому рисунку видно, что общая дисперсия предсказаний в зависимости от обучающего множества у бэггинга значительно ниже, чем у отдельных деревьев, а в среднем предсказания деревьев и бэггинга не отличаются.\n\nЧтобы подтвердить это наблюдение, мы можем изобразить смещение и разброс случайных деревьев и бэггинга в зависимости от максимальной глубины:\n\n![4](https://yastatic.net/s3/education-portal/media/4_3_32fef6a2cc_5995be8be9.webp)\n\nНа графике видно, как значительно бэггинг сократил дисперсию. На самом деле, дисперсия уменьшилась практически в 10 раз, что равняется числу базовых алгоритмов ($k$), которые бэггинг использовал для предсказания:\n\n![4](https://yastatic.net/s3/education-portal/media/4_4_d48dd95df3_cc2bc21e01.webp)\n\nКод для отрисовки картинок и подсчёта смещения и разброса можно найти [тут](https://github.com/yandexdataschool/ML-Handbook-materials/blob/main/chapters/ensembles/bias_variance.ipynb).\n\n## Random Forest\n\nВ предыдущем разделе мы сделали предположение, что базовые алгоритмы некоррелированы, и за счёт этого получили очень сильное уменьшение дисперсии у ансамбля относительно входящих в него базовых алгоритмов. Однако в реальной жизни добиться этого сложно: ведь базовые алгоритмы учили одну и ту же зависимость на пересекающихся выборках. Поэтому будет странно, если корреляция на самом деле нулевая. Но на практике оказывается, что **строгое выполнение этого предположения не обязательно**. Достаточно, чтобы алгоритмы были в некоторой степени не похожи друг на друга. На этом строится развитие идеи бэггинга для решающих деревьев — случайный лес.\n\nПостроим ансамбль алгоритмов, где базовый алгоритм — это решающее дерево. Будем строить по следующей схеме:\n\n1. Для построения $i$-го дерева:\n\n   * Сначала, как в обычном бэггинге, из обучающей выборки $X$ выбирается с возвращением случайная подвыборка $X^i$ того же размера, что и $X$.\n\n   * В процессе обучения каждого дерева **в каждой вершине** случайно выбираются $n < N$ признаков, где $N$ — полное число признаков (метод случайных подпространств), и среди них ищется оптимальный сплит. Такой приём как раз позволяет управлять степенью скоррелированности базовых алгоритмов.\n\n2. Чтобы получить предсказание ансамбля на тестовом объекте, усредняем отдельные ответы деревьев (для регрессии) или берём самый популярный класс (для классификации).\n\n3. Profit. Мы построили **Random Forest (случайный лес)** — комбинацию бэггинга и метода случайных подпространств над решающими деревьями.\n\nВнимательный читатель мог заметить, что при построении случайного леса у специалиста по машинному обучению есть несколько степеней свободы. Давайте обсудим их подробнее.\n\n### Какая должна быть глубина деревьев в случайном лесу?\n\nОшибка модели (на которую мы можем повлиять) состоит из смещения и разброса. Разброс мы уменьшаем с помощью процедуры бэггинга. На смещение бэггинг не влияет, а хочется, чтобы у леса оно было небольшим. Поэтому смещение должно быть небольшим у самих деревьев, из которых строится ансамбль.\n\nУ неглубоких деревьев малое число параметров, то есть дерево способно запомнить только верхнеуровневые статистики обучающей подвыборки. Они во всех подвыборках будут похожи, но будут не очень подробно описывать целевую зависимость. Поэтому при изменении обучающей подвыборки предсказание на тестовом объекте будет стабильным, но не точным (низкая дисперсия, высокое смещение).\n\nНаоборот, у глубоких деревьев нет проблем запомнить подвыборку подробно. Поэтому предсказание на тестовом объекте будет сильнее меняться в зависимости от обучающей подвыборки, зато в среднем будет близко к истине (высокая дисперсия, низкое смещение).\n\nВывод: используем глубокие деревья.\n\n### Сколько признаков надо подавать дереву для обучения?\n\nОграничивая число признаков, которые используются в обучении одного дерева, мы также управляем качеством случайного леса. Чем больше признаков, тем больше корреляция между деревьями и тем меньше чувствуется эффект от ансамблирования. Чем меньше признаков, тем слабее сами деревья.\n\nПрактическая рекомендация — брать корень из числа всех признаков для классификации и треть признаков для регрессии.\n\n### Сколько должно быть деревьев в случайном лесе?\n\nВыше было показано, что увеличение числа элементарных алгоритмов в ансамбле не меняет смещения и уменьшает разброс. Так как число признаков и варианты подвыборок, на которых строятся деревья в случайном лесе, ограничены, уменьшать разброс до бесконечности не получится. Поэтому имеет смысл построить график ошибки от числа деревьев и ограничить размер леса в тот момент, когда ошибка перестанет значимо уменьшаться.\n\nВторым практическим ограничением на количество деревьев может быть время работы ансамбля. Однако есть положительное свойство случайного леса: случайный лес можно строить и применять параллельно, что сокращает время работы, если у нас есть несколько процессоров. Но процессоров, скорее всего, всё же сильно меньше числа деревьев, а сами деревья обычно глубокие. Поэтому на большом числе деревьев Random Forest может работать дольше желаемого и количество деревьев можно сократить, немного пожертвовав качеством.\n\n## Бустинг\n\n**Бустинг (boosting)** — это ансамблевый метод, в котором так же, как и в методах выше, строится множество базовых алгоритмов из одного семейства, объединяющихся затем в более сильную модель. Отличие состоит в том, что в бэггинге и случайном лесе базовые алгоритмы учатся независимо и параллельно, а в бустинге — последовательно.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/4_5_98b5004456_b5c396fb5a.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Автор изображения –\n    <a href=\"https://towardsdatascience.com/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205\">Joseph Rocca</a>.\n  </figcaption>\n</figure>\n\nКаждый следующий базовый алгоритм в бустинге обучается так, чтобы уменьшить общую ошибку  всех своих предшественников. Как следствие, итоговая композиция будет иметь меньшее смещение, чем каждый отдельный базовый алгоритм (хотя уменьшение разброса также может происходить).\n\nПоскольку основная цель бустинга — уменьшение смещения, в качестве базовых алгоритмов часто выбирают алгоритмы с высоким смещением и небольшим разбросом. Например, если в качестве базовых классификаторов выступают деревья, то их глубина должна быть небольшой — обычно не больше 2-3 уровней.\n\nЕщё одной важной причиной для выбора моделей с высоким смещением в качестве базовых является то, что такие модели, как правило, быстрее учатся.  Это важно для их последовательного обучения, которое может стать очень дорогим по времени, если на каждой итерации будет учиться сложная модель. На текущий момент основным видом бустинга с точки зрения применения на практике является **градиентный бустинг**, о котором подробно рассказывается в соответствующем [параграфе](https://academy.yandex.ru/handbook/ml/article/gradientnyj-busting).\n\nХотя случайный лес — мощный и достаточно простой для понимания и реализации алгоритм, на практике он чаще всего уступает градиентному бустингу. Поэтому градиентный бустинг сейчас — основное продакшн-решение, если работа происходит с табличными данными (в работе с однородными данными — картинками, текстами — доминируют нейросети).\n\n## Стекинг\n\n**Стекинг (stacking)** — алгоритм ансамблирования, основные отличия которого от предыдущих состоят в следующем:\n\n1. он может использовать алгоритмы разного типа, а не только из какого-то фиксированного семейства. Например, в качестве базовых алгоритмов могут выступать метод ближайших соседей и линейная регрессия\n2. результаты базовых алгоритмов объединяются в один с помощью обучаемой мета-модели, а не с помощью какого-либо обычного способа агрегации (суммирования или усреднения)\n\nОбучение стекинга проходит в несколько этапов:\n\n1. общая выборка разделяется на тренировочную и тестовую\n2. тренировочная выборка делится на $n$ фолдов. Затем эти фолды перебираются тем же способом, что используется при кросс-валидации: на каждом шаге фиксируются $(n - 1)$ фолдов для обучения базовых алгоритмов и один — для их предсказаний (вычисления мета-факторов). Такой подход нужен для того, чтобы можно было использовать всё тренировочное множество, и при этом базовые алгоритмы не переобучались\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/4_6_a01e6d6da8_476bb77afa.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Автор изображения — \n    <a href=\"https://medium.com/@stevenyu530_73989/stacking-and-blending-intuitive-explanation-of-advanced-ensemble-methods-46b295da413c\">Steven Yu</a>.  \n  </figcaption>\n</figure>\n\n3. на полученных мета-факторах обучается мета-модель. Кроме мета-факторов, она может принимать на вход и фичи из исходного датасета. Выбор зависит от решаемой задачи\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/4_7_ff33dd2f94_5e074dfd14.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Автор изображения — \n    <a href=\"https://medium.com/@stevenyu530_73989/stacking-and-blending-intuitive-explanation-of-advanced-ensemble-methods-46b295da413c\">Steven Yu</a>. \n  </figcaption>\n</figure>\n\nДля получения мета-факторов на тестовом множестве базовые алгоритмы можно обучить на всём тренировочном множестве — переобучения в данном случае возникнуть не должно.\n\nЕсли данных достаточно много, то можно просто разделить обучающие данные на две непересекающиеся части: ту, на которой учатся базовые алгоритмы, и ту, на которой они делают свои предсказания и обучается мета-модель. Использование такого простого разбиения вместо кросс-валидации на тренировочных данных иногда называют **блендингом (blending)**. Если данных совсем много, то тестовое множество тоже можно разделить на две части: тестовую и валидационную, и использовать последнюю для подбора гиперпараметров моделей-участников.\n\nС точки зрения смещения и разброса стекинг не имеет прямой интерпретации, так как не минимизирует напрямую ни ту, ни другую компоненту ошибки. Удачно работающий стекинг просто уменьшает ошибку, и, как следствие, её компоненты тоже будут убывать.\n\n## Почитать по теме\n\n* [Лекция](https://github.com/esokolov/ml-course-hse/blob/master/2020-fall/lecture-notes/lecture08-ensembles.pdf) Евгения Соколова про bias-variance decomposition и бэггинг\n* [Блог-пост](https://towardsdatascience.com/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205) про ансамбли от Joseph Rocca\n* [Блог-пост](https://medium.com/@stevenyu530_73989/stacking-and-blending-intuitive-explanation-of-advanced-ensemble-methods-46b295da413c) про стекинг и блендинг от Steven Yu",
        "handbook": "Учебник по машинному обучению",
        "title": "Ансамбли в машинном обучении",
        "description": "Как смешать несколько моделей в одну. Стэкинг, бэггинг, случайные леса"
    },
    {
        "path": "/handbook/ml/article/gradientnyj-busting",
        "content": "В прошлых разделах мы научились соединять базовые алгоритмы в ансамбль с помощью бэггинга (и, в частности, строить из решающих деревьев случайные леса). Теперь мы рассмотрим другой способ объединять базовые алгоритмы в композицию — градиентный бустинг.\n\nВ ходе обучения случайного леса каждый базовый алгоритм строится независимо от остальных. Бустинг, в свою очередь, воплощает идею последовательного построения линейной комбинации алгоритмов. Каждый следующий алгоритм старается уменьшить ошибку текущего ансамбля.\n\nБустинг, использующий деревья решений в качестве базовых алгоритмов, называется **градиентным бустингом над решающими деревьями**, (**Gradient Boosting on Decision Trees**, **GBDT**).\n\nОн отлично работает на выборках с «табличными», неоднородными данными. Пример таких данных — описание пользователя Яндекса через его возраст, пол, среднее число поисковых запросов в день, число заказов такси и так далее. Такой бустинг способен эффективно находить нелинейные зависимости в данных различной природы.\n\nЭтим свойством обладают все алгоритмы, которые используют деревья решений, однако именно GBDT обычно выигрывает в подавляющем большинстве задач. Благодаря этому он широко применяется во многих конкурсах по машинному обучению и задачах из индустрии:\n\n* поисковом ранжировании;\n* рекомендательных системах;\n* таргетировании рекламы;\n* предсказании погоды;\n* выбора пункта назначения такси и многих других.\n\nНе так хорошо бустинг проявляет себя на однородных данных: текстах, изображениях, звуке, видео. В таких задачах нейросетевые подходы почти всегда демонстрируют лучшее качество.\n\nИ хотя деревья решений — традиционный выбор для объединения в ансамбли, никто не запрещает использовать и другие алгоритмы (например, линейные модели) в качестве базовых. Эта возможность реализована в пакете XGBoost.\n\nСтоит только понимать, что построенная композиция окажется линейной комбинацией линейных моделей, то есть опять-таки линейной моделью - или нейросетью с одним полносвязным слоем. Это уменьшает возможности ансамбля эффективно определять нелинейные зависимости в данных. Поэтому в этом параграфе мы рассмотрим только бустинг над решающими деревьями.\n\n## Интуиция\n\nРассмотрим задачу регрессии с квадратичной функцией потерь:\n\n$$\\mathcal{L}(y, x) = \\frac{1}{2}\\sum^{N}_{i=1}\\left(y_i -  a(x_i)\\right)^{2} \\rightarrow \\min\n$$\n\nДля решения будем строить композицию из $K$ базовых алгоритмов:\n\n$$a(x) = a_K(x) = b_1(x) + b_2(x) + \\dots +b_K(x)\n$$\n\nЕсли мы обучим единственное решающее дерево, то качество такой модели, скорее всего, будет низким. Однако мы знаем, на каких объектах построенное дерево давало точные предсказания, а на каких ошибалось.\n\nПопробуем использовать эту информацию и обучим ещё одну модель. Допустим, что предсказание первой модели на объекте $x_l$ на 10 больше, чем необходимо (т.е. $b_1(x_l) = y_l + 10$). Если бы мы могли обучить новую модель, которая на $x_l$ будет выдавать ответ $-10$, то сумма ответов этих двух моделей на объекте $x_l$ в точности совпала бы с истинным значением:\n\n$$b_1(x_l) + b_2(x_l) = (y_l + 10) + (-10) = y_l \n$$\n\nДругими словами, если вторая модель научится предсказывать разницу между реальным значением и ответом первой, то это позволит уменьшить ошибку композиции.\n\nВ реальности вторая модель тоже не сможет обучиться идеально, поэтому обучим третью, которая будет «компенсировать» неточности первых двух. Будем продолжать так, пока не построим композицию из $K$ алгоритмов.\n\nДля объяснения метода градиентного бустинга полезно воспользоваться следующей аналогией. Бустинг можно представить как гольфиста, цель которого — загнать мяч в лунку с координатой $y_{\\text{ball}}$. Положение мяча здесь – ответ композиции $a(x_{\\text{ball}})$. Гольфист мог бы один раз ударить по мячу, не попасть в лунку и пойти домой, но настырность заставляет его продолжить.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/5_1_848ce5004c_60a9bfa9fd.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://explained.ai/gradient-boosting/L2-loss.html\">Источник</a>\n  </figcaption>\n</figure>\n\nПо счастью, ему не нужно начинать каждый раз с начальной позиции. Следующий удар гольфиста переводит мяч из текущего положения $a_k(x_{\\text{ball}})$ в положение $a_{k+1}(x_{\\text{ball}})$. Каждый следующий удар — это та поправка, которую вносит очередной базовый алгоритм в композицию. Если гольфист все делает правильно, то функция потерь будет уменьшаться:\n\n$$\\mathcal{L}(y, a_{k+1}(x)) < \\mathcal{L}(y, a_{k}(x)),\n$$\n\nто есть мяч постепенно будет приближаться к лунке.\n\nУдары при этом делаются не хаотично. Гольфист оценивает текущее положение мяча относительно лунки и следующим ударом старается нивелировать те проблемы, которые он создал себе всеми предыдущими.  Подбираясь к лунке, он будет бить всё аккуратнее и, возможно, даже возьмет другую клюшку, но точно не будет лупить так же, как из первоначальной позиции. В итоге комбинация всех ударов рано или поздно перенесет мяч в лунку.\n\nПодобно тому, как гольфист постепенно подводит мяч к цели, бустинг с каждым новым базовым алгоритмом всё больше приближает предсказание к истинному значению метки объекта.\n\nРассмотрим теперь другую аналогию — разложение функции в ряд Тейлора. Из курса математического анализа известно, что (достаточно хорошую) бесконечно дифференцируемую функцию $f(x)$ на интервале $x \\in \\left(a - R, a + R\\right)$ можно представить в виде бесконечной суммы степенных функций:\n\n$$f(x) = \\sum\\limits_{n = 0}^{\\infty}\\frac{f^{(n)}\\left(a\\right)}{n!}\\left(x - a\\right)^{n}.\n$$\n\nОдна, самая первая степенная функция в разложении, очень грубо приближает $f(x)$. Прибавляя к ней следующую, мы получим более точное приближение. Каждая следующая элементарная функция увеличивает точность приближения, но менее заметна в общей сумме. Если нам не требуется абсолютно точное разложение, вместо бесконечного ряда Тейлора мы можем ограничиться суммой его первых $k$ элементов. Таким образом, интересующую нас функцию мы с некоторой точностью представили в виде суммы «простых» функций.\n\nПеренесём эту идею на задачи машинного обучения. В машинном обучении мы пытаемся по выборке $(x_i, y_i)$ восстановить неизвестную истинную зависимость. Прежде всего, мы выбираем подходящий алгоритм. Мы можем выбрать «сложный» алгоритм, который сразу хорошо выучит истинную зависимость.\n\nА можем обучить «простой», который выучит истинную зависимость посредственно. Затем мы добавим к нему ещё один такой простой алгоритм, чтобы уточнить предсказание первого алгоритма. Продолжая этот процесс, мы получим сумму простых алгоритмов, где первый алгоритм грубо приближает истинную зависимость, а каждый следующий делает приближение всё точнее.\n\n## Пример с задачей регрессии: формальное описание\n\nРассмотрим тот же пример с задачей регрессии и квадратичной функцией потерь:\n\n$$\\mathcal{L}(y, x) = \\frac{1}{2}\\sum\\limits^{N}_{i=1}\\left(y_i -  a(x_i)\\right)^{2} \\rightarrow \\min\n$$\n\nДля решения также будем строить композицию из $K$ базовых алгоритмов семейства $\\mathcal{B}$:\n\n$$a(x) = a_K(x) = b_1(x) + b_2(x) + \\dots + b_K(x)\n$$\n\nВ качестве базовых алгоритмов выберем, как и условились в начале параграфа, семейство $\\mathcal{B}$ решающих деревьев некоторой фиксированной глубины.\n\nИспользуя известные нам методы построения решающих деревьев, обучим алгоритм $b_1(x) \\in \\mathcal{B}$, который наилучшим образом приближает целевую переменную:\n\n$$b_1(x) = \\underset{b\\in \\mathcal{B}}{\\mathrm{argmin}} \\, \\mathcal{L}(y, b(x))\n$$\n\nПостроенный алгоритм $b_1(x)$, скорее всего, работает не идеально. Более того, если базовый алгоритм работает слишком хорошо на обучающей выборке, то высока вероятность переобучения: низкий уровень смещения, но высокий уровень разброса. Далее вычислим, насколько сильно отличаются предсказания этого дерева от истинных значений:\n\n$$s_i^{1} = y_i - b_1(x_i)\n$$\n\nТеперь мы хотим скорректировать $b_1(x)$ с помощью $b_2(x)$. В идеале так, чтобы $b_2(x)$ идеально предсказывал величины $s_i^{1}$, ведь в этом случае\n\n$$   a_2(x_i) = b_1(x_i) + b_2(x_i) = \n$$\n\n$$   = b_1(x_i) + s_i^1 = b_1(x_i) + (y_i - b_1(x_i)) = y_i \n$$\n\nНайти совершенный алгоритм, скорее всего, не получится, но по крайней мере мы можем выбрать из семейства наилучшего представителя для такой задачи. Итак, второе решающее дерево будет обучаться предсказывать разности $s_i^1$:\n\n$$b_2(x) = \\underset{b\\in \\mathcal{B}}{\\mathrm{argmin}} \\, \\mathcal{L}(s^1, b(x))\n$$\n\nОжидается, что композиция из двух таких моделей $a_2(x) = b_1(x) + b_2(x)$ станет более качественно предсказывать целевую переменную $y$.\n\nДалее рассуждения повторяются до построения всей композиции. На $k$-ом шаге вычисляется разность между правильным ответом и текущим предсказанием композиции из $k - 1$ алгоритмов:\n\n$$\ns_i^{k - 1} = y_i - \\sum_{j=1}^{k - 1} b_{j}(x_i) = y_i - a_{k - 1}(x_i)\n$$\n\n\nЗатем $k$-й алгоритм учится предсказывать эту разность:\n\n$$\nb_k(x) = \\underset{b\\in \\mathcal{B}}{\\mathrm{argmin}} \\, \\mathcal{L}(s^{k - 1}, b(x)), \n$$\n\nа композиция в целом обновляется по формуле\n\n$$\na_k(x) = a_{k - 1}(x) + b_k(x)\n$$\n\nОбучение $K$ базовых алгоритмов завершает построение композиции.\n\n## Обобщение на другие функции потерь\n\n### Интуиция\n\nОтметим теперь важное свойство функции потерь в рассмотренном выше примере с регрессией. Для этого посчитаем производную функции потерь по предсказанию $z = a_k(x_i)$ модели для $i$-го объекта:\n\n$$\n\\frac{\\partial{\\mathcal{L}(y_i,z)}}{\\partial{z}}\\bigg|_{z=a_k(x_i)} = \\frac{\\partial}{\\partial{z}}\\frac{1}{2}\\left(y_i -  z\\right)^{2}\\bigg|_{z=a_k(x_i)} = a_k(x_i) - y_i \n$$\n\nВидим, что разность, на которую обучается $k$-й алгоритм, выражается через производную:\n\n$$\ns_i^{k} = y_i -a_k(x_i) = -\\frac{\\partial{\\mathcal{L}(y_i,z)}}{\\partial{z}}\\bigg|_{z=a_k(x_i)}\n$$\n\nТаким образом, для каждого объекта $x_i$ очередной алгоритм в бустинге обучается предсказывать антиградиент функции потерь по предсказанию модели $-\\frac{\\partial{\\mathcal{L}(y_i,z)}}{\\partial{z}}$ в точке $a_k(x_i)$ предсказания текущей части композиции на объекте $x_i$.\n\n**Почему же это важно?** Дело в том, что это наблюдение позволяет обобщить подход построения бустинга на произвольную дифференцируемую функцию потерь. Для этого мы заменяем обучение на разность $s_i^k$ обучением на антиградиент функции потерь $(-g_i^k)$, где\n\n$$g_i^k =\\frac{\\partial{\\mathcal{L}(y_i,z)}}{\\partial{z}}\\bigg|_{z=a_k(x_i)}\n$$\n\nВспомните аналогию с гольфистом: обучение композиции можно представить как перемещение предсказания из точки $(a_k(x_1), a_k(x_2), \\dots, a_k(x_N))$ в точку $(a_{k+1}(x_1), a_{k+1}(x_2), \\dots, a_{k+1}(x_N))$. В конечном итоге мы ожидаем, что точка $(a_K(x_1), a_K(x_2), \\dots, a_K(x_N))$ будет располагаться как можно ближе к точке с истинными значениями $(y_1, y_2, \\dots, y_N)$.\n\n![5](https://yastatic.net/s3/education-portal/media/5_2_ddc4f74a07_a6da8f6e38.webp)\n\nВ случае квадратичной функции потерь интуиция вполне подкрепляется математикой. Изменится ли что-либо в наших действиях, если мы поменяем квадратичную функцию потерь на любую другую? С одной стороны, мы, как и прежде, можем двигаться в направлении уменьшения разности предсказания и истинного значения: любая функция потерь поощряет такие шаги для каждого отдельного объекта, ведь для любой адекватной функции потерь выполнено $\\mathcal{L}(y, y) = 0$.\n\nНо мы можем посмотреть на задачу и с другой стороны: не с точки зрения уменьшения расстояния между вектором предсказаний и вектором истинных значений, а с точки зрения уменьшения значения функции потерь. Для наискорейшего уменьшения функции потерь нам необходимо шагнуть в сторону её антиградиента по вектору предсказаний текущей композиции, то есть как раз таки в сторону вектора $(-g_1^k,\\dots,-g_N^k)$. Это направление не обязано совпадать с шагом по направлению уменьшения разности предсказания и истинного значения. Например, может возникнуть гипотетическая ситуация, как на рисунке ниже:\n\n![5](https://yastatic.net/s3/education-portal/media/5_3_affa81aaa3_39366ae5f4.webp)\n\nВ изображённом примере рассматриваются два объекта $x_1$ и $x_2$. Текущее предсказание для них — $(a_k(x_1), a_k(x_2))$, а окружность определяет варианты следующего шага: первый вариант — пойти в направлении $(s_1^k, s_2^k)$, как делалось ранее; второй — пойти в направлении антиградиента. Также показаны линии уровня значений функции потерь. Функция потерь в этом примере устроена таким образом, что $L_2 < L_1$, из-за чего шаг по антиградиенту оказывается более выгодным.\n\nДвижение в сторону антиградиента более выгодно с точки зрения минимизации функции потерь — плюс оно также позволяет справляться с ситуациями, когда явно посчитать остаток (разницу между целевым значением и предсказанием) не представляется возможным.\n\nОдин из таких примеров — задача ранжирования. В задаче ранжирования объекты в датасете разбиты на группы и требуется построить модель, по предсказаниям которой можно было бы «правильно» упорядочить документы в каждой группе (обычно по убыванию предсказания модели).\n\n**Что значит упорядочить «правильно»?** Это значит, что полученная по предсказаниям модели перестановка объектов в группе должна быть близка к идеальной по некоторой метрике.\n\n**Как задается идеальная перестановка?** Есть два способа:\n\n* Первый способ — проставить каждому объекту число $y$, по которому можно отсортировать объекты для получения идеальной перестановки. Это число можно рассматривать как таргет и обучать модель регрессии — в некоторых случаях это даже будет работать хорошо.\n* Второй способ — задать набор пар объектов, которые обозначают их порядок относительно друг друга в идеальной перестановке. То есть пара $(i, j)$ означает, что объект с номером $i$ должен стоять раньше в перестановке, чем объект с номером $j$.\n\nВо втором способе таргетов у объектов нет, но дифференцируемая функция потерь есть — в библиотеке CatBoost она называется PairLogit и вычисляется по формуле:\n\n$$   PairLogit = \\frac{-\\sum\\limits_{p, n \\in Pairs} \\left(log(\\displaystyle\\frac{1}{1 + e^{- (a_{p} - a_{n})}})\\right)}{|Pairs|},\n$$\n\nгде $a_p$ и $a_n$ — это предсказания модели на объектах $p$ и $n$ соответственно. Градиент такой функции потерь посчитать можно, а разницу между предсказанием и истинным значением — нет.\n\n### Математическое обоснование\n\nПопробуем записать наши интуитивные соображения более формально. Пусть $\\mathcal{L}$ – дифференцируемая функция потерь, а наш алгоритм $a(x)$ представляет собой композицию базовых алгоритмов:\n\n$$   a(x) = a_k(x) = b_1(x) + \\ldots + b_k(x)\n$$\n\nМы строим нашу композицию «жадно»:\n\n$$   a_k(x) = a_{k - 1}(x) + b_k(x),\n$$\n\nгде вновь добавляемый базовый алгоритм $b_k$ обучается так, чтобы улучшить предсказания текущей композиции:\n\n$$   b_k = \\underset{b\\in \\mathcal{B}}{\\mathrm{argmin}} \\sum_{i = 1}^N \\mathcal{L}(y_i, a_{k - 1}(x_i) + b(x_i))\n$$\n\nМодель $b_0$ выбирается так, чтобы минимизировать потери на обучающей выборке:\n\n$$   b_0 = \\underset{b\\in \\mathcal{B}}{\\mathrm{argmin}} \\sum_{i = 1}^N \\mathcal{L}(y_i, b(x_i))\n$$\n\nДля построения базовых алгоритмов на следующих шагах рассмотрим разложение Тейлора функции потерь $\\mathcal L$ до первого члена в окрестности точки $(y_i, a_{k - 1}(x_i))$:\n\n$$   \\mathcal{L}(y_i, a_{k - 1}(x_i) + b(x_i)) \\approx \n   \\mathcal{L}(y_i, a_{k - 1}(x_i)) + b(x_i) \\frac{\\partial \\mathcal{L}(y_i, z)}{\\partial z} \\bigg|_{z = a_{k - 1}(x_i)} \n   = \\mathcal{L}(y_i, a_{k - 1}(x_i)) + b(x_i) g_i^{k - 1}\n$$\n\nИзбавившись от постоянных членов, мы получим следующую оптимизационную задачу:\n\n$$   b_k \\approx \\underset{b\\in \\mathcal{B}}{\\mathrm{argmin}} \\sum_{i = 1}^N b(x_i) g_i^{k - 1}\n$$\n\nПоскольку суммируемое выражение — это скалярное произведение двух векторов, его значение минимизируют $b(x_i)$, пропорциональные значениям $-g_i^{k - 1}$. Поэтому на каждой итерации базовые алгоритмы $b_k$ обучаются предсказывать значения антиградиента функции потерь по текущим предсказаниям композиции.\n\nИтак, использованная нами интуиция шага в сторону «уменьшения остатка» удивительным образом привела к оптимальным смещениям в случае квадратичной функции потерь, но для других функций потерь это не так: для них смещение происходит в сторону антиградиента.\n\nПолучается, что в общем случае на каждой итерации базовые алгоритмы должны приближать значения антиградиента функции потерь. Однако есть частный случай, в котором в качестве таргета для базового алгоритма выгоднее использовать именно «остатки» — это касается функции потерь MAE. Её производная равна -1, 0 или \\+1.\n\nПриближая базовым алгоритмом антиградиент MAE, количество итераций до сходимости будет расти пропорционально масштабу таргета. То есть, если домножить целевое значение на 10, то потребуется в 10 раз больше итераций градиентного бустинга. Использование остатков в качестве таргета для базового алгоритма не имеет такой проблемы. Аналогичные рассуждения верны также для функции MAPE, в которой проблема с масштабом таргета может проявляться еще сильнее.\n\n### Обучение базового алгоритма\n\nПри построении очередного базового алгоритма $b_{k+1}$ мы решаем задачу регрессии с таргетом, равным антиградиенту функции потерь исходной задачи на предсказании $a_k = b_1 + \\ldots + b_k$.\n\nТеоретически можно воспользоваться любым методом построения регрессионного дерева. Важно выбрать оценочную функцию $S$, которая будет показывать, насколько текущая структура дерева хорошо приближает антиградиент. Её нужно будет использовать для построения критерия ветвления:\n\n$$|R| \\cdot S(R) - |R_{right}| \\cdot S(R_{right}) - |R_{left}| \\cdot S(R_{left}) \\rightarrow \\max,\n$$\n\nгде $S(R)$ — значение функции $S$ в вершине $R$, $S(R_{left}), S(R_{right})$ — значения в левом и правом сыновьях $R$ после добавления предиката, $\\mid \\, \\cdot \\, \\mid$ — количество элементов, пришедших в вершину.\n\nНапример, можно использовать следующие оценочные функции:\n\n$$ L_2(g, p) = \\sum\\limits_{i=1}^N\\left(p_i - g_i\\right)^2,\\\\\nCosine(g, p) = -\\frac{\\sum\\limits_{i=1}^N(p_i \\cdot g_i)}{\\sqrt{\\sum\\limits_{i=1}^Np_i^2} \\cdot \\sqrt{\\sum\\limits_{i=1}^Ng_i^2}},\n$$\n\nгде $p_i$ — предсказание дерева на объекте $x_i$, $g_i$ — антиградиент, на который учится дерево, $p = {p_i}{i=1}^N$, $g = { g_i }^N$. Функция $L_2$ представляет собой среднеквадратичную ошибку, а функция $Cosine$ определяет близость через косинусное расстояние между векторами предсказаний и антиградиентов.\n\nВ итоге обучение базового алгоритма проходит в два шага:\n\n* по **функции потерь** вычисляется целевая переменная для обучения следующего базового алгоритма:\n\n$$g_i^k =\\frac{\\partial{\\mathcal{L}(y_i,z)}}{\\partial{z}}\\bigg|_{z=a_k(x_i)}\n$$\n\n* строится регрессионное дерево на обучающей выборке $(x_i, -g_i^k)$, минимизирующее выбранную **оценочную функцию**.\n\n### На практике\n\nПоскольку для построения градиентного бустинга достаточно уметь считать градиент функции потерь по предсказаниям, с его помощью можно решать широкий спектр задач. В библиотеках градиентного бустинга даже реализована возможность создавать свои функции потерь: для этого достаточно уметь вычислять ее градиент, зная истинные значения и текущие предсказания для элементов обучающей выборки.\n\nТипичный градиентный бустинг имеет в составе несколько тысяч деревьев решений, которые необходимо строить последовательно. Построение решающего дерева на выборках типичного размера и современном железе, даже с учетом всех оптимизаций, требует небольшого, но всё-таки заметного времени (0.1-1c), которое для всего ансамбля превратится в десятки минут. Это не так быстро, как обучение линейных моделей, но всё-таки значительно быстрее, чем обучение типичных нейросетей.\n\n### Темп обучения (learning rate)\n\nОбучение композиции с помощью градиентного бустинга может привести к переобучению, если базовые алгоритмы слишком сложные. Например, если сделать решающие деревья слишком глубокими (более 10 уровней), то при обучении бустинга ошибка на обучающей выборке даже при довольно скромном $K$ может приблизиться к нулю, то есть предсказание будет почти идеальным, но на тестовой выборке всё будет плохо.\n\nСуществует два решения этой проблемы.\n\n* Во-первых, необходимо упростить базовую модель, уменьшив глубину дерева (либо примерив какие-либо ещё техники регуляризации).\n\n* Во-вторых, мы можем ввести параметр, называемый **темпом обучения** (**learning rate**) $\\eta \\in (0, 1]$:\n\n$$a_{k+1}(x) = a_{k}(x) + \\eta b_{k+1}(x) \n$$\n\nПрисутствие этого параметра означает, что каждый базовый алгоритм вносит относительно небольшой вклад во всю композицию: если расписать сумму целиком, она будет иметь вид\n\n$$a_{k+1}(x) = b_1(x) + \\eta b_2(x) + \\eta b_3(x) + \\ldots + \\eta b_{k+1}(x)\n$$\n\nЗначение параметра обычно определяется эмпирически по входным данным. В библиотеке CatBoost темп обучения может быть выбран автоматически по набору данных. Для этого используется заранее обученная линейная модель, предсказывающая темп обучения по мета-параметрам выборки данных: числу объектов, числу признаков и другим.\n\nТемп обучения связан с количеством итераций градиентного бустинга. Чем меньше learning rate, тем больше итераций потребуется сделать для достижения того же качества на обучающей выборке.\n\n### Feature importance\n\nОтдельные деревья решений можно легко интерпретировать, просто визуализируя их структуру. Но в модели градиентного бустинга содержатся сотни деревьев, и поэтому её нелегко интерпретировать с помощью визуализации входящих в неё деревьев. При этом хотелось бы, как минимум, понимать, какие именно признаки в данных оказывают наибольшее влияние на предсказание композиции.\n\nМожно сделать следующее наблюдение: признаки из верхней части дерева влияют на окончательное предсказание для большей доли обучающих объектов, чем признаки, попавшие на более глубокие уровни.\n\nТаким образом, ожидаемая доля обучающих объектов, для которых происходило ветвление по данному признаку, может быть использована в качестве оценки его относительной важности для итогового предсказания. Усредняя полученные оценки важности признаков по всем решающим деревьям из ансамбля, можно уменьшить дисперсию такой оценки и использовать ее для отбора признаков. Этот метод известен как **MDI** (**mean decrease in impurity**).\n\nСуществуют и другие методы оценки важности признаков для ансамблей: например, Permutation feature importance (см. [описание](https://scikit-learn.org/stable/modules/permutation_importance.html#permutation-importance) в sklearn) и множество разных подходов, [предлагаемых](https://catboost.ai/en/docs/concepts/fstr) в библиотеке CatBoost. Все эти техники отбора признаков применимы также и для случайных лесов.\n\n### Реализации\n\nДля общего развития имеет смысл посмотреть реализацию в [sklearn](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html), но на практике она весьма медленная и не такая уж умная.\n\nХороших реализаций GBDT есть, как минимум, три: [LightGBM](https://lightgbm.readthedocs.io/en/latest/), [XGBoost](https://xgboost.readthedocs.io/en/latest/) и [CatBoost](https://catboost.ai/). Исторически они отличались довольно сильно, но за последние годы успели скопировать друг у друга все хорошие идеи.\n\n#### Форма деревьев\n\nОдно из основных отличий LightGBM, XGBoost и CatBoost — форма решающих деревьев.\n\nLightGBM строит деревья по принципу: «На каждом шаге делим вершину с наилучшим скором», а основным критерием остановки выступает максимально допустимое количество вершин в дереве. Это приводит к тому, что деревья получаются несимметричными, то есть поддеревья могут иметь разную глубину — например, левое поддерево может иметь глубину $2$, а правое может разрастись до глубины $15$.\n\nС одной стороны, это позволяет быстро подогнаться под обучающие данные. С другой — бесконтрольный рост дерева в глубину неизбежно ведет к переобучению, поэтому LightGBM позволяет помимо количества вершин ограничивать и максимальную глубину. Впрочем, это ограничение обычно все равно выше, чем для XGBoost и CatBoost.\n\n![tree](https://yastatic.net/s3/education-portal/media/tree_lightgbm_b27000abd5_dcdf18005a.webp)\n\nXGBoost строит деревья по принципу: «Строим дерево последовательно по уровням до достижения максимальной глубины». Отдельного ограничения на количество вершин нет, так как оно естественным образом получается из ограничения на глубину дерева. В XGBoost деревья «стремятся» быть симметричными по глубине, и в идеале получается полное бинарное дерево, если это не противоречит другим ограничениям (например, ограничению на минимальное количество объектов в листе). Такие деревья обычно являются более устойчивыми к переобучению.\n\n![tree](https://yastatic.net/s3/education-portal/media/tree_xgboost_e0caf19935_5029e855a6.webp)\n\nCatBoost строит деревья по принципу: «Все вершины одного уровня имеют одинаковый предикат». Одинаковые сплиты во всех вершинах одного уровня позволяют избавиться от ветвлений (конструкций if-else) в коде инференса модели с помощью битовых операций и получить более эффективный код, который в разы ускоряет применение модели, в особенности в случае применения на батчах.\n\nКроме этого, такое ограничение на форму дерева выступает в качестве сильной регуляризации, что делает модель более устойчивой к переобучению. Основной критерий остановки, как и в случае XGBoost, — ограничение на глубину дерева. Однако, в отличие от XGBoost, в CatBoost всегда создаются полные бинарные деревья, несмотря на то, что в некоторые поддеревья может не попасть ни одного объекта из обучающей выборки.\n\n![tree](https://yastatic.net/s3/education-portal/media/tree_catboost_d501cbfe52_d44e880b4e.webp)\n\n### Где используется градиентный бустинг\n\nЕсли коротко — везде.\n\nСегодня это один из двух главных подходов, которые используются на практике (второй — это нейронные сети, конечно). Формально градиентный бустинг слабее и менее гибок, чем сети, но выигрывает в простоте настройки темпа обучения и применения, размере и интерпретируемости модели.\n\nВо многих компаниях, так или иначе связанных с ML, он используется для всех задач, которые не связаны с однородными данными (картинками, текстами, и так далее). Типичный поисковый запрос в Яндексе, выбор отеля на Booking.com или сериала на вечер в Netflix задействует несколько десятков моделей GBDT.\n\nВпрочем, в будущем можно ожидать плавного исчезновения этого подхода, так как улучшение архитектур глубинного обучения и дальнейшее развитие железа нивелирует его преимущество по сравнению с нейросетями.\n\n## Почитать по теме\n\n* [Серия блог-постов](https://explained.ai/gradient-boosting/) о градиентном бустинге от Terence Parr and Jeremy Howard\n* [Раздел документации](https://scikit-learn.org/stable/modules/ensemble.html#mathematical-formulation) sklearn с теоретическими выкладками для градиентного бустинга",
        "handbook": "Учебник по машинному обучению",
        "title": "Градиентный бустинг",
        "description": "Как устроено самое мощное семейство не-нейросетевых моделей: градиентный бустинг над решающими деревьями"
    },
    {
        "path": "/handbook/ml/article/metriki-klassifikacii-i-regressii",
        "content": "<blockquote>\n    <p>Гораздо легче что-то измерить, чем понять, что именно вы измеряете</p>\n    <cite>\n      <b>Джон Уильям Салливан</b>\n    </cite>\n</blockquote>\n\nЗадачи машинного обучения с учителем, как правило, состоят в восстановлении зависимости между парами (признаковое описание, целевая переменная) по данным, доступным нам для анализа. Алгоритмы машинного обучения (learning algorithm), со многими из которых вы уже успели познакомиться, позволяют построить модель, аппроксимирующую эту зависимость. Но как понять, насколько качественной получилась аппроксимация?\n\nПочти наверняка наша модель будет ошибаться на некоторых объектах: будь она даже идеальной, шум или выбросы в тестовых данных всё испортят. При этом разные модели будут ошибаться на разных объектах и в разной степени. Задача специалиста по машинному обучению — подобрать подходящий критерий, который позволит сравнивать различные модели.\n\n**Важно**: качество модели нельзя оценивать на обучающей выборке. Как минимум, это стоит делать на отложенной (тестовой) выборке, но если вам это позволяют время и вычислительные ресурсы, стоит прибегнуть и к более надёжным способам проверки — например, *кросс-валидации* (о ней мы поговорим в следующем параграфе).\n\n## Выбор метрик в реальных задачах\n\nВозможно, вы уже участвовали в соревнованиях по анализу данных. На таких соревнованиях **метрику** (критерий качества модели) организатор выбирает за вас, и она, как правило, довольно понятным образом связана с результатами предсказаний. Но на практике всё бывает намного сложнее.\n\nНапример, мы хотим:\n\n* решить, сколько коробок с бананами нужно завтра привезти в конкретный магазин — чтобы предложение соответствовало спросу, и не пришлось выбрасывать излишки;\n* увеличить счастье пользователя от работы с сервисом, чтобы он стал лояльным и приносил стабильный прогнозируемый доход;\n* решить, нужно ли направить человека на дополнительное обследование.\n\nВ каждом конкретном случае может возникать целая иерархия метрик. Представим, например, что речь идёт о стриминговом музыкальном сервисе, пользователей которого мы решили порадовать сгенерированными самодельной нейросетью треками — не защищёнными авторским правом, а потому совершенно бесплатными.\n\nИерархия метрик могла бы иметь такой вид:\n\n1. Самый верхний уровень: будущий доход сервиса — невозможно измерить в моменте, сложным образом зависит от совокупности всех наших усилий;\n2. Медианная длина сессии, возможно, служащая оценкой радости пользователей, которая, как мы надеемся, повлияет на их желание продолжать платить за подписку — её нам придётся измерять в продакшене, ведь нас интересует реакция настоящих пользователей на новшество;\n3. Доля удовлетворённых качеством сгенерированной музыки асессоров, на которых мы потестируем её до того, как выставить на суд пользователей;\n4. Функция потерь, на которую мы будем обучать генеративную сеть.\n\nНа этом примере мы можем заметить сразу несколько общих закономерностей. Во-первых, метрики бывают **offline** и **online** (**оффлайновыми** и **онлайновыми**). Online-метрики вычисляются по данным, собираемым с работающей системы (например, медианная длина сессии). Offline-метрики могут быть измерены до введения модели в эксплуатацию, например, по историческим данным или с привлечением специальных людей, асессоров.\n\nПоследнее часто применяется, когда метрика — это реакция живого человека: скажем, так поступают поисковые компании, которые предлагают людям оценить качество ранжирования экспериментальной системы ещё до того, как рядовые пользователи увидят эти результаты в обычном порядке. На самом же нижнем этаже иерархии лежат оптимизируемые в ходе обучения функции потерь.\n\nВ данном разделе нас будут интересовать offline-метрики, которые могут быть измерены без привлечения людей.\n\n## Функция потерь $\\neq$ метрика качества\n\nКак мы узнали ранее, методы обучения реализуют разные подходы к обучению:\n\n* обучение на основе прироста информации (как в деревьях решений);\n* обучение на основе сходства (как в методах ближайших соседей);\n* обучение на основе вероятностной модели данных (например, максимизацией правдоподобия);\n* обучение на основе ошибок (минимизация эмпирического риска).\n\nИ в рамках обучения на основе минимизации ошибок мы уже отвечали на вопрос: как можно штрафовать модель за предсказание на обучающем объекте.\n\nВо время сведения задачи о построении решающего правила к задаче численной оптимизации, мы вводили понятие функции потерь и, обычно, объявляли целевой функцией сумму потерь от предсказаний на всех объектах обучающей выборки.\n\nВажно понимать разницу между функцией потерь и метрикой качества. Её можно сформулировать следующим образом:\n\n* Функция потерь возникает в тот момент, когда мы сводим задачу построения модели к задаче оптимизации. Обычно требуется, чтобы она обладала хорошими свойствами (например, дифференцируемостью).\n\n* Метрика — внешний, объективный критерий качества, обычно зависящий не от параметров модели, а только от предсказанных меток.\n\nВ некоторых случаях метрика может совпадать с функцией потерь. Например, в задаче регрессии MSE играют роль как функции потерь, так и метрики. Но, скажем, в задаче бинарной классификации они почти всегда различаются: в качестве функции потерь может выступать кросс-энтропия, а в качестве метрики — **число верно угаданных меток** (**accuracy**). Отметим, что в последнем примере у них различные аргументы: на вход кросс-энтропии нужно подавать логиты, а на вход accuracy — предсказанные метки (то есть по сути argmax логитов).\n\n## Бинарная классификация: метки классов\n\nПерейдём к обзору метрик и начнём с самой простой разновидности классификации — бинарной, а затем постепенно будем наращивать сложность.\n\nНапомним постановку задачи бинарной классификации: нам нужно по обучающей выборке $\\\\{(x_i, y_i)\\\\}_{i=1}^N$, где $y_i\\in\\\\{0, 1\\\\}$ построить модель, которая по объекту $x$ предсказывает метку класса $f(x)\\in\\\\{0, 1\\\\}$.\n\nПервый критерий качества, который приходит в голову, — **accuracy**, то есть доля объектов, для которых мы правильно предсказали класс:\n\n$$\\color{#348FEA}{\\text{Accuracy}(y, y^{pred}) = \\frac{1}{N} \\sum_{i=1}^N \\mathbb{I}[y_i = f(x_i)]} \n$$\n\nИли же сопряженная ей метрика — **доля ошибочных классификаций** (**error rate**):\n\n$$\\text{Error rate} = 1 - \\text{Accuracy}\n$$\n\nПознакомившись чуть внимательнее с этой метрикой, можно заметить, что у неё есть несколько недостатков:\n\n* она не учитывает дисбаланс классов. Например, в задаче диагностики редких заболеваний классификатор, предсказывающий всем пациентам отсутствие болезни будет иметь достаточно высокую accuracy просто потому, что больных людей в выборке намного меньше;\n* она также не учитывает цену ошибки на объектах разных классов. Для примера снова можно привести задачу медицинской диагностики: если ошибочный положительный диагноз для здорового больного обернётся лишь ещё одним обследованием, то ошибочно отрицательный вердикт может повлечь роковые последствия.\n\n### Confusion matrix (матрица ошибок)\n\nИсторически задача бинарной классификации — это задача об обнаружении чего-то редкого в большом потоке объектов, например, поиск человека, больного туберкулёзом, по флюорографии. Или задача признания пятна на экране приёмника радиолокационной станции бомбардировщиком, представляющем угрозу охраняемому объекту (в противовес стае гусей).\n\nПоэтому класс, который представляет для нас интерес, называется «положительным», а оставшийся — «отрицательным».\n\nЗаметим, что для каждого объекта в выборке возможно 4 ситуации:\n\n* мы предсказали *положительную* метку и *угадали*.  Будет относить такие объекты к **true positive** (**TP**) группе. True — потому что предсказали мы правильно, а positive — потому что предсказали положительную метку;\n* мы предсказали *положительную* метку, но *ошиблись* в своём предсказании — **false positive** (**FP**). False, потому что предсказание было неправильным;\n* мы предсказали *отрицательную* метку и *угадали* — **true negative** (**TN**);\n* и наконец, мы предсказали *отрицательную* метку, но *ошиблись* — **false negative** (**FN**).\n  Для удобства все эти 4 числа изображают в виде таблицы, которую называют **confusion matrix** (**матрицей ошибок**):\n\n![6](https://yastatic.net/s3/education-portal/media/6_1_30cbee6683_c3501f5f67.webp)\n\nНе волнуйтесь, если первое время эти обозначения будут сводить вас с ума (будем откровенны, даже профи со стажем в них порой путаются), однако логика за ними достаточно простая: первая часть названия группы показывает угадали ли мы с классом, а вторая — какой класс мы предсказали.\n\n![6](https://yastatic.net/s3/education-portal/media/6_2_32713f12dd_1b17ad9844.webp)\n\n**Пример**\n\nПопробуем воспользоваться введёнными метриками в боевом примере: сравним работу нескольких моделей классификации на [Breast cancer wisconsin (diagnostic) dataset](https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+\\(Diagnostic\\)).\n\nОбъекты выборки — фотографии биопсии грудных опухолей. С их помощью было сформировано признаковое описание, которое заключается в характеристиках ядер клеток (таких как радиус ядра, его текстура, симметричность). Положительным классом в такой постановке будут злокачественные опухоли, а отрицательным — доброкачественные.\n\n**Модель 1. Константное предсказание**\n\nРешение задачи начнём с самого простого классификатора, который выдаёт на каждом объекте константное предсказание — самый часто встречающийся класс.\n\n{% cut \"Зачем вообще замерять качество на такой модели?\" %}\n\nПри разработке модели машинного обучения для проекта всегда желательно иметь некоторую baseline модель. Так нам будет легче проконтролировать, что наша более сложная модель действительно даёт нам прирост качества.\n\n{% endcut %}\n\n```python\nfrom sklearn.datasets \nimport load_breast_cancer \nthe_data = load_breast_cancer()    \n\n# 0 — «доброкачественный» \n# 1 — «злокачественный» \nrelabeled_target = 1 - the_data[\"target\"] \n\nfrom sklearn.model_selection import train_test_split \nX = the_data[\"data\"] \ny = relabeled_target \nX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) \n\nfrom sklearn.dummy import DummyClassifier \ndc_mf = DummyClassifier(strategy=\"most_frequent\") \ndc_mf.fit(X_train, y_train) \n\nfrom sklearn.metrics import confusion_matrix \ny_true = y_test y_pred = dc_mf.predict(X_test) \ndc_mf_tn, dc_mf_fp, dc_mf_fn, dc_mf_tp = confusion_matrix(y_true, y_pred, labels = [0, 1]).ravel() \n```\n\n#|\n||\n\n\n|\n\nПрогнозируемый    класс \\+\n\n|\n\nПрогнозируемый класс -\n\n||\n||\n\nИстинный класс \\+\n\n|\n\nTP = 0\n\n|\n\nFN = 53\n\n||\n||\n\nИстинный класс -\n\n|\n\nFP = 0\n\n|\n\nTN = 90\n\n||\n|#\n\nОбучающие данные таковы, что наш dummy-классификатор все объекты записывает в отрицательный класс, то есть признаёт все опухоли доброкачественными. Такой наивный подход позволяет нам получить минимальный штраф за FP (действительно, нельзя ошибиться в предсказании, если положительный класс вообще не предсказывается), но и максимальный штраф за FN (в эту группу попадут все злокачественные опухоли).\n\n**Модель 2. Случайный лес.**\n\nНастало время воспользоваться всем арсеналом моделей машинного обучения, и начнём мы со случайного леса.\n\n```python\nfrom sklearn.ensemble import RandomForestClassifier \nrfc = RandomForestClassifier()       \nrfc.fit(X_train, y_train)       \ny_true = y_test       \ny_pred = rfc.predict(X_test)       \nrfc_tn, rfc_fp, rfc_fn, rfc_tp = confusion_matrix(y_true, y_pred, labels = [0, 1]).ravel()\n```\n\n#|\n||\n\n\n|\n\nПрогнозируемый класс \\+\n\n|\n\nПрогнозируемый класс -\n\n||\n||\n\nИстинный класс \\+\n\n|\n\nTP = 52\n\n|\n\nFN = 1\n\n||\n||\n\nИстинный класс -\n\n|\n\nFP = 4\n\n|\n\nTN = 86\n\n||\n|#\n\nМожно сказать, что этот классификатор чему-то научился, так как главная диагональ матрицы стала содержать все объекты из отложенной выборки, за исключением 4 \\+ 1 = 5 объектов (сравните с 0 \\+ 53 объектами dummy-классификатора, все опухоли объявляющего доброкачественными).\n\nОтметим, что вычисляя долю недиагональных элементов, мы приходим к метрике **error rate**, о которой мы говорили в самом начале:\n\n$$\\text{Error rate} = \\frac{FP + FN}{ TP + TN + FP + FN}\n$$\n\nтогда как доля объектов, попавших на главную диагональ — это как раз таки accuracy:\n\n$$\\text{Accuracy} = \\frac{TP + TN}{ TP + TN + FP + FN}\n$$\n\n**Модель 3. Метод опорных векторов.**\n\nДавайте построим еще один классификатор на основе линейного метода опорных векторов.\n\n**Важно**: Не забудьте привести признаки к единому масштабу, иначе численный алгоритм не сойдется к решению и мы получим гораздо более плохо работающее решающее правило. Попробуйте проделать это упражнение.\n\n```python\nfrom sklearn.svm import LinearSVC\nfrom sklearn.preprocessing import StandardScaler \nss = StandardScaler() ss.fit(X_train) \nscaled_linsvc = LinearSVC(C=0.01,random_state=42) \nscaled_linsvc.fit(ss.transform(X_train), y_train) \ny_true = y_test \ny_pred = scaled_linsvc.predict(ss.transform(X_test)) \ntn, fp, fn, tp = confusion_matrix(y_true, y_pred, labels = [0, 1]).ravel() \n```\n\n#|\n||\n\n\n|\n\nПрогнозируемый класс \\+\n\n|\n\nПрогнозируемый класс -\n\n||\n||\n\nИстинный класс \\+\n\n|\n\nTP = 50\n\n|\n\nFN = 3\n\n||\n||\n\nИстинный класс -\n\n|\n\nFP = 1\n\n|\n\nTN = 89\n\n||\n|#\n\n**Сравним результаты**\n\nЛегко заметить, что каждая из двух моделей лучше классификатора-пустышки, однако давайте попробуем сравнить их между собой. С точки зрения *error rate* модели практически одинаковы: 5/143 для леса против 4/143 для SVM.\n\nПосмотрим на структуру ошибок чуть более внимательно: лес — (FP = 4, FN = 1), SVM — (FP = 1, FN = 3). Какая из моделей предпочтительнее?\n\n**Замечание**: Мы сравниваем несколько классификаторов на основании их предсказаний на отложенной выборке. Насколько ошибки данных классификаторов зависят от разбиения исходного набора данных? Иногда в процессе оценки качества мы будем получать модели, чьи показатели эффективности будут статистически неразличимыми.\n\nПусть мы учли предыдущее замечание и эти модели действительно статистически значимо ошибаются в разную сторону. Мы встретились с очевидной вещью: на матрицах нет отношения порядка. Когда мы сравнивали dummy-классификатор и случайный лес с помощью Accuracy, мы всю сложную структуру ошибок свели к одному числу, так как на вещественных числах отношение порядка есть. Сводить оценку модели к одному числу очень удобно, однако не стоит забывать, что у вашей модели есть много аспектов качества.\n\nЧто же всё-таки важнее уменьшить: FP или FN? Вернёмся к задаче:\n\n* FP — доля доброкачественных опухолей, которым ошибочно присваивается метка злокачественной;\n* FN — доля злокачественных опухолей, которые классификатор пропускает.\n\nВ такой постановке становится понятно, что при сравнении выиграет модель с меньшим FN (то есть лес в нашем примере), ведь каждая не обнаруженная опухоль может стоить человеческой жизни.\n\nРассмотрим теперь другую задачу: по данным о погоде предсказать, будет ли успешным запуск спутника. FN в такой постановке — это ошибочное предсказание неуспеха, то есть не более, чем упущенный шанс (если вас, конечно не уволят за срыв сроков). С FP всё серьёзней: если вы предскажете удачный запуск спутника, а на деле он потерпит крушение из-за погодных условий, то ваши потери будут в разы существеннее.\n\nИтак, из примеров мы видим, что в текущем виде введенная нами **доля ошибочных классификаций** не даст нам возможности учесть неравную важность FP и FN. Поэтому введем две новые метрики: точность и полноту.\n\n### Точность и полнота\n\nAccuracy - это метрика, которая характеризует качество модели, агрегированное по всем классам. Это полезно, когда классы для нас имеют одинаковое значение. В случае, если это не так, accuracy может быть обманчивой.\n\nРассмотрим ситуацию, когда положительный класс это событие редкое. Возьмем в качестве примера поисковую систему - в нашем хранилище хранятся миллиарды документов, а релевантных к конкретному поисковому запросу на несколько порядков меньше.\n\nПусть мы хотим решить задачу бинарной классификации «документ d релевантен по запросу q». Благодаря большому дисбалансу, Accuracy dummy-классификатора, объявляющего все документы нерелевантными, будет близка к единице. Напомним, что $\\text{Accuracy} = \\frac{TP + TN}{TP + TN + FP + FN}$, и в нашем случае высокое значение метрики будет обеспечено членом TN, в то время для пользователей более важен высокий TP.\n\nПоэтому в случае ассиметрии классов, можно использовать метрики, которые не учитывают TN и ориентируются на TP.\n\nЕсли мы рассмотрим долю правильно предсказанных положительных объектов среди всех объектов, предсказанных положительным классом, то мы получим метрику, которая называется **точностью (precision)**\n\n$$\\color{#348FEA}{\\text{Precision} = \\frac{TP}{TP + FP}}\n$$\n\nИнтуитивно метрика показывает долю релевантных документов среди всех найденных классификатором. Чем меньше ложноположительных срабатываний будет допускать модель, тем больше будет её Precision.\n\nЕсли же мы рассмотрим долю правильно найденных положительных объектов среди всех объектов положительного класса, то мы получим метрику, которая называется **полнотой (recall)**\n\n$$\\color{#348FEA}{\\text{Recall} = \\frac{TP}{TP + FN}}\n$$\n\nИнтуитивно метрика показывает долю найденных документов из всех релевантных. Чем меньше ложно отрицательных срабатываний, тем выше recall модели.\n\nНапример, в задаче предсказания злокачественности опухоли точность показывает, сколько из определённых нами как злокачественные опухолей действительно злокачественные, а полнота — какую долю злокачественных опухолей нам удалось выявить.\n\nХорошее понимание происходящего даёт следующая картинка:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/6_3_c4ba781675_908f105eb3.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://en.wikipedia.org/wiki/Precision_and_recall\">Источник</a>\n  </figcaption>\n</figure>\n\n### Recall@k, Precision@k\n\nМетрики Recall и Precision хорошо подходят для задачи поиска «документ d релевантен запросу q», когда из списка рекомендованных алгоритмом документов нас интересует только первый. Но не всегда алгоритм машинного обучения вынужден работать в таких жестких условиях. Может быть такое, что вполне достаточно, что релевантный документ попал в первые k рекомендованных.\n\nНапример, в интерфейсе выдачи первые три подсказки видны всегда одновременно и вообще не очень понятно, какой у них порядок. Тогда более честной оценкой качества алгоритма будет «в выдаче D размера k по запросу q нашлись релевантные документы». Для расчёта метрики по всей выборке объединим все выдачи и рассчитаем precision, recall как обычно подокументно.\n\n### F1-мера\n\nКак мы уже отмечали ранее, модели очень удобно сравнивать, когда их качество выражено одним числом. В случае пары Precision-Recall существует популярный способ скомпоновать их в одну метрику - взять их среднее гармоническое. Данный показатель эффективности исторически носит название **F1-меры (F1-measure)**.\n\n$$\\color{#348FEA}{F_1 = \\frac{2}{\\frac{1}{Recall} + \\frac{1}{Precision}}} = \n$$\n\n$$ = 2 \\frac{Recall \\cdot Precision }{Recall + Precision} = \\frac\n{TP} {TP + \\frac{FP + FN}{2}}\n$$\n\nСтоит иметь в виду, что F1-мера предполагает одинаковую важность Precision и Recall, если одна из этих метрик для вас приоритетнее, то можно воспользоваться $F_{\\beta}$ мерой:\n\n$$F_{\\beta} = (\\beta^2 + 1) \\frac{Recall \\cdot Precision }{Recall + \\beta^2Precision}\n$$\n\n## Бинарная классификация: вероятности классов\n\nМногие модели бинарной классификации устроены так, что класс объекта получается бинаризацией выхода классификатора по некоторому фиксированному порогу:\n\n$$f\\left(x ; w, w_{0}\\right)=\\mathbb{I}\\left[g(x, w) > w_{0}\\right].\n$$\n\nНапример, модель логистической регрессии возвращает оценку вероятности принадлежности примера к положительному классу. Другие модели бинарной классификации обычно возвращают произвольные вещественные значения, но существуют техники, называемые [калибровкой классификатора](https://academy.yandex.ru/handbook/ml/article/kak-ocenivat-veroyatnosti), которые позволяют преобразовать предсказания в более или менее корректную оценку вероятности принадлежности к положительному классу.\n\nКак оценить качество предсказываемых вероятностей, если именно они являются нашей конечной целью? Общепринятой мерой является логистическая функция потерь, которую мы изучали раньше, когда говорили об устройстве некоторых методов классификации (например уже упоминавшейся логистической регрессии).\n\nЕсли же нашей целью является построение прогноза в терминах метки класса, то нам нужно учесть, что в зависимости от порога мы будем получать разные предсказания и разное качество на отложенной выборке. Так, чем ниже порог отсечения, тем больше объектов модель будет относить к положительному классу. Как в этом случае оценить качество модели?\n\n### AUC\n\nПусть мы хотим учитывать ошибки на объектах обоих классов. При уменьшении порога отсечения мы будем находить (правильно предсказывать) всё большее число положительных объектов, но также и неправильно предсказывать положительную метку на всё большем числе отрицательных объектов. Естественным кажется ввести две метрики **TPR** и **FPR**:\n\n**TPR** (**true positive rate**) — это полнота, доля положительных объектов, правильно предсказанных положительными:\n\n$$TPR = \\frac{TP}{P} = \\frac{TP}{TP + FN} \n$$\n\n**FPR** (**false positive rate**) — это доля отрицательных объектов, неправильно предсказанных положительными:\n\n$$FPR = \\frac{FP}{N} = \\frac{FP}{FP + TN}\n$$\n\nОбе эти величины растут при уменьшении порога. Кривая в осях TPR/FPR, которая получается при варьировании порога, исторически называется **ROC-кривой** (**receiver operating characteristics curve**, сокращённо **ROC curve**). Следующий [интерактивный график](https://yastatic.net/s3/academy/ml/roc_auc/roc.html) поможет вам понять поведение ROC-кривой.\n\nЖелтая и синяя кривые показывают распределение предсказаний классификатора на объектах положительного и отрицательного классов соответственно. То есть значения на оси X (на графике с двумя гауссианами) мы получаем из классификатора.\n\n* Если классификатор идеальный, — две кривые разделимы по оси X, — то на правом графике мы получаем ROC-кривую (0,0)-\\>(0,1)-\\>(1,1), площадь под которой равна 1.\n\n* Если классификатор случайный (предсказывает одинаковые метки положительным и отрицательным объектам), то мы получаем ROC-кривую (0,0)-\\>(1,1), площадь под которой равна 0.5.\n\nПоэкспериментируйте с разными вариантами распределения предсказаний по классам и посмотрите, как меняется ROC-кривая.\n\nЧем лучше классификатор разделяет два класса, тем больше площадь (*area under curve*) под ROC-кривой — и мы можем использовать её в качестве метрики. Эта метрика называется **AUC** и она работает благодаря следующему свойству ROC-кривой:\n\n**AUC** равен доле пар объектов вида (объект класса 1, объект класса 0), которые алгоритм верно упорядочил, то есть предсказание классификатора на первом объекте больше:\n\n$$\\color{#348FEA}{\\operatorname{AUC} = \\frac{\\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{N}\\mathbb{I}[y_i < y_j] I^{\\prime}[f(x_{i}) < f(x_{j})]}{\\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{N}\\mathbb{I}[y_i < y_j]}}\n$$\n\n$$I^{\\prime}\\left[f(x_{i}) < f(x_{j})\\right]=\n\\left\\{\n  \\begin{array}{ll}\n    0, & f(x_{i}) > f(x_{j}) \\\\\n    0.5 & f(x_{i}) = f(x_{j}) \\\\\n    1, & f(x_{i}) < f(x_{j})\n  \\end{array}\n\\right.\n$$\n\n$$I\\left[y_{i}< y_{j}\\right]=\n\\left\\{\n  \\begin{array}{ll}\n    0, & y_{i} \\geq y_{j} \\\\\n    1, & y_{i} < y_{j}\n  \\end{array}\n\\right.\n$$\n\nЧтобы детальнее разобраться, почему это так, советуем вам обратиться к [материалам А.Г.Дьяконова](https://dyakonov.org/2017/07/28/auc-roc-%D0%BF%D0%BB%D0%BE%D1%89%D0%B0%D0%B4%D1%8C-%D0%BF%D0%BE%D0%B4-%D0%BA%D1%80%D0%B8%D0%B2%D0%BE%D0%B9-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA/).\n\nВ каких случаях лучше отдать предпочтение этой метрике? Рассмотрим следующую задачу: некоторый сотовый оператор хочет научиться предсказывать, будет ли клиент пользоваться его услугами через месяц. На первый взгляд кажется, что задача сводится к бинарной классификации с метками 1, если клиент останется с компанией и $0$ — иначе.\n\nОднако если копнуть глубже в процессы компании, то окажется, что такие метки практически бесполезны. Компании скорее интересно упорядочить клиентов по вероятности прекращения обслуживания и в зависимости от этого применять разные варианты удержания: кому-то прислать скидочный купон от партнёра, кому-то предложить скидку на следующий месяц, а кому-то и новый тариф на особых условиях.\n\nТаким образом, в любой задаче, где нам важна не метка сама по себе, а правильный порядок на объектах, имеет смысл применять AUC.\n\nУтверждение выше может вызывать у вас желание использовать AUC в качестве метрики в задачах ранжирования, но мы призываем вас быть аккуратными.\n\n{% cut \"Подробнее\" %}\n\nПродемонстрируем это на следующем примере: пусть наша выборка состоит из $9100$ объектов класса $0$ и $10$ объектов класса $1$, и модель расположила их следующим образом:\n\n$$\\underbrace{0 \\dots 0}_{9000} ~ \\underbrace{1 \\dots 1}_{10} ~ \\underbrace{0 \\dots 0}_{100}\n$$\n\nТогда AUC будет близка к единице: количество пар правильно расположенных объектов будет порядка $90000$, в то время как общее количество пар порядка $91000$.\n\nОднако самыми высокими по вероятности положительного класса будут совсем не те объекты, которые мы ожидаем.\n\n{% endcut %}\n\n### Average Precision\n\nБудем постепенно уменьшать порог бинаризации. При этом полнота будет расти от $0$ до $1$, так как будет увеличиваться количество объектов, которым мы приписываем положительный класс (а количество объектов, на самом деле относящихся к положительному классу, очевидно, меняться не будет).\n\nПро точность же нельзя сказать ничего определённого, но мы понимаем, что скорее всего она будет выше при более высоком пороге отсечения (мы оставим только объекты, в которых модель «уверена» больше всего). Варьируя порог и пересчитывая значения Precision и Recall на каждом пороге, мы получим некоторую кривую примерно следующего вида:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/6_4_99f6621d79_48bf9f5797.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html\">Источник</a>\n  </figcaption>\n</figure>\n\nРассмотрим среднее значение точности (оно равно площади под кривой точность-полнота):\n\n$$\\text { AP }=\\int_{0}^{1} p(r) d r\n$$\n\nПолучим показатель эффективности, который называется **average precision**. Как в случае матрицы ошибок мы переходили к скалярным показателям эффективности, так и в случае с кривой точность-полнота мы охарактеризовали ее в виде числа.\n\n## Многоклассовая классификация\n\nЕсли классов становится больше двух, расчёт метрик усложняется. Если задача классификации на $K$ классов ставится как $K$ задач об отделении класса $i$ от остальных ($i=1,\\ldots,K$), то для каждой из них можно посчитать свою матрицу ошибок. Затем есть два варианта получения итогового значения метрики из $K$ матриц ошибок:\n\n1. Усредняем элементы матрицы ошибок (TP, FP, TN, FN) между бинарными классификаторами, например $TP = \\frac{1}{K}\\sum_{i=1}^{K}TP_i$. Затем по одной усреднённой матрице ошибок считаем Precision, Recall, F-меру. Это называют **микроусреднением**.\n2. Считаем Precision, Recall для каждого классификатора отдельно, а потом усредняем. Это называют **макроусреднением**.\n\nПорядок усреднения влияет на результат в случае дисбаланса классов. Показатели TP, FP, FN — это счётчики объектов. Пусть некоторый класс обладает маленькой мощностью (обозначим её $M$). Тогда значения TP и FN при классификации этого класса против остальных будут не больше $M$, то есть тоже маленькие. Про FP мы ничего уверенно сказать не можем, но скорее всего при дисбалансе классов классификатор не будет предсказывать редкий класс слишком часто, потому что есть большая вероятность ошибиться. Так что FP тоже мало. Поэтому усреднение первым способом сделает вклад маленького класса в общую метрику незаметным. А при усреднении вторым способом среднее считается уже для нормированных величин, так что вклад каждого класса будет одинаковым.\n\nРассмотрим пример. Пусть есть датасет из объектов трёх цветов: желтого, зелёного и синего. Желтого и зелёного цветов почти поровну — 21 и 20 объектов соответственно, а синих объектов всего 4.\n\n![6](https://yastatic.net/s3/education-portal/media/6_5_39d7ed0a4b_4172960c78.webp)\n\nМодель по очереди для каждого цвета пытается отделить объекты этого цвета от объектов оставшихся двух цветов. Результаты классификации проиллюстрированы матрицей ошибок. Модель «покрасила» в жёлтый 25 объектов, 20 из которых были действительно жёлтыми (левый столбец матрицы). В синий был «покрашен» только один объект, который на самом деле жёлтый (средний столбец матрицы). В зелёный — 19 объектов, все на самом деле зелёные (правый столбец матрицы).\n\n![6](https://yastatic.net/s3/education-portal/media/6_6_345d577f40_4611fec57e.webp)\n\nПосчитаем Precision классификации двумя способами:\n\n1. С помощью микроусреднения получаем\n\n$$\\text{Precision} = \\frac{\\dfrac{1}{3}\\left(20 + 0 + 19\\right)}{\\dfrac{1}{3}\\left(20 + 0 + 19\\right) + \\dfrac{1}{3}\\left(5 + 1 + 0\\right)} = 0.87\n$$\n\n2. С помощью макроусреднения получаем\n\n$$\\text{Precision} = \\dfrac{1}{3}\\left( \\frac{20}{20 + 5} + \\frac{0}{0 + 1} + \\frac{19}{19 + 0}\\right) = 0.6\n$$\n\nВидим, что макроусреднение лучше отражает тот факт, что синий цвет, которого в датасете было совсем мало, модель практически игнорирует.\n\n## Как оптимизировать метрики классификации?\n\nПусть мы выбрали, что метрика качества алгоритма будет $F(a(X), Y)$. Тогда мы хотим обучить модель так, чтобы $F$ на валидационной выборке была минимальная/максимальная. Лучший способ добиться минимизации метрики $F$ — оптимизировать её напрямую, то есть выбрать в качестве функции потерь ту же $F(a(X), Y)$. К сожалению, это не всегда возможно. Рассмотрим, как оптимизировать метрики иначе.\n\nМетрики precision и recall невозможно оптимизировать напрямую, потому что эти метрики нельзя рассчитать на одном объекте, а затем усреднить. Они зависят от того, какими были правильная метка класса и ответ алгоритма на всех объектах. Чтобы понять, как оптимизировать precision, recall, рассмотрим, как расчитать эти метрики на отложенной выборке.\nПусть модель обучена на стандартную для классификации функцию потерь (LogLoss).\n\nДля получения меток класса специалист по машинному обучению сначала применяет на объектах модель и получает вещественные предсказания модели ($p_i \\in \\left(0, 1\\right)$). Затем предсказания бинаризуются по порогу, выбранному специалистом: если предсказание на объекте больше порога, то метка класса 1 (или «положительная»), если меньше — 0 (или «отрицательная»). Рассмотрим, что будет с метриками precision, recall в крайних положениях порога.\n\n**Пусть порог равен нулю**\n\nТогда всем объектам будет присвоена положительная метка. Следовательно, все объекты будут либо TP, либо FP, потому что отрицательных предсказаний нет, $TP + FP = N$, где $N$ — размер выборки. Также все объекты, у которых метка на самом деле 1, попадут в TP.\n\nПо формуле точность $\\text{Precision} = \\frac{TP}{TP + FP} = \\frac1N \\sum_{i = 1}^N \\mathbb{I} \\left[ y_i = 1 \\right]$ равна среднему таргету в выборке. А полнота $\\text{Recall} = \\frac{TP}{TP + FN} = \\frac{TP}{TP + 0} = 1$ равна единице.\n\n**Пусть теперь порог равен единице**\n\nТогда ни один объект не будет назван положительным, $TP = FP = 0$. Все объекты с меткой класса 1 попадут в FN. Если есть хотя бы один такой объект, то есть $FN \\ne 0$, будет верна формула $\\text{Recall} = \\frac{TP}{TP + FN} = \\frac{0}{0+ FN} = 0$.\n\nТо есть при пороге единица, полнота равна нулю. Теперь посмотрим на точность. Формула для Precision состоит только из счётчиков положительных ответов модели (TP, FP). При единичном пороге они оба равны нулю, $\\text{Precision} = \\frac{TP}{TP + FP} = \\frac{0}{0 + 0}$то есть при единичном пороге точность неопределена. Пусть мы отступили чуть-чуть назад по порогу, чтобы хотя бы несколько объектов были названы моделью положительными.\n\nСкорее всего это будут самые «простые» объекты, которые модель распознает хорошо, потому что её предсказание близко к единице. В этом *предположении* $FP \\approx 0$. Тогда точность $\\text{Precision} = \\frac{TP}{TP + FP} \\approx \\frac{TP}{TP + 0} \\approx 1$ будет близка к единице.\n\nИзменяя порог, между крайними положениями, получим графики Precision и Recall, которые выглядят как-то так:\n\n![6](https://yastatic.net/s3/education-portal/media/6_7_286c6fd4d1_eb7cc4d9a2.webp)\n\nRecall меняется от единицы до нуля, а Precision от среднего тагрета до какого-то другого значения (нет гарантий, что график монотонный).\n\nИтого оптимизация precision и recall происходит так:\n\n1. Модель обучается на стандартную функцию потерь (например, LogLoss).\n2. Используя вещественные предсказания на валидационной выборке, перебирая разные пороги от 0 до 1, получаем графики метрик в зависимости от порога.\n3. Выбираем нужное сочетание точности и полноты.\n\nПусть теперь мы хотим максимизировать метрику **AUC**. Стандартный метод оптимизации, градиентный спуск, предполагает, что функция потерь дифференцируема. AUC этим качеством не обладает, то есть мы не можем оптимизировать её напрямую. Поэтому для метрики AUC приходится изменять оптимизационную задачу.\n\nМетрика AUC считает долю верно упорядоченных пар. Значит от исходной выборки можно перейти к выборке упорядоченных пар объектов. На этой выборке ставится задача классификации: метка класса 1 соответствует правильно упорядоченной паре, 0 — неправильно.\n\nНовой метрикой становится accuracy — доля правильно классифицированных объектов, то есть доля правильно упорядоченных пар. Оптимизировать accuracy можно по той же схеме, что и precision, recall: обучаем модель на LogLoss и предсказываем вероятности положительной метки у объекта выборки, считаем accuracy для разных порогов по вероятности и выбираем понравившийся.\n\n## Регрессия\n\nВ задачах регрессии целевая метка у нас имеет потенциально бесконечное число значений. И природа этих значений, обычно, связана с каким-то процессом измерений:\n\n* величина температуры в определенный момент времени на метеостанции\n* количество прочтений статьи на сайте\n* количество проданных бананов в конкретном магазине, сети магазинов или стране\n* дебит добывающей скважины на нефтегазовом месторождении за месяц и т.п.\n\nМы видим, что иногда метка это целое число, а иногда произвольное вещественное число. Обычно случаи целочисленных меток моделируют так, словно это просто обычное вещественное число. При таком подходе может оказаться так, что модель A лучше модели B по некоторой метрике, но при этом предсказания у модели A могут быть не целыми. Если в бизнес-задаче ожидается именно целочисленный ответ, то и оценивать нужно огрубление.\n\nОбщая рекомендация такова: оценивайте весь каскад решающих правил: и те «внутренние», которые вы получаете в результате обучения, и те «итоговые», которые вы отдаёте бизнес-заказчику.\n\nНапример, вы можете быть удовлетворены, что стали ошибаться не во втором, а только в третьем знаке после запятой при предсказании погоды. Но сами погодные данные измеряются с точностью до десятых долей градуса, а пользователь и вовсе может интересоваться лишь целым числом градусов.\n\nИтак, напомним постановку задачи регрессии: нам нужно по обучающей выборке $\\{(x_i, y_i)\\}_{i=1}^N$, где $y_i \\in \\mathbb{R}$ построить модель f(x).\n\nВеличину $e_i = f(x_i) - y_i$ называют ошибкой на объекте i или регрессионным остатком.\n\nВесь набор ошибок на отложенной выборке может служить аналогом матрицы ошибок из задачи классификации. А именно, когда мы рассматриваем две разные модели, то, глядя на то, как и на каких объектах они ошиблись, мы можем прийти к выводу, что для решения бизнес-задачи нам выгоднее взять ту или иную модель. И, аналогично со случаем бинарной классификации, мы можем начать строить агрегаты от вектора ошибок, получая тем самым разные метрики.\n\n### MSE, RMSE, $R^2$\n\nMSE — одна из самых популярных метрик в задаче регрессии. Она уже знакома вам, так как применяется в качестве функции потерь (или входит в ее состав) во многих ранее рассмотренных методах.\n\n$$MSE(y^{true}, y^{pred}) = \\frac1N\\sum_{i=1}^{N} (y_i - f(x_i))^2 \n$$\n\nИногда для того, чтобы показатель эффективности MSE имел размерность исходных данных, из него извлекают квадратный корень и получают показатель эффективности RMSE.\n\nMSE неограничен сверху, и может быть нелегко понять, насколько «хорошим» или «плохим» является то или иное его значение. Чтобы появились какие-то ориентиры, делают следующее:\n\n* Берут наилучшее константное предсказание с точки зрения MSE — среднее арифметическое меток $\\bar{y}$. При этом чтобы не было подглядывания в test, среднее нужно вычислять по обучающей выборке\n\n* Рассматривают в качестве показателя ошибки:\n\n  $$R^2 = 1 - \\frac{\\sum_{i=1}^{N} (y_i - f(x_i))^2}{\\sum_{i=1}^{N} (y_i - \\bar{y})^2}.\n  $$\n  \n  У идеального решающего правила $R^2$ равен $1$, у наилучшего константного предсказания он равен $0$ на обучающей выборке. Можно заметить, что $R^2$ показывает, какая доля дисперсии таргетов (знаменатель) объяснена моделью.\n\nMSE квадратично штрафует за большие ошибки на объектах. Мы уже видели проявление этого при обучении моделей методом минимизации квадратичных ошибок — там это проявлялось в том, что модель старалась хорошо подстроиться под выбросы.\n\nПусть теперь мы хотим использовать MSE для оценки наших регрессионных моделей. Если большие ошибки для нас действительно неприемлемы, то квадратичный штраф за них — очень полезное свойство (и его даже можно усиливать, повышая степень, в которую мы возводим ошибку на объекте). Однако если в наших тестовых данных присутствуют выбросы, то нам будет сложно объективно сравнить модели между собой: ошибки на выбросах будет маскировать различия в ошибках на основном множестве объектов.\n\nТаким образом, если мы будем сравнивать две модели при помощи MSE, у нас будет выигрывать та модель, у которой меньше ошибка на объектах-выбросах, а это, скорее всего, не то, чего требует от нас наша бизнес-задача.\n\n{% cut \"История из жизни про бананы и квадратичный штраф за ошибку\" %}\n\nИз-за неверно введенных данных метка одного из объектов оказалась в 100 раз больше реального значения. Моделировалась величина при помощи градиентного бустинга над деревьями решений. Функция потерь была MSE.\n\nОднажды уже во время эксплуатации случилось ЧП: у нас появились предсказания, в 100 раз превышающие допустимые из соображений физического смысла значения. Представьте себе, например, что вместо обычных 4 ящиков бананов система предлагала поставить в магазин 400. Были распечатаны все деревья из ансамбля, и мы увидели, что постепенно число ящиков действительно увеличивалось до прогнозных 400.\n\nБыло решено проверить гипотезу, что был выброс в данных для обучения. Так оно и оказалось: всего одна точка давала такую потерю на объекте, что алгоритм обучения решил, что лучше переобучиться под этот выброс, чем смириться с большим штрафом на этом объекте. А в эксплуатации у нас возникли точки, которые плюс-минус попадали в такие же листья ансамбля, что и объект-выброс.\n\nИзбежать такого рода проблем можно двумя способами: внимательнее контролируя качество данных или адаптировав функцию потерь.\n\nАналогично, можно поступать и в случае, когда мы разрабатываем метрику качества: менее жёстко штрафовать за большие отклонения от истинного таргета.\n\n{% endcut %}\n\n### MAE\n\nИспользовать RMSE для сравнения моделей на выборках с большим количеством выбросов может быть неудобно. В таких случаях прибегают к также знакомой вам в качестве функции потери метрике **MAE** (**mean absolute error**):\n\n$$MAE(y^{true}, y^{pred}) = \\frac{1}{N}\\sum_{i=1}^{N} \\left|y_i - f(x_i)\\right| \n$$\n\n### Метрики, учитывающие относительные ошибки\n\nИ MSE и MAE считаются как сумма абсолютных ошибок на объектах.\n\nРассмотрим следующую задачу: мы хотим спрогнозировать спрос товаров на следующий месяц. Пусть у нас есть два продукта: продукт A продаётся в количестве 100 штук, а продукт В в количестве 10 штук. И пусть базовая модель предсказывает количество продаж продукта A как 98 штук, а продукта B как 8 штук. Ошибки на этих объектах добавляют 4 штрафных единицы в MAE.\n\nИ есть 2 модели-кандидата на улучшение. Первая предсказывает товар А 99 штук, а товар B 8 штук. Вторая предсказывает товар А 98 штук, а товар B 9 штук.\n\nОбе модели улучшают MAE базовой модели на 1 единицу. Однако, с точки зрения бизнес-заказчика вторая модель может оказаться предпочтительнее, так как предсказание продажи редких товаров может быть приоритетнее. Один из способов учесть такое требование — рассматривать не абсолютную, а относительную ошибку на объектах.\n\n### MAPE, SMAPE\n\nКогда речь заходит об относительных ошибках, сразу возникает вопрос: что мы будем ставить в знаменатель?\n\nВ метрике **MAPE** (**mean absolute percentage error**) в знаменатель помещают целевое значение:\n\n$$MAPE(y^{true}, y^{pred}) = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{ \\left|y_i - f(x_i)\\right|}{\\left|y_i\\right|} \n$$\n\nС особым случаем, когда в знаменателе оказывается $0$, обычно поступают «инженерным» способом: или выдают за непредсказание $0$ на таком объекте большой, но фиксированный штраф, или пытаются застраховаться от подобного на уровне формулы и переходят к метрике **SMAPE** (**symmetric mean absolute percentage error**):\n\n$$SMAPE(y^{true}, y^{pred}) = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{ 2 \\left|y_i - f(x_i)\\right|}{y_i + f(x_i)} \n$$\n\nЕсли же предсказывается ноль, штраф считаем нулевым.\n\nТаким переходом от абсолютных ошибок на объекте к относительным мы сделали объекты в тестовой выборке равнозначными: даже если мы делаем абсурдно большое предсказание, на фоне которого истинная метка теряется, мы получаем штраф за этот объект порядка 1 в случае MAPE и 2 в случае SMAPE.\n\n### WAPE\n\nКак и любая другая метрика, MAPE имеет свои границы применимости: например, она плохо справляется с прогнозом спроса на товары с прерывистыми продажами. Рассмотрим такой пример:\n\n#|\n||\n\n\n|\n\nПонедельник\n\n|\n\nВторник\n\n|\n\nСреда\n\n||\n||\n\nПрогноз\n\n|\n\n55\n\n|\n\n2\n\n|\n\n50\n\n||\n||\n\nПродажи\n\n|\n\n50\n\n|\n\n1\n\n|\n\n50\n\n||\n||\n\nMAPE\n\n|\n\n10%\n\n|\n\n100%\n\n|\n\n0%\n\n||\n|#\n\nСреднее MAPE — 36.7%, что не очень отражает реальную ситуацию, ведь два дня мы предсказывали с хорошей точностью. В таких ситуациях помогает **WAPE** (**weighted average percentage error**):\n\n$$WAPE(y^{true}, y^{pred}) = \\frac{\\sum_{i=1}^{N} \\left|y_i - f(x_i)\\right|}{\\sum_{i=1}^{N} \\left|y_i\\right|} \n$$\n\nЕсли мы предсказываем идеально, то WAPE = 0, если все предсказания отдаём нулевыми, то WAPE = 1.\n\nВ нашем примере получим WAPE = 5.9%\n\n### RMSLE\n\nАльтернативный способ уйти от абсолютных ошибок к относительным предлагает метрика **RMSLE** (**root mean squared logarithmic error**):\n\n$$RMSLE(y^{true}, y^{pred}| c) = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left(\\vphantom{\\frac12}\\log{\\left(y_i + c \\right)} - \\log{\\left(f(x_i) + c \\right)}\\right)^2 } \n$$\n\nгде нормировочная константа $c$ вводится искусственно, чтобы не брать логарифм от нуля. Также по построению видно, что метрика пригодна лишь для неотрицательных меток.\n\n### Веса в метриках\n\nВсе вышеописанные метрики легко допускают введение весов для объектов. Если мы из каких-то соображений можем определить стоимость ошибки на объекте, можно брать эту величину в качестве веса. Например, в задаче предсказания спроса в качестве веса можно использовать стоимость объекта.\n\n### Доля предсказаний с абсолютными ошибками больше, чем d\n\nЕще одним способом охарактеризовать качество модели в задаче регрессии является доля предсказаний с абсолютными ошибками больше заданного порога $d$:\n\n$$\\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{I}\\left[ \\left| y_i - f(x_i) \\right| > d \\right] \n$$\n\nНапример, можно считать, что прогноз погоды сбылся, если ошибка предсказания составила меньше 1/2/3 градусов. Тогда рассматриваемая метрика покажет, в какой доле случаев прогноз не сбылся.\n\n## Как оптимизировать метрики регрессии?\n\nПусть мы выбрали, что метрика качества алгоритма будет $F(a(X), Y)$. Тогда мы хотим обучить модель так, чтобы F на валидационной выборке была минимальная/максимальная. Аналогично задачам классификации лучший способ добиться минимизации метрики $F$ — выбрать в качестве функции потерь ту же $F(a(X), Y)$. К счастью, основные метрики для регрессии: MSE, RMSE, MAE можно оптимизировать напрямую. С формальной точки зрения MAE не дифференцируема, так как там присутствует модуль, чья производная не определена в нуле. На практике для этого выколотого случая в коде можно возвращать ноль.\n\nДля оптимизации MAPE придётся изменять оптимизационную задачу. Оптимизацию MAPE можно представить как оптимизацию MAE, где объектам выборки присвоен вес $\\frac{1}{\\vert y_i\\vert}$.",
        "handbook": "Учебник по машинному обучению",
        "title": "Метрики классификации и регрессии",
        "description": "Как оценить качество модели для классификации или регрессии и почему для разных задач нужны разные метрики"
    },
    {
        "path": "/handbook/ml/article/kross-validaciya",
        "content": "Кросс-валидация — это процедура для оценки качества работы модели, которая широко применяется в машинном обучении. Она помогает сравнить между собой различные модели и выбрать наилучшую для конкретной задачи.\n\nВ этом разделе мы рассмотрим наиболее распространённые методы кросс-валидации, а также обсудим возможные проблемы, которые могут возникнуть в процессе их применения.\n\n## Hold-out\n\nМетод **hold-out** представляет из себя простое разделение на train и test:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_1_a22d1d013b_d1b3904fa6.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://neptune.ai/blog/cross-validation-in-machine-learning-how-to-do-it-right\">Источник</a>\n  </figcaption>\n</figure>\n\nТакое разделение очень легко реализовать с помощью библиотеки [sklearn](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html):\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n \nX, y = np.arange(1000).reshape((500, 2)), np.arange(500)\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, \n    test_size=0.2, \n    random_state=42\n)\n```\n\nЧтобы оценить модель, вы обучаете её на тренировочном множестве, а результаты измеряете на тестовом. У sklearn по дефолту выставлен параметр `shuffle=True`, то есть перед разделением на тренировочное и тестовое множества происходит перемешивание семплов (и для воспроизводимости такого разбиения нужно фиксировать `random_state`).\n\nА что будет, если не перемешать данные?\n\nЕсли обучение модели не зависит от порядка подачи в неё примеров (что верно, например, для k-NN или решающего дерева), то перемешивание данных влияет только на то, кто в итоге окажется в train и test. Если данные шли какими-то группами, например сначала 800 картинок с кошками, а за ними 200 картинок с собаками, а `train_test_split` был совершён в пропорции 0.8, то модель просто не увидит собак в трейне.\n\nА в случае когда модель обучается с помощью градиентного спуска или его вариации (про различные модификации SGD подробно рассказывается в [параграфе](https://academy.yandex.ru/handbook/ml/article/nejronnye-seti) о нейросетях), отсутствие перемешивания данных может влиять более интересным образом.\n\nВот пример из практики Yandex.Research —  как вы думаете, что не так с графиком обучения данной модели?\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_1b_dedbd700bb_e4f6168c56.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://yadi.sk/i/nUiHl4VPMOCz0g\">Источник: курс Лены Войты по NLP</a>\n  </figcaption>\n</figure>\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nНа графике видна периодичность по числу итераций! По большим пикам можно вычислить места, где проход по данным начался заново. Кроме того, график в конце ползёт вниз, что означает, что модель уже начала переобучаться, выучив последовательность данных на трейне и используя эту информацию больше, чем сами данные.\n\nЕсли данные перемешать, то график обучения станет таким:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_1c_fc36f7f76b_e7a88f91dd.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://yadi.sk/i/nUiHl4VPMOCz0g\">Источник: курс Лены Войты по NLP</a>\n  </figcaption>\n</figure> \n\nМожно привести даже более простой пример, когда отсутствие перемешивания данных может вас сильно подвести. Допустим, у вас большой датасет из миллиона кошек и собак и вам нужно научить модель их различать.\n\nПусть изначальный порядок тренировочных данных такой: сначала подряд идёт полмиллиона картинок с кошками, а затем так же подряд идут картинки с собаками. Тогда модель на первой половине обучения выучит, что на картинке всегда кошка, а за вторую забудет, что учила на первой, и будет всегда предсказывать собак. При этом на сами данные при предсказании она опираться не будет вообще.\n\n{% endcut %}\n\nПродолжим. Если у вас достаточно данных, лучше всегда предусматривать также валидационное множество:\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n \nX, y = np.arange(1000).reshape((500, 2)), np.arange(500)\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, \n    test_size=0.2, \n    random_state=42\n)\nX_train, X_val, y_train, y_val = train_test_split(\n    X_train, y_train, \n    test_size=0.1, \n    random_state=42\n)\n```\n\nЕсли вы перебираете какие-то модели для вашей задачи, то оптимизировать их качества стоит на валидационном множестве, а окончательное сравнение моделей проводить на тестовом множестве.\n\nОптимизация качеств модели может включать в себя подбор гиперпараметров, подбор архитектуры (в случае нейросетей) или подбор оптимального трешолда для максимизации значений целевой метрики (например, вы делаете двуклассовую классификацию, а модель выдаёт непрерывные значения от 0 до 1, которые нужно бинаризовать так, чтобы получить максимальный скор по F1) и так далее.\n\nЕсли же оптимизировать качества моделей и проводить их сравнение на одном и том же множестве, то можно неявно заложить в модели информацию о тестовом множестве и получить результаты хуже ожидаемых на новых данных.\n\nНемного прервёмся на [пример](https://www.johndcook.com/blog/2015/03/17/a-subtle-way-to-over-fit/) — к чему может привести неявное использование моделью тестового множества\n\nПредставьте, что вы хотите обучить модель одномерной линейной регрессии для предсказания ваших данных:\n\n$$  y = mx + b,\n$$\n\nгде $m$ и $b$ — искомые параметры вашей модели.\n\nОднако представьте, что параметр $b$ вам кто-то запретил обучать на тренировочном множестве и для вас у этой модели всего один параметр. Пусть на первой итерации у вас задано какое-то фиксированное $b = b_0$, вы с ним подобрали на трейне лучшее $m$ при данном $b_0$ и замерили качество получившейся модели на тестовом множестве.\n\nНа следующей итерации вы взяли новое значение $b = b_1$, повторили с ним предыдущий шаг и так далее. Теперь пришло время выбирать модель, и из всех них вы выбрали ту, которая показала лучший результат на тестовом множестве. Вам может показаться, что ваша модель с **одним параметром** обучена на трейне и всё хорошо, но на самом деле вы использовали оба множества, чтобы обучить модель с **двумя параметрами**, и теперь ваша тестовая оценка качества модели завышена.\n\nМожет показаться, что этот пример довольно искусственный, но он на самом деле легко переносится на модели любой сложности. Просто представьте себе, что часть обучаемых весов вашей сложной модели вам запретили обучать на трейне и вы начинаете так же, как и выше, оценивать их на тесте, то есть по факту **учить** на тесте.\n\nА чем такая ситуация отличается от подбора *гиперпараметров* модели (которые вы уже действительно не можете обучить на трейне) сразу на тестовом множестве? Вообще говоря, ничем.\n\nПродолжим. Для окончательного применения найденную лучшую модель можно обучить на всех имеющихся данных. Правда, вы не сможете оценить качество получившейся модели, так как у вас уже не будет тестового множества. Чтобы примерно оценить, как будет вести себя модель при добавлении новых данных, вы можете построить **кривые обучения**: графики качества модели на трейне и на тесте в зависимости от числа поданных семплов на вход.\n\nКривые обучения могут выглядеть следующим образом (код для отрисовки таких кривых можно [найти](https://scikit-learn.org/stable/auto_examples/model_selection/plot_learning_curve.html) в документации библиотеки sklearn):\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_2_b49c30e479_3a7cee8402.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://scikit-learn.org/stable/auto_examples/model_selection/plot_learning_curve.html\">Источник</a>\n  </figcaption>\n</figure>\n\nЕсли графики подсказывают, что качество модели по валидационным метрикам продолжает расти, имеет смысл добавить новые данные.\n\nНа картинке выше приведены кривые обучения двух моделей на одном и том же датасете. Модель слева показала итоговые результаты явно хуже модели справа — плюс график качества на валидации у неё близок к плато, хотя и продолжает расти, — а качество модели справа могло бы ещё вырасти при добавлении дополнительных семплов (качество на трейне константно высокое, а на валидации возрастает).\n\n### Стратификация (stratification)\n\nПри простом случайном разделении на тренировочное и тестовое множества (как в примерах выше) может случиться так, что их распределения окажутся не такими, как у всего исходного множества. Проиллюстрируем такую ситуацию на примере случайного разбиения датасета [Iris](https://archive.ics.uci.edu/ml/datasets/iris) на трейн и тест. Распределение классов в данном датасете равномерное:\n\n* $33.3\\%$ Setosa\n* $33.3\\%$ Versicolor\n* $33.3\\%$ Virginica\n\nСлучайное разбиение, в котором две трети цветов (100) отправились в трейн, а оставшаяся треть (50) отправилась в тест, может выглядеть, например, так:\n\n* трейн: 38 $\\times$ Setosa, 28 $\\times$ Versicolor, 34 $\\times$ Virginica (распределение $38\\%:28\\%:34\\%$)\n* тест: 12 $\\times$ Setosa, 22 $\\times$ Versicolor, 16 $\\times$ Virginica (распределение $24\\%:44\\%:32\\%$)\n\nЕсли распределение цветов в исходном датасете отражает то, что в природе они встречаются одинаково часто, то мы только что получили два новых датасета, не соответствующих распределению цветов в природе. Распределения обоих датасетов вышли не только несбалансированными, но ещё и разными: самый частый класс в трейне соответствует наименее частому классу в тесте.\n\nНа помощь в такой ситуации может прийти **стратификация**: разбиение на трейн и тест, сохраняющее соотношение классов, представленное в исходном датасете. В библиотеке sklearn такое разбиение можно получить с помощью параметра `stratify`:\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n \nX, y = np.arange(1000).reshape((500, 2)), np.random.choice(4, size=500, p=[0.1, 0.2, 0.3, 0.4])\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, \n    test_size=0.2, \n    random_state=42,\n    stratify=y\n)\n```\n\nВ целом на достаточно больших датасетах (порядка хотя бы 10 тысяч семплов) со сбалансированными классами можно не очень сильно беспокоиться об описанной выше проблеме и использовать обычный random split.\n\nНо если у вас очень несбалансированные данные, в которых один класс встречается сильно чаще другого (как, например, в задачах фильтрации спама или сегментации осадков на спутниковых снимках), стратификация может довольно сильно помочь.\n\n## k-Fold\n\nМетод **k-Fold** чаще всего имеют в виду, когда говорят о кросс-валидации. Он является обобщением метода hold-out и представляет из себя следующий алгоритм:\n\n1. Фиксируется некоторое целое число $k$ (обычно от 5 до 10), меньшее числа семплов в датасете.\n2. Датасет разбивается на $k$ одинаковых частей (в последней части может быть меньше семплов, чем в остальных). Эти части называются *фолдами*.\n3. Далее происходит $k$ итераций, во время каждой из которых один фолд выступает в роли тестового множества, а объединение остальных — в роли тренировочного. Модель учится на $k - 1$ фолде и тестируется на оставшемся.\n4. Финальный скор модели получается либо усреднением $k$ получившихся тестовых результатов, либо измеряется на отложенном тестовом множестве, не участвовавшем в кросс-валидации.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_3_98fef6af39_2821047743.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://neptune.ai/blog/cross-validation-in-machine-learning-how-to-do-it-right\">Источник</a>\n  </figcaption>\n</figure>\n\nЭтот метод есть в sklearn:\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import KFold\n \nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\ny = np.array([1, 2, 3, 4])\nkf = KFold(n_splits=2)\n \nfor train_index, test_index in kf.split(X):\n    print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n'''\nresult:\nTRAIN: [2 3] TEST: [0 1]\nTRAIN: [0 1] TEST: [2 3]\n'''\n```\n\nВ коде выше получилось два фолда: в первый вошли объекты с индексами 2 и 3, во второй — объекты с индексами 0 и 1. На первой итерации алгоритма фолд с индексами 2 и 3 будет тренировочным, а на второй — фолд с индексами 0 и 1. В sklearn есть также метод `cross_val_score`, принимающий на вход классификатор, данные и способ разбиения данных (либо число фолдов) и возвращающий результаты кросс-валидации:\n\n```python\nfrom sklearn.model_selection import cross_val_score\n \nclf = svm.SVC(kernel='linear', C=1, random_state=42)\nscores = cross_val_score(clf, X, y, cv=5)\nprint(scores)\n'''\nresult:\narray([0.96..., 1. , 0.96..., 0.96..., 1. ])\n'''\n```\n\nИнтересный вопрос состоит в том, какую модель брать для сравнения с остальными на отложенном тестовом множестве (если оно у вас есть) либо для окончательного применения в задаче. После применения k-Fold для одной модели у вас на руках останется $k$ экземпляров (инстансов) этой модели, обученных на разных подмножествах трейна. Возможные варианты:\n\n* делать предсказание с помощью усреднения предсказаний этих $k$ инстансов;\n* из этих $k$ инстансов выбрать тот, который набрал лучший скор на своём тестовом фолде, и применять дальше его;\n* заново обучить модель уже на всех $k$ фолдах и делать предсказания уже этой моделью.\n\nВыбирать, какой способ лучше, нужно в зависимости от конкретной задачи и имеющихся вычислительных возможностей.\n\nМетод k-Fold даёт более надёжную оценку качества модели, чем hold-out, так как обучение и тест модели происходят на разных подмножествах исходного датасета. Однако проведение $k$ итераций обучения и теста может быть вычислительно затратным, и поэтому метод обычно применяют либо когда данных достаточно мало, либо при наличии большого количества вычислительных ресурсов, позволяющих проводить все $k$ итераций параллельно.\n\nВ реальных задачах данных зачастую достаточно много для того, чтобы hold-out давал хорошую оценку качества модели, поэтому k-Fold в больших задачах применяется не очень часто.\n\n### Leave-one-out\n\nМетод **leave-one-out (LOO)** — частный случай метода k-Fold: в нём каждый фолд состоит ровно из одного семпла. LOO тоже есть в библиотеке sklearn:\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import LeaveOneOut\n \nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([1, 2, 3])\nloo = LeaveOneOut()\n \nfor train_index, test_index in loo.split(X):\n    print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n'''\nresult:\nTRAIN: [1 2] TEST: [0]\nTRAIN: [0 2] TEST: [1]\nTRAIN: [0 1] TEST: [2]\n'''\n```\n\nЭтот метод может понадобиться в случае, если у вас очень мало данных, — например, в задаче сегментации клеток на изображениях с оптического микроскопа, — и вы хотите использовать максимальное их количество для обучения модели.\n\nДля валидации на каждой итерации методу требуется всего один семпл, однако и итераций будет столько, сколько семплов в данных, поэтому метод неприменим для средних и больших задач.\n\n### Stratified k-Fold\n\nМетод **stratified k-Fold** — это метод k-Fold, использующий стратификацию при разбиении на фолды: каждый фолд содержит примерно такое же соотношение классов, как и всё исходное множество. Такой подход может потребоваться в случае, например, очень несбалансированного соотношения классов, когда при обычном random split некоторые фолды могут либо вообще не содержать семплов каких-то классов, либо содержать их слишком мало. Этот метод также представлен в sklearn:\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import StratifiedKFold\n \nX = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\ny = np.array([0, 0, 1, 1])\nskf = StratifiedKFold(n_splits=2)\n \nfor train_index, test_index in skf.split(X, y):\n    print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n'''\nresult:\nTRAIN: [1 3] TEST: [0 2]\nTRAIN: [0 2] TEST: [1 3]\n'''\n```\n\n### Кросс-валидация на временных рядах\n\nСуществует такая задача, как прогнозирование временных рядов. На практике она часто возникает в форме «Что будет с показателями нашего продукта в ближайший день / месяц / год?». При этом имеются какие-то исторические данные этих показателей за предыдущее время, которые можно визуализировать в виде некоторого графика по времени:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_4_ef89402b78_919466fe3d.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://habr.com/ru/company/ods/blog/327242/\">Источник</a>\n  </figcaption>\n</figure>\n\nЭтот график — пример графика временного ряда, и наша задача — спрогнозировать, как будет выглядеть данный график в будущие моменты времени. Кросс-валидация моделей для такой задачи осложняется тем, что данные не должны пересекаться по времени: тренировочные данные должны идти до валидационных, а валидационные — до тестовых. С учётом этих особенностей фолды в кросс-валидации для временных рядов располагаются вдоль временной оси так, как показано на следующей картинке:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_5_7849d6b92e_7fc7a11936.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://habr.com/ru/company/ods/blog/327242/\">Источник</a>\n  </figcaption>\n</figure>\n\nВ sklearn реализована такая схема кросс-валидации:\n\n```python\nimport numpy as np\nfrom sklearn.model_selection import TimeSeriesSplit\nX = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\ny = np.array([1, 2, 3, 4, 5, 6])\ntscv = TimeSeriesSplit()\nprint(tscv)\n \nfor train_index, test_index in tscv.split(X):\n    print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n \n'''\nresult:\nTRAIN: [0] TEST: [1]\nTRAIN: [0 1] TEST: [2]\nTRAIN: [0 1 2] TEST: [3]\nTRAIN: [0 1 2 3] TEST: [4]\nTRAIN: [0 1 2 3 4] TEST: [5]\n'''\n```\n\n## Когда стоит заподозрить, что оценка качества модели завышена?\n\nВаша модель показала очень высокое качество на тестовых данных, вы радостно откидываетесь на спинку кресла и достаёте шампанское... Или пока рано? Перед тем как информировать коллег о своих высоких результатах, проверьте, что вы не допустили какую-то из следующих ошибок:\n\n* ваши данные не были перемешаны (вспоминаем пример выше с тензорбордом курильщика);\n* вы подбирали гиперпараметры на тестовом множестве и на нём же оценивали качество модели;\n* у вас в данных есть фича, которая в некотором смысле является «прокси» к таргету (proxy for the target). Это такая фича, которая почти равна таргету, хотя формально им не является и так же, как и таргет, не будет доступна на момент реального применения модели;\n\n{% cut \"Пример\" %}\n\nПусть вы хотите предсказывать, сколько будут зарабатывать выпускники разных вузов с разных факультетов через 10 лет после выпуска. Допустим, что у вас есть разнообразные исторические данные о прошлых выпускниках (какие вуз / школу оканчивали, какие факультеты, в каком городе и так далее), где много колонок, и есть искушение особенно не вглядываться в каждую отдельную колонку, а просто разбить данные на трейн и тест и отправить в модель. Но потом вдруг обнаруживается, что у вас всё это время имелась колонка «Доход через пять лет после выпуска», которая явно скоррелирована с таргетом и является важной для вашей модели, но на момент реального применения модели этой информации у вас не будет. Соответственно, наличием этой колонки во многом и объяснялся высокий скор вашей модели. Мораль: всегда внимательно изучайте свои данные перед обучением моделей.\n\n{% endcut %}\n\n* вы проводили feature engineering на всём датасете, а не только на трейне. Например, вы строили [tf-idf](https://ru.wikipedia.org/wiki/TF-IDF) фичи или [bag-of-words](https://en.wikipedia.org/wiki/Bag-of-words_model) на всех данных, а не только на трейне, тем самым заложив в свои тренировочные данные информацию о тестовых данных;\n* вы применяли [стандартизацию](https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing) данных на всём датасете, а не только на трейне. Например, в случае [StandardScaler](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html) тестовое множество повлияет на используемые этим методом оценки среднего и стандартного отклонения;\n* вы смешали трейн с тестом.\n\nПоследний пункт может звучать очень банально, но на практике часто оказывается, что правильно разделить данные на тренировочные и тестовые не так просто даже с учётом всех описанных выше техник. Об этом в следующих разделах.\n\n### Примеры подмешивания тестовых данных в тренировочные\n\n* Ваши данные зависят от времени, а вы при разбиении на трейн и тест это не учли. Например, вы применили обычный random split при работе с временными рядами, передав тем самым вашей модели информацию из будущего. Или вы предсказываете погоду на несколько часов вперёд, а у вас данные из одного и того же дня находятся и в трейне, и в тесте.\n* У вас есть датасет с картинками, и вы решили увеличить количество семплов в нём с помощью [аугментаций](https://www.tensorflow.org/tutorials/images/data_augmentation?hl=en) (примерами аугментаций могут служить симметричные отражения, повороты, растяжения). При этом вы взяли весь датасет, применили к нему аугментации и только после этого разделили на трейн и тест. В таком случае преобразования какой-то одной картинки могут попасть в оба множества, и вы получите пересечение трейна и теста.\n* Вы решаете задачу рекомендации статей или постов пользователям на основании их комментариев и прочтений, при этом в трейне и тесте у вас одни и те же пользователи.\n* Вы решаете какую-то задачу, где происходит работа с видеоданными. Например, распознаёте движение по видео или предсказываете фамилию актёра, попавшего в кадр. При этом в трейн и тест у вас попадают различные кадры из одного и того же видео.\n* У вас есть спутниковые снимки, и вы хотите по ним предсказывать рельеф местности. При этом у вас в трейне и тесте есть кропы снимков над одними и теми же географическими координатами (хоть и в разное время).\n* Вы обучаете голосового ассистента в звуковом потоке распознавать момент, когда к нему обращаются (например, «Слушай, Алиса», «Ok, Google»). При этом у вас в трейне и тесте одни и те же люди. Это, на первый взгляд, не очень страшная проблема, но на самом деле достаточно большая нейронка может запомнить интонации и манеру речи конкретного человека и будет использовать эти сведения для тестовых записей с этим человеком. При этом на новых людях распознавание будет работать сильно хуже.\n* Вы хотите расширить тренировочный датасет какими-то дополнительными данными из другого датасета, но при этом оказывается, что другой датасет содержит в себе часть тестового множества вашего исходного датасета. Например, есть два публичных датасета: [ImageNet LSVRC 2015](https://academictorrents.com/collection/imagenet-lsvrc-2015), в котором 1000 классов и чуть больше миллиона изображений, и [ImageNet](http://image-net.org/), в котором 21 тысяча классов и чуть больше 14 миллионов изображений. При этом первый полностью содержится во втором, поэтому использование ImageNet для расширения обучающей выборки из ImageNet LSVRC 2015 может закончиться тем, что в трейне окажутся примеры из тестового множества, сформированного из ImageNet LSVRC 2015.\n\n### Ещё один интересный пример, когда что-то пошло не так\n\nПример заимствован [отсюда](https://developers.google.com/machine-learning/data-prep/construct/sampling-splitting/example). Допустим, что вы должны обучить модель, предсказывающую тему новостной статьи по её тексту. Если отсортировать статьи по дате их публикации, то ваши данные могут выглядеть, например, так:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_6_4a97ad2ce5_410a5118ff.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://developers.google.com/machine-learning/data-prep/construct/sampling-splitting/example\">Источник</a>\n  </figcaption>\n</figure> \n\nЗдесь форма и цвет фигуры соответствуют новости, которой посвящена статья. Почему случайное разбиение данных на трейн и тест может привести к проблемам в этой задаче?\n\nНа самом деле новостные статьи с одной и той же тематикой появляются кластерами во времени, так как статьи о новом событии выходят, как правило, порциями в то же время, когда произошло событие. Если разбить данные случайно, то тренировочное и тестовое множества с большой вероятностью будут содержать статьи на одни и те же наборы тем:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_7_4998b50a02_0091ffb9bc.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://developers.google.com/machine-learning/data-prep/construct/sampling-splitting/example\">Источник</a>\n  </figcaption>\n</figure>\n\nТакое разбиение не соответствует тому, как потом модель будет применяться в реальной задаче: при нём модель будет ожидать равномерного распределения тем, предложенных ей в трейне, тогда как в реальности ей на вход будут приходить всё те же кластеры, и они, вообще говоря, не обязаны были быть в её тренировочном множестве. Простым решением будет при разбиении на трейн и тест учитывать время, когда была опубликована статья:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/7_8_7a0bf8731d_497f253c52.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://developers.google.com/machine-learning/data-prep/construct/sampling-splitting/example\">Источник</a>\n  </figcaption>\n</figure>\n\nТут нужно, однако, учитывать, что в реальности кластеры историй по времени выражены не столь чётко и могут пересекаться. Поэтому если трейн и тест расположены слишком близко друг от друга по времени, то они могут пересечься. В принципе, это не так плохо с учётом того, что новости о каких-то событиях могут продолжать выходить в течение некоторого растянутого промежутка времени. Но если хочется избежать такой ситуации, то можно оставить между трейном и тестом некоторый временной зазор: тренироваться, например, на апрельских публикациях, а тестироваться на второй неделе мая, оставив, таким образом, недельный промежуток между двумя множествами.\n\n## Почитать по теме\n\n* [Оригинальный текст](https://developers.google.com/machine-learning/data-prep/construct/sampling-splitting/example) описанного выше примера.\n* [Ещё один классный пример](https://developers.google.com/machine-learning/crash-course/18th-century-literature), когда случайное разбиение данных может испортить ML-модель.\n* [Отличный блог-пост](https://neptune.ai/blog/cross-validation-in-machine-learning-how-to-do-it-right) от Neptune про различные методы кросс-валидации.\n* [Раздел нашего учебника](https://academy.yandex.ru/handbook/ml/article/metriki-klassifikacii-i-regressii), посвящённый сравнению и оценке качества моделей.\n* [Большая статья-обзор](https://arxiv.org/pdf/1811.12808.pdf) про методы сравнения моделей и оценки их качества.\n* [Секция Model Selection](https://scikit-learn.org/stable/model_selection.html) от sklearn.\n* [Блог-пост](https://hunch.net/?p=22) про различные «умные» способы получить завышенные оценки качества моделей.\n* Отличный [гайд](https://www.ritchieng.com/applying-machine-learning/#2c-learning-curves) о том, как читать графики обучающих кривых в разных случаях.\n* [Статья про временные ряды](https://habr.com/ru/company/ods/blog/327242/) из курса «Открытый курс машинного обучения» от ODS\n* [Библиотека Prophet от Facebook](https://facebook.github.io/prophet/docs/quick_start.html##python-api) для прогнозирования временных рядов, у которой есть своя [имплементация кросс-валидации](https://facebook.github.io/prophet/docs/diagnostics.html) с дополнительными фичами (таблицы с результатами кросс-валидации, красивые графики).\n* [Здесь](https://facebook.github.io/prophet/) можно почитать статью с теоретическим обоснованием метода Prophet.\n* [Отличное видео про лики в данных](https://community.datarobot.com/t5/sessions/data-cheats-how-target-leakage-affects-models/ba-p/8220) от DataRobot.\n* [Блог-пост](https://community.datarobot.com/t5/blog/what-is-target-leakage-and-how-do-i-avoid-it/ba-p/1973) на эту же тему от них же.\n* [Статья](https://arxiv.org/pdf/2007.13237.pdf) про методики разбиения данных в рекомендательных системах.",
        "handbook": "Учебник по машинному обучению",
        "title": "Кросс-валидация",
        "description": "Как строить надёжные оценки качества моделей и никогда не смешивать train и test"
    },
    {
        "path": "/handbook/ml/article/podbor-giperparametrov",
        "content": "Для начала поймём, в чём отличие параметров модели от гиперпараметров:\n\n* **параметры** настраиваются в процессе обучения модели на данных. Например, веса в линейной регрессии, нейросетях, структура решающего дерева;\n* **гиперпараметры** — это характеристики модели, которые фиксируются до начала обучения: глубина решающего дерева, значение силы регуляризации в линейной модели, learning rate для градиентного спуска.\n\nРассмотрим, например, модель линейной регрессии:\n\n$$    f(X) = X w, \n$$\n\nгде\n\n* $w = (w_0, w_1, \\ldots, w_n)$ — веса модели;\n* $X = (x_{ij})$ — матрица, в которой каждая строка содержит признаки одного объекта выборки (для удобства записи считаем, что первый столбец в этой матрице константный).\n\nЭта модель может обучаться посредством минимизации следующего функционала:\n\n$$    \\mathcal{L} = \\| y - X w\\|^2 + C \\| w \\|^2, \n$$\n\nгде $y$ — целевая переменная, $C$ — коэффициент регуляризации. В процессе минимизации $\\mathcal{L}$ веса $w$ настраиваются по обучающей выборке, то есть являются параметрами. В то же время величина коэффициента регуляризации задаётся до начала обучения, то есть она — гиперпараметр.\n\n![8](https://yastatic.net/s3/education-portal/media/8_1_16b2ffe33e_47a7a2d8fb.webp)\n\nЕщё хороший пример — решающее дерево. Его гиперпараметры: максимальная глубина дерева, критерий ветвления, минимальное число семплов в листе дерева и ещё много других. А параметр — сама структура решающего дерева: обучение состоит в том, чтобы на каждом уровне дерева выбрать, по какому признаку должно произойти ветвление и с каким пороговым значением этого признака.\n\nКачество модели может очень сильно варьироваться в зависимости от гиперпараметров, поэтому существуют разнообразные методы и инструменты для их подбора. При этом, вне зависимости от выбранного вами метода подбора гиперпараметров, оценку и сравнение моделей нужно проводить грамотно. Пусть у нас есть несколько моделей разной природы (метод ближайших соседей, случайный лес, логистическая регрессия) или несколько нейросеток с разными архитектурами. Нужно для каждой из моделей подобрать гиперпараметры, а затем модели с наилучшими гиперпараметрами сравнить между собой.\n\nЕсть два наиболее часто используемых варианта.\n\n### Первый вариант\n\nРазделить выборку на тренировочную, валидационную и тестовую части, для каждой модели выбирать гиперпараметры, максимизирующие её метрики на валидации, а окончательное сравнение моделей проводить по тестовым метрикам.\n\nРазделения только на тренировочную и тестовую выборки недостаточно, так как в модель через подобранные гиперпараметры просачивается информация о тестовой выборке. Это означает, что на новых данных модели могут не сохранить свои качества и что их сравнение не будет честным.\n\n   <figure>\n    <img src=\"https://yastatic.net/s3/education-portal/media/8_2_b6c8676778_ef9b0cebbe.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n    <figcaption>\n    <a href=\"https://stats.stackexchange.com/questions/410118/cross-validation-vs-train-validation-test\">Источник</a>\n    </figcaption>\n   </figure>\n\n### Второй вариант\n\nПровести [кросс-валидацию](https://en.wikipedia.org/wiki/Cross-validation_\\(statistics\\)).\n\nКросс-валидация может быть нужна в случаях, если данных мало или мы не хотим зависеть от конкретного выбора валидационного множества. Примерный алгоритм:\n\n* зафиксировать некоторое тестовое множество и отложить его;\n* разделить оставшееся множество данных на $k$ фолдов (подмножеств), пройтись по ним циклом, на каждой итерации фиксируя один фолд в качестве валидационного и обучаясь на остальных;\n* в качестве оценки качества модели взять среднее значение валидационной метрики по фолдам;\n* финальное сравнение моделей с уже подобранными гиперпараметрами проводить на отложенном тестовом множестве.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_3_715a0c2b1d_7a496fcd6e.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  Визуализация алгоритма.\n    <a href=\"https://towardsdatascience.com/cross-validation-and-hyperparameter-tuning-how-to-optimise-your-machine-learning-model-13f005af9d7d\">Источник</a>\n  </figcaption>\n</figure>\n\nПодробное описание процесса сравнения моделей между собой можно найти в параграфах, посвящённых [кросс-валидации](https://academy.yandex.ru/handbook/ml/article/kross-validaciya) и [сравнению и оценке качества моделей](https://academy.yandex.ru/handbook/ml/article/metriki-klassifikacii-i-regressii).\n\nДалее мы рассмотрим несколько методов подбора гиперпараметров для моделей, а в конце будет приведён список питоновских библиотек, в которых эти методы реализованы, и дано верхнеуровневое сравнение всех описанных методов между собой.\n\n## Grid Search\n\nСамый естественный способ организовать перебор наборов гиперпараметров — сделать перебор по сетке (**Grid Search**):\n\n* для каждого гиперпараметра фиксируется несколько значений;\n* перебираются все комбинации значений различных гиперпараметров, на каждой из этих комбинаций модель обучается и тестируется;\n* выбирается комбинация, на которой модель показывает лучшее качество.\n\nПримеры:\n\n* для метода ближайших соседей можно, например, перебирать по сетке число соседей (например, от 1 до 20) и метрику, по которой будет измеряться расстояние между объектами выборки (евклидова, манхэттенская и так далее);\n* для решающих деревьев можно перебирать по сетке сочетания значений максимальной глубины дерева и различные критерии ветвления (критерий Джини, энтропийный критерий).\n\nПеребор некоторых значений гиперпараметров можно вести по логарифмической шкале, так как это позволяет быстрее определить правильный порядок параметра и в то же время значительно уменьшить время поиска. Так можно подбирать, например, значение learning rate для градиентного спуска, значение константы регуляризации для линейной регрессии или метода SVM.\n\nСразу же видно естественное ограничение данного метода: если комбинаций параметров слишком много либо каждое обучение / тест длится долго, алгоритм не завершится за разумное время.\n\n## Random Search\n\nЕсли у вас возникает очень большое количество комбинаций параметров, вы можете какими-то способами пытаться справляться с этой проблемой:\n\n* можно взять меньше значений каждого гиперпараметра, но тогда есть шансы пропустить наилучшую комбинацию;\n* можно уменьшить число фолдов в кросс-валидации, но оценка параметров станет более шумной;\n* можно оптимизировать параметры последовательно, а не перебирать их комбинации, но снова есть шанс получить неоптимальное решение;\n* можно перебирать не все комбинации гиперпараметров, а только случайное подмножество.\n\nПоследний способ называется **Random Search**. Для каждого гиперпараметра задаётся распределение, из которого выбирается его значение, и комбинация гиперпараметров составляется семплированием из этих распределений (хорошие советы по поводу выбора распределений можно найти в [документации sklearn](https://scikit-learn.org/stable/modules/grid_search.html#randomized-parameter-search)). Таким образом, благодаря случайному выбору очередной комбинации гиперпараметров вы можете найти оптимальную комбинацию за меньшее число итераций.\n\nВот это изображение хорошо иллюстрирует отличия поиска по сетке от случайного поиска:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_4_5781994f1e_95e59d0869.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://jmlr.csail.mit.edu/papers/volume13/bergstra12a/bergstra12a.pdf\">Источник</a>\n  </figcaption>\n</figure>\n\nТо есть: качество нашей модели в зависимости от гиперпараметров — это функция многих переменных с некоторой нетривиальной поверхностью. Но эта поверхность [может зависеть](https://medium.com/rants-on-machine-learning/smarter-parameter-sweeps-or-why-grid-search-is-plain-stupid-c17d97a0e881#.pkwq17od8) от одной из своих переменных сильно меньше, чем от другой. Если бы мы знали, какой гиперпараметр важнее для перформанса модели, мы бы рассмотрели больше его возможных значений, но часто у нас нет такой информации, и мы рассматриваем некоторое наперёд заданное число значений для каждого гиперпараметра.\n\nRandom Search может за то же число итераций, что и Grid Search, рассмотреть более разнообразные значения гиперпараметров. Тем самым он с большей вероятностью найдёт те значения, которые больше всего влияют на качество модели, а значит, с большей вероятностью найдёт наилучшую комбинацию значений гиперпараметров.\n\nЕсть [ещё одно](https://web.archive.org/web/20160701182750/http://blog.dato.com/how-to-evaluate-machine-learning-models-part-4-hyperparameter-tuning) довольно интересное объяснение, почему Random Search работает хорошо. Рассмотрим случай, когда у нас конечная сетка гиперпараметров (каждому гиперпараметру сопоставлено конечное число значений).\n\nВ этой сетке выделим группу размера $5\\%$ от общего числа наборов гиперпараметров, на которой модель достигает лучшего качества (можно мысленно отранжировать все наборы по качеству в некоторый список и взять топ $5\\%$ этого списка). Тогда некоторый набор гиперпараметров не попадает в эту группу с вероятностью $1 - 0.05$. Если мы насемплировали $n$ наборов, то каждый из них не попал в эту группу с вероятностью $(1 - 0.05)^n$, и, соответственно, вероятность того, что хотя бы один насемплированный набор попал в лучшую группу, равна $1 - (1 - 0.05)^n$. Мы можем решить неравенство\n\n$$    1 - (1 - 0.05)^n \\ge 0.95 \n$$\n\nи выяснить, что при $n \\ge 60$ мы попадём в топ 5% с вероятностью, не меньшей $0.95$. Это в большинстве случаев значительно быстрее, чем перебор всех комбинаций гиперпараметров с помощью Grid Search.\n\nЕсли в рассуждении выше у нас некоторым гиперпараметрам соответствует непрерывное распределение, то всегда можно предположить, что мы уже насемплировали из этих распределений некоторое конечное число значений (равное числу итераций Random Search), а дальше считать, что мы работаем с конечной сеткой.\n\nКонечно, остаётся наша зависимость от самой сетки гиперпараметров, и не всякая сетка обязана содержать в себе глобальный максимум перформанса модели или даже гиперпараметры из интервала вокруг него.\n\n## Exploration vs exploitation\n\nВ машинном обучении достаточно часто встречаются такие термины, как **exploration** и **exploitation**. Суть этих терминов хорошо поясняет следующий пример из реальной жизни. Допустим, перед вами стоит выбор, в какой ресторан пойти сегодня. Пусть ваш любимый ресторан находится прямо за углом.\n\nВы ходите туда каждый день и поэтому достаточно уверены в том, насколько вкусным будет ваш обед. Но при этом не рассматриваете никакие другие опции и, возможно, упускаете возможность поесть гораздо вкуснее в другом месте. Если же вы будете обедать каждый раз в новом месте, то очень часто будете не удовлетворены результатом.\n\n![8](https://yastatic.net/s3/education-portal/media/8_5_d5dff4b143_7276b2c3ca.webp)\n\nВ описанных далее методах подбора гиперпараметров будет так или иначе происходить поиск баланса между exploration и exploitation. Одно из основных отличий всех методов, которые будут описаны далее, от Grid Search и Random Search — возможность учитывать результаты предыдущих вычислений.\n\nОдна из возможных стратегий выбора точки для следующей итерации — *exploration*: исследование тех областей, в которых у нас мало семплов на текущей итерации, что даёт нам возможность с меньшей вероятностью пропустить оптимальное значение.\n\nДругая стратегия — *exploitation*: выбирать больше семплов в областях, которые мы достаточно неплохо изучили и где, как мы считаем, с большой вероятностью находится оптимум.\n\n## Байесовская оптимизация\n\nБайесовская оптимизация — это итерационный метод, позволяющий оценить оптимум функции, не дифференцируя её. Кроме того, на каждой итерации метод указывает, в какой следующей точке мы с наибольшей вероятностью улучшим нашу текущую оценку оптимума. Это позволяет значительно сократить количество вычислений функции, каждое из которых может быть довольно затратным по времени.\n\nПодбор гиперпараметров тоже можно сформулировать в виде задачи, которая может решаться с помощью байесовской оптимизации. Пусть, например, наша функция — значение валидационных метрик в зависимости от текущего сочетания гиперпараметров. Её вычисление затратно по времени (нужно натренировать и провалидировать модель), и мы не можем вычислить градиенты этой функции по её переменным (нашим гиперпараметрам).\n\nБайесовская оптимизация имеет две основные компоненты:\n\n* вероятностную модель, которая приближает распределение значений целевой функции в зависимости от имеющихся исторических данных (часто в качестве такой модели выбирают [гауссовские процессы](https://krasserm.github.io/2018/03/19/gaussian-processes/));\n* функцию, которая позволяет по некоторым статистикам текущей вероятностной модели функции $f$ указать, в какой следующей точке нужно вычислить значение $f$. Эта функция называется *acquisition function*. Она должна балансировать между *exploration* и *exploitation* в следующем смысле:\n  * *exploration* — исследовать те точки, в которых дисперсия нашей вероятностной модели велика;\n  * *exploitation* — исследовать те точки, где среднее нашей модели велико (и может служить оценкой максимума $f$).\n\nПростой пример acquisition function — сумма среднего вероятностной модели и стандартного отклонения с некоторым весом:\n\n$$    \\alpha(x) = \\mu(x) + \\beta \\sigma(x), \n$$\n\nгде $x$ — точка из пространства, в котором мы оптимизируем целевую функцию (в нашем контексте это вектор значений гиперпараметров). На картинке ниже изображены обе компоненты, из которых складывается данная acquisition function, — среднее вероятностной модели $\\mu$ (синий график) и доверительный интервал, ширина которого в каждой точке пропорциональна стандартному отклонению вероятностной модели (жёлтая область).\n\nСреднее модели $\\mu$ стремится приблизить искомую функцию $f$ и в точности равно $f$ в тех точках, где значения $f$ известны. Доверительный интервал имеет переменную ширину, так как чем дальше находится некоторая точка от тех, значения в которых известны, тем более модель не уверена в том, какое значение функции в этой точке, и тем шире доверительный интервал. Наоборот, в точках, где значения известны, доверительный интервал имеет нулевой радиус.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_6_07b9debf98_1a548f93c4.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://www.borealisai.com/en/blog/tutorial-8-bayesian-optimization/\">Источник</a>\n  </figcaption>\n</figure>\n\nБайесовская оптимизация в общем случае представляет из себя следующий алгоритм. Пусть $S_t$ — множество предыдущих наблюдений целевой функции $f$: $(f(x_1), \\ldots, f(x_t))$, а $\\alpha(\\cdot)$ — некоторая acquisition function.\n\n* На итерации $t + 1$ вычисляется точка $x_{t + 1}$, в которой нужно провести следующее вычисление целевой функции:\n\n$$    x_{t + 1} = \\arg \\max_{x \\in X} \\alpha(x|S_t). \n$$\n\n* Вычисляется значение $f(x_{t + 1})$, и обновляется множество наблюдений $S_{t + 1} = (S_t, f(x_{t + 1}))$.\n* Обновляется статистическая модель.\n\nЧтобы такой алгоритм работал эффективно, $\\alpha$ должна быть легко вычислимой и дифференцируемой.\n\nНа рисунке ниже изображены три итерации этого алгоритма. Здесь пунктирная линия — это целевая функция, сплошная линия — график среднего вероятностной модели, жёлтым цветом обозначен доверительный интервал модели.\n\nСерый график снизу — это график acquisition function. Её значения велики там, где вероятностная модель предсказывает большие значения целевой функции (exploitation), и там, где велика неуверенность вероятностной модели (exploration).\n\nНа каждой итерации находится точка максимума acquisition function (чёрный крестик), и следующая итерация произойдёт в этой точке (серый кружок на графике функции). На нижнем графике побеждает exploitation, так как acquisition function верно предсказала, что наблюдения из неизвестных областей слабо повлияют на нашу текущую оценку максимума $f$.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_7_6b2dcdd077_c22b9ae61a.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7352306\">Источник</a>\n  </figcaption>\n</figure>\n\nБайесовская оптимизация хорошо работает, когда нужно оптимизировать небольшое число гиперпараметров, так как в наивной реализации алгоритм не поддаётся распараллеливанию. При большой размерности пространства гиперпараметров скорость сходимости не лучше, чем у обычного Random Search ([как утверждается в этой статье](https://arxiv.org/pdf/1603.06560.pdf)).\n\nБайесовская оптимизация в изначальной постановке предполагалась для работы с непрерывными гиперпараметрами, а для работы с категориальными гиперпараметрами ей нужны некоторые трюки:\n\n1. Если нужно найти оптимальное значение только одного гиперпараметра и этот параметр категориальный, то можно, например, использовать Thompson sampling (как тут в [разделе «Bernoulli bandit»](https://www.borealisai.com/en/blog/tutorial-8-bayesian-optimization/)). Вообще, проблему выбора наилучшего значения категориального гиперпараметра можно переформулировать как [multi-armed bandit problem](https://lilianweng.github.io/lil-log/2018/01/23/the-multi-armed-bandit-problem-and-its-solutions.html) и использовать любой известный способ решения этой задачи.\n\n2. Если категориальных гиперпараметров больше одного и кроме них есть некатегориальные, то:\n\n* можно попробовать использовать специальные виды ядер в гауссовских процессах, [как, например, сделано здесь](https://www.cs.toronto.edu/~duvenaud/thesis.pdf);\n* можно заменить гауссовские процессы на Random Forest (подробнее можно посмотреть здесь в [разделе «Random Forests»](https://www.borealisai.com/en/blog/tutorial-8-bayesian-optimization/)).\n\n## Tree-structured Parzen Estimator (TPE)\n\nАлгоритм TPE, как и алгоритм байесовской оптимизации, итерационный: на каждой итерации принимается решение о том, какие следующие значения гиперпараметров нужно выбрать, исходя из результатов предыдущих итераций. Но идейно имеет довольно сильные отличия.\n\nПредположим сначала, что мы хотим сделать поиск оптимального значения для **одного** гиперпараметра.\n\nНа нескольких первых итерациях алгоритму требуется «разогрев»: нужно иметь некоторую группу значений данного гиперпараметра, на которой известно качество модели. Самый простой способ собрать такие наблюдения — провести несколько итераций Random Search (количество итераций определяется пользователем).\n\nСледующим шагом будет разделение собранных во время разогрева данных на две группы. В первой группе будут те наблюдения, для которых модель продемонстрировала лучшее качество, а во второй — все остальные. Размер доли лучших наблюдений задаётся пользователем: чаще всего это 10-25% от всех наблюдений. Картинка ниже иллюстрирует такое разбиение:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_8_46b76c5fad_946af17422.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html\">Источник</a>\n  </figcaption>\n</figure>\n\nДалее некоторым образом строятся оценки распределения $\\ell(x)$ лучших наблюдений и распределения $g(x)$ всех остальных в пространстве значений рассматриваемого гиперпараметра.\n\n{% cut \"О том, как оцениваются$\\ell(x)$и $g(x)$\" %}\n\nЕсли гиперпараметр принимает **непрерывные значения**, то распределения $\\ell(x)$ и $g(x)$ можно оценить на основе **Parzen window density estimation**. Идея данного метода в следующем. Пусть у нас имеются точки $x_1, \\ldots, x_n$, которые были насемплированы из некоторого неизвестного распределения $f$. Нам нужно каким-то образом оценить $f$ по известным данным. Для этого каждое наблюдение $x_i$ помещается в центр некоторого симметричного распределения $K$ с дисперсией $h$, а оценкой для $f$ становится смесь этих распределений:\n\n$$\\hat f_h(x) = \\frac{1}{nh} \\sum_{i = 1}^n K \\left(\\frac{x - x_i}{h}\\right) \n$$\n\nРаспределения $K$ обычно называют *ядрами*, примеры ядер можно найти [тут](https://en.wikipedia.org/wiki/Kernel_\\(statistics\\)). На картинке ниже показана зависимость вида итогового распределения от параметра $h$ (который часто называют *bandwidth*):\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_9_417e64fa15_8d08288b69.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://stats.stackexchange.com/questions/244012/can-you-explain-parzen-window-kernel-density-estimation-in-laymans-terms\">Источник</a>\n  </figcaption>\n</figure>\n\nЧем больше у нас наблюдений, тем точнее можем оценить целевое распределение:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_10_8600188ec2_9de7620d70.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html\">Источник</a>\n  </figcaption>\n</figure>\n\nЕсли гиперпараметр **категориальный** и принимает значения $c_1, \\ldots, c_n$, то в качестве $\\ell(x)$ и $g(x)$ можно задать категориальные распределения в виде наборов из $n$ вероятностей $(p_1, \\ldots, p_n)$, где $p_i$ соответствует вероятности насемплировать значение $c_i$. Значения $p_i$ для $\\ell(x)$ будут пропорциональны числу раз, которое каждое из значений $c_i$ встретилось в группе лучших наблюдений (и, соответственно, худших наблюдений в случае $g(x)$). Например, пусть у гиперпараметра всего 3 значения и уже прошло 60 итераций алгоритма. Пусть среди лучших 15 испытаний 2 раза встретилось значение $c_1$, 5 раз встретилось значение $с_2$ и 8 раз встретилось значение $c_3$. Тогда $\\ell(x) \\sim \\left( p_1 = \\frac{2}{15}, p_2 = \\frac{5}{15}, p_3 = \\frac{8}{15} \\right)$. Аналогично будет строиться $g(x)$.\n\n{% endcut %}\n\nНа следующем шаге алгоритма мы семплируем несколько значений-кандидатов из распределения $\\ell(x)$ (количество таких семплирований тоже задаётся пользователем, можно задать их число равным, например, 1000). Из насемплированных кандидатов мы хотим найти тех, кто с большей вероятностью окажется в первой группе (состоящей из лучших наблюдений), чем во второй. Для этого для каждого кандидата $x$ вычисляется **Expected Improvement**:\n\n$$EI(x) = \\frac{\\ell(x)}{g(x)} \n$$\n\n**Замечание**: На самом деле стоит отметить, что в [оригинальной статье](https://proceedings.neurips.cc/paper/2011/file/86e8f7ab32cfd12577bc2619bc635690-Paper.pdf) величина $EI$ имеет более общее определение. Но там же доказывается, что максимизация $EI$ в исходном определении эквивалентна максимизации отношения выше.\n\nКандидат с наибольшим значением $EI(x)$ будет включён в множество рассматриваемых гиперпараметров на следующей итерации:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_11_91fd470896_82cc1456cb.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html\">Источник</a>\n  </figcaption>\n</figure>\n\nПосле того как было выбрано значение-кандидат, максимизирующее $EI$, обучается модель с этим значением гиперпараметра. После обучения мы замеряем её качество на валидационной выборке и в соответствии с этим результатом обновляем распределения $\\ell(x)$ и $g(x)$: снова ранжируем всех имеющихся кандидатов по качеству модели с учётом последнего, из топ 10-25% формируется обновлённое $\\ell(x)$, из остальных — $g(x)$. Так происходит столько раз, сколько итераций алгоритма мы задали.\n\nТеперь опишем, как алгоритм работает в общем случае, когда гиперпараметров **более одного**. Алгоритм работает с гиперпараметрами, представляя их в форме дерева (отсюда «tree» в названии). Например, в документации [Hyperopt](https://github.com/hyperopt/hyperopt/wiki/FMin#22-a-search-space-example-scikit-learn) можно увидеть такой пример:\n\n```\nfrom hyperopt import hp\n \nspace = hp.choice('classifier_type', [\n    {\n        'type': 'naive_bayes',\n    },\n    {\n        'type': 'svm',\n        'C': hp.lognormal('svm_C', 0, 1),\n        'kernel': hp.choice('svm_kernel', [\n            {'ktype': 'linear'},\n            {'ktype': 'RBF', 'width': hp.lognormal('svm_rbf_width', 0, 1)},\n            ]),\n    },\n    {\n        'type': 'dtree',\n        'criterion': hp.choice('dtree_criterion', ['gini', 'entropy']),\n        'max_depth': hp.choice('dtree_max_depth',\n            [None, hp.qlognormal('dtree_max_depth_int', 3, 1, 1)]),\n        'min_samples_split': hp.qlognormal('dtree_min_samples_split', 2, 1, 1),\n    },\n])\n```\n\nНа рисунке ниже изображено дерево, соответствующее данному примеру:\n\n![8](https://yastatic.net/s3/education-portal/media/8_12_ec1b579327_12dd0b843a.webp)\n\nКорень дерева $\\varepsilon$ — фиктивная вершина, введённая для удобства. Здесь первый уровень дерева — выбор классификатора (наивный байес, SVM, решающее дерево). Дальнейшие уровни — гиперпараметры самих классификаторов и зависящие уже от них гиперпараметры (например, SVM $\\to$ kernel $\\to$ RBF $\\to$ width). Движение по дереву во время итераций алгоритма происходит по некоторому пути от корня к листу и обратно вдоль пройденного пути (этот процесс подробнее описан ниже).\n\nПод некоторыми вершинами записан набор гиперпараметров в скобках (например, `kernel` и `C` под SVM). Это означает, что при приходе в эту вершину значения всех гиперпараметров, перечисленных в скобках, должны так или иначе быть выбраны.\n\nКаждой вершине дерева, в которой будет происходить семплирование значений, сопоставляется своя пара  $\\ell(x)$ и $g(x)$ с учётом значений, насемплированных на этапе «разогрева». Каждому гиперпараметру, перечисленному в скобках, соответствует своя собственная пара. Если из названия гиперпараметра не идут стрелки (например, `C` у SVM и `min_samples_split` у Decision Tree), то это означает, что от его значения не зависят значения никаких других гиперпараметров.\n\nПоэтому либо будет выбрано его значение, максимизирующее $EI$ для соответствующих ему $\\ell$ и $g$, либо уже ничего не нужно семплировать (как, например, в вершинах `linear` или `gini`). Если же из гиперпараметра идут стрелки на следующий уровень, то с помощью максимизации $EI$ будет выбрано, в каком направлении сделать переход. Например, из корня $\\varepsilon$ выбирается, какой классификатор рассмотреть на следующем этапе, а из параметра `kernel` можно перейти либо к `RBF`, либо к `linear`.\n\nТеперь опишем сам алгоритм. Сначала так же, как и в одномерном случае, происходит «разогрев»: проводится некоторое количество итераций Random Search с теми изначальными распределениями, которые были заданы для гиперпараметров (в примере из Hyperopt эти распределения задаются как `hp.qlognormal`, `hp.lognormal` и так далее). Затем начинается итерационное обновление дерева гиперпараметров. Обновление дерева на каждой итерации происходит в два этапа:\n\n1. Сначала алгоритм идёт из корня дерева до некоторого листа. В каждой вершине для каждого соответствующего ей гиперпараметра он находит значение, максимизирующее $EI$. Если выбор значения для некоторого гиперпараметра означает переход на следующий уровень дерева, он идёт в ту вершину, которая соответствует максимизации $EI$. Так он идёт до тех пор, пока не упрётся в какой-то лист. Пройденный путь от корня до листа задаёт полный набор значений гиперпараметров для модели, и её с этими значениями можно провалидировать.\n\n{% cut \"Пример\" %}\n\nПусть вы находитесь в корне $\\varepsilon$ и выбираете классификатор. Допустим, классификатор SVM оказался оптимальным по критерию $EI$. Вы переходите в соответствующую ему вершину, и здесь вам нужно провести семплирование значений для двух гиперпараметров: `kernel` и `C`. Для `C` вы выбираете некоторое значение, которое максимизирует $EI$. Пусть оно оказалось равно $0.1$. А для `kernel` вы с помощью максимизации $EI$ выбираете, в какую вершину на следующем уровне вы отправитесь. Пусть эта вершина — `RBF`. Для него вы семплируете конкретное значение `width` — пусть оно оказалось равным $0.9$. Получилось, что вы прошли полный путь и получили модель с заданным набором гиперпараметров: $SVM(C = 0.1, kernel = RBF(width = 0.9))$, которую теперь можно провалидировать.\n\n{% endcut %}\n\n2. После того как модель, полученная на предыдущем этапе, была провалидирована, распределения в вершинах дерева нужно обновить в соответствии с информацией о полученном качестве. Для этого алгоритм поднимается из листа наверх, обновляя распределения во всех вершинах дерева вдоль своего пути. В каждой вершине для каждого гиперпараметра процедура обновления та же, что была описана для одного гиперпараметра: имеющиеся значения гиперпараметров переранжируются по качеству с учётом результата последнего кандидата (этот результат общий для всех вершин вдоль пути), по топ 10-25% оценивается $\\ell(x)$, по остальным — $g(x)$.\n\nВ качестве окончательного ответа алгоритм выдаёт набор гиперпараметров (или, как в примере выше, не только гиперпараметры, но даже саму модель), на котором было получено лучшее качество за все итерации. Число итераций алгоритма задаётся пользователем.\n\nЗа дальнейшими деталями о процедуре обновления дерева для алгоритма TPE можно обратиться к [этой статье](https://arxiv.org/pdf/1208.3719.pdf) и к [исходному коду](https://github.com/hyperopt/hyperopt/blob/master/hyperopt/tpe.py#L662) алгоритма TPE из библиотеки Hyperopt.\n\nСтоит заметить, что если гиперпараметры не лежат вместе ни в одном пути в дереве, то TPE считает их независимыми. Это — недостаток данного алгоритма, так как некоторые гиперпараметры, находящиеся по смыслу в разных путях в дереве, зависят от друг от друга.\n\nНапример, с регуляризацией мы можем тренировать нейросеть большее число эпох, чем без регуляризации, потому что без регуляризации сеть на большом числе эпох может начать переобучаться. В этом конкретном примере можно использовать такой трюк:\n\n```\nhp.choice('training_parameters', [\n    {\n        'regularization': True,\n        'n_epochs': hp.quniform('n_epochs', 500, 1000, q=1),\n    }, {\n        'regularization': False,\n        'n_epochs': hp.quniform('n_epochs', 20, 300, q=1),\n    },\n])\n```\n\nНо если внутренние зависимости между гиперпараметрами вам неизвестны, то алгоритм не сможет найти их сам.\n\nКритерий $EI$ позволяет методу TPE балансировать между *exploration* и *exploitation*. Семплирование из распределения $\\ell(x)$ — это, с одной стороны, exploitation, так как гиперпараметры, семплируемые из него, близки к оптимуму, но это же привносит элемент exploration, так как семплируемые гиперпараметры не равны оптимуму в точности.\n\n## Population Based Training (PBT)\n\nЭтот метод использует идеи из теории [эволюционных стратегий](https://lilianweng.github.io/lil-log/2019/09/05/evolution-strategies.html) и с самого начала включает в себя параллельные вычисления.\n\nМетоды, описанные выше, имеют свои сильные и слабые стороны.\n\n* Grid Search и Random Search:\n  * отлично параллелизуются;\n  * не используют результаты предыдущих итераций.\n* БО и TPE:\n  * трудно параллелизуются;\n  * используют результаты предыдущих итераций, при сходимости результаты лучше, чем у Random Search и Grid Search.\n\nВ алгоритме PBT была сделана попытка объединить сильные стороны обеих групп, что проиллюстрировано на картинке ниже:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_13_9ca8874e96_a5714a6d1e.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/1711.09846.pdf\">Источник</a>\n  </figcaption>\n</figure>\n\nВ процессе работы алгоритм обучает не одну модель, а целую **популяцию** $\\mathcal{P}$ моделей — набор моделей одинакового типа, отличающихся только набором гиперпараметров:\n\n$$    \\mathcal{P} = \\{(\\theta_i, h_i) \\, | \\, i = 1, \\ldots, N \\}, \n$$\n\nгде $\\theta_i$ и $h_i$ — веса и гиперпараметры модели $i$ соответственно.\n\nПредполагается также, что модели обучаются как-то итерационно, например градиентным спуском (но могут использоваться и безградиентные методы, такие как эволюционные стратегии). Изначально каждая модель в популяции имеет случайные веса и гиперпараметры. Каждая модель из популяции тренируется параллельно с остальными, и периодически качество каждой модели замеряется независимо от остальных.\n\nКак только какая-то модель считается «созревшей» для обновления (например, прошла достаточное число шагов градиентного спуска или преодолела некоторый порог по качеству), у неё появляется шанс быть обновлённой относительно всей остальной популяции:\n\n* процедура **exploit()**: если у модели низкое качество относительно популяции, то её веса заменяются на веса модели с более высоким качеством;\n* процедура **explore()**: если веса модели были перезаписаны, шаг *explore* добавляет случайный шум в параметры модели.\n\nПри таком подходе только лучшие пары моделей и гиперпараметров выживут и будут обновляться, что позволяет добиться более высокой утилизации ресурсов.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/8_14_1816a593dc_5deea06c15.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/1711.09846.pdf\">Источник</a>\n  </figcaption>\n</figure>\n\nСтоит отметить, что наиболее оптимальный размер популяции, выявленный авторами в результате экспериментов, — от 20 до 40, что довольно много и не реализуется на обычном ноутбуке.\n\nКрасивая гифка с демонстрацией работы алгоритма:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/evolution_b2d6991401_845361a5fa.gif\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://deepmind.com/blog/article/population-based-training-neural-networks\">Источник</a>\n  </figcaption>\n</figure>\n\n## Open-source-библиотеки\n\n### Scikit-learn\n\nВ библиотеке [Scikit-learn](https://scikit-learn.org/stable/index.html) есть реализации Grid Search и Random Search, что очень удобно, если вы используете модели из sklearn. Примеры их использования можно найти [здесь](https://scikit-learn.org/stable/modules/grid_search.html#randomized-parameter-optimization).\n\n### Hyperopt\n\nВ библиотеке [Hyperopt](http://hyperopt.github.io/hyperopt/) реализованы три метода оптимизации гиперпараметров:\n\n* Random Search\n* TPE\n* [Adaptive TPE](https://github.com/electricbrainio/hypermax)\n\nУ них есть небольшой [туториал](https://github.com/hyperopt/hyperopt/wiki/FMin) по тому, как начать пользоваться библиотекой. Кроме того, у них есть обёртка над sklearn, позволяющая работать с моделями оттуда: [Hyperopt-sklearn](https://github.com/hyperopt/hyperopt-sklearn).\n\n### Optuna\n\nВ библиотеке [Optuna](https://optuna.org/) реализованы те же методы оптимизации, что и в Hyperopt, но по многим параметрам она оказывается удобнее. Хорошее сравнение Optuna и Hyperopt можно найти [здесь](https://neptune.ai/blog/optuna-vs-hyperopt).\n\n### Scikit-Optimize\n\nВ библиотеке [Scikit-Optimize](https://scikit-optimize.github.io/stable/index.html) реализованы алгоритмы байесовской оптимизации и Random Search. Кроме самих методов оптимизации библиотека предоставляет отличный инструментарий для различных [визуализаций](https://neptune.ai/blog/scikit-optimize#8). Хорошее описание возможностей библиотеки можно найти [тут](https://neptune.ai/blog/scikit-optimize).\n\n### Keras Tuner\n\nБиблиотека [Keras Tuner](https://keras-team.github.io/keras-tuner/) позволяет подбирать гиперпараметры для нейросеток, написанных на TensorFlow 2.0, и для обычных моделей из Scikit-learn. Доступные методы оптимизации — Random Search и [Hyperband](https://arxiv.org/pdf/1603.06560.pdf). Хороший гайд по использованию данной библиотеки можно найти [тут](https://blog.tensorflow.org/2020/01/hyperparameter-tuning-with-keras-tuner.html).\n\n## Summary\n\nСписок описанных методов не исчерпывает все существующие на данный момент методы оптимизации гиперпараметров: остались за кадром такие алгоритмы, как [ASHA](https://arxiv.org/pdf/1810.05934.pdf), [Hyperband](https://arxiv.org/pdf/1603.06560.pdf), [BOHB](https://arxiv.org/abs/1807.01774). Хороший сравнительный обзор этих трёх алгоритмов можно найти [здесь](https://neptune.ai/blog/hyperband-and-bohb-understanding-state-of-the-art-hyperparameter-optimization-algorithms).\n\nМы собрали все описанные выше алгоритмы в таблицу, чтобы вам было удобнее сравнивать их между собой. А к некоторым оставили дополнительные комментарии.\n\n**Grid Search**. Хорошо работает, когда у вас совсем мало гиперпараметров либо вы смогли распараллелить его работу.\n\n* Сильные стороны:\n  * самый простой для понимания и реализации;\n  * тривиально распараллеливается.\n* Слабые стороны:\n  * не использует результаты других итераций;\n  * ограничен в выборе заданной сеткой;\n  * долго работает, если делает последовательный перебор по сетке. Нет гарантий на необходимое число итераций.\n\nВ защиту этого метода хочется сказать, что часто на практике приходится делать перебор гиперпараметров вообще вручную (если один инстанс вашей модели учится недели две и использует много ресурсов) либо по очень небольшой сетке. Так что метод вполне в ходу :)\n\n**Random Search**. Метод представляет собой небольшое усложнение над Grid Search, но при этом оказывается намного более эффективным.\n\n* Сильные стороны:\n  * случайный перебор по сетке позволяет находить оптимальные гиперпараметры более эффективно, чем Grid Search, в частности из-за того, что непрерывные параметры можно задать в виде распределения, а не перечислять значения заранее;\n  * тривиально распараллеливается;\n  * допускает усиление за счёт [использования квазислучайных распределений](http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html#random-search) при семплировании.\n* Слабые стороны:\n  * не использует результаты других итераций;\n  * ограничен в выборе заданной сеткой, хотя и в некоторых случаях менее жёстко, чем Grid Search.\n\n**Байесовская оптимизация**\n\n* Сильные стороны:\n  * использует результаты предыдущих итераций;\n  * может моделировать внутренние зависимости между гиперпараметрами (за счёт работы с ними в едином подмножестве $\\mathbb{R}^n$, где $n$ — число гиперпараметров);\n  * может расширять заданные изначально границы множества поиска гиперпараметров;\n  * достигает более высокого качества, чем Random Search, если удалось провести достаточное количество итераций.\n* Слабые стороны:\n  * паралеллится нетривиально;\n  * в нераспараллеленном случае работает долго, так как для каждой итерации ему приходится заново строить вероятностную модель. В случае если такая модель — гауссовские процессы, сложность получается порядка $n^3$, где $n$ — число гиперпараметров;\n  * для работы с категориальными гиперпараметрами нужны нетривиальные хаки.\n\n**Tree-structured Parzen Estimator**\n\n* Сильные стороны:\n\n  * использует результаты предыдущих итераций;\n  * может работать с зависимостями между гиперпараметрами, в которых один гиперпараметр не будет рассматриваться, если другой не примет какое-то определённое значение (например, число нейронов во втором слое нейросети нужно перебирать, если параметр «число слоёв» имеет значение не менее двух);\n  * имеет линейную сложность по числу гиперпараметров (в отличие от БО);\n  * не требует специальных хаков для работы с категориальными признаками, так как каждый гиперпараметр в этом алгоритме имеет своё отдельное одномерное распределение, и не нужно строить сложное совместное распределение всех гиперпараметров (как в БО);\n  * достигает высоких результатов по качеству, довольно часто используется в соревнованиях.\n\n* Слабые стороны:\n\n  * не может моделировать неявные зависимости между гиперпараметрами (те, которые юзер не задал с помощью дерева);\n  * хотя сложность и меньше, чем у БО, может работать довольно медленно даже на не очень большом числе гиперпараметров.\n\n**Population Based Training**\n\n* Сильные стороны:\n  * параллельный by design;\n  * может использовать результаты предыдущих итераций.\n* Слабые стороны:\n  * для эффективной работы нужно много воркеров (от 20 до 40), что нетривиально для реализации.\n\n## Почитать по теме\n\n* [Примеры](https://scikit-learn.org/stable/modules/grid_search.html#exhaustive-grid-search) использования Grid Search от sklearn.\n* [Примеры](https://scikit-learn.org/stable/modules/grid_search.html#randomized-parameter-optimization) использования Random Search от sklearn.\n* [Хороший блог-пост о гиперпараметрах](http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html#random-search), в первом разделе которого есть интересные рассуждения про усиление Random Search с помощью квазислучайных распределений.\n* [Блог-пост](https://deepmind.com/blog/article/population-based-training-neural-networks) от DeepMind про предложенный ими алгоритм Population Based Training.\n* [Оригинальная статья](https://arxiv.org/pdf/1711.09846.pdf), где был предложен алгоритм.\n* [Блог-пост](https://lilianweng.github.io/lil-log/2019/09/05/evolution-strategies.html) про эволюционные стратегии.\n\nА если вам интересно как следует разобраться в байесовской оптимизации (в частности, рассмотреть больше примеров вероятностных моделей и разных acquisition function), то вот полезный контент:\n\n* [Отличный туториал](https://www.borealisai.com/en/blog/tutorial-8-bayesian-optimization/) по различным методам оптимизации гиперпараметров, в частности по байесовской оптимизации.\n* [Статья-обзор](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7352306), подробно объясняющая математические детали методов байесовской оптимизации и содержащая примеры их применения в ресёрче и индустрии.\n* [Видеолекция](https://www.youtube.com/watch?v=PgJMLpIfIc8) Евгения Бурнаева на летней школе Deep \\| Bayes.\n* [Оригинальная статья](https://proceedings.neurips.cc/paper/2011/file/86e8f7ab32cfd12577bc2619bc635690-Paper.pdf), в которой были предложены методы TPE и байесовская оптимизация.\n* [Пример использования skopt (Scikit-Optimize)](https://scikit-optimize.github.io/stable/auto_examples/sklearn-gridsearchcv-replacement.html) — нахождение лучших параметров для SVM с помощью байесовской оптимизации.\n* [Реализация](https://colab.research.google.com/github/krasserm/bayesian-machine-learning/blob/master/bayesian_optimization.ipynb) алгоритма байесовской оптимизации и примеры использования библиотечных реализаций.\n* [Про гауссовские процессы](http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html) с хорошими визуализациями.\n* [Более формально про гауссовские процессы](https://krasserm.github.io/2018/03/19/gaussian-processes/), но с хорошими примерами на питоне.\n\nДля дальнейшего изучения метода TPE можно использовать следующие источники:\n\n* [Оригинальная статья](https://proceedings.neurips.cc/paper/2011/file/86e8f7ab32cfd12577bc2619bc635690-Paper.pdf), в которой были предложены методы TPE и байесовская оптимизация.\n* [Блог-пост](http://neupy.com/2016/12/17/hyperparameter_optimization_for_neural_networks.html) про TPE и остальные методы тюнинга гиперпараметров от NeuPy. Там же можно найти пример применения TPE из [Hyperopt](https://github.com/hyperopt/hyperopt).\n* [Отличное объяснение](https://stats.stackexchange.com/questions/244012/can-you-explain-parzen-window-kernel-density-estimation-in-laymans-terms) того, что такое Parzen window density estimation.\n* [Отличный туториал](https://www.borealisai.com/en/blog/tutorial-8-bayesian-optimization/) по различным методам оптимизации гиперпараметров (который уже был упомянут выше в разделе про байесовскую оптимизацию).",
        "handbook": "Учебник по машинному обучению",
        "title": "Подбор гиперпараметров",
        "description": "Как эффективно подбирать значения гиперпараметров модели и не переобучиться при этом"
    },
    {
        "path": "/handbook/ml/article/veroyatnostnyj-podhod-v-ml",
        "content": "В этом разделе мы посмотрим на те же самые модели машинного обучения, но с другой стороны: будем интерпретировать их как вероятностные.\n\nВ первом параграфе мы расскажем, как обращаться с вероятностными моделями, и покажем, что привычный вам подбор параметров модели с помощью минимизации функции потерь соответствует подбору параметров методом максимального правдоподобия. Это даст возможность транслировать в мир ML известные результаты о свойствах оценок максимального правдоподобия, но в то же время и обнажит их недостатки. Благодаря этому мы сможем по-новому взглянуть на логистическую регрессию и с новым пониманием сформулировать её обобщение — generalized linear model (GLM).\n\nПо ходу дела мы обнаружим, что большинство классификаторов, хоть и делают вид, что предсказывают корректные вероятности, на самом деле вводят в заблуждение.\n\nВ третьем параграфе мы поговорим о том, как проверить отклонение предсказанных значений от истинных вероятностей и как поправить ситуацию.\n\nДалее мы обсудим генеративный подход к классификации и разберём несколько примеров генеративных моделей, после чего перейдём к байесовскому подходу оценивания параметров, который, хоть зачастую и трудно осуществим вычислительно, однако обладает большей теоретической стройностью. Он позволяет оценивать распределение параметров и предсказаний (например, уверенность в нашей оценке), а кроме того — даёт нам возможность измерить качество модели, не прибегая к проверке на тестовой выборке.\n\nЕсли вы готовы — давайте приступим!\n\n## Случайность как источник несовершенства модели\n\nПрактически любая наша модель — несовершенна. Но объяснять это несовершенство можно по-разному.\n\nПредставим, что мы решаем задачу регрессии $y\\simeq \\langle x, w\\rangle$: например, пытаемся по университетским оценкам выпускника предсказать его годовую зарплату. Ясно, что точная зависимость у нас не получится как минимум потому, что мы многого не знаем о выпускнике: куда он пошёл работать, насколько он усерден, как у него с soft skills и так далее. Как же нам быть?\n\nПервый вариант — просто признать, что мы не получим идеальную модель, но постараться выучить оптимальную, насколько это возможно. То есть приблизить таргет предсказаниями наилучшим образом с точки зрения какой-то меры близости, которую мы подберём из экспертных соображений.\n\nТак мы получаем простой инженерный подход к машинному обучению: есть формула, в которой присутствуют некоторые параметры ($w$), есть формализация того, что такое «приблизить» (функция потерь) — и мы бодро решаем задачу оптимизации по параметрам.\n\nВторой вариант — свалить вину за неточности наших предсказаний на случайность. В самом деле: если мы что-то не можем измерить, то для нас это всё равно что случайный фактор. В постановке задачи мы заменяем приближённое равенство $y\\simeq \\langle x, w\\rangle$ на точное\n\n$$y=(\\langle x, w\\rangle, \\text { искажённое шумом } \\varepsilon)\n$$\n\nНапример, это может быть аддитивный шум (чаще всего так и делают):\n\n$$y = \\langle x, w\\rangle + \\varepsilon\n$$\n\nгде $\\varepsilon$ — некоторая случайная величина, которая представляет этот самый случайный шум. Тогда получается, что для каждого конкретного объекта $x_i$ соответствующий ему истинный таргет — это сумма $\\langle x_i, w\\rangle$ и конкретной реализации шума $\\varepsilon$.\n\nПри построении такой модели мы можем выбирать различные распределения шума, кодируя тем самым, какой может быть ошибка. Чаще всего выбирают гауссовский шум: $\\varepsilon\\sim\\mathcal{N}(0,\\sigma^2)$ с некоторой фиксированной дисперсией $\\sigma^2$ — но могут быть и другие варианты.\n\nПроиллюстрируем, как ведут себя данные, подчиняющиеся закону $y = ax + b + \\varepsilon$, $\\varepsilon\\sim\\mathcal{N}(0, \\sigma^2)$:\n\n![9](https://yastatic.net/s3/education-portal/media/9_1_01798dd1e4_623222483e.webp)\n\n**Вопрос на подумать**. Зачем человеку может прийти в голову предположить, что в модели линейной регрессии $y\\sim Xw + \\varepsilon$ шум $\\varepsilon$ имеет распределение Лапласа? А распределение Коши? Чем свойства таких моделей будут отличаться от свойств модели с нормальным шумом?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nДавайте посмотрим, как выглядят плотности этих трёх распределений:\n\n![9](https://yastatic.net/s3/education-portal/media/9_2_e57a6770be_8a354aec5b.webp)\n\nРаспределение Лапласа имеет «более тяжёлые хвосты», чем нормальное: это значит, что плотность медленнее падает с удалением от среднего. Таким образом, этому распределению могут подчиняться данные, в которых имеются выбросы. Если не гнаться за строгостью, можно сказать, что модель с нормальным шумом будет пытаться объяснить выбросы, меняя под них $w$, тогда как лапласовский шум потерпит их, не подгоняя $w$.\n\nУ распределения Коши хвосты «ещё более тяжёлые», что, в теории, даёт возможность модели с таким шумом описывать даже ещё более шумные данные.\n\nПроиллюстрируем датасеты, сгенерированные из моделей с каждым из типов шума: нормальным, лапласовским и Коши.\n\n![9](https://yastatic.net/s3/education-portal/media/9_3_7384d3087c_7ae3d004f9.webp)\n\n{% endcut %}\n\nКак вы могли заметить, в каждом из подходов после того, как мы зафиксировали признаки (то есть координаты $x_i$), остаётся своя степень свободы: в инженерном это выбор функции потерь, а в вероятностном — выбор распределения шума.\n\nДальше в этом параграфе мы увидим, что на самом деле эти два подхода глубинным образом связаны между собой, причём выбор функции потерь — это в некотором смысле то же самое, что выбор распределения шума.\n\n## Условное распределение на таргет, непрерывный случай\n\nДопустим, что мы исследуем вероятностную модель таргета с аддитивным шумом\n\n$$y = f_w(x) + \\varepsilon,\n$$\n\nгде $f_w$ — некоторая функция, не обязательно линейная с (неизвестными пока) параметрами $w$, а $\\varepsilon$ — случайный шум с плотностью распределения $\\varepsilon\\sim p_{\\varepsilon}(t)$. Для каждого конкретного объекта $x_i$ значение $f_w(x_i)$ — это просто константа, но для $y_i$ оно превращается в случайную величину, зависящую от $x_i$ (и ещё от $w$, на самом деле).\n\nТаким образом, можно говорить об условном распределении\n\n$$p_y(y \\vert x, w)\n$$\n\nДля каждого конкретного $x_i$ и $w$ распределение соответствующего $y_i$ — это просто $p_{\\varepsilon}(y - f_{w}(x_i))$, ведь $y - f_w(X) = \\varepsilon$.\n\n**Пример**. Рассмотрим вероятностную модель $y = \\langle x, w\\rangle + \\varepsilon$, где $\\varepsilon\\sim\\mathcal{N}(0, \\sigma^2)$. Тогда для фиксированного $x_i$ имеем $y_i = \\langle x_i, w\\rangle + \\varepsilon$. Поскольку $\\langle x_i, w\\rangle$ — константа, мы получаем\n\n$$y_i\\sim\\mathcal{N}(\\langle x_i, w\\rangle, \\sigma^2).\n$$\n\nЭто можно записать и так:\n\n$$p(y_i\\vert x_i, w)\\sim\\mathcal{N}(y_i\\vert\\langle x_i, w\\rangle, \\sigma^2),\n$$\n\nгде выражение справа — это значение функции плотности нормального распределения с параметрами $\\langle x_i, w\\rangle, \\sigma^2$ в точке $y_i$. В частности, $\\langle x_i, w\\rangle = \\mathbb{E}(y_i\\vert x_i)$.\n\n## Более сложные вероятностные модели\n\nНа самом деле, мы можем для нашей задачи придумывать любую вероятностную модель $p_y(y \\vert x, w)$, не обязательно вида $y = f_w(X) + \\varepsilon$.\n\nПредставьте, что мы хотим предсказывать точку в плоскости штанг, в которую попадает мячом бьющий по воротам футболист. Можно предположить, что она имеет нормальное распределение со средним (цель удара), которое определяется ситуацией на поле и состянием игрока, и некоторой дисперсией (то есть скалярной ковариационной матрицей), которая тоже зависит от состояния игрока и ещё разных сложных факторов, которые мы объявим случайными.\n\nСостояние игрока — это сложное понятие, но, вероятно, мы можем выразить его, зная пульс, давление и другие физические показатели. В свою очередь, ситуацию на поле можно описать, как функцию от позиций и движений других игроков, судьи и зрителей — но всего не перечислишь, поэтому нам снова придётся привлекать случайность. Таким образом, мы получаем то, что называется **графической моделью**:\n\n![9](https://yastatic.net/s3/education-portal/media/9_4_8a62e69dca_e58af3573c.webp)\n\nЗдесь стрелки означают статистические зависимости, а отсутствие стрелок — допущение о статистической независимости. Конечно же, это лишь допущение, принятое нами для ограничения сложности модели: ведь пульс человека и давление взаимосвязаны, равно как и поведение различных игроков на поле. Но мы уже обсуждали, что каждая модель, в том числе и вероятностная, является лишь приблизительным отражением бесконечно сложного мира. Впрочем, если у нас много вычислительных ресурсов, то никто не мешает нам попробовать учесть и все пропущенные сейчас зависимости.\n\nРасписав всё по определению условной вероятности, мы получаем следующую вероятностную модель:\n\n![9](https://yastatic.net/s3/education-portal/media/9_5_6348aec2cb_5cfcd9d525.webp)\n\nв которой, конечно же, мы должны все вероятности расписать через какие-то понятные и логически обоснованные распределения — но пока воздержимся от этого.\n\n## Оценка максимального правдоподобия = оптимизация функции потерь\n\nМы хотим подобрать такие значения параметров $w$, для которых модель $p_y(y \\vert x, w)$ была бы наиболее адекватна обучающим данным. Суть **метода максимального правдоподобия** (maximum likelihood estimation) состоит в том, чтобы найти такое $w$, для которого вероятность (а в данном, непрерывном, случае плотность вероятности) появления выборки $y = \\{y_1, \\ldots, y_N\\}$ была бы максимальной, то есть\n\n$$\\widehat{w}_{MLE} = \\underset{w}{\\operatorname{argmax}}p(y \\vert X, w)\n$$\n\nВеличина $p(y \\vert X, w)$ называется **функцией правдоподобия** (likelihood). Если мы считаем, что все объекты независимы, то функция правдоподобия распадается в произведение:\n\n$$p(y \\vert X, w) = p(y_1 \\vert x_1, w) \\cdot\\ldots\\cdot p(y_i \\vert x_i, w)\n$$\n\nТеперь, поскольку перемножать сложно, а складывать легко (и ещё поскольку мы надеемся, что раз наши объекты всё-таки наблюдаются в природе, их правдоподобие отлично от нуля), мы переходим к логарифму функции правдоподобия:\n\n$$l(y \\vert X,w) = \\log{p(y_1 \\vert x_1, w)} + \\ldots + \\log{p(y_i \\vert x_i, w)}\n$$\n\nэту функцию мы так или иначе максимизируем по $w$, находя оценку максимального правдоподобия $\\hat{w}$.\n\nКак мы уже обсуждали выше, $p(y_i \\vert x_i, w) = p_{\\varepsilon}(y - f_{w}(x_i))$, то есть\n\n$$l(y \\vert X,w) = \\sum\\limits_{i=1}^N\\log{p_{\\varepsilon}(y_i - f_w(x_i))}\n$$\n\nМаксимизация функции правдоподобия соответствует минимизации\n\n$$\\sum\\limits_{i=1}^N\\left[-\\log{p_{\\varepsilon}(y_i - f_w(x_i))}\\right]\n$$\n\nа это выражение можно интерпретировать, как функцию потерь. Вот и оказывается, что подбор параметров вероятностей модели с помощью метода максимального правдоподобия — это то же самое, что «инженерная» оптимизация функции потерь. Давайте посмотрим, как это выглядит в нескольких простых случаях.\n\n**Пример**. Давайте предположим, что наш таргет связан с данными вот так:\n\n$$y_i = \\langle x_i, w \\rangle + \\varepsilon\n$$\n\nгде $\\varepsilon\\sim\\mathcal{N}(0, \\sigma^2)$, то есть\n\n$$p(\\varepsilon) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp\\left(-\\frac{\\varepsilon^2}{2\\sigma^2}\\right)\n$$\n\nСлучайная величина $y_i$ получается из шума $\\varepsilon$ сдвигом на постоянный вектор $\\langle x_i, w \\rangle$, так что она тоже распределена нормально с той же дисперсией $\\sigma^2$ и со средним $\\langle x_i, w \\rangle$\n\n$$p(y_i\\vert \\langle x_i, w \\rangle) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp\\left(-\\frac{(y_i - \\langle x_i, w \\rangle)^2}{2\\sigma^2}\\right)\n$$\n\nПравдоподобие выборки имеет вид\n\n$$p(y\\vert X, w) = \\prod_{i=1}^N p(y_i \\vert x_i, w) = \\prod_{i=1}^N \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp\\left(-\\frac{(y_i-\\langle w,x_i\\rangle)^2}{2\\sigma^2}\\right)\n$$\n\nЛогарифм правдоподобия можно переписать в виде\n\n$$l(y \\vert X,w) = \\sum_{i=1}^N \\left(-\\log({\\sqrt{2 \\pi \\sigma^2}}) -\\frac{(y_i-\\langle w,x_i\\rangle)^2}{2\\sigma^2}\\right)\n$$\n\nПостоянными слагаемыми можно пренебречь, и тогда оказывается, что максимизация этой величины равносильна минимизации\n\n$$ \\sum_{i=1}^N (y_i-\\langle w,x_i\\rangle)^2\n$$\n\nМы получили обычную квадратичную функцию потерь. Итак, обучать вероятностную модель линейной регрессии с нормальным шумом — это то же самое, что учить «инженерную» модель с функцией потерь MSE.\n\n**Вопрос на подумать**. Какая вероятностная модель соответствует обучению линейной регрессии с функцией потерь MAE\n\n$$\\sum_{i=1}^N \\vert y_i-\\langle w,x_i\\rangle\\vert?\n$$\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nМинимизация функции потерь MAE соответствует максимизации\n\n$$\\sum_{i=1}^N\\left[-\\vert y_i-\\langle w,x_i\\rangle\\vert\\right]\n$$\n\nМы хотим найти такое распределение, для которого эта штука является с точностью до константы логарифмом функции правдоподобия. Что ж, возьмём экспоненту:\n\n$$\\text{exp}\\left[-\\sum_{i=1}^N\\vert y_i-\\langle w,x_i\\rangle\\vert\\right] =\n\\prod_{i=1}^N\\text{exp}\\left(-\\vert y_i-\\langle w,x_i\\rangle\\vert\\right)$$\n\nЕсли теперь это умножить на $\\left(\\frac12\\right)^{N}$, то мы получим функцию правдоподобия для распределения Лапласа:\n\n$$\\prod_{i=1}^N\\frac12\\text{exp}\\left(-\\vert y_i-\\langle w,x_i\\rangle\\vert\\right) = \\prod_{i=1}^NLaplace\\left(y_i-\\langle w,x_i\\rangle\\right)\n$$\n\nИтак, учить «инженерную» модель с функцией потерь MAE — это то же самое, что обучать вероятностную модель линейной регрессии с лапласовским шумом.\n\n{% endcut %}\n\n## Предсказание в вероятностных моделях\n\nТеперь представим, что параметры подобраны, и подумаем о том, как же теперь делать предсказания.\n\nРассмотрим модель линейной регрессии\n\n$$y = \\langle x, w\\rangle + \\varepsilon,\\quad\\varepsilon\\sim\\mathcal{N}(0,\\sigma^2)\n$$\n\nЕсли $w$ известен, то для нового объекта $x_0$ соответствующий таргет имеет вид\n\n$$y_0 = \\langle x_0, w\\rangle + \\varepsilon\\sim\\mathcal{N}(\\langle x_0, w\\rangle, \\sigma^2)\n$$\n\nТаким образом, $y_0$ дан нам не точно, а в виде распределения (и логично: ведь мы оговорились выше, что ответы у нас искажены погрешностью, проинтерпретированной, как нормальный шум). Но что делать, если требуют назвать конкретное число? Кажется логичным выдать условное матожидание $\\mathbb{E}(y_0\\vert x_0) = \\langle x_0, w\\rangle$, тем более что оно совпадает с условной медианой и условной модой этого распределения.\n\nЕсли же медиана, мода и математическое ожидание различаются, то можно выбрать что-то из них с учётом особенностей задачи. Но на практике в схеме $y\\sim f(x) + \\varepsilon$ чаще всего рассматривают именно симметричные распределения с нулевым матожиданием, потому что для них $f(x)$ совпадает с условным матожиданием $\\mathbb{E}(y\\vert x)$ и является логичным точечным предсказанием.\n\nПриведём пример. Допустим шум $\\varepsilon$ был бы из экспоненциального распределения. Тогда $f(x)$ была бы условным минимумом распределения. В принципе, можно придумать задачу, для которой такая постановка (предсказание минимума) была бы логичной. Но это всё же довольно экзотическая ситуация. Приводим для сравнения модели с нормальным, лапласовским и экспоненциальным шумом:\n\n![9](https://yastatic.net/s3/education-portal/media/9_5b_275fad6f75_71f67fcd24.webp)\n\n## Условное распределение на таргет, дискретный случай\n\nДопустим, мы имеем дело с задачей классификации с $K$ классами. Как мы можем её решать? Самый наивный вариант — научиться по каждому объекту $x_i$ предсказывать некоторое число для каждого класса, и у кого число больше — тот класс и выбираем! Наверное, так можно сделать, если мы придумаем хорошую функцию потерь. Но сразу в голову приходит мысль: почему бы не начать предсказывать не просто число, а вероятность?\n\nТаким образом, задача классификации сводится к предсказанию\n\n$$P(y_i = k \\vert x_i)\n$$\n\nи как будто бы выбору класса с наибольшей вероятностью. Впрочем, как мы увидим дальше, всё не всегда работает так просто.\n\nОдну такую модель — правда, только для бинарной классификации — вы уже знаете. Это логистическая регрессия:\n\n$$P(y_i = 1 \\vert x_i,w) = \\frac{1}{1+e^{-\\langle x_i, w\\rangle}},\\quad P(y_i = 0 \\vert x_i,w) = \\frac{e^{-(x_i, w)}}{1+e^{-\\langle x_i, w\\rangle}} = \\frac{1}{1+e^{\\langle x_i, w\\rangle}}\n$$\n\nкоторую также можно записать в виде\n\n$$y_i \\vert x_i \\sim \\color{red}{Bern}\\left(\\frac{1}{1+e^{-\\langle x_i, w\\rangle}}\\right)\n$$\n\nгде $\\color{red}{Bern}(p)$ — распределение Бернулли с параметром $p$.\n\nНахождение вероятностей классов можно разделить на два этапа:\n\n$$\\begin{aligned}\n&\\text { Находим }\\\\\n&x_i \\xrightarrow{\\text { логиты }}\\left(-\\left\\langle x_i, w\\right\\rangle,\\left\\langle x_i, w\\right\\rangle\\right) \\xrightarrow{\\sigma}\\left(\\sigma\\left(-\\left\\langle x_i, w\\right\\rangle\\right), \\sigma\\left(\\left\\langle x_i, w\\right\\rangle\\right)\\right)\n\\end{aligned}\n$$\n\nгде, напомним, $\\sigma$ — это сигмоида:\n\n$$\\sigma(t) = \\frac{1}{1+e^{-t}}\n$$\n\nСигмоида тут не просто так. Она обладает теми счастливыми свойствами, что\n\n* монотонно возрастает;\n\n* отображает всю числовую прямую на интервал $(0,1)$;\n\n* $\\sigma(-x) = 1 - \\sigma(x)$.\n\nВот такой вид имеет её график:\n\n![9](https://yastatic.net/s3/education-portal/media/9_6_b02f5cb3c2_300bacce84.webp)\n\nИными словами, с помощью сигмоиды можно делать «вероятности» из чего угодно, то есть более или менее для любого отображения $f_w$ (из признакового пространства в $\\mathbb{R}$) с параметрами $w$ построить модель бинарной классификации:\n\n$$P(y_i = 0 \\vert x_i, w) = \\sigma(f_w(-x_i)),\\quad P(y_i = 1 \\vert x_i, w) = \\sigma(f_w(x_i)).\n$$\n\nКак и в случае логистической регрессии, такая модель равносильна утверждению о том, что\n\n$$f_w(x_i) = \\log{\\frac{p(y = 1 \\vert x_i,w)}{p(y = 0 \\vert x_i, w)}}.\n$$\n\nПохожим способом можно строить и модели для многоклассовой классификации. В этом нам поможет обобщение сигмоиды, которое называется **softmax**:\n\n$$softmax(t_1,\\ldots,t_K) = \\left(\\frac{e^{t_1}}{\\sum_{k=1}^Ke^{t_k}},\\ldots,\\frac{e^{t_K}}{\\sum_{k=1}^Ke^{t_k}}\\right)\n$$\n\nА именно, для любого отображения $f_w$ из пространства признаков в $\\mathbb{R}^K$ мы можем взять модель\n\n$$\\left(P(y_i = k \\vert x_i, w)\\right)^K_{k=1} = softmax(f_w(x_i))\n$$\n\nЕсли все наши признаки — вещественные числа, а $f_w(x_i) = x_iW$ — просто линейное отображение, то мы получаем однослойную нейронную сеть\n\n$$\\left(P(y_i = k \\vert x_i, w)\\right)^K_{k=1} = softmax(x_iW)\n$$\n\n![9](https://yastatic.net/s3/education-portal/media/9_7_ac9ec70d39_9cf6bad9a3.webp)\n\n**Предостережение**. Всё то, что мы описали выше, вполне работает на практике (собственно, классификационные нейросети зачастую так и устроены), но корректным не является.\n\nВ самом деле, мы говорим, что строим оценки вероятностей $P(y_i = k \\vert x_i, w)$, но для подбора параметров используем не эмпирические вероятности, а только лишь значения $\\underset{k}{\\operatorname{argmax}} \\ P(y_i = k \\vert x_i, w)$, то есть метки предсказываемых классов. Таким образом, при обучении мы не будем различать следующие две ситуации:\n\n![9](https://yastatic.net/s3/education-portal/media/9_8_33dfe17736_21e3dc05b5.webp)\n\nЭто говорит нам о некоторой неполноценности такого подхода.\n\nЗаметим ещё вот что. В случае бинарной классификации выбор предсказываемого класса как $\\underset{k}{\\operatorname{argmax}} P(y_i=k \\vert x_i,w)$ равносилен выбору того класса, для которого $P(y_i=k \\vert x_i,w) > \\frac{1}{2}$. Но если наши оценки вероятностей неадекватны, то этот вариант проваливается, и мы встаём перед проблемой выбора порога: каким должно быть значение $\\widehat{t}$, чтобы мы могли приписать класс 1 тем объектам $x_i$, для которых $\\sigma(f_w(x_i)) > \\widehat{t}$?\n\nВ одном из следующих параграфов мы обсудим, как всё-таки правильно предсказывать вероятности.",
        "handbook": "Учебник по машинному обучению",
        "title": "Вероятностный подход в ML",
        "description": null
    },
    {
        "path": "/handbook/ml/article/eksponencialnyj-klass-raspredelenij-i-princip-maksimalnoj-entropii",
        "content": "## Мотивация: метод моментов\n\nМетод моментов — это ещё один способ, наряду с методом максимального правдоподобия, оценки параметров распределения по данным $x_1,\\ldots,x_N$. Суть его в том, что мы выражаем через параметры распределения теоретические значения моментов $\\mu_k = \\mathbb{E}x^k$ нашей случайной величины, затем считаем их выборочные оценки $\\widehat{\\mu}_k = \\frac1N\\sum_ix_i^k$, приравниваем их все друг к другу и, решая полученную систему, находим оценки параметров.\n\nМожно доказать, что полученные оценки являются состоятельными, хотя могут быть смещены.\n\n**Пример 1**. Оценим параметры нормального распределения $\\mathcal{N}(\\mu, \\sigma^2)$ с помощью метода моментов.\n\nТеоретические моменты равны\n\n$$\\mu_1 = \\mu,\\quad\\mu_2 = \\sigma^2 + \\mu^2\n$$\n\nЗапишем систему:\n\n$$\\begin{cases}\n\\widehat{\\mu} = \\frac1N\\sum_i x_i,\\\\\n\\widehat{\\sigma}^2 + \\widehat{\\mu}^2 = \\frac1N\\sum_ix_i^2\n\\end{cases}\n$$\n\nИз неё очевидным образом находим\n\n$$\\widehat{\\mu} = \\frac1N\\sum_ix_i \n$$\n\n$$\\widehat{\\sigma}^2 = \\frac1N\\sum_ix_i^2 - \\left(\\frac1N\\sum_i x_i\\right)^2=\n$$\n\n$$=\\frac1N\\sum_i\\left(x_i - \\widehat{\\mu}\\right)^2\n$$\n\nЛегко видеть, что полученные оценки совпадают с оценками максимального правдоподобия\n\n**Пример 2**. Оценим параметр $\\mu$ логнормального распределения\n\n$$p(x) = \\frac1{x\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(\\log{x} - \\mu)^2}{2\\sigma^2}\\right)\n$$\n\nпри известном $\\sigma^2$. Будет ли оценка совпадать с оценкой, полученной с помощью метода максимального правдоподобия?\n\nТеоретическое математическое ожидание равно $\\exp\\left(\\mu + \\frac{\\sigma^2}2\\right)$, откуда мы сразу находим оценку $\\widehat{\\mu} = \\log\\left(\\frac1N\\sum_i x_i\\right) - \\frac{\\sigma^2}2$.\n\nТеперь запишем логарифм правдоподобия:\n\n$$l(X) = -\\sum_i\\log{x_i} - \\sum_i\\frac{(\\log{x_i} - \\mu)^2}{2\\sigma^2} + const\n$$\n\nДифференцируя по $\\mu$ и приравнивая производную к нулю, получаем\n\n$$\\widehat{\\mu}_{MLE} = \\frac1N\\sum_i\\log{x_i}\n$$\n\nчто вовсе не совпадает с оценкой выше.\n\nНесколько приукрасив ситуацию, можно сделать вывод, что первые два выборочных момента позволяют если не править миром, то уверенно восстанавливать параметры распределений. А теперь давайте представим, что мы посчитали $\\frac1N\\sum_ix_i$ и $\\frac1N\\sum_ix_i^2$, а семейство распределений пока не выбрали.\n\nКак же совершить этот судьбоносный выбор? Давайте посмотрим на следующие три семейства и подумаем, в каком из них мы бы стали искать распределение, зная его истинные матожидание и дисперсию?\n\n![10](https://yastatic.net/s3/education-portal/media/10_1_f204345b73_03123eb66b.webp)\n\nПочему-то хочется сказать, что в первом. Почему? Второе не симметрично — но почему мы так думаем? Если мы выберем третье, то добавим дополнительную информацию как минимум о том, что у распределения конечный носитель. А с чего бы? У нас такой инфомации вроде бы нет.\n\nОбщая идея такова: мы будем искать распределение, которое удовлетворяет только явно заданным нами ограничениям и не отражает никакого дополнительного знания о нём. Но чтобы эти нестрогие рассуждения превратить в формулы, придётся немного обогатить наш математический аппарат и научиться измерять количество информации.\n\n## Энтропия и дивергенция Кульбака-Лейблера\n\nИзмерять «знание» можно с помощью **энтропии Шэннона**. Она определяется как\n\n$$\\color{#348FEA}{H(P) = -\\sum_xP(x)\\log{P(x)}}\n$$\n\nдля дискретного распределения и\n\n$$\\color{#348FEA}{H(p) = -\\int p(x)\\log{p(x)}dx}\n$$\n\nдля непрерывного. В классическом определении логарифм двоичный, хотя, конечно, варианты с разным основанием отличаются лишь умножением на константу.\n\nНеформально можно представлять, что энтропия показывает, насколько сложно предсказать значение случайной величины. Чуть более строго — сколько в среднем бит нужно потратить, чтобы передать информацию о её значении.\n\n**Пример 1**. Рассмотрим схему Бернулли с вероятностью успеха $p$. Энтропия её результата равна\n\n$$-(1 - p)\\cdot\\log_2(1 - p) - p\\cdot\\log_2{p}\n$$\n\nДавайте посмотрим на график этой функции:\n\n![10](https://yastatic.net/s3/education-portal/media/10_2_d107fffe47_f64a04ca06.webp)\n\nМинимальное значение (нулевое) энтропия принимает при $p\\in\\{0,1\\}$. В самом деле, для такого эксперимента мы всегда можем наверняка сказать, каков будет его исход; обращаясь к другой интерпретации — чтобы сообщить кому-то о результате эксперимента, достаточно $0$ бит (ведь получатель сообщения и так понимает, что вышло).\n\nМаксимальное значение принимается в точке $\\frac12$, что вполне соответствует тому, что при $p=\\frac12$ предсказать исход эксперимента сложнее всего.\n\n{% cut \"Дополнение для ценителей математики.\" %}\n\nПопробуем для этого простого примера объяснить, почему среднее число бит, необходимых для передачи информации об исходе эксперимента, выражается формулой с логарифмами.\n\nТеперь пусть $p$ произвольно. Рассмотрим $N»1$ независимых испытаний $x_1,\\ldots, x_N$; среди них будет $n_0\\approx (1-p)N$ неудачных и $n_1\\approx pN$ удачных. Посчитаем, сколько бит потребуется, чтобы закодировать последовательность $x_i$ для известных $n_0$ и $n_1$. Общее число таких последовательностей равно $C_N^{n_1} = \\frac{N!}{n_0!n_1!}$, а чтобы закодировать каждую достаточно будет $\\log_2\\left(\\frac{N!}{n_0!n_1!}\\right)$ бит — это количество информации, содержащееся во всей последовательности. Таким образом, в среднем, чтобы закодировать результат одного испытания необходимо\n\n$$\\frac1N\\log_2\\left(\\frac{N!}{n_0!n_1!}\\right)\n$$\n\nбит информации. Перепишем это выражение, использовав формулу Стирлинга $\\log{N!}\\approx N\\log{N} - N$:\n\n$$\\frac1N\\left(\\log_2{N!} - \\log_2{n_0!} - \\log_2{n_1!}\\right) \\approx \n$$\n\n$$\\approx const\\cdot\\frac1N\\left(N\\log_2{N} - N - n_0\\log_2{n_0} + n_0 - n_1\\log_2{n_1} + n_1\\right) =\n$$\n\n$$=const\\cdot\\frac1N\\left(N\\log_2{N} - (1-p)N\\log_2{(1-p)N} - pN\\log_2{pN}\\right) =\n$$\n\n$$=const\\cdot\\left(-(1-p)\\cdot\\log_2(1-p) - p\\log_2{p}\\right)\n$$\n\nВот мы и вывели формулу энтропии!\n\n{% endcut %}\n\n**Пример 2**. Энтропия нормального распределения $\\mathcal{N}(\\mu, \\sigma^2)$ равна $\\frac12\\log(2\\pi\\sigma^2) + \\frac12$, и чем меньше дисперсия, тем меньше энтропия, что и логично: ведь когда дисперсия мала, значения сосредоточены возле матожидания, и они становятся менее «разнообразными».\n\nЭнтропия тесно связана с другим важным понятием из теории информации — **дивергенцией Кульбака-Лейблера**. Она определяется для $p(x)$ $q(x)$ как\n\n$$\\color{#348FEA}{KL(p\\vert\\vert q) = \\int p(x)\\log{\\frac{p(x)}{q(x)}}dx}\n$$\n\nв непрерывном случае и точно так же, но только с суммой вместо интеграла в дискретном.\n\nДивергенцию можно представить в виде разности:\n\n$$KL(p\\vert\\vert q) = (-\\int p(x)\\log{q(x)}dx) - (-\\int p(x)\\log{p(x)}dx)\n$$\n\nВычитаемое — это энтропия, которая, как мы уже поняли, показывает, сколько в среднем бит требуется, чтобы закодировать значение случайной величины. Уменьшаемое похоже по виду, и можно показать, что оно говорит о том, сколько в среднем бит потребуется на кодирование случайной величины с плотностью $p$ алгоритмом, оптимизированным для кодирования случайной величины $q$.\n\nИными словами, дивергенция Кульбака-Лейблера говорит о том, насколько увеличится средняя длина кодов для значений $p$, если при настройке алгоритма кодирования вместо $p$ использовать $q$. Более подробно вы можете почитать, например, в [этом посте](https://habr.com/ru/post/484756/).\n\nДивергенция Кульбака-Лейблера в некотором роде играет роль расстояния между распределениями. В частности, $KL(p\\vert\\vert q)\\geqslant0$, причём дивергенция равна нулю, только если распределения совпадают почти всюду. Но при этом она не является симметричной: вообще говоря, $KL(p\\vert\\vert q)\\ne KL(q\\vert\\vert p)$.\n\n**Вопрос на подумать**. Пусть $p(x)$ — распределение, заданное на отрезке $[a, b]$. Выразите энтропию через дивергенцию Кульбака-Лейблера $p(x)$ с равномерным на отрезке распределением $q_U(x)=\\frac1{b-a}\\mathbb{I}_{[a,b]}(x)$.\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nРаспишем дивергенцию:\n\n$$KL(p\\vert\\vert q_U) = -\\left(-\\int_a^b p(x)\\log{p(x)}dx\\right) - \\int_a^b p(x)\\log{\\underbrace{q(x)}_{=\\frac1{b-a}\\text{ на }[a,b]}}dx=\n$$\n\n$$=\\log(b-a) - H(p)\n$$\n\nАналогичное соотношение можно выписать и для распределения, заданного на конечном множестве.\n\n{% endcut %}\n\n## Принцип максимальной энтропии\n\nТеперь наконец мы готовы сформулировать, какие распределения мы хотим искать.\n\n**Принцип максимальной энтропии**. Среди всех распределений на заданном носителе $\\mathbb{X}$, удовлетворяющих условиям $\\mathbb{E}u_1(x) = \\mu_1$, ..., $\\mathbb{E}u_k(x) = \\mu_k$, где $u_i$ — некоторые функции, мы хотим иметь дело с тем, которое имеет наибольшую энтропию.\n\nВ самом деле, энтропия выражает нашу меру незнания о том, как ведёт себя распределение, и чем она больше — тем более «произвольное распределение», по крайней мере, в теории.\n\nДавайте рассмотрим несколько примеров, которые помогут ещё лучше понять, почему некоторые распределения так популярны:\n\n**Пример 1**. На конечном множестве $1,\\ldots,n$ наибольшую энтропию имеет равномерное распределение (носитель — конечное множество из $n$ элементов, других ограничений нет).\n\n**Доказательство**: Пусть $p_i$, $i=1,\\ldots,n$ — некоторое распределение, $q_i=\\frac1n$ — равномерное. Запишем их дивергенцию Кульбака-Лейблера:\n\n$$KL(p\\vert\\vert q) = \\sum_i p_i\\log{p_i} - \\sum_i p_i\\log{q_i} =\n$$\n\n$$= -H(p) + \\log{n}\\underbrace{\\sum_ip_i}_{=1}\n$$\n\nТак как дивергенция Кульбака-Лейблера всегда неотрицательна, получаем, что $H(p)\\leqslant\\log{n}$. При этом равенство возможно, только если распределения совпадают.\n\n**Пример 2**. Среди распределений, заданных на всей вещественной прямой и имеющих заданные матожидание $\\mu$ и дисперсию $\\sigma^2$ наибольшую энтропию имеет нормальное распределение $\\mathcal{N}(\\mu,\\sigma^2)$.\n\n**Доказательство**: Пусть $p(x)$ — некоторое распределение, $q(x)\\sim\\mathcal{N}(\\mu, \\sigma^2)$. Запишем их дивергенцию Кульбака-Лейблера:\n\n$$KL(p\\vert\\vert q) = \\int p(x)\\log{p(x)}dx - \\int p(x)\\log{q(x)}dx =\n$$\n\n$$= -H(p) - \\int p(x)\\left(-\\frac12\\log(2\\pi\\sigma^2) - \\frac1{2\\sigma^2}(x - \\mu)^2\\right)dx =\n$$\n\n$$= - H(p) +\\frac12\\log(2\\pi\\sigma^2)\\cdot\\underbrace{\\int p(x)dx}_{=1} + \\frac1{2\\sigma^2}\\underbrace{\\int(x - \\mu)^2p(x)dx}_{=\\mathbb{V}p=\\sigma^2} =\n$$\n\n$$= - H(p) + \\underbrace{\\frac12\\log(2\\pi\\sigma^2) + \\frac12}_{=H(q)}\n$$\n\nТак как дивергенция Кульбака-Лейблера всегда неотрицательна, получаем, что $H(p)\\leqslant H(q)$. При этом равенство возможно, только если распределения $p$ и $q$ совпадают почти всюду, а с точки зрения теории вероятностей такие распределения различать не имеет смысла.\n\n**Пример 3**. Среди распределений, заданных на множестве положительных вещественных чисел и имеющих заданное матожидание $\\lambda$ наибольшую энтропию имеет показательное распределение с параметром $\\frac1{\\lambda}$ (его плотность равна $p(x) = \\frac1{\\lambda}\\exp\\left(-\\frac1{\\lambda}x\\right)\\mathbb{I}_{(0;+\\infty)}(x)$).\n\nВсе хорошо знакомые нам распределения, не правда ли? Проблема в том, что они свалились на нас чудесным образом. Возникает вопрос, можно ли их было не угадать, а вывести как-нибудь? И как быть, если даны не эти конкретные, а какие-то другие ограничения?\n\nОказывается, что при некоторых не очень обременительных ограничениях ответ можно записать с помощью распределений экспоненциального класса. Давайте же познакомимся с ними поближе.\n\n## Экспоненциальное семейство распределений\n\nГоворят, что семейство распределений относится к **экспоненциальному классу**, если оно может быть представлено в следующем виде:\n\n$$\\color{#348FEA}{p(x\\vert\\theta) = \\frac1{h(\\theta)}g(x)\\cdot\\exp\\left(\\theta^Tu(x)\\right)}\n$$\n\nгде $\\theta$ — вектор вещественнозначных параметров (различные значения которых дают те или иные распределения из семейства), $h, g > 0$, $u$ — некоторая вектор-функция, и, разумеется, сумма или интеграл по $x$ равняется единице. Последнее, в частности, означает, что\n\n$$h(\\theta) = \\int g(x)\\exp\\left(\\theta^Tu(x)\\right)dx\n$$\n\n(или сумма в дискретном случае).\n\n**Пример 1**. Покажем, что нормальное распределение принадлежит экспоненциальному классу. Для этого мы должны представить привычную нам функцию плотности\n\n$$p(x \\vert \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n$$\n\nв виде\n\n$$p(x\\vert\\theta) = \\frac{g(x)\\cdot\\exp\\left(\\sum_i\\text{(параметр)}_i\\cdot\\text{(функция от x)}_i\\right)}{\\text{что-то, не зависящее от $x$}}\n$$\n\nРаспишем\n\n$$\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) =\n\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac1{2\\sigma^2}x^2 + \\frac{\\mu}{\\sigma^2}x + \\frac{\\mu^2}{2\\sigma^2}\\right)=$$\n\n$$\\frac{\\exp\\left(-\\frac1{2\\sigma^2}x^2 + \\frac{2\\mu}{2\\sigma^2}x\\right)}{\\sqrt{2\\pi}\\sigma\\exp\\left(-\\frac{\\mu^2}{2\\sigma^2}\\right)}=$$\n\nОпределим\n\n$$u_1(x) = x,\\qquad u_2(x) = x^2\n$$\n\n$$\\theta_1 = \\frac{\\mu}{\\sigma^2},\\quad \\theta_2 = -\\frac1{2\\sigma^2}\n$$\n\n$$h(\\theta) = \\sqrt{2\\pi}\\sigma\\exp\\left(-\\frac{\\mu^2}{2\\sigma^2}\\right)\n$$\n\nЕсли теперь всё-таки честно выразить $h$ через $\\theta$ (это мы оставляем в качестве лёгкого упражнения), то получится\n\n$$p(x \\vert \\mu, \\sigma^2) = \\frac1{h(\\theta)}\\exp\\left(\\theta^Tu(x)\\right)\n$$\n\nВ данном случае функция $g(x)$ просто равна единице.\n\n**Пример 2**. Покажем, что распределение Бернулли принадлежит экспоненциальному классу. Для этого попробуем преобразовать функцию вероятности (ниже $x$ принимает значения $0$ или $1$):\n\n$$P(x \\vert p) = p^x(1 - p)^{1 - x} = \\exp\\left(x\\log{p} + (1 - x)\\log(1 - p)\\right)\n$$\n\nТеперь мы можем положить $u(x) = \\left(x, 1 - x\\right)$, $\\theta = \\left(p, 1 - p\\right)$, и всё получится. Единственное, что смущает, — это то, что компоненты вектора $u(x)$ линейно зависимы. Хотя это не является формальной проблемой, но всё же хочется с этим что-то сделать. Исправить это можно, если переписать\n\n$$p^x(1 - p)^{1 -x} = (1 - p)\\exp\\left(x\\log{p} + (-x)\\log(1 - p)\\right) =\n$$\n\n$$=(1 - p)\\exp\\left(x\\log{\\frac{p}{1 - p}}\\right)\n$$\n\nи определить уже минимальное представление с $u(x) = x$, $\\theta = \\log{\\frac{p}{1 - p}}$ — мы ведь уже сталкивались с этим выражением, когда изучали логистическу регрессию, не так ли?\n\n**Вопрос на подумать**. Принадлежит ли к экспоненциальному классу семейство равномерных распределений на отрезках $U[a, b]$? Казалось бы, да: так как:\n\n$$p(x) = \\frac{1}{b - a}\\mathbb{I}_{[a,b]}(x)\\exp(0)\n$$\n\nВ чём может быть подвох?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nНет, не принадлежит. Давайте вспомним, как звучало определение экспоненциального семейства. Возможно, вас удивило, что там было написано не «распределение относится», а «семейство распределений относится».\n\nЭто важно: ведь семейство определяется именно различными значениями $\\theta$, и если нас интересует семейство равномерных распределений на отрезках, определяемое параметрами $a$ и $b$, то они не могут быть в функции $g(x)$, они должны быть под экспонентой, а экспонента ни от чего не может быть равна индикатору.\n\nПри этом странное и не очень полезное семейство с нулём параметров, состоящее из одинокого распределения $U[0,1]$ можно считать относящимся к экспоненциальному классу: ведь для него формула\n\n$$p(x) = \\mathbb{I}_{[0,1]}(x)\\exp(0)\n$$\n\nбудет работать.\n\n{% endcut %}\n\nКак мы увидели, к экспоненциальным семействам относятся как непрерывные, так и дискретные распределения. Вообще, к ним относится большая часть распределений, которыми Вам на практике может захотеться описать $Y \\vert X$.\n\nВ том числе:\n\n* нормальное;\n* распределение Пуассона;\n* экспоненциальное;\n* биномиальное, мультиномиальное (с фиксированным числом испытаний);\n* геометрическое;\n* $\\chi^2$-распределение;\n* бета-распределение;\n* гамма-распределение;\n* распределение Дирихле.\n\nК экспоненциальным семействам не относятся, к примеру:\n\n* равномерное распределение на отрезке;\n* $t$-распределение Стьюдента;\n* распределение Коши;\n* смесь нормальных распределений.\n\n## MLE для семейства из экспоненциального класса\n\nВозможно, вас удивил странный и на первый взгляд не очень естественный вид $p(x\\vert\\theta)$. Но всё не просто так: оказывается, что оценка максимального правдоподобия параметров распределений из экспоненциального класса устроена очень интригующе.\n\nЗапишем функцию правдоподобия выборки $X = (x_1,\\ldots,x_N)$:\n\n$$p(X\\vert\\theta) = h(\\theta)^{-N}\\cdot\\left(\\prod_{i=1}^Ng(x_i)\\right)\\cdot\\exp\\left(\\theta^T\\left[\\sum_{i=1}^Nu(x_i)\\right]\\right)\n$$\n\nЕё логарифм равен\n\n$$l(X\\vert\\theta) = -N\\log{h(\\theta)} + \\sum_{i=1}^N\\log{g(x_i)} + \\theta^T\\left[\\sum_{i=1}^Nu(x_i)\\right]\n$$\n\nДифференцируя по $\\theta$, получаем\n\n$$\\nabla_{\\theta}l(X\\vert\\theta) = -N\\nabla_{\\theta}\\log{h(\\theta)} + \\left[\\sum_{i=1}^Nu(x_i)\\right]\n$$\n\nТут нам потребуется следующая\n\n**Лемма**. $\\nabla_{\\theta}\\log{h(\\theta)} = \\mathbb{E}u(x)$\n\n**Доказательство**:\n\nКак мы уже отмечали в прошлом пункте:\n\n$$h(\\theta) = \\int g(x)\\exp\\left(\\theta^Tu(x)\\right)dx\n$$\n\nСледовательно,\n\n$$\\nabla_{\\theta}\\log{h(\\theta)} = \\frac{\\nabla_{\\theta}\\int g(x)\\exp\\left(\\theta^Tu(x)\\right)dx}{\\int g(x)\\exp\\left(\\theta^Tu(x)\\right)dx} =\n$$\n\n$$= \\frac{\\int u(x)g(x)\\exp\\left(\\theta^Tu(x)\\right)dx}{h(\\theta)} =\n$$\n\n$$=\\int u(x)\\cdot\\frac1{h(\\theta)}g(x)\\exp\\left(\\theta^Tu(x)\\right)dx = \\mathbb{E}u(x)\n$$\n\nКстати, можно ещё доказать, что\n\n$$\\frac{\\partial}{\\partial \\theta_i\\partial\\theta_j}\\log{h(\\theta)} = \\text{Cov}(u_i(x), u_j(x))\n$$\n\nПриравнивая $\\nabla_{\\theta}l(X\\vert\\theta)$ к нулю и применяя лемму, мы получаем, что\n\n$$\\color{#348FEA}{\\mathbb{E}u(x) = \\frac1N\\left[\\sum_{i=1}^Nu(x_i)\\right]}\n$$\n\nТаким образом, теоретические матожидания всех компонент $u_i(x)$ должны совпадать с их эмпирическими оценками, а метод максимального правдоподобия совпадает с методом моментов для $\\mathbb{E}u_i(x)$ в качестве моментов.\n\nИ в следующем пункте выяснится, что распределения из семейств, относящихся к экспоненциальному классу, это те самые распределения, которые имеют максимальную энтропию из тех, что имеют заданные моменты $\\mathbb{E}u_i(x)$.\n\n\\*\\*Пример.\\*\\*Рассмотрим вновь логнормальное распределение:\n\n$$p(x) = \\frac1{x\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac{(\\log{x} - \\mu)^2}{2\\sigma^2}\\right) =\n$$\n\n$$=\\frac1{x\\sqrt{2\\pi\\sigma^2}}\\exp\\left(-\\frac1{2\\sigma^2}\\log^2{x} + \\frac{\\mu}{\\sigma^2}\\log{x} - \\frac{\\mu^2}{2\\sigma^2}\\right) =\n$$\n\n$$=\\frac1{x\\sqrt{2\\pi\\sigma^2}\\exp\\left(\\frac{\\mu^2}{2\\sigma^2}\\right)}\\exp\\left(\\underbrace{\\frac{\\mu}{\\sigma^2}}_{=\\theta_1}\\underbrace{\\log{x}}_{=u_1(x)} -\\underbrace{\\frac1{2\\sigma^2}}_{=\\theta_2}\\underbrace{\\log^2{x}}_{=u_2(x)}  \\right) =\n$$\n\n$$\\frac{1}{\\sqrt{-\\pi\\theta_2^{-1}}\\cdot\\exp{-\\frac{\\theta_1^2}{4\\theta_2}}}\\cdot\\frac1x\\exp\\left(\\theta_1u_1(x) + \\theta_2u_2(x)\\right)\n$$\n\nКак видим, логнормальное распределение тоже из экспоненциального класса. Вас может это удивить: ведь выше мы обсуждали, что для него метод моментов и метод максимального правдоподобия дают разные оценки.\n\nНо никакого подвоха тут нет: мы просто брали не те моменты. В данном случае $u_1(x) = \\log{x}$, $u_2(x) = \\log^2{x}$, их матожидания и надо брать; тогда для параметров, получаемых из MLE, должно выполняться\n\n$$\\mathbb{E}\\log{x} = \\frac1N\\sum_i\\log{x_i},\\quad \\mathbb{E}\\log^2{x} = \\frac1N\\sum_i\\log^2{x_i}\n$$\n\nМатожидания в левых частых мы должны выразить через параметры — и нам для этого совершенно не обязательно что-то интегрировать! В самом деле:\n\n$$\\mathbb{E}\\log{x} = \\frac{\\partial}{\\partial\\theta_1}\\log{h(\\theta)} =\n$$\n\n$$=\\frac{\\partial}{\\partial\\theta_1}\\left(-\\frac12\\log{\\pi} + \\frac12\\log{\\theta_2} - \\frac{\\theta_1^2}{4\\theta_2^2}\\right) = -\\frac{\\theta_1}{2\\theta_2^2}\n$$\n\n$$\n\\mathbb{E}\\log^2{x} = \\frac{\\partial}{\\partial\\theta_2}\\log{h(\\theta)} = \\frac1{2\\theta_2} + \\frac{\\theta_1^2}{2\\theta_2^3}\n$$\n\n## Теорема Купмана-Питмана-Дармуа\n\nТеперь мы наконец готовы сформулировать одно из самых любопытных свойств семейств экспоненциального класса.\n\nВ следующей теореме мы опустим некоторые не очень обременительные условия регулярности. Просто считайте, что для хороших дискретных и абсолютно непрерывных распределений, с которыми вы в основном и будете сталкиваться, это так.\n\n**Теорема**. Пусть $p(x) = \\frac1{h(\\theta)}\\exp\\left(\\theta^Tu(x)\\right)$ — распределение, причём $\\theta$ — вектор длины $n$ и $\\mathbb{E}u_i(x) = \\alpha_i$ для некоторых фиксированных $\\alpha_i$, $i=1,\\ldots,n$. Тогда распределение $p(x)$ обладает наибольшей энтропией среди распределений с тем же носителем, для которых $\\mathbb{E}u_i(x) = \\alpha_i$, $i=1,\\ldots,n$. При этом оно  — единственное с таким свойством: в том смысле, что любое другое распределение, обладающее этим свойством, совпадает с ним почти всюду.\n\n{% cut \"Идея обоснования через оптимизацию.\" %}\n\nМы приведём рассуждение для дискретного случая; в абсолютно непрерывном рассуждения будут по сути теми же, только там придётся дифференцировать не по переменным, а по функциям, и мы решили не ввергать вас в мир вариационного исчисления.\n\nВ дискретном случае у нас есть счётное семейство точек $x_1, x_2,\\ldots$, и распределение определяется счётным набором вероятностей $p_i$ принимать значение $x_i$. Мы будем решать задачу\n\n$$\\begin{cases}\n-\\sum_j p_j\\log{p_j}\\longrightarrow\\max,\\\\\n\\sum_jp_ju_i(x_j) = \\alpha_i, i = 1,\\ldots,n,\\\\\n\\sum_jp_j = 1,\\\\\np_j\\geqslant0\n\\end{cases}\n$$\n\nЗапишем лагранжиан:\n\n$$\\mathcal{L} = \\sum_j p_j\\log{p_j} + \\sum_i\\theta_i\\left(\\alpha_i - \\sum_jp_ju_i(x_j)\\right)+\n$$\n\n$$+\\theta_0\\left(\\sum_jp_j - 1\\right) - \\sum_j\\lambda_jp_j\n$$\n\nПродифференцируем его по $p_j$:\n\n$$\\frac{\\partial\\mathcal{L}}{\\partial p_j} = \\log{p_j} + 1 - \\sum_i\\theta_iu_i(x_j) + \\theta_0 - \\lambda_j\n$$\n\nПриравнивая это к нулю, получаем\n\n$$p_j = \\frac{\\exp\\left(\\langle \\theta, u(x_j)\\rangle\\right)}{\\exp\\left(\\lambda_j - \\theta_0 - 1\\right)}\n$$\n\nЧислитель уже ровно такой, как и должен быть у распределения из экспоненциального класса. Разберёмся со знаменателем.\n\nЛегко видеть, что условие $p_j\\geqslant0$ заведомо выполнено (ведь тут сплошные экспоненты), так что его можно было выкинуть из постановки задачи оптимизации или, что то же самое, положить $\\lambda_j = 0$. Параметр $\\theta_0$ находится из условия $\\sum_jp_j = 1$, а точнее, выражается через остальные $\\theta_i$, что позволяет записать знаменатель в виде $h(\\theta)$.\n\n{% endcut %}\n\n{% cut \"Идея доказательства «в лоб».\" %}\n\nКак и следовало ожидать, оно ничем не отличается от того, как мы доказывали максимальность энтропии у равномерного или нормального распределения. Пусть $q(x)$ — ещё одно распределение, для которого\n\n$$\\int u_i(x)q(x)dx = \\int u_i(x)p(x)dx\n$$\n\nдля всех $i = 1,\\ldots,n$. Тогда\n\n$$0\\leqslant KL(q\\vert\\vert p) = \\int q(x)\\log\\left(\\frac{q(x)}{p(x)}\\right)dx = \n$$\n\n$$=\\underbrace{\\int q(x)\\log{q(x)}dx}_{-H(q)} - \\int q(x)\\log{p(x)}dx=\n$$\n\n$$=-H(q) - \\int q(x)\\left(-\\log{h(\\theta)} + \\sum_i\\theta_iu_i(x)\\right)dx =\n$$\n\n$$=-H(q) - \\log{h(\\theta)}\\underbrace{\\int q(x)dx}_{=1=\\int p(x)dx} - \\sum_i\\theta_i\\underbrace{\\int q(x)u_i(x)dx}_{=\\int p(x)u_i(x)dx} =\n$$\n\n$$=-H(q) - \\int p(x)\\left(-\\log{h(\\theta)} + \\sum_i\\theta_iu_i(x)\\right)dx =\n$$\n\n$$=-H(q) + \\int p(x)\\log{p(x)}dx = -H(q) + H(p)\n$$\n\nТаким образом, $H(p)\\geqslant H(q)$, причём по уже не раз использованному нами свойству дивергенции Кульбака-Лейблера из $H(p) = H(q)$ будет следовать то, что $p$ и $q$ совпадают почти всюду.\n\n{% endcut %}\n\nРассмотрим несколько примеров:\n\n**Пример 1**. Среди распределений на множестве $\\{1,2,3,\\ldots\\}$ неотрицательных целых чисел с заданным математическим ожиданием $\\mu$ найдём распределение с максимальной энтропией.\n\nВ данном случае у нас лишь одна функция $u_1(x) = x$, которая соответствует фиксации матожидания $\\mathbb{E}x$. Плотность будет вычисляться только в точках $x=k$, $k=1,2,\\ldots$ и будет иметь вид\n\n$$p_k = p(k) = \\frac1{h(\\theta)}\\exp\\left(\\theta k\\right)\n$$\n\nВ этой формуле уже безошибочно угадывается геометрическое распределение с $p = 1 - e^{\\theta}$. Параметр $p$ можно подобрать из соображений того, что математическое ожидание равно $\\mu$. Матожидание геометрического распределения равно $\\frac1p$, так что $p = \\frac1{\\mu}$. Окончательно,\n\n$$p_k = \\frac1{\\mu}\\left(1 - \\frac1{\\mu}\\right)^{k-1}\n$$\n\n**Пример 2**. Среди распределений на всей вещественной прямой с заданным математическим ожиданием $\\mu$ найдём распределение с максимальной энтропией.\n\n{% cut \"А сможете ли вы его найти? Решение под катом.\" %}\n\nТеория говорит нам, что его плотность должна иметь вид\n\n$$p(x) = \\frac1{h(\\theta)}\\exp\\left(\\theta x\\right)\n$$\n\nно интеграла экспоненты не существует, то есть применение «в лоб» теоремы провалилось. И неспроста: если даже рассмотреть все нормально распределённые случайные величины со средним $\\mu$, их энтропии, равные $\\frac12 + \\frac12\\log(2\\pi\\sigma^2)$ не ограничены сверху, то есть величины с наибольшей энтропией не существует.\n\n{% endcut %}",
        "handbook": "Учебник по машинному обучению",
        "title": "Экспоненциальный класс распределений и принцип максимальной энтропии",
        "description": null
    },
    {
        "path": "/handbook/ml/article/obobshyonnye-linejnye-modeli",
        "content": "## Мотивация\n\nДо сих пор мы рассматривали в основном модели вида\n\n$$y\\sim f(x) + \\varepsilon\n$$\n\nс шумом $\\varepsilon$ из того или иного распределения. Но у этих моделей:\n\n* шум не зависит от $x$;\n* $y$ может принимать любые значения.\n\nА что, если мы захотим предсказывать время ожидания доставки? Казалось бы, чем дольше время потенциального ожидания, тем больше его дисперсия. А как корректно предсказывать таргет, который принимает только целые значения?\n\nОдин из подходов мы обсудим в этом параграфе. Грубо говоря, вместо того, чтобы прибавлять один и тот же шум, мы зафиксируем семейство распределений $p(y\\vert\\mu(x))$, в котором изменяемым параметром будет зависящее от $x$ математическое ожидание $\\mu(x)$.\n\nВот как могут выглядеть такие модели для случаев, если $p$ нормальное с фиксированной дисперсией, экспоненциальное или пуассоновское соответственно:\n\n![11](https://yastatic.net/s3/education-portal/media/11_1_2d3c074374_99fed934e7.webp)\n\nКак видим, такой подход позволяет получать и модели с меняющейся дисперсией шума, и модели с целочисленным таргетом.\n\n## Определение\n\nМы рассмотрим достаточно широкий класс моделей — **обобщённые линейные модели** (**generalized linear models**, **GLM**). К ним относятся, в частности, линейная и логистическая регрессии. В итоге мы научимся подбирать подходящую регрессионную модель для самых разных типов данных.\n\nВспомним, что вероятностную модель линейной регрессии можно записать как\n\n$$y \\vert x \\sim\\color{red}{\\mathcal N}(\\langle x, w\\rangle, \\tau^2),\n$$\n\nа вероятностную модель логистической регрессии — как\n\n$$y \\vert x \\sim \\color{red}{Bern}(\\color{blue}{\\sigma}(\\langle x, w\\rangle)),\n$$\n\nгде $\\color{red}{Bern}(p)$ — распределение Бернулли с параметром $p$, а $\\color{blue}{\\sigma}(u) = \\frac{1}{1+e^{-u}}$.\n\nИтак, чем в этих терминах отличаются вероятностные модели линейной и логистической регрессии? Во первых, параметризованное семейство распределений для $y \\vert x$, а именно, $\\textcolor{red}{\\mathcal{N}(\\ast, \\sigma^2)}$ в случае линейной регрессии и $\\color{red}{Bern}$ в случае логистической.\n\nВо-вторых, в обоих случаях математическое ожидание условного распределения $y\\vert x$ является функцией от $\\langle x, w\\rangle$. На это можно посмотреть и по-другому: для каждой из задач выбрана функция $g$ такая, что $g(\\mathbb E(y \\vert x)) = \\langle x, w\\rangle$. Эта функция называется **функцией связи** (**link function**).\n\nВ случае линейной регрессии  $g(u) = u$. В самом деле, $\\mathbb E(y \\vert x) = \\mathbb E{\\mathcal N}(\\langle x, w\\rangle, \\tau^2) = \\langle x, w\\rangle$. В случае логистической регрессии $g(u) = \\sigma^{-1}(u) = \\text{logit}(u) = \\log\\frac{u}{1-u}$. Давайте это тоже проверим. В модели логистической регрессии условное распределение $y \\vert x$ — это распределение Бернулли с вероятностью успеха $\\sigma(\\langle x, w\\rangle)$, и этой же вероятности равно его математическое ожидание. Следовательно, $g(\\sigma(\\langle x, w\\rangle)) = \\sigma^{-1}(\\sigma(\\langle x, w\\rangle)) = \\langle x, w\\rangle$.\n\nОбобщая, можно сказать, что, если данные таковы, что $\\mathbb E(Y \\vert X)$ не является линейной функцией от $x$, мы линеаризуем $\\mathbb E(Y \\vert X)$ с помощью функции связи $g$.\n\n**Замечание:** Вообще говоря, нормальное распределение определяется не только своим математическим ожиданием, но и стандартным отклонением. То есть, в отличие от логистической регрессии, модель линейной регрессии не позволяет для данного $x$ оценить все параметры распределения $y \\vert x$, и дисперсию приходится фиксировать изначально. К счастью, выбор её значения в нормальном распределении не влияет ни на оптимальный вектор весов $w$, ни на итоговые предсказания $\\mathbb E(Y \\vert X)$, которые выдаёт обученная модель.\n\nПродолжим. Задав эти две составляющие — параметризованное семейство распределений и функцию связи — мы получим обобщённую линейную модель (GLM).\n\nДля нового объекта $x$ она выдаст предсказание $\\widehat{y} = \\mathbb{E}(y\\vert x) = g^{-1}(\\langle x, w\\rangle)$, а выбор класса распределений $y \\vert x$ потребуется нам для подбора весов $w$. В принципе, можно выбрать любой класс распределений $y \\vert x$ и любую монотонную функцию связи $g$, получив некоторую вероятностную модель. Однако обычно для упрощения поиска оптимальных весов $w$ в GLM предполагают, что $y \\vert x$ принадлежит одному из достаточно простых семейств экспоненциального класса.\n\n## Что даёт нам принадлежность экспоненциальному классу?\n\nВ контексте GLM обычно рассматривают подкласс экспоненциального класса, состоящий из семейств, представимых в виде\n\n$$\\color{#348FEA}{p(y \\vert \\theta, \\phi) = \\exp\\left(\\frac{y\\theta - a(\\theta)}{\\phi} + b(y, \\phi)\\right)}\n$$\n\nгде $\\theta$ и $\\phi$ — скалярные параметры, причём $\\phi$ — нечто фиксированное, обычно дисперсия, которая чаще всего полагается равной $1$, а значения $\\theta$ параметризуют распределения из семейства. Нетрудно переписать плотность в более привычном для нас виде, чтобы стало очевидно, что это семейство действительно из экспоненциального класса:\n\n$$p(y \\vert \\theta, \\phi) = \\frac1{\\exp\\left(\\frac{a(\\theta)}{\\phi}\\right)}\\exp(b(y,\\phi))\\exp\\left(\\frac{y\\theta}{\\phi}\\right)\n$$\n\nДействительно, если вспомнить, что $\\varphi$ — это константа, а не параметр, то получается очень похоже на\n\n$$p(y\\vert\\nu) = \\frac1{h(\\nu)}g(y)\\cdot\\exp\\left(\\nu^Tu(y)\\right)\n$$\n\nВ частности, мы видим, что $u(y)$ состоит из единственной компоненты $u_1(y)$, равной $\\frac{y}{\\phi}$. По доказанной в предыдущем разделе лемме имеем тогда, что математическое ожидание $\\mu$ такой случайной величины равно\n\n$$\\mu = \\phi\\mathbb{E}u_1(y) = \\phi\\frac{\\partial}{\\partial\\theta}\\left(\\frac{a(\\theta)}{\\phi}\\right) = a'(\\theta)\n$$\n\nДо сих пор мы рассуждали о распределении $p(y)$ без $x$ в условии. Что будет, если его добавить? Параметр $\\phi$ мы договорились сохранять постоянным, тогда от $x$ должен зависеть единственный оставшийся параметр $\\theta$.\n\nСамый естественный в нашей ситуации вариант — это положить $\\theta = \\langle x, w\\rangle$. В GLM мы вводили функцию $g$, для которой $g(\\mathbb E(y \\vert x)) = \\langle x, w\\rangle$, то есть $\\mathbb{E}(y\\vert x) = g^{-1}(\\langle x, w\\rangle)$. Но ведь матожидание $y$ равно $a'(\\theta)$, то есть $a'(\\langle x, w\\rangle)$. Это позволяет нам однозначно определить функцию связи $g = (a')^{-1}$. Такая функция связи называется **канонической функцией связи** (**canonical link function**).\n\n## Примеры\n\nПоговорим немного о том, как на практике подбирать $\\phi, a, b$, чтобы по классу распределений $y \\vert x$ определить каноническую функцию связи. Чтобы разобраться, рассмотрим несколько примеров.\n\n**Пример 1**. Пусть мы решили применить к данным линейную регрессию. Тогда\n\n$$p(y \\vert x, w, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(y-\\langle x, w\\rangle)^2}{2\\sigma^2}\\right)\n$$\n\nОбозначим для краткости $\\mu = \\langle x, w\\rangle$ и будем рассматривать $p(y\\vert \\mu, \\sigma^2)$.\n\nМы уже знаем, что семейство нормальных распределений относится к экспоненциальному классу, но давайте выразим эту плотность в описанном выше более частном виде:\n\n$$p(y \\vert \\mu, \\sigma^2) = \\exp\\left(-\\frac{(y-\\mu)^2 }{2\\sigma^2}- \\log(2\\pi\\sigma^2)\\right)\n$$\n\nВ формуле экспоненциального семейства распределений единственная часть, не зависящая от $\\theta$, — это функция $b$. Поскольку $\\mu=a'(\\theta)$, функция $b$ также не должна зависеть от $\\mu$. Так что внутри экспоненты выделим в качестве функции $b$ всё, что не зависит от $\\mu$:\n\n$$p(y \\vert \\mu, \\sigma^2) = \\exp\\left(\\frac{\\overbrace{y\\mu}^{=y\\theta} - \\overbrace{\\mu^2/2}^{=a(\\theta)}}{\\underbrace{\\sigma^2}_{=\\phi}}\\underbrace{ - \\left(\\frac{y_i^2}{2\\sigma^2} + \\log(2\\pi\\sigma^2)\\right)}_{=b(y,\\phi)}\\right)\n$$\n\nЭта формула уже похожа на формулу экспоненциального семейства распределений и видно, что $\\phi=\\sigma^2$, $\\theta=g(\\mu)=\\mu$ (коэффициент при $y$), $a(\\theta) = \\mu^2/2 = \\theta^2/2$, $b(y, \\phi) = -\\frac{y^2}{2\\sigma^2} - \\log(2\\pi\\sigma^2)$.\n\nКаноническая функция связи является обратной к $a'(\\theta) = \\theta$, то есть $\\langle x, w\\rangle = g(\\mu) = \\mu$, как мы и привыкли.\n\n**Пример 2**. Проделаем то же самое, но теперь для распределения Бернулли.\n\n{% cut \"Если вам интересно — попробуйте сперва сами, прежде чем читать решение.\" %}\n\nПусть $\\mu = \\mathbb{E}(y\\vert x)$. Тогда функция вероятности имеет вид\n\n$$p(y \\vert \\mu) = \\mu^y(1-\\mu)^{1-y} = \\exp\\left(y\\log\\left(\\frac{\\mu}{1-\\mu}\\right) + \\log\\left(1-\\mu\\right)\\right) =\n$$\n\n$$=\\exp\\left(\\frac{y\\log\\left(\\frac{\\mu}{1-\\mu}\\right) - \\left[-\\log\\left(1-\\mu\\right)\\right]}{1} + 0\\right)\n$$\n\nТо есть мы можем положить $\\phi=1$, $\\theta = \\log\\frac{\\mu}{1-\\mu}$, $a(\\theta) = -\\log\\left(1-\\mu\\right) = \\log\\left(1 + e^{\\theta}\\right)$, $b=0$.\n\nНайдём каноническую функцию связи. Имеем $a'(\\theta) = \\frac{e^{\\theta}}{1 + e^{\\theta}}$. Следовательно, $g(t) = \\log\\left(\\frac{t}{1-t}\\right)$. Как и ожидалось, это функция $\\text{logit}=\\sigma^{-1}$, используемая в логистической регрессии. Соответственно, $\\langle x, w\\rangle = \\sigma^{-1}(\\mathbb{E}(y\\vert x))$.\n\n{% endcut %}\n\n**Пример 3**. Хорошо, про линейную и логистическую регрессию мы и так знали. Давайте попробуем решить с помощью GLM новую задачу.\n\nПусть мы хотим по каким-то признакам $X$ предсказать количество «лайков», которое пользователи поставят посту в социальной сети за первые 10 минут после публикации. Конечно, можно использовать для этого линейную регрессию. Однако предположение линейной регрессии, что $Y \\vert X\\sim\\mathcal N$, в данном случае странное по нескольким причинам.\n\nВо-первых, количество лайков заведомо не может быть отрицательным, а нормальное распределение всегда будет допускать ненулевую вероятность отрицательного значения.\n\nВо-вторых, количество лайков — всегда целое число.\n\nВ-третьих, у распределения количества лайков, скорее всего, **положительный коэффициент асимметрии** (**skewness**). То есть, если модель предсказывает, что под постом будет 100 лайков, мы скорее можем ожидать, что под ним окажется 200 лайков, чем 0. Нормальное распределение симметрично и не может описать такие данные.\n\nС другой стороны, если мы предположим, что в первые 10 минут после публикации есть какая-то постоянная частота (своя для каждого поста, зависящая от $x$), с которой пользователи ставят лайк, мы получим, что количество лайков имеет распределение Пуассона. Распределение Пуассона не имеет описанных выше проблем:\n\n![11](https://yastatic.net/s3/education-portal/media/11_2_afee3ae8d2_7a01880860.webp)\n\nНо какая будет каноническая функция связи, если мы считаем, что $Y \\vert X\\sim\\text{Poisson}$? Аналогично первому и второму примерам:\n\n$$p(y \\vert \\mu) = \\frac{e^{-\\mu}\\mu^y}{y!} = \\exp\\left(y\\log\\mu - \\mu - \\log y!\\right)\n$$\n\nОткуда $\\phi=1$, $\\theta = g(\\mu) = \\log\\mu$, $a(\\theta) = \\mu = \\exp(\\theta)$, $b(y, \\phi) = -\\log y!$\n\nЗначит, эта модель (она называется **пуассоновская регрессия**), будет предсказывать с помощью формулы $\\mathbb E(y \\vert x) = g^{-1}(\\langle x, w\\rangle)= \\exp(\\langle x, w\\rangle)$.\n\n**Вопрос на подумать**. В каких ситуациях была бы полезной функция связи **complementary log-log link** (cloglog)\n\n$$g(x) = \\log(-log(1 - x))?\n$$\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nДавайте разбираться. Предсказание с такой функцией связи будет иметь вид\n\n$$\\mathbb{E}(y\\vert x) = g^{-1}(\\langle x, w\\rangle) = 1 - \\exp(-\\exp(\\langle x, w\\rangle))\n$$\n\nФункция $g^{-1}$ принимает значения на отрезке от $0$ до $1$, так что речь идёт о предсказании вероятностей в задаче бинарной классификации. Сравним $g^{-1}$ с привычной нам сигмоидой:\n\n![11](https://yastatic.net/s3/education-portal/media/11_3_e80e95a22d_176bc8cb91.webp)\n\nГрафик $g^{-1}$ не симметричен.  Можно сказать, что модель, основанная на функции связи cloglog, похожа на логистическую регрессию в области точек, уверенно отнесённых к нулевому классу, но с уменьшением этой уверенности они приписываются близкие к единице вероятности всё «охотнее».\n\nЭта функция связи может оказаться полезной, если объекты положительного класса редки (обнаружение редких событий).\n\n{% endcut %}",
        "handbook": "Учебник по машинному обучению",
        "title": "Обобщённые линейные модели",
        "description": "Как прокачать линейную модель с помощью распределений из экспоненциального класса"
    },
    {
        "path": "/handbook/ml/article/kak-ocenivat-veroyatnosti",
        "content": "Мы уже упоминали, что оценивать вероятности классов как $softmax(f_w(x_i))$ для какой-то произвольной функции $f_w$ — это дело подозрительное.\n\nВ этом разделе мы поговорим о том, как это делать хорошо и правильно.\n\n## Что же такое вероятность класса, если объект либо принадлежит этому классу, либо нет?\n\nОграничимся пока случаем двуклассовой классификации — с классами 0 и 1. Если утверждается, что мы предсказываем корректную вероятность класса 1 (обозначим её $q(x_i)$), то прогноз «объект $x_i$ принадлежит классу 1 с вероятностью $\\frac23$» должен сбываться в $\\frac23$ случаев.\n\nТо есть, условно говоря, если мы возьмём все объекты, то среди них что-то около двух третей действительно имеет класс 1.\n\nНа математическом языке это можно сформулировать так: **Если** $\\widehat{p}$ — предсказанная вероятность класса 1, то $P(y_i = 1 \\vert q(x_i) = \\widehat{p}) = \\widehat{p}$.\n\nК сожалению, в реальной жизни $\\widehat{p}$ — это скорее всего вещественные числа, которые будут различными для различных $y_i$, и никаких вероятностей мы не посчитаем, но мы можем разбить отрезок $[0,1]$ на бины, внутри каждого из которых уже вычислить, каковая там доля объектов класса 1, и сравнить эту долю со средним значением вероятности в бине:\n\n![12](https://yastatic.net/s3/education-portal/media/12_1_dd31ed3340_7d8ad4073b.webp)\n\nУ модели, которая идеально предсказывает вероятности (как обычно говорят, у идеально **калиброванной** модели) жёлтые точки на диаграме калибровки должны совпадать с розовыми.\n\nА вот на картинке выше это не так: жёлтые точки всегда ниже розовых. Давайте поймём, что это значит. Получается, что наша модель систематически завышает предсказанную вероятность (розовые точки), и порог отсечения нам, выходит, тоже надо было бы сдвинуть вправо:\n\n![12](https://yastatic.net/s3/education-portal/media/12_2_32a327a143_5d630cba01.webp)\n\nНо такая картинка, пожалуй, говорит о какой-то серьёзной патологии классификатора. Гораздо чаще встречаются следующие две ситуации:\n\n* Слишком уверенный (**overconfident**) классификатор:\n  ![12](https://yastatic.net/s3/education-portal/media/12_3_033f331fed_bfa91b03f0.webp)\n  Такое случается с сильными классификаторыми (например, нейросетями), которые учились на метки классов, а не на вероятности: тем самым процесс обучения стимулировал их всегда давать ответ, как можно более близкий к 0 или 1.\n\n* Неуверенный (**underconfident**) классификатор:\n  ![12](https://yastatic.net/s3/education-portal/media/12_4_d557d0984e_3ae1636aec.webp)\n\nТакое может случиться, например, если мы слишком много обращаем внимания на трудные для классификации объекты на границе классов (как, скажем, в SVM), в каком-то смысле в ущерб более однозначно определяемым точкам. Этим же могут и грешить модели на основе бэггинга (например, случайный лес). Грубо говоря, среднее нескольких моделей предскажет что-то близкое к единице только если все слагаемые предскажут что-то, близкое к единице — но из-за дисперсии моделей это будет случаться реже, чем могло бы. Подробнее можно почитать в [статье](https://www.cs.cornell.edu/~alexn/papers/calibration.icml05.crc.rev3.pdf).\n\n## Вам скажут: логистическая регрессия корректно действительно предсказывает вероятности\n\nВам даже будут приводить какие-то обоснования. Важно понимать, что происходит на самом деле, и не дать ввести себя в заблуждение. В качестве противоядия от иллюзий предлагаем рассмотреть два примера.\n\nРассмотрим датасет c двумя классами (ниже на картинке обучающая выборка)\n\n![12](https://yastatic.net/s3/education-portal/media/12_5_3bf7088887_bf6be965c8.webp)\n\nОбучим на нём логистическую регрессию из sklearn безо всяких параметров (то есть $L^2$-регуляризованную, но это не так важно). Классы не так-то просто разделить, вот и логистическая регрессия так себе справляется. Ниже изображена часть тестовой выборки вместе с предсказанными вероятностями классов для всех точек области\n\n![12](https://yastatic.net/s3/education-portal/media/12_6_92240fb793_9a11d1ca90.webp)\n\nВидим, что модель не больно-то уверена в себе, и ясно почему: признаковое описание достаточно бедное и не позволяет нам хорошо разделить классы, хотя, казалось бы, это можно довольно неплохо сделать.\n\nПопробуем поправить дело, добавив полиномиальные фичи, то есть все $x^jy^k$ для $0\\leqslant j,k\\leqslant 5$ в качестве признаков, и обучив поверх этих данных логистическую регрессию. Снова нарисуем некоторые точки тестовой выборки и предсказания вероятностей для всех точек области:\n\n![12](https://yastatic.net/s3/education-portal/media/12_7_c7891d2b70_b4811d8762.webp)\n\nВидим, что у нас сочетание двух проблем: неуверенности посередине и очень уверенных ошибок по краям.\n\nНарисуем теперь калибровочные кривые для обеих моделей:\n\n![12](https://yastatic.net/s3/education-portal/media/12_8_e2058527bc_1a80004c21.webp)\n\nКалибровочные кривые весьма примечательны; в любом случае ясно, что с предсказанием вероятностей всё довольно плохо. Посмотрим ещё, какие вероятности наши классификаторы чаще приписывают объектам:\n\n![12](https://yastatic.net/s3/education-portal/media/12_9_cf3ce123f2_048ddd0652.webp)\n\nКак и следовало ожидать, предсказания слабого классификатора тяготеют к серединке (та самая неуверенность), а среди предсказаний переобученного очень много крайне уверенных — и совсем не всегда правильных.\n\n## Но почему же все твердят, что логистическая регрессия хорошо калибрована?!\n\nПопробуем понять и простить её.\n\nКак мы помним, логистическая регрессия учится путём минимизации функционала\n\n$$l(X, y) = -\\sum_{i=1}^N(y_i\\log(\\sigma(\\langle w, x_i\\rangle)) + (1 - y_i)\\log(1 - \\sigma(\\langle w, x_i\\rangle)))\n$$\n\nОтметим между делом, что каждое слагаемое — это кроссэнтропия распределения $P$, заданного вероятностями $P(0) = 1 - \\sigma(\\langle w, x_i\\rangle)$ и $P(1) = \\sigma(\\langle w, x_i\\rangle)$, и тривиального распределения, которое равно $y_i$ с вероятностью $1$.\n\nДопустим, что мы обучили по всему универсуму данных $\\mathbb{X}$ идеальную логистическую регрессию с идеальными весами $w^{\\ast}$. Пусть, далее, оказалось, что у нас есть $n$ объектов $x_1,\\ldots,x_n$ с одинаковым признаковым описанием (то есть по сути представленных одинаковыми векторами $x_i$), но, возможно, разными истинными метками классов $y_1,\\ldots,y_n$. Тогда соответствующий им кусок функции потерь имеет вид\n\n$$-\\left(\\sum_{i=1}^ny_i\\right)\\log(\\sigma(\\langle w, x_1\\rangle)) -\\left(\\sum_{i=1}^n (1 - y_i)\\right)\\log(1 - \\sigma(\\langle w, x_1\\rangle)) =\n$$\n\n$$=-n\\left(\\vphantom{\\frac12}p_0\\log(\\sigma(\\langle w, x_1\\rangle)) + p_1\\log(1 - \\sigma(\\langle w, x_1\\rangle))\\right)\n$$\n\nгде $p_j$ — частота $j$-го класса среди истинных меток. В скобках также стоит кросс-энтропия распределения, задаваемого частотой меток истинных классов, и распределения, предсказываемого логистической регрессией. Минимальное значение кросс-энтропии (и минимум функции потерь) достигается, когда\n\n$$\\sigma(\\langle w, x_1\\rangle) = p_0,\\quad 1 - \\sigma(\\langle w, x_1\\rangle) = p_1\n$$\n\nРезультат, полученный для $n$ совпадающих точек будет приблизительно верным и для $n$ достаточно близких точек в случае, когда:\n\n* признаковое описание данных достаточно хорошее — классы не перемешаны как попало и всё-таки близки к разделимым;\n* модель не переобученная — то есть, предсказания вероятностей не скачут очень уж резко — вспомните второй пример.\n\nНа всех этих точках модель будет выдавать примерно долю положительных, то есть тоже хорошую оценку вероятности.\n\n## Как же всё-таки предсказать вероятности: методы калибровки\n\nПусть наша модель (бинарной классификации) для каждого объекта $x_i$ выдаёт некоторое число $q(x_i)\\in[0,1]$. Как же эти числа превратить в корректные вероятности?\n\n* **Гистограммная калибровка**. Мы разбиваем отрезок $[0,1]$ на бины $\\mathbb{B}_1,\\ldots,\\mathbb{B}_k$ (одинаковой ширины или равномощные) и хотим на каждом из них предсказывать всегда одну и ту же вероятность: $\\theta_j$, если $q(x_i)\\in \\mathbb{B}_j$. Вероятности $\\theta_i$ подбираются так, чтобы они как можно лучше приближали средние метки классов на соответствующих бинах. Иными словами, мы решаем задачу\n\n$$\\sum_{j=1}^k\\left|\\frac{\\sum_{i=1}^N\\mathbb{I}\\{q(x_i)\\in\\mathbb{B}_j\\}y_i}{ \\vert \\mathbb{B}_j \\vert } - \\theta_j\\right|\\longrightarrow\\min\\limits_{(\\theta_1,\\ldots,\\theta_k)}\n$$\n\nВместо разности модулей можно рассматривать и разность квадратов.\n\nМетод довольно простой и понятный, но требует подбора числа бинов и предсказывает лишь дискретное множество вероятностей.\n\n**Изотоническая регрессия**. Этот метод похож на предыдущий, только мы будем, во-первых, настраивать и границы $0=b_0,b_1,\\ldots,b_k = 1$ бинов $\\mathbb{B}_j = \\{t \\vert  b_{j-1}\\leqslant b_j\\}$, а кроме того, накладываем условие $\\theta_1\\leqslant\\ldots\\leqslant\\theta_k$. Искать $b_j$ и $\\theta_j$ мы будем, приближая $y_i$ кусочно постоянной функцией $g$ от $q(x_i)$:\n\n$$\\sum_{i=1}^N(y_i - g(q(x_i)))^2\\longrightarrow\\min_{g}\n$$\n\n![12](https://yastatic.net/s3/education-portal/media/12_10_cb986c5c52_bf6f8b6e33.webp)\n\nМинимизация осуществляется при помощи pool adjacent violators algorithm, и эти страницы слишком хрупки, чтобы выдержать его формулировку.\n\n* **Калибровка Платта** представляет собой по сути применение сигмоиды поверх другой модели (то есть самый наивный способ получения «вероятностей»). Более точно, если $q(x_i)$ — предсказанная вероятность, то мы полагаем\n\n$$P(y_i = 1\\mid x_i) = \\sigma(aq(x_i) + b) = \\frac1{1 + e^{-aq(x_i) - b}}\n$$\n\nгде $a$ и $b$ подбираются методом максимального правдоподобия на отложенной выборке:\n\n$$-\\sum_{i=1}^N(\\vphantom{\\frac12}y_i\\log(\\sigma(q(x_i))) + (1 - y_i)\\log(1 - \\sigma(q(x_i))))\\longrightarrow\\min\\limits_{a,b}\n$$\n\nДля избежания переобучения Платт предлагал также заменить метки $y_i$ и $(1 - y_i)$ на регуляризованные вероятности таргетов:\n\n$$t_0 = \\frac1{\\#\\{i \\vert y_i = 0\\} + 2},\\quad t_1 = \\frac{\\#\\{i \\vert y_i = 1\\} + 1}{\\#\\{i \\vert y_i = 0\\} + 2}\n$$\n\nКалибровка Платта неплохо справляется с выколачиванием вероятностей из SVM, но для более хитрых классификаторов может спасовать. В целом, можно показать, что этот метод хорошо работает, если для каждого из истинных классов предсказанные вероятности $q(x_i)$ распределы нормально с одинаковыми дисперсиями. Подробнее об этом вы можете почитать в [этой статье](https://research-information.bris.ac.uk/ws/portalfiles/portal/154625753/Full_text_PDF_final_published_version_.pdf). Там же описано обобщение данного подхода — бета-калибровка.\n\nС большим количеством других методов калибровки вы можете познакомиться в [этой статье](https://dyakonov.org/2020/03/27/%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0-%D0%BA%D0%B0%D0%BB%D0%B8%D0%B1%D1%80%D0%BE%D0%B2%D0%BA%D0%B8-%D1%83%D0%B2%D0%B5%D1%80%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8)\n\n## Как измерить качество калибровки\n\nКалибровочные кривые хорошо показывают, что есть проблемы, но как оценить наши усилия по улучшению предсказания вероятностей? Хочется иметь какую-то численную метрику. Мы упомянем две разновидности — прямое воплощение описанных выше идей.\n\n* **Expected/Maximum calibration error**. Самый простой способ, впрочем — он наследник идеи с калибровочной кривой. А именно, разобьём отрезок $[0,1]$ на бины $\\mathbb{B}_1,\\ldots,\\mathbb{B}_k$ по предсказанным вероятностям и вычислим\n\n$$\\sum_{j=1}^k\\frac{\\#\\mathbb{B}_j}{N}\\left|\\overline{y}(\\mathbb{B}_j) - \\overline{q}(\\mathbb{B}_j)\\right|\n$$\n\nили\n\n$$\\max\\limits_{j=1,\\ldots,k}\\left|\\overline{y}(\\mathbb{B}_j) - \\overline{q}(\\mathbb{B}_j)\\right|\n$$\n\nгде $\\overline{y}(\\mathbb{B}_j)$ — среднее значение $y_i$, а $\\overline{q}(\\mathbb{B}_j)$ — среднее значение $q(x_i)$ для $x_i$, таких что $q(x_i)\\in\\mathbb{B}_j$. Проблема этого способа в том, что мы можем очень по-разному предсказывать в каждом из бинов вероятности (в том числе константой) без ущерба для метрики.\n\n* **Brier score**. Одна из популярных метрик, которая попросту измеряет разницу между предсказанными вероятностями и \\$ y_i \\$:\n\n$$\\sum_{i=1}^N(y_i - q(x_i))^2\n$$\n\nКазалось бы, в чём смысл? Немного подрастить мотивацию помогает следующий пример. Допустим, наши таргеты совершенно случайны, то есть $P(y_i = 1 \\vert x_i) = P(y_i)$. Тогда хорошо калиброванный классификатор должен для каждого $x_i$ предсказывать вероятность $\\frac12$; соответственно, его brier score равен $\\frac14$. Если же классификатор хоть в одной точке выдаёт вероятность $p>\\frac12$, то в маленькой окрестности он должен выдавать примерно такие же вероятности.\n\nПоскольку же таргет случаен, локальный кусочек суммы из brier score будет иметь вид $\\frac{N'}{2}p^2 + \\frac{N'}{2}(1-p)^2 < \\frac{N'}2$, что хуже, чем получил бы всегда выдающий $\\frac12$ классификатор.\n\nНе обязательно брать квадратичную ошибку; сгодится и наш любимый log-loss:\n\n$$\\sum_{i=1}^N\\left(\\vphantom{\\frac12}y_i\\log{q(x_i)} + (1 - y_i)\\log(1 - q(x_i))\\right)\n$$\n\nЭто же и помогает высветить ограничения подхода, если вспомнить рассуждения о калиброванности логистической регрессии. Для достаточно гладких классификатора и датасета brier score и log-loss будут адекватными средствами оценки, но если нет — возможно всякое.\n\n**Вопрос на засыпку**: а как быть, если у нас классификация не бинарная, а многоклассовая? Что такое хорошо калиброванный классификатор? Как это определить численно? Как заставить произвольный классификатор предсказывать вероятности?\n\nМы не будем про это рассказывать, но призываем читателя подумать над этим самостоятельно или, например, посмотреть [туториал](https://classifier-calibration.github.io/) с ECML KDD 2020.",
        "handbook": "Учебник по машинному обучению",
        "title": "Как оценивать вероятности",
        "description": "Как правильно оценить вероятности классов в задаче классификации"
    },
    {
        "path": "/handbook/ml/article/generativnyj-podhod-k-klassifikacii",
        "content": "Классификационные модели, которые мы рассматривали в предыдущих параграфах, нацелены непосредственно на оценку $P(Y \\vert X)$. Такие модели называются **дискриминативными**.\n\nК ним относится, например, логистическая регрессия: она предлагает оценку $\\hat P(y=1 \\vert x) = \\sigma(w\\^Tx)$. В процессе обучения дискриминативные модели подбирают разделяющую поверхность (гиперплоскость в случае логистической регрессии). Новые объекты дискриминативная модель классифицирует в зависимости от того, по какую сторону от разделяющей поверхности они лежат.\n\nНапример, обучившись на изображениях домашних кошек (y=0) и рысей (y=1), дискриминативная модель будет определять, новое изображение больше похоже на кошку или на рысь. При этом, если на вход такой модели дать изображение собаки (объект класса, которого не было в обучении, выброс), дискриминативная модель заведомо не сможет обнаружить, что это и не кошка, и не рысь, и отнесёт такой объект к одному из «знакомых» ей классов.\n\nВ этом параграфе мы поговорим о другой группе моделей, которые нацелены на оценку $P(X, Y) = P(X \\vert Y)P(Y)$. Такая модель описала бы, как обычно выглядят кошки, как они могут выглядеть, а каких кошек точно не бывает. Так же она описала бы и рысей. Она также определила бы по обучающим данным, насколько изображения кошек встречаются чаще, чем изображения рысей, т.е. оценила бы $P(Y)$.\n\n## Генеративный и дискриминативный подходы к обучению\n\nЕсли модель позволила точно оценить распределение $P(X \\vert Y)$, с её помощью можно генерировать объекты из этого условного распределения, в нашем примере — изображения кошек и рысей соответственно.\n\nА вместе распределение $P(X, Y)$ дало бы нам возможность генерировать изображения и кошек, и рысей, причём именно в той пропорции, в которой они встречаются в реальном мире.  Поэтому модели, оценивающие $P(X, Y)$, называют **генеративными**. Ещё одно достоинство генеративных моделей — их способность находить выбросы в данных: объект $x$ можно считать выбросом, если $P(x \\vert y)$ мало для каждого класса $y$.\n\nЗаметим, что находить выбросы с помощью генеративной модели можно и когда класс всего один — то есть никакие метки классов не доступны. Такая задача называется одноклассовой классификацией. Например, если у нас есть не размеченный датасет с аудиозаписями речи людей, то, обучив на нём генеративную модель, оценивающую в данном случае $P(X \\vert Y)=P(X)$, мы сможем для нового аудио $x$ определить, похоже ли оно на аудиозапись человеческой речи (значение $P(x)$ велико), или это что-то другое: синтезированная речь, посторонний шум и т.п. (значение $P(x)$ мало).\n\nЕсли мы знаем, что «выбросы», с которыми модели предстоит сталкиваться, — это, как правило, синтезированная речь, то, мы можем дополнить датасет вторым классом, состоящим из синтезированной речи, и смоделировать также распределение этого класса. Это позволит существенно увеличить качество детектирования таких выбросов.\n\nЧтобы использовать генеративную модель для классификации, необходимо выразить $P(Y \\vert X)$ через $P(X \\vert Y)$ и $P(Y)$. Сделать это позволяет формула Байеса:\n\n$$P(y \\vert x) = \\frac{P(x, y)}{\\sum\\limits_{y'\\in Y} P(y')P(x \\vert y')} = \\frac{P(y)P(x \\vert y)}{\\sum\\limits_{y'\\in Y} P(y')P(x \\vert y')}\n$$\n\nКлассификация в генеративных моделях осуществляется с помощью байесовского классификатора:\n\n$$a(x) = \\arg\\max\\limits_{y\\in Y} P(y \\vert x) = \\arg\\max\\limits_{y\\in Y} \\frac{P(y)P(x \\vert y)}{\\sum\\limits_{y'\\in Y} P(y')P(x \\vert y')} = \\arg\\max\\limits_{y\\in Y} P(y)P(x \\vert y)\n$$\n\nОценить $P(Y)$, как правило, несложно. Для этого используют частотные оценки, полученные в обучающей выборке:\n\n<a name=\"eq:class_proba_estimation\"><b>Выражение (1)</b></a>\n\n$$\\hat P(Y=y) = \\frac{\\#(Y=y)}{N}\n$$\n\nОтметим ещё раз, что использование генеративного подхода позволяет внедрять в модель априорные знания о $P(y)$. Это не очень впечатляет, когда речь идёт о бинарной классификации, но всё меняется, если рассмотреть задачу ASR (автоматического распознавания речи), в которой по записи голоса восстанавливается произносимый текст.\n\nТаргетами здесь могут быть любые предложения или даже более развёрнутые тексты. При этом размеченных данных (запись, текст) обычно намного меньше, чем доступных текстов, и обученная на большом чисто текстовом корпусе языковая модель, которая будет оценивать вероятность того или иного предложения, может стать большим подспорьем, позволив из нескольких фонетически корректных наборов слов выбрать тот, который в большей степени похож на настоящее предложение.\n\nНо как смоделировать распределение $P(X, Y)$? Пространство всех возможных функций распределения $P(X, Y)$ бесконечномерно, из-за чего оценить произвольное распределение с помощью конечной выборки невозможно. Поэтому перед оценкой $P(X, Y)$ на это распределение накладывают дополнительные ограничения. Некоторые простые примеры таких ограничений мы рассмотрим в следующих разделах.\n\n### Gaussian discriminant analysis\n\nМодель гауссовского (или квадратичного) дискриминантного анализа (GDA) строится в предположении, что распределение объектов каждого класса $y$ подчиняется многомерному нормальному закону со средним $\\mu_y$ и ковариационной матрицей $\\Sigma_y$:\n\n$$p(x \\mid y)=\\frac{1}{(2 \\pi)^{n / 2}\\left|\\Sigma_y\\right|^{1 / 2}} \\exp \\left(-\\frac{1}{2}\\left(x-\\mu_y\\right)^T \\Sigma_y^{-1}\\left(x-\\mu_y\\right)\\right)\n$$\n\nТогда функция правдоподобия\n\n$$\\mathcal L(P(Y), \\mu, \\Sigma) = \\prod_{i=1}^N p(x_i \\vert y_i; \\mu_{y_i}, \\Sigma_{y_i})P(y_i)\n$$\n\nдостигает максимума при\n\n$$\\hat\\mu_y = \\frac{\\sum\\limits_{i=1}^N{x_i\\mathbb{1}_{y_i=y}}}{\\sum\\limits_{i=1}^N\\mathbb{1}_{y_i=y}},\\hspace{5mm} \n\\hat\\Sigma_y = \\frac{\\sum\\limits_{i=1}^N{(x_i - \\hat\\mu_{y})(x_i - \\hat\\mu_{y})^T \\mathbb{1}_{y_i=y}}}{\\sum\\limits_{i=1}^N\\mathbb{1}_{y_i=y}}\n$$\n\nИ $\\hat P(Y)$, представленной выше [см. выражение ](#eq:class_proba_estimation)$(1)$.\n\nРассмотрим, как выглядит разделяющая поверхность в модели GDA. На поверхности, разделяющей классы $y_i$ и $y_j$ выполняется\n\n$$P(y_i \\vert x)=P(y_j \\vert x) \\Leftrightarrow\n$$\n\n$$p(x \\vert y_i)P(y_i) = p(x \\vert y_j)P(y_j)\\Leftrightarrow\n$$\n\n$$\\log p(x \\vert y_i) + \\log P(y_i) - \\log p(x \\vert y_j) - \\log P(y_j) = 0\\Leftrightarrow\n$$\n\n<a name=\"eq:GDA_boundary\"><b>Выражение</b> (2)</a>\n\n$$ \\begin{equation}\n -\\frac{1}{2}(x-\\mu_{y_i})^T\\Sigma_{y_i}^{-1} (x-\\mu_{y_i})-\\log (2\\pi)^{n/2}|\\Sigma_{y_i}|^{1/2} + \\log P(y_i) +\n\\frac{1}{2}(x-\\mu_{y_j})^T\\Sigma_{y_j}^{-1} (x-\\mu_{y_j}) + \\log (2\\pi)^{n/2}|\\Sigma_{y_j}|^{1/2} - \\log P(y_j) = 0\n \\end{equation}\n$$\n\nПоскольку левая часть [уравнения (2)](#eq:GDA_boundary) квадратична по $x$, разделяющая поверхность между двумя классами будет представлять из себя гиперповерхность порядка 2. Пример разделяющей поверхности многоклассовой модели GDA приведён [на рис.](#fig:GDA_boundary)\n\n<a name=\"#fig:GDA_boundary\"></a>\n\n![13](https://yastatic.net/s3/education-portal/media/13_1_2660eb2f8c_71298899ca.webp)\n\nПлотность классов и разделяющая поверхность в многоклассовой модели LDA [см. рисунок](#fig:LDA_boundary).\n\n<a name=\"ss:GDA\"></a>\n\n![13](https://yastatic.net/s3/education-portal/media/13_2_c3eb5fda88_7f6c93e95f.webp)\n\n### Linear Discriminant Analysis\n\nВ [выражении (2)](#eq:GDA_boundary) член второго порядка $x^T (\\Sigma_{y_j}^{-1} - \\Sigma_{y_i}^{-1})x$ зануляется при $\\Sigma_{y_i}=\\Sigma_{y_j}$. Таким образом, если дополнительно предположить, что все классы имеют общую ковариационную матрицу $\\Sigma$, разделяющая поверхность между любыми двумя классами будет  линейной ([см. рисунок](#fig:LDA_boundary)). Поэтому такая модель называется линейным дискриминантным анализом (LDA).\n\nНа этапе обучения единственное отличие модели LDA от GDA состоит в оценке ковариационной матрицы:\n\n$$\\hat \\Sigma = \\frac{1}{N}\\sum\\limits_{i=1}^N{(x_i - \\hat\\mu_{y_i})(x_i - \\hat\\mu_{y_i})^T}\n$$\n\nЗаметим, что в модели GDA для каждого класса требовалось оценить порядка $d^2$ параметров. Это может привести к переобучению в случае, если размерность пространства признаков велика, а некоторые классы представлены в обучающей выборке малым количеством объектов. В LDA для каждого класса требуется оценить лишь порядка $d$ параметров (значение $P(y)$ и элементы вектора $\\mu_y$), и ещё $d^2$ общих для всех классов параметров (элементы матрицы $\\Sigma$).\n\nТаким образом, основное преимущество модели LDA перед GDA — её меньшая склонность к переобучению, недостаток — линейная разделяющая поверхность.\n\n## Метод наивного байеса\n\nПредположим, что признаки $X$ объектов каждого класса $y$ — независимые случайные величины:\n\n$$\\forall y\\in Y \\hspace{2mm} \\forall U, V: U\\sqcup V = \\{1, ... d\\}, \\hspace{2mm} \\forall x^u\\subset \\mathbb R^{|U|}, x^v\\subset \\mathbb R^{|V|}\n$$\n\n$$P(X^U\\in x^u, X^V\\in x^v|Y=y) = P(X^U\\in x^u|Y=y)P(X^V\\in x^u|Y=y).\n$$\n\nВ таком случае говорят, что величины $X$ условно независимы относительно $Y$. Тогда справедливо\n\n<a name=\"eq:cond_independent\"><b>Выражение (3)</b></a>\n\n$$\\begin{equation}\nP(X \\vert Y) = P(X^1, X^2, ..., X^d \\vert Y) = P(X^1 \\vert Y)P(X^2, ..., X^d \\vert Y) = ... = P(X^1 \\vert Y)P(X^2 \\vert Y)...P(X^d \\vert Y)\n\\end{equation}\n$$\n\nТо есть для того, чтобы оценить плотность многомерного распределения $P(X \\vert Y)$ достаточно оценить плотности одномерных распределений $P(X^i \\vert Y)$, [см. рисунок](#fig:blobs_density).\n\n<a name=\"#fig:blobs_density\"></a>\n\n![13](https://yastatic.net/s3/education-portal/media/13_3_c4a7d7b883_d120c7e624.webp)\n\nНа рисунке приведён пример условно независимых относительно $Y$ случайных величин $X^1, X^2$. Для оценки плотности двумерных распределений объектов классов достаточно оценить плотности маргинальных распределений, изображённые графиками вдоль осей.\n\nРассмотрим пример. Пусть решается задача классификации отзывов об интернет-магазине на 2 категории: $Y=0$ — отрицательный отзыв, клиент остался не доволен, и $Y=1$ — положительный отзыв. Пусть признак $X^w$ равен 1, если слово $w$ присутствует в отзыве, и 0 иначе. Тогда условие [выражения ](#eq:cond_independent)$(3)$ означает, что, в частности, наличие или отсутствие слова «дозвониться» в отрицательном отзыве не влияет на вероятность наличия в этом отзыве слова «телефон».\n\nНа практике в процессе feature engineering почти всегда создаётся много похожих признаков, и условно независимые признаки можно встретить очень редко. Поэтому генеративную модель, построенную в предположении условия [выражения ](#eq:cond_independent)$(3)$, называют наивным байесовским классификатором (Naive Bayes classifier, NB).\n\nОбучение модели NB заключается в оценке распределений $P(Y)$ и $P(X^i \\vert Y)$. Для $P(Y)$ можно использовать частотную оценку [выражения ](#eq:class_proba_estimation)$(1)$. $P(X^i \\vert y)$ — одномерное распределение. Рассмотрим несколько способов оценки одномерного распределения.\n\n## Оценка одномерного распределения\n\nПусть мы хотим оценить одномерное распределение $P(X)$.\n\nЕсли распределение $P(X)$ дискретное, требуется оценить его функцию массы, то есть вероятность того, что величина $X$ примет значение $x_j$. Метод максимума правдоподобия приводит к частотной оценке:\n\n<a name=\"eq:freq_estimation\"><b>Выражение (4)</b></a>\n\n$$\\hat P(X = x_j) = \\frac{\\#(X = x_j)}{N}\n$$\n\nГде $N$ — размер выборки, по которой оценивается распределение $X$ (количество объектов класса $y$ в случае оценки плотности класса $y$).\n\nПри этом может оказаться, что некоторое значение $x_j$ ни разу не встречается в обучающей выборке. Например, в случае классификации отзывов методом Наивного Байеса, слово «амбивалентно» не встретилось ни в одном положительном отзыве, но встретилось в отрицательных. Тогда использование [оценки выражения ](#eq:freq_estimation)$(4)$ приведёт к тому, что все отзывы с этим словом будут определяться NB как отрицательные с вероятностью 1. Чтобы избежать принятия таких радикальных решений при недостатке статистики, используют сглаживание Лапласа:\n\n$$\\hat P(X = x_j) = \\frac{\\#(X = x_j) + \\alpha}{N + m\\alpha},\n$$\n\nгде $m$ — количество различных значений, принимаемых случайной величиной $X$, $\\alpha$ — гиперпараметр.\n\nДля оценки плотности $p$ абсолютно непрерывного распределения в точке $a$ можно разделить количество объектов обучающей выборки в окрестности точки $a$ на размер этой окрестности:\n\n$$\\hat p(a) = \\frac{\\sum\\limits_{j}\\mathbb{1}_{a - h < X_j < a + h}}{2h} = \\frac{\\sum\\limits_{j}\\mathbb{1}_{-h < X_j - a < h}}{2h}.\n$$\n\nОбычно объекты, лежащие дальше от точки $a$, учитывают с меньшим весом. Таким образом, оценка плотности приобретает вид\n\n$$\\hat p(a) = \\frac{\\sum\\limits_{j}K_h(X_j - a)}{2h},\n$$\n\nгде функция $K_h$, называемая ядром, обычно имеет носитель $(-h, h)$ ([см. рисунок ниже](#fig:kernels.png)). Такой способ оценки плотности называют непараметрическим.\n\n<a name=\"#fig:kernels.png\"></a>\n\n![13](https://yastatic.net/s3/education-portal/media/13_4_afa4131520_58616d333d.webp)\n\nРезультат оценки плотности с разными ядрами. Использованы [изображения из:](https://scikit-learn.org/stable/auto_examples/neighbors/plot_kde_1d.html)\n\n![13](https://yastatic.net/s3/education-portal/media/13_5_8f654203b4_7ec3cb808d.webp)\n\nПри параметрической оценке плотности предполагают, что искомое распределение лежит в параметризованном классе, и подбирают значения параметров при помощи метода максимума правдоподобия. Например, предположим, что искомое распределение нормальное. Тогда функция его плотности имеет вид\n\n$$p(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n$$\n\nТаким образом, чтобы оценить плотность $p(x)$, достаточно оценить параметры $\\mu, \\sigma$. Метод максимума правдоподобия в этом случае даст такие оценки:\n\n$\\hat\\mu = \\overline X$ — выборочное среднее, $\\hat\\sigma = \\sqrt{\\frac{1}{N}\\sum_{j=1}^N (X_j - \\overline X)}$ — выборочное стандартное отклонение.\n\nЕсли в модели NB распределения всех признаков объектов каждого класса нормальные, оценив параметры этих распределений, мы сможем каждый класс $y$ описать нормальным распределением со средним $\\mu_p$ и диагональной ковариационной матрицей, значения на диагонали которой обозначим $\\sigma_p$.\n\nТаким образом, полученная модель (Gaussian Naive Bayes, GNB) эквивалентна модели [GDA](#ss:GDA) с дополнительным ограничением на диагональность ковариационных матриц.\n\n## Наивный байесовский подход и логистическая регрессия\n\nПредположим теперь, что в модели GNB класса всего 2, причём соответствующие им ковариационные матрицы совпадают, как это было в модели LDA. Таким образом $\\sigma_0 = \\sigma_1 = \\sigma$.\n\nПосмотрим, как будет выглядеть $P(Y \\vert X)$ в этом случае. По теореме Байеса имеем\n\n$$P(Y=1 \\vert X) = \\frac{P(Y = 1)P(X \\vert Y = 1)}{P(Y = 1)P(X \\vert Y = 1) + P(Y = 0)P(X \\vert Y = 0)}\n$$\n\nРазделим числитель и знаменатель полученного выражения на числитель:\n\n$$P(Y=1 \\vert X) = \\frac{1}{1 + \\frac{P(Y = 0)P(X \\vert Y = 0)}{P(Y = 1)P(X \\vert Y = 1)}} = \\frac{1}{1 + \\exp\\left(\\ln\\frac{P(Y=0)P(X \\vert Y=0)}{P(Y=1)P(X \\vert Y=1)}\\right)}\n$$\n\nИз условной независимости $X^i$ относительно $Y$ получаем\n\n<a name=\"eq:posterior\"><b>Формула (5)</b></a>\n\n$$\\begin{equation}\nP(Y=1 \\vert X) = \\frac{1}{1 + \\exp\\left(\\ln\\frac{P(Y=0)}{P(Y=1)} + \\sum\\limits_{i=1}^d \\ln\\frac{P(X^i \\vert Y=0)}{P(X^i \\vert Y=1)}\\right)}\n\\end{equation}\n$$\n\nПерепишем сумму в знаменателе, воспользовавшись формулой плотности нормального распределения\n\n$$\\sum\\limits_{i=1}^d \\ln\\frac{P(X^i \\vert Y=0)}{P(X^i \\vert Y=1)} = \\sum\\limits_{i=1}^d \\ln\\frac{\\frac{1}{\\sqrt{2\\pi\\sigma_i^2}}\\exp \\left(\\frac{-(X^i - \\mu_{0,i})^2}{2\\sigma_i^2}\\right)}{\\frac{1}{\\sqrt{2\\pi\\sigma_i^2}}\\exp \\left(\\frac{-(X^i - \\mu_{1,i})^2}{2\\sigma_i^2}\\right)} \n$$\n\n$$= \\sum\\limits_{i=1}^d \\frac{\\left(X^i - \\mu_{1, i}\\right)^2 - \\left(X^i - \\mu_{0, i}\\right)^2}{2\\sigma_i^2}= \n\\sum\\limits_{i=1}^d \\left(\\frac{\\mu_{0, i} - \\mu_{1, i}}{\\sigma_i^2}X^i + \\frac{\\mu_{1, i} ^ 2 - \\mu_{0, i} ^ 2}{2\\sigma_i^2}\\right)$$\n\nПодставляя это выражение в [формулу  (5) ](#eq:posterior), получаем\n\n$$P(Y=1 \\vert X) = \\frac{1}{1 + \\exp\\left(\\ln\\frac{P(Y=0)}{P(Y=1)} + \\sum\\limits_{i=1}^d \\left(\\frac{\\mu_{0, i} - \\mu_{1, i}}{\\sigma_i^2}X^i + \\frac{\\mu_{1, i} ^ 2 - \\mu_{0, i} ^ 2}{2\\sigma_i^2}\\right)\\right)}\n$$\n\nТаким образом, $P(Y=1 \\vert X)$ представляется в GNB с общей ковариационной матрицей в таком же виде, как в модели логистической регрессии:\n\n<a name=\"eq:logreg\"><b>Формула (6)</b></a>\n\n$$\\begin{equation}\nP(Y=1 \\vert X) = \\frac{1}{1 + \\exp\\left(w_0 + \\sum\\limits_{i=1}^d w_i X^i\\right)}\n\\end{equation}\n$$\n\nгде в случае GNB\n\n$$w_0 = \\ln\\frac{P(Y=1)}{P(Y=0)} +\\sum\\limits_{i=1}^d\\frac{\\mu_{1, i} ^ 2 - \\mu_{0, i} ^ 2}{2\\sigma_i^2}, \\quad\nw_i = \\frac{\\mu_{0, i} - \\mu_{1, i}}{\\sigma_i^2} \\hspace{1cm} i=1, \\dots, l$$\n\nОднако это не значит, что модели эквивалентны: модель логистической регрессии накладывает менее строгие ограничения на распределение $P(X, Y)$, чем GNB.\n\nТак, $X^i$ могут не являться условно независимыми относительно $Y$, а распределения $P(X \\vert Y=y)$ могут не удовлетворять нормальному закону, но $P(y \\vert X)$ может при этом всё равно представляться в виде [формулы  (6) ](#eq:logreg).\n\nВ этом случае использование метода логистической регрессии предпочтительнее. С другой стороны, если есть основания полагать, что требования GNB выполняются, то от GNB можно ожидать более высокого качества классификации по сравнению с логистической регрессией.",
        "handbook": "Учебник по машинному обучению",
        "title": "Генеративный подход к классификации",
        "description": "Как использовать распределение меток классов в задаче классификации. LDA, QDA и наивный байес"
    },
    {
        "path": "/handbook/ml/article/bajesovskij-podhod-k-ocenivaniyu",
        "content": "## Априорное знание\n\nНачнём с простого вопроса: как нам внести в модель априорные знания.\n\nПредставьте, что мы обучаем модель линейной регрессии $y\\sim \\langle x, w\\rangle + \\varepsilon$, $\\varepsilon\\sim\\mathcal{N}(0,\\sigma^2)$. С помощью MLE мы получили некоторую оценку $\\widehat{w}$ на веса $w$ — всякие ли их значения мы встретим с покорностью и смирением? Наверное, мы удивимся, если какие-то компоненты вектора $\\widehat{w}$ будут очень большими по сравнению с элементами $X$: пожалуй, наша физическая интуиция будет бунтовать против этого, мы задумаемся о том, что из-за потенциальных ошибок сокращения вычисление предсказаний $(x_i, \\widehat{w})$ окажутся неточным — в общем, хотелось бы по возможности избежать этого. Но как?\n\nБудь мы приверженцами чисто инженерного подхода, мы бы сделали просто: прибавили бы к функции потерь слагаемое $\\alpha \\left\\|\\omega  \\right\\|_{2}^{2}$, или $\\alpha \\left\\|\\omega  \\right\\|_1$, или ещё что-то такое — тогда процедура обучения стала бы компромиссом между минимизацией исходного лосса и этой добавки, что попортило бы слегка близость $y\\sim \\langle x, w \\rangle$, но зато позволило бы лучше контролировать масштаб $\\widehat{w}$. Надо думать, вы узнали в этой конструкции старую добрую регуляризацию.\n\nНо наша цель — зашить наше априорное знание о том, что компоненты $w$ не слишком велики по модулю, в вероятностную модель. Введение в модель априорного знания соответствует введению априорного распределения на $w$. Какое распределение выбрать? Ну, наверное, компоненты $w$ будут независимыми (ещё нам не хватало задавать взаимосвязи между ними!), а каждая из них будет иметь какое-то непрерывное распределение, в котором небольшие по модулю значения более правдоподобны, а совсем большие очень неправдоподобны.\n\nМы знаем такие распределения? Да, и сразу несколько. Например, нормальное. Логично было бы определить\n\n$$p(w) = \\prod_{i=1}^D\\mathcal{N}(w_i \\vert 0,\\tau^2)\n$$\n\nгде $\\tau^2$ — какая-то дисперсия, которую мы возьмём с потолка или подберём по валидационной выборке. Отметим, что выбор нормального распределение следует и из принципа максимальной энтропии: ведь у него наибольшая энтропия среди распределений на всей числовой оси с нулевым матожиданием и дисперсией $\\tau^2$.\n\nКонтроль масштаба весов — это, вообще говоря, не единственное, что мы можем потребовать. Например, мы можем из каких-то физических соображений знать, что тот или иной вес в линейной модели непременно должен быть неотрицательным. Тогда в качестве априорного на этот вес мы можем взять, например, показательное распределение (которое, напомним, обладает максимальной энтропией среди распределений на положительных числах с данным матожиданием).\n\n## Оцениваем не значение параметра, а его распределение\n\nРаз уж мы начали говорить о распределении на веса $w$, то почему бы не пойти дальше. Решая задачу классификации, мы уже столкнулись с тем, что может быть важна не только предсказанная метка класса, но и вероятности. Аналогичное верно и для задачи регрессии. Давайте рассмотрим две следующих ситуации, в каждой из которых мы пытаемся построить регрессию $y\\sim ax + b$:\n\n![14](https://yastatic.net/s3/education-portal/media/14_1_697c390275_382aa2e9ab.webp)\n\nНесмотря на то, что в каждом из случаев «точная формула» или градиентный спуск выдадут нам что-то, степень нашей уверенности в ответе совершенно различная. Один из способов выразить (не)уверенность — оценить распределение параметров. Так, для примеров выше распределения на параметр $a$ могли бы иметь какой-то такой вид:\n\n![14](https://yastatic.net/s3/education-portal/media/14_2_74dbd0c395_3d885b645a.webp)\n\nДальше мы постараемся формализовать процесс получения таких оценок.\n\n## Построение апостериорного распределения\n\nДавайте ненадолго забудем про линейную регрессию и представим, что мы подобрали с пола монету, которая выпадает орлом с некоторой неизвестной пока вероятностью $\\theta$. До тех пор, пока мы не начали её подкидывать, мы совершенно ничего не знаем о $\\theta$, эта вероятность может быть совершенно любой — то есть априорное распределение на $\\theta$ является равномерным (на отрезке $[0,1]$):\n\n$$p(\\theta) = \\mathbb{I}_{[0;1]}(\\theta)\n$$\n\nТеперь представим, что мы подкинули её $n$ раз, получив результаты $Y = (y_1,\\ldots,y_n)$ ($0$ — решка, $1$ — орёл), среди которых $n_0 = n - \\sum_{i=1}^ny_i$ решек и $n_1=\\sum_{i=1}^ny_i$ орлов. Определённо наши познания о числе $p$ стали точнее: так, если $n_1$ мало, то можно заподозрить, что и $p$ невелико (уже чувствуете, запахло распределением!).\n\nРаспределение мы посчитаем с помощью формулы Байеса:\n\n$$\\color{#348FEA}{p(\\theta \\vert Y) = \\frac{p(\\theta , Y)}{p(Y)} = \\frac{p(Y \\vert \\theta)p(\\theta)}{\n\\int p(Y \\vert \\psi)p(\\psi)d\\psi}}\n$$\n\nв нашем случае:\n\n$$p(\\theta \\vert Y) = \\frac{\\prod_{i=1}^n\\theta^{y_i}(1 - \\theta)^{1 - y_i}\\mathbb{I}_{[0,1]}(\\theta)}{\n\\int_0^1\\prod_{i=1}^n\\psi^{y_i}(1 - \\psi)^{1 - y_i}d\\psi} =\n$$\n\n$$=\\frac{\\theta^{n_1}(1 - \\theta)^{n_0}\\mathbb{I}_{[0,1]}(\\theta)}{\n\\int_0^1\\psi^{n_1}(1 - \\psi)^{n_0}d\\psi}\n$$\n\nВ этом выражении нетрудно узнать бета-распределение: $\\text{Beta}(n_1 + 1, n_0 + 1)$. Давайте нарисует графики его плотности для нескольких конкретных значений $n_0$ и $n_1$:\n\n![14](https://yastatic.net/s3/education-portal/media/14_3_f944ffcbc1_b36f7d62ea.webp)\n\nКак можно заметить, с ростом $n$ мы всё лучше понимаем, каким может быть $\\theta$, при этом если орёл выпадал редко, то пик оказывается ближе к нулю, и наоборот. Ширина пика в каком-то смысле отражает нашу уверенность в том, какими могут быть значения параметра, и не случайно чем больше у нас данных — тем уже будет пик, то есть тем больше уверенности.\n\nРаспределение $p(\\theta\\vert Y)$ параметра, полученное с учётом данных, называется **апостериорным**. Переход от априорного распределения к апостериорному отражает обновление нашего представления о параметрах распределения с учётом полученной информации, и этот процесс является сердцем байесовского подхода. Отметим, что если нам придут новые данные $Y' = (y_1',\\ldots,y_m')$, в которых $m_0$ решек и $m_1$ орлов, мы сможем ещё раз обновить распределение по той же формуле Байеса:\n\n$$p(\\theta \\vert Y\\cup Y') = p([\\theta\\vert Y]\\vert Y') = \\frac{p(Y'\\vert\\theta)p(\\theta\\vert Y)}{p(Y')}=\n$$\n\n$$=\\frac{\\theta^{m_1}(1 - \\theta)^{m_0}\\frac{\\theta^{n_1}(1 - \\theta)^{n_0}}{B(n_1 + 1, n_0 + 1)}\\mathbb{I}_{[0,1]}(\\theta)}{\n\\text{злой интеграл}} =\n$$\n\n$$=\\frac{\\theta^{n_1 + m_1}(1 - \\theta)^{n_0 + m_0}}{\\text{константа}}\\sim\\text{Beta}(n_1 + m_1 + 1, n_0 + m_0 + 1)\n$$\n\n**Вопрос на подумать**. Пусть $p(y\\vert\\mu) = \\mathcal{N}(y\\vert\\mu,\\sigma^2)$ — нормальное распределение с фиксированной дисперсией $\\sigma^2$, а для параметра $\\mu$ в качестве априорного выбрано также нормальное распределение $\\mathcal{N}(y\\vert \\lambda,\\theta^2)$. Каким будет апостериорное распределение при условии данных $Y = (y_1,\\ldots,y_n)$?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\n$$p(\\theta \\vert Y) = \\frac{\\left[\\prod_{i=1}^n\\frac1{\\sqrt{2\\pi\\sigma^2}}e^{-\\frac{(y_i - \\mu)^2}{2\\sigma^2}}\\right]\\cdot\\frac1{\\sqrt{2\\pi\\theta^2}}e^{-\\frac{(\\mu - \\lambda)^2}{2\\theta^2}}}{\n\\text{злой интеграл}} =\n$$\n\n$$=\\frac{\\frac1{(2\\pi\\sigma^2)^{\\frac{n}2}}\\cdot\\frac1{\\sqrt{2\\pi\\theta^2}}e^{-\\frac1{2\\sigma^2}\\sum_{i=1}^n(y_i - \\mu)^2-\\frac{1}{2\\theta^2}(\\mu - \\lambda)^2}}{\n\\text{злой интеграл}}\n$$\n\nС точностью до множителей, не зависящих от $\\mu$, это экспонента квадратичной формы, то есть распределение будет нормальным. Давайте найдём его параметры. Для этого нам нужно выделить в показателе полный квадрат:\n\n$$=\\frac{e^{-\\frac12\\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\theta^2}\\right)\\mu^2 + \\left(\\frac1{\\sigma^2}\\sum_{i=1}^ny_i + \\frac1{\\theta^2}\\lambda\\right)\\mu + \\text{свободный член}}}{\n\\text{что-то, где нет }\\mu} =\n$$\n\nОбозначим $\\rho^2 = \\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\theta^2}\\right)^{-1}$\n\n$$=frac{e^{-\\frac1{2\\rho^2}\\left[\\mu^2 - \\rho^2\\left(\\frac1{\\sigma^2}\\sum_{i=1}^ny_i + \\frac1{\\theta^2}\\lambda\\right)\\right]^2 + \\text{остальное}}}{\n\\text{что-то, где нет }\\mu}\n$$\n\nТеперь уже хорошо видно, что получилось нормальное распределение с параметрами\n\n$$\\lambda_{new} = \\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\theta^2}\\right)^{-1}\\left(\\frac1{\\sigma^2}\\sum_{i=1}^ny_i + \\frac1{\\theta^2}\\lambda\\right)\n$$\n\n$$\\theta_{new}^2 = \\left(\\frac{n}{\\sigma^2} + \\frac{1}{\\theta^2}\\right)^{-1}\n$$\n\nФормулы жутковатые, но проинтерпретировать их можно. Например, мы видим, что появление больших $y_i$ будет сдвигать среднее, а дисперсия уменьшается с ростом $n$.\n\n{% endcut %}\n\n## Сопряжённые распределения\n\nВ двух предыдущих примерах нам очень сильно повезло, что апостериорные распределения оказались нашими добрыми знакомыми. Если же взять случайную пару распределений $p(y\\vert\\theta)$ и $p(\\theta)$, результат может оказаться совсем не таким приятным.\n\nВ самом деле, нет никакой проблемы в том, чтобы посчитать числитель формулы Байеса, но вот интеграл в знаменателе может и не найтись. Поэтому выбирать распределения нужно с умом. Более того, поскольку апостериорное распределение само станет априорным, когда придут новые данные, хочется, чтобы априорное и апостериорное распределения были из одного семейства; пары (семейств) распределений $p(y\\vert\\theta)$ и $p(\\theta)$, для которых это выполняется, называются **сопряжёнными** $p(\\theta)$ называется **сопряжённым** к $p(y\\vert\\theta)$. Полезно помнить несколько наиболее распространённых пар сопряжённых распределений:\n\n* $p(y\\vert\\theta)$ — распределение Бернулли с вероятностью успеха $\\theta$, $p(\\theta)$ — бета распределение;\n* $p(y\\vert\\mu)$ — нормальное с матожиданием $\\mu$ и фиксированной дисперсией $\\sigma^2$, $p(\\theta)$ также нормальное;\n* $p(y\\vert\\lambda)$ — показательное с параметром $\\lambda$, $p(\\lambda)$ — гамма распределение;\n* $p(y\\vert\\lambda)$ — пуассоновское с параметром $\\lambda$, $p(\\lambda)$ — гамма распределение;\n* $p(y\\vert\\theta)$ — равномерное на отрезке $[0,\\theta]$, $p(\\theta)$ — Парето;\n\nВозможно, вы заметили, что почти все указанные выше семейства распределений (кроме равномерного и Парето) относятся к экспоненциальному классу. И это не случайность! Экспоненциальный класс и тут лучше всех: оказывается, что для $p(y\\vert\\theta)$ из экспоненциального класса можно легко подобрать сопряжённое $p(\\theta)$. Давайте же это сделаем.\n\nПусть $p(y\\vert\\theta)$ имеет вид\n\n$$p(y\\vert\\theta) = \\frac1{h(\\theta)}g(y)\\exp(\\theta^Tu(y))\n$$\n\nПоложим\n\n$$p(\\theta) = \\frac1{h^{\\nu}(\\theta)}\\exp(\\eta^T\\theta)\\cdot f(\\eta, \\nu)\n$$\n\nгде $f(\\eta, \\nu)$ — множитель, обеспечивающий равенство единице интеграла от этой функции. Найдём апостериорное распределение:\n\n$$p(\\theta\\vert Y) = \\frac{\\left[\\prod_{i=1}^n\\frac1{h(\\theta)}g(y_i)\\exp(\\theta^Tu(y_i))\\right]\\frac1{h^{\\nu}(\\theta)}\\exp(\\eta^T\\theta)\\cdot f(\\eta, \\nu)}{\\text{злой интеграл}} =\n$$\n\n$$= \\frac{\\frac1{h^{\\nu + n}(\\theta)}\\exp\\left(\\theta^T\\left[\\eta + \\sum_{i=1}^nu(y_i)\\right]\\right)}{\\text{что-то, где нет }\\theta}\n$$\n\nЭто распределение действительно из того же семейства, что и $p(\\theta)$, только с новыми параметрами:\n\n$$\\eta_{new} = \\eta + \\sum_{i=1}^nu(y_i),\\quad\\nu_{new} = \\nu + n\n$$\n\n**Пример**. Пусть $p(y\\vert q) = q^y(1 - q)^{1 - y}$ подчиняется распределению Бернулли. Напомним, что оно следующим образом представляется в привычном для экспоненциального класса виде:\n\n$$p(y\\vert q) = \\underbrace{(1 - q)}_{=\\frac1{h(q)}}\\exp\\left(\\underbrace{y}_{=u_1(y)}\\underbrace{\\log{\\frac{q}{1 - q}}}_{=\\theta}\\right)\n$$\n\nПредлагается брать априорное распределение вида\n\n$$p(q) = \\frac{(1 - q)^{\\nu}\\exp\\left(\\eta\\log{\\frac{q}{1-q}}\\right)}{\\text{что-то, где нет}q}\n$$\n\nТогда апостериорное распределение будет иметь вид (проверьте, посчитав по формуле Байеса!)\n\n$$p(q\\vert Y) = \\frac{(1 - q)^{\\nu + n}\\exp\\left(\\left[\\eta + \\sum_{i=1}^ny_i\\right]\\log{\\frac{q}{1-q}}\\right)}{\\text{что-то, где нет}q}\n$$\n\nПревратив логарифм частного в сумму, а экспоненту суммы в произведение, легко убедиться, что получается то самое бета распределение, которое мы уже получали выше.\n\n## Оценка апостериорного максимума (MAP)\n\nАпостериорное распределение — это очень тонкий инструмент анализа данных, но иногда надо просто сказать число (или же интеграл в знаменателе не берётся и мы не можем толком посчитать распределение). В качестве точечной оценки логично выдать самое вероятное значение $\\theta\\vert Y$ (интеграл в знаменателе от $\\theta$ не зависит, поэтому на максимизацию не влияет):\n\n$$\\color{blue}{\\widehat{\\theta}_{MAP} = \\underset{\\theta}{\\operatorname{argmax}}{p(\\theta \\vert Y)} = \\underset{\\theta}{\\operatorname{argmax}}{p(Y \\vert \\theta)p(\\theta)}}\n$$\n\nЭто число называется **оценкой апостериорного максимума (MAP)**.\n\nЕсли же в формуле выше перейти к логарифмам, то мы получим кое-что, до боли напоминающее старую добрую регуляризацию (и не просто так, как мы вскоре убедимся!):\n\n$$\\underset{\\theta}{\\operatorname{argmax}}{p(Y \\vert \\theta)p(\\theta)} = \\underset{\\theta}{\\operatorname{argmax}}\\log(p(Y \\vert \\theta)p(\\theta)) = \n$$\n\n$$=\\underset{\\theta}{\\operatorname{argmax}}\\left(\\vphantom{\\frac12}\\log{p(Y \\vert \\theta)} + \\log{p(\\theta)}\\right)\n$$\n\n**Пример**. Рассмотрим снова распределение Бернулли $p(y\\vert q)$ и априорное распределение $p(q)\\sim\\text{Beta}(q\\vert a, b)$. Тогда MAP-оценка будет равна\n\n$$\\underset{q}{\\operatorname{argmax}}{p(Y \\vert q)p(q)} = \\underset{q}{\\operatorname{argmax}}{q^{\\sum_{i=1}^ny_i}(1 - q)^{n - \\sum_{i=1}^ny_i}\\cdot q^{a - 1}(1 - q)^{b - 1}} = \n$$\n\n$$\\underset{q}{\\operatorname{argmax}}\\left((a - 1 + \\sum_{i=1}^ny_i)\\log{q} + (b - 1 + n - \\sum_{i=1}^ny_i)\\log(1 - q)\\right)\n$$\n\nДифференцируя по $q$ и приравнивая производную к нулю, мы получаем\n\n$$q = \\frac{a + \\sum_{i=1}^ny_i - 1}{a + b + n - 2}\n$$\n\nВ отличие от оценки максимального правдоподобия $\\frac{\\sum_{i=1}^ny_i}{n}$ мы здесь используем априорное знание: параметры $(a - 1)$ и $(b - 1)$ работают как «память о воображаемых испытаниях», как будто бы до того, как получить данные $y_i$, мы уже имели $(a - 1)$ успехов и $(b - 1)$ неудач.\n\n## Связь MAP- и MLE-оценок\n\nОценка максимального правдоподобия является частным случаем апостериорной оценки.\n\nВ самом деле, если априорное распределение является равномерным, то есть $p(\\theta)$ не зависит $\\theta$ (если веса $\\theta$ вещественные, могут потребоваться дополнительные усилия, чтобы понять, как такое вообще получается), и тогда\n\n$$\\widehat{\\theta}_{MAP} = \\underset{\\theta}{\\operatorname{argmax}}\\log{p(Y \\vert \\theta)p(\\theta)} = \\underset{\\theta}{\\operatorname{argmax}}\\left(\\log{p(Y \\vert \\theta)} + \\underbrace{\\log{p(\\theta)}}_{=const}\\right) =\n$$\n\n$$= \\underset{\\theta}{\\operatorname{argmax}}\\log{p(y \\vert \\theta)} = \\widehat{\\theta}_{MLE}\n$$\n\n## Байесовские оценки для условных распределений\n\nВ предыдущих разделах мы разобрали, как байесовский подход работает для обычных, не условных распределений. Теперь вернёмся к чему-то более близкому к машинному обучению, а именно к распределениям вида $y\\vert x,w$, и убедимся, что для них байесовских подход работает точно так же, как и для обычных распределений.\n\nИмея некоторое распределение $p(y\\vert x, w)$, мы подбираем для него априорное распределение на веса $p(w)$ (и да, оно не зависит от $x$: ведь априорное распределение существует ещё до появления данных) и вычисляем апостериорное распределение на веса:\n\n$$p(w \\vert X, y)\n$$\n\nВычислять его мы будем по уже привычной формуле Байеса:\n\n$$\\color{blue}{p(w \\vert X, y) = \\frac{p(y, w \\vert X)}{p(y)} = \\frac{p(y \\vert X, w)p(w)}{p(y)}}\n$$\n\nПовторим ещё разок, в чём суть байесовского подхода: у нас было некоторое априорное представление $\\color{blue}{p(w)}$ о распределении весов $\\color{blue}{w}$, а теперь, посмотрев на данные $(x_i, y_i)_{i=1}^n$, мы уточняем своё понимание, формулируя апостериорное представление $p(w \\vert X, y)$.\n\nЕсли же нам нужна только точечная оценка, мы можем ограничиться оценкой апостериорного максимума (MAP):\n\n$$\\color{blue}{\\widehat{w}_{MAP} = \\underset{w}{\\operatorname{argmax}}{p(w \\vert X,y)} = \\underset{w}{\\operatorname{argmax}}{p(y \\vert X, w)p(w)}} = \n$$\n\n$$=\\underset{w}{\\operatorname{argmax}}\\left(\\vphantom{\\frac12}\\log{p(y \\vert X, w)} + \\log{p(w)}\\right)\n$$\n\nчто уже до неприличия напоминает регуляризованную модель\n\n## Пример: линейная регрессия с $L^2$-регуляризацией как модель с гауссовским априорным распределением на веса\n\nВ модели линейной регрессии $y = \\langle x, w\\rangle + \\varepsilon$, $\\varepsilon\\sim\\mathcal{N}(0, \\sigma^2)$ введём априорное распределение на веса вида\n\n$$\\color{blue}{p(w) = \\mathcal{N}(w  \\vert  0, \\tau^2I) = \\prod_{j=1}^D \\mathcal{N}(w_j \\vert  0, \\tau^2) = \\prod_{j=1}^D p(w_j)}\n$$\n\nТогда $\\widehat{w}_{MAP}$ — точка минимума следующего выражения:\n\n$$-\\log{p(y \\vert X, w)} - \\log{p(w)} =-\\sum_{i=1}^Np(y_i \\vert x_i, w) - \\sum_{j=1}^Dp(w_j) =\n$$\n\n$$=-\\sum_{i=1}^N\\left(-\\frac12\\log(2\\pi\\sigma^2) - \\frac{(y_i - (w, x_i))^2}{2\\sigma^2}\\right)\n-\\sum_{j=1}^D\\left(-\\frac12\\log(2\\pi\\tau^2) - \\frac{w_j^2}{2\\tau^2}\\right)=$$\n\n$$\n= \\frac1{2\\sigma^2}\\sum_{i=1}^N(y_i - (w, x_i))^2 + \\frac1{2\\tau^2}\\sum_{j=1}^D w_j^2+\\text{ не зависящие от }w\\text{ члены}\n$$\n\nПолучается, что\n\n$$\\color{blue}{\\widehat{w}_{MAP} = \\underset{w}{\\operatorname{argmin}}\\left(\\vphantom{\\frac12}\\sum_{i=1}^N(y_i - (w, x_i))^2 + \\frac{\\sigma^2}{\\tau^2}\\|w\\|^2\\right)}\n$$\n\nа это же функция потерь для линейной регрессии с $L^2$-регуляризацией! Напомним на всякий случай, что у этой задачи есть «точное» решение\n\n$$\\color{blue}{\\widehat{w}_{MAP} = \\left(X^TX + \\frac{\\sigma^2}{\\tau^2}I\\right)^{-1}X^Ty}\n$$\n\nДля этого примера мы можем вычислить и апостериорное распределение $p(w \\vert X, y)$. В самом деле, из написанного выше мы можем заключить, что\n\n$$\\log{p(w \\vert X, y)} = \\log(p(y \\vert X, w)p(w)) - \\log{p(y)} = \n$$\n\n$$=\\frac1{2\\sigma^2}(y - Xw)^T(y - Xw) + \\frac1{2\\tau^2}w^Tw+\\text{ не зависящие от }w\\text{ члены}\n$$\n\nТаким образом, $\\log{p(w \\vert X, y)}$ — это квадратичная функция от $w$, откуда следует, что апостериорное распределение является нормальным. Чтобы найти его параметры, нужно немного преобразовать полученное выражение:\n\n$$\\ldots=\\frac1{2\\sigma^2}(y^Ty - w^TX^Ty - y^TWx + w^TX^TXw) + \\frac1{2\\tau^2}w^Tw+\\mathrm{const}(w) =\n$$\n\n$$=w^T\\left(\\frac1{2\\sigma^2}X^TX + \\frac1{2\\tau^2}I\\right)w - \\frac{1}{2\\sigma^2}w^TX^Ty - \\frac1{2\\sigma^2}y^TWx + \\mathrm{const}(w) =\n$$\n\n$$=\\frac12\\left(w - \\widehat{w}_{MAP}\\right)^T\\left(\\frac1{\\sigma^2}X^TX + \\frac1{\\tau^2}I\\right)\\left(w - \\widehat{w}_{MAP}\\right) + \\mathrm{const}(w)=\n$$\n\nТаким образом,\n\n$$\\color{blue}{p(w \\vert X,y) = \\mathcal{N}\\left(\\widehat{w}_{MAP}, \\left(\\frac1{\\sigma^2}X^TX + \\frac1{\\tau^2}I\\right)^{-1}  \\right)}\n$$\n\nКак видим, от априорного распределения оно отличается корректировкой как матожидания $0\\mapsto\\widehat{w}_{MAP}$, так и ковариационной матрицы $\\left(\\frac1{\\tau^2}I\\right)^{-1}\\mapsto\\left(\\frac1{\\sigma^2}X^TX + \\frac1{\\tau^2}I\\right)^{-1}$. Отметим, что $X^TX$ — это, с точностью до численного множителя, оценка ковариационной матрицы признаков нашего датасета (элементы матрицы $X^TX$ — это скалярные произведения столбцов $X$, то есть столбцов значений признаков).\n\n**Иллюстрация**. Давайте на простом примере (датасет с двумя признаками) посмотрим, как меняется апостериорное распределение $w$ с ростом размера обучающей выборки:\n\n![14](https://yastatic.net/s3/education-portal/media/14_4_80113d832e_8eae2745c6.webp)\n\nКак видим, не только мода распределения, то есть $\\widehat{w}_{MAP}$ приближается к своему истинному значению, но и дисперсия распределения постепенно уменьшается.\n\n**Ещё иллюстрация**. Теперь рассмотрим задачу аппроксимации неизвестной функции одной переменной (чьи значения в обучающей выборке искажены нормальным шумом) многочленом третьей степени. Её, разумеется, тоже можно решать, как задачу линейной регрессии на коэффициенты многочлена. Давайте нарисуем, как будут выглядеть функции, сгенерированные из распределения ${p(w \\vert X,y)}$ для разного объёма обучающей выборки:\n\n![14](https://yastatic.net/s3/education-portal/media/14_5_eee8390d4e_a5da4d0d9c.webp)\n\nТут тоже видим, что функции не только становятся ближе к истинной, но и разброс их уменьшается.\n\n## Пример: линейная регрессия с $L^1$-регуляризацией как модель с лапласовским априорным распределением на веса\n\nДругое распределение, которое тоже может кодировать наше желание, чтобы небольшие по модулю значения $w_j$ были правдоподобными, а большие не очень, — распределение Лапласа. Посмотрим, что будет, если его взять в качестве априорного распределения на веса.\n\n$$\\color{blue}{p(w) = \\prod_{j=1}^D p(w_j) = \\prod_{j=1}^D\\frac{\\lambda}{2}\\exp(-\\lambda|w_m|)}\n$$\n\nПроводя такое же вычисление, получаем, что\n\n$$\\color{blue}{\\widehat{w}_{MAP} = \\underset{w}{\\operatorname{argmin}}\\left(\\vphantom{\\frac12}\\sum_{i=1}^N(y_i - (w, x_i))^2 + \\lambda\\sum_{j=1}^D|w_j|\\right)}\n$$\n\nа это же функция потерь для линейной регрессии с $L^1$-регуляризацией!\n\n## Как делать предсказания\n\nВсе изложенные выше рассуждения проводились в ситуации, когда $X = X_{train}$ — обучающая выборка. Для неё мы можем посчитать\n\n$$p(w \\vert X_{train}, y_{train}) = \\frac{(y \\vert X,w)p(w)}{p(y)}\n$$\n\nи точечную апостериорную оценку $\\widehat{w}_{MAP} = \\underset{w}{\\operatorname{argmax}}{p(y \\vert X,w)p(y)}$. А теперь пусть нам дан новый объект $x_0\\in\\mathbb{X}$. Какой таргет $y_0$ мы для него предскажем?\n\nБыло бы естественным, раз уж мы предсказываем распределение для $w$, и для $y_0$ тоже предсказывать распределение. Делается это следующим образом:\n\n$$p(y_0 \\vert x_0, X_{train}, y_{train}) = \\int{p(y_0 \\vert x_0,w)p(w \\vert X_{train}, y_{train})}dw\n$$\n\nНадо признать, что вычисление этого интеграла не всегда посильная задача, поэтому зачастую приходится «просто подставлять $\\widehat{w}_{MAP}$». В вероятностных терминах это можно описать так: вместо сложного апостериорного распределения $p(w \\vert X_{train}, y_{train})$ мы берём самое грубое на свете приближение\n\n$$p(w \\vert X_{train}, y_{train})\\approx\\delta(w - \\widehat{w}_{MAP}),\n$$\n\nгде $\\delta(t)$ — дельта-функция, которая не является честной функцией (а является тем, что математики называют обобщёнными функциями), которая определяется тем свойством, что $\\int f(t)\\delta(t)dt = f(0)$ для достаточно разумных функций $f$. Если не мудрствовать лукаво, то это всё значит, что\n\n$$p(y_0 \\vert x_0,X_{train}, y_{train})\\approx p(y_0 \\vert x_0,\\widehat{w}_{MAP})\n$$\n\n**Пример**. Пусть $y\\sim Xw + \\varepsilon$, $\\varepsilon\\sim\\mathcal{N}(0,\\sigma)^2$ — модель линейной регрессии с априорным распределением $p(w) = \\mathcal{N}(0,\\tau^2)$ на параметры. Тогда, как мы уже видели раньше,\n\n$$p(w \\vert X,y) = \\mathcal{N}\\left(w \\vert \\widehat{w}_{MAP}, \\left(\\frac1{\\sigma^2}X^TX + \\frac1{\\tau^2}I\\right)^{-1}  \\right)\n$$\n\nПопробуем для новой точки $x_0$ посчитать распределение на $y_0$. Рекомендуем читателю попробовать самостоятельно посчитать интеграл или же обратиться к пункту 7.6.2 книжки «Machine Learning A Probabilistic Perspective» автора Kevin P. Murphy, убедившись, что\n\n$$p(y_0 \\vert x_0, X_{train}, y_{train}) = \\mathcal{N}\\left(y_0 \\vert x_0\\widehat{w}_{MAP},\n\\sigma^2 + \\sigma^2x_0^T\\left(X^TX + \\frac{\\sigma^2}{\\tau^2}I\\right)^{-1}x_0\\right)$$\n\nчто, очевидно, более содержательно, чем оценка, полученная с помощью приближения $p(w \\vert X_{train}, y_{train})\\approx\\delta(w - \\widehat{w}_{MAP})$:\n\n$$p(y_0 \\vert x_0, \\widehat{w}_{MAP}) = \\mathcal{N}\\left(y_0\\left \\vert x_0\\widehat{w}_{MAP},\n\\sigma^2\\right.\\right)$$\n\nСобственно, видно, что в этом случае\n\n**Пример в примере**. Рассмотрим полюбившуюся уже нам задачу приближения функции многочленом степени не выше $3$ (в которой мы строим модели с $\\sigma^2 = \\tau^2 = 1$). Для $N = 8$ мы получали такую картинку:\n\n![14](https://yastatic.net/s3/education-portal/media/14_6_c96cd72460_919321cff2.webp)\n\nЕсли оценить по приведённым выше формулам $p(y_0 \\vert x_0, X_{train}, y_{train})$ для разных $x_0$, то можно убедиться, что модель в большей степени уверена в предсказаниях для точек из областей, где было больше точек из обучающей выборки:\n\n![14](https://yastatic.net/s3/education-portal/media/14_7_f8bdef58c8_d73727a08c.webp)\n\n## Байесовский подход и дообучение моделей\n\nДо сих пор мы в основном рассуждали о моделях машинного обучения как о чём-то, что один раз обучается и дальше навсегда застывает в таком виде, но в жизни такое скорее редкость. Мы пока не будем обсуждать изменчивость истинных зависимостей во времени, но даже если истина неизменна, к нам могут поступать новые данные, которые очень хотелось бы использовать для дообучения модели.\n\nОбычные, не байесовские вероятностные модели не предоставляют таких инструментов. Оценку максимального правдоподобия придётся пересчитывать заново (хотя, конечно, можно схитрить, использовав старое значение в качестве начального приближения при итеративной оптимизации). Байесовский же подход позволяет оформить дообучения в виде простой и элегантной формулы: при добавлении новых данных $(x_{N+1}, y_{N+1}),\\ldots,(x_M, y_M)$ имеем\n\n$$p\\left(w\\vert (x_i, y_i)_{i=1}^M\\right) = \\frac{p\\left((y_i)_{i=N+1}^M\\vert (x_i)_{i=N+1}^M\\right) p\\left(w\\vert (x_i, y_i)_{i=1}^N\\right)}{p\\left( (y_i)_{i=N+1}^M \\right)}\n$$\n\n## Байесовский подход к выбору модели: мотивация\n\nНам часто приходится выбирать: дерево или случайный лес, линейная модель или метод ближайших соседей; да, собственно, и внутри наших вероятностных моделей есть параметры (скажем, дисперсия шума $\\sigma^2$ и $\\tau^2$), которые надо бы подбирать. Но как?\n\nВ обычной ситуации мы выбираем модель, обученную на выборке $(X_{train}, y_{train})$ в зависимости от того, как она себя ведёт на валидационной выборке $(X_{val}, y_{val})$ (сравниваем правдоподобие или более сложные метрики) — или же делаем кросс-валидацию. Но как сравнивать модели, выдающие распределение?\n\nОтветим вопросом на вопрос: а как вообще сравнивать модели? Назначение любой модели — объяснять мир вокруг нас, и её качество определяется именно тем, насколько хорошо она справляется с этой задачей. Тестовая выборка — это хороший способ оценки, потому что она показывает, насколько вписываются в модель новые данные. Но могут быть и другие соображения, помогающие оценить качество модели.\n\n### Пример №1\n\nАналитик Василий опоздал на работу. Своему руководителю он может предложить самые разные объяснения — и это будет выработанная на одном обучающем примере модель, описывающая причины опоздания и потенциально позволяющая руководителю принять решение о том, карать ли Василия.\n\nКонечно, руководитель мог бы принять изложенную Василием модель к сведению, подождать, пока появятся другие опоздавшие, и оценить её, так скажем, на тестовой выборке, но стоит ли? Давайте рассмотрим несколько конкретных примеров:\n\n* Модель «Василий опоздал, потому что так получилось», то есть факт опоздания — это просто ни от чего не зависящая случайная величина. Такая модель плоха тем, что (а) не предлагает, на самом деле, никакого объяснения тому факту, что Василий опоздал, а его коллега Надежда не опоздала и (б) совершенно не помогает решить, наказывать ли за опоздание. Наверное, такое не удовлетворит руководителя.\n\n* Модель «Василий опоздал, потому что рядом с его домом открылся портал в другой мир, где шла великая битва орков с эльфами, и он почувствовал, что просто обязан принять в ней участие на стороне орков, которых привёл к победе, завоевав руку и сердце орочьей принцессы, после чего был перенесён обратно в наш скучный мир завистливым шаманом». Чем же она плоха? Битва с эльфами — это, безусловно, важное и нужное дело, и на месте руководителя мы бы дружно согласились, что причина уважительная. Но заметим, что в рамках этой модели можно объяснить множество потенциальных исходов, среди которых довольно маловероятным представляется наблюдаемый: тот, в котором Василий не погиб в бою, не остался со своей принцессой и не был порабощён каким-нибудь завистливым шаманом. Отметим и другой недостаток этой модели: её невозможно провалидировать. Если в совершенно случайной модели можно оценить вероятность опоздания и впоследствии, когда накопятся ещё примеры, проверить, правильно ли мы её посчитали, то в мире, где открываются порталы и любой аналитик может завоевать сердце орочьей принцессы, возможно всё, и даже если больше никто не попадёт в такую ситуацию, Василий всё равно сможет бить себя в грудь кулаком и говорить, что он избранный. Так что, наверное, это тоже не очень хорошая модель.\n\n* Модель «Василий опоздал, потому что проспал» достаточно проста, чтобы в неё поверить, и в то же время даёт руководителю возможность принять решение, что делать с Василием.\n\n### Пример №2\n\nОбратимся к примеру из машинного обучения. Сравним три модели линейной регрессии:\n\n![14](https://yastatic.net/s3/education-portal/media/14_8_625e0200be_9761c8224e.webp)\n\nДаже и не запрашивая тестовую выборку, мы можем сделать определённые выводы о качестве этих моделей. Средняя (квадратичная) явно лучше левой (линейной), потому что она лучше объясняет то, что мы видим: тот факт, что облако точек обучающей выборки выглядит вогнутым вниз.\n\nА что с правым, почему мы можем утверждать, что он хуже? Есть много причин критиковать его. Остановимся вот на какой. На средней картинке у нас приближение квадратичной функцией, а на правой — многочленом довольно большой степени (на самом деле, десятой). А ради интереса: как выглядит график квадратичной функции и как — многочлена десятой степени со случайно сгенерированными коэффициентами? Давайте сгенерируем несколько и отметим их значения в точках обучающей выборки:\n\n![14](https://yastatic.net/s3/education-portal/media/14_9_cc0a3b2fb0_5a712ffb7f.webp)\n\nОбратите внимание на масштаб на графиках справа. И какова вероятность, что нам достался именно тот многочлен десятой степени, у которого значения в обучающих точках по модулю в пределах сотни? Очевидно, она очень мала. Поэтому мы можем сказать, что выбор в качестве модели многочлена десятой степени не очень обоснован.\n\n### Попробуем резюмировать\n\nСлишком простая модель плохо объясняет наблюдаемые нами данные, тогда как слишком сложная делает это хорошо, но при этом описывает слишком многообразный мир, в котором имеющиеся у нас данные оказываются уже слишком частным случаем. В каком-то смысле наш способ выбора модели оказывается переформулировкой **бритвы Оккама**: из моделей, пристойно описывающих наблюдаемые явления, следует выбирать наиболее минималистичную.\n\n## Байесовский подход к выбору модели: формализация\n\nПусть у нас есть некоторое семейство моделей $\\mathcal{J}$ и для каждого $j\\in\\mathcal{J}$ задана какая-то своя вероятностная модель. В духе байесовского подхода было бы оценить условное распределение моделей\n\n$$p(j \\vert y, X) = \\frac{p(y \\vert X,j)p(j)}{\\sum\\limits_{j\\in\\mathcal{J}}p(j, y \\vert X)}\n$$\n\nи в качестве наилучшей модели взять её моду. Если же считать все модели равновероятными, то мы сводим всё к максимизации только лишь $p(y \\vert X,j) = p_j(y \\vert X)$:\n\n$$\\color{blue}{\\widehat{\\jmath} = \\underset{j}{\\operatorname{argmax}}\\int{p_j(y \\vert X,w)p_j(w)}dw =\\underset{j}{\\operatorname{argmax}}p_j(y \\vert X)}\n$$\n\nВеличина $p_j(y \\vert X)$ называется **обоснованностью** (**evidence, marginal likelihood**) модели.\n\nОтметим, что такое определение вполне согласуется с мотивацией из предыдущего подраздела. Слишком простая модель плохо описывает наблюдаемые данные, и потому будет отвергнута. В свою очередь, слишком сложная модель способна описывать гораздо большее многообразие явлений, чем нам было бы достаточно. Таким образом, компромисс между качеством описания и сложностью и даёт нам оптимальную модель.\n\n### Пример\n\nВернёмся к нашей любимой задаче аппроксимации функции одной переменной многочленом небольшой степени по нескольким точкам, значение в которых было искажено нормальным шумом. Построим несколько моделей, приближающих многочленом степени не выше некоторого $\\mathrm{deg}$ (будет принимать значения 1, 3 и 6), положив в вероятностной модели $\\sigma^2 = \\tau^2 = 1$.\n\nМы не будем приводить полный вывод обоснованности для задачи регрессии $p(y \\vert X,w) = \\mathcal{N}(y \\vert Xw,\\sigma^2I)p(w \\vert \\tau^2I)$, а сразу выпишем ответ:\n\n$$p(y \\vert X) = \\mathcal{N}\\left(0, \\sigma^2I + \\tau^2XX^T\\right)\n$$\n\nПосмотрим, какой будет обоснованность для разного числа обучающих точек:\n\n![14](https://yastatic.net/s3/education-portal/media/14_10_9007290755_b7cce910b1.webp)\n\nМожно убедиться, что для регрессии по двум точкам наиболее обоснованная — линейная модель (и неудивительно), тогда как с ростом числа точек более обоснованной становится модель с многочленом третьей степени; слишком сложная же модель шестой степени всегда плетётся в хвосте.\n\n### Аппроксимация обоснованности и байесовский информационный критерий\n\nТочно вычислить обоснованность может быть трудной задачей (попробуйте проделать это сами хотя бы для линейной регрессии!). Есть разные способы посчитать её приближённо; мы рассмотрим самый простой.\n\nНапомним, что\n\n$$p(y \\vert X) = \\int{p(y \\vert X,w)p(w)}dw \n$$\n\nВоспользуемся **приближением Лапласа**, то есть разложим $p(y \\vert X,w)$ (как функцию от $w$) вблизи своего максимума, то есть вблизи $\\widehat{w} := \\widehat{w}_{MLE}$ в ряд Тейлора:\n\n$$\\log{p(y \\vert X,w)} \\approx \\log{p(y \\vert X,\\widehat{w})} - \\frac12(w - \\widehat{w})^TI_N(\\widehat{w})(w - \\widehat{w}),\n$$\n\nгде линейный член отсутствует, поскольку разложение делается в точке локального экстремума, а $I(\\widehat{w})$ — знакомая нам матрица Фишера $I_N(\\widehat{w}) = -\\mathbb{E}\\nabla^2_w\\log{p(y \\vert X,w)}\\vert_{\\widehat{w}} = NI_1(\\widehat{w})$.\n\nДалее, $p(w)$ мы можем с точностью до второго порядка приблизить $p(\\widehat{w}_{MAP})$. Получается, что\n\n$$p(y \\vert X)\\approx\\int e^{\\log{p(y \\vert X,\\widehat{w})} - \\frac{N}2(w - \\widehat{w})^TI_1(\\widehat{w})(w - \\widehat{w})}p(\\widehat{w}_{MAP})dw =\n$$\n\n$$= e^{\\log{p(y \\vert X,\\widehat{w})}}p(\\widehat{w}_{MAP})\\int e^{ - \\frac{N}{2}(w - \\widehat{w})^TI_1(\\widehat{w})(w - \\widehat{w})}dw = \n$$\n\n$$= e^{\\log{p(y \\vert X,\\widehat{w})}}p(\\widehat{w}_{MAP})\\cdot (2\\pi)^{D/2}\\frac{|I_1(\\widehat{w})|^{-\\frac12}}{N^{D/2}} =\n$$\n\n$$=\\exp\\left(\\log{p(y \\vert X,\\widehat{w})} - \\frac{D}2\\log{N} + \\text{всякие штуки}\\right)\n$$\n\nНесмотря на то, что $p(\\widehat{w}_{MAP})$ и $\\vert I_1(\\widehat{w})\\vert^{-\\frac12}$, сгруппированные нами во «всякие штуки», существенным образом зависят от модели, при больших $N$ они вносят в показатель гораздо меньше вклада, чем первые два слагаемых. Таким образом, мы можем себе позволить вместо трудновычисляемых $p(y \\vert X)$ использовать для сравнения модели \\$ \\\\color\\{blue\\} \\{ \\\\mbox\\{байесовский информационный критерий (BIC)\\}:\\} \\$\n\n$$\\color{blue}{BIC = D\\log{N} - 2\\log{p(y \\vert X,\\widehat{w})}}\n$$\n\n## Фреквентисты против байесиан: кто кого?\n\nМы с вами познакомились с двумя парадигмами оценивания:\n\n* **фреквентистской** (frequentist, от слова \"frequency\", частота) — в которой считается, что данные являются случайным (настоящая случайность!) семплом из некоторого фиксированного распределения, которое мы стараемся оценить по этому семплу, и\n* **байесовской** — в которой данные считаются данностью и в которой мы используем данные для обновления наших априорных представлений о распределении параметров (здесь случайности нет, а есть лишь нехватка знания).\n\nУ обеих есть свои достоинства и недостатки, поборники и гонители. К недостаткам байесовской относится, безусловно, её вычислительная сложность: возможно, вы помните, в пучину вычислений сколь мрачных нас низвергла банальная задача линейной регрессии, и дальше становится только ещё трудней. Если мы захотим байесовский подход применять к более сложным моделям, например, нейросетям, нам придётся прибегать к упрощениям, огрублениям, приближениям, что, разумеется, ухудшает наши оценки. Но, если простить ему эту вынужденную неточность, он логичнее и честней, и мы продемонстрируем это на следующем примере.\n\nОдно известное свойство оценки максимального правдоподобия — **асимптотическая нормальность**. Если оценивать наши веса $w$ по различным наборам из $N$ обучающих примеров, причём считать, что наборы выбираются случайно (не будем уточнять, как именно), то оценка $\\widehat{w}_{MLE}$ тоже превращается в случайную величину, которая как-то распределена. Теория утверждает, что при $N\\rightarrow\\infty$\n\n$$\\quad \\widehat{w}_{MLE}\\sim\\mathcal{N}\\left(w^{\\ast}, I_N({w}^{\\ast})^{-1}\\right)\n$$\n\nгде $w^{\\ast}$ — истинное значение весов, а $I_N({w}^{\\ast})$ — матрица информации Фишера, которая определяется как\n\n$$I_N({w}^{\\ast}) = \\mathbb{E}\\left[\\left(\\left.\\frac{\\partial}{\\partial w_i}\\log{p(y \\vert X,w)}\\right|_{w^{\\ast}}\\right)\\left(\\left.\\frac{\\partial}{\\partial w_j}\\log{p(y \\vert X,w)}\\right|_{w^{\\ast}}\\right)\\right]\n$$\n\nчто при некоторых не слишком обременительных ограничениях равно\n\n$$I_N({w}^{\\ast}) = -\\mathbb{E}\\left[\\left.\\frac{\\partial^2}{\\partial w_i\\partial w_j}\\log{p(y \\vert X,w)}\\right|_{w^{\\ast}}\\right]\n$$\n\nПри этом поскольку $\\log{p(y \\vert X,w)} = \\sum_{i=1}^N\\log{p(y \\vert X,w)}$, матрица тоже распадается в сумму, и получается, что $I_N({w}^{\\ast}) = NI_1(w^{\\ast})$, то есть с ростом $N$ ковариация $(NI_1(w^{\\ast}))^{-1}$ оценки максимального правдоподобия стремится к нулю.\n\nНа интуитивном уровне можно сказать, что матрица информации Фишера показывает, сколько информации о весах $w$ содержится в $X$.\n\nПоговорим о проблемах. В реальной ситуации мы не знаем $w^{\\ast}$ и тем более не можем посчитать матрицу Фишера, то есть мы с самого начала вынуждены лукавить. Ясно, что вместо $w^{\\ast}$ можно взять просто $\\widehat{w}$, а вместо $I_N(w^{\\ast})$ — матрицу $I_N(\\widehat{w})$, которую можно даже при желании определить как\n\n$$-\\left(\\left.\\frac{\\partial^2}{\\partial w_i\\partial w_j}\\log(p(y \\vert X, w))\\right|_{w^{\\ast}}\\right)\n$$\n\nбезо всякого математического ожидания. Итак, хотя мы можем теперь построить доверительный интервал для оцениваемых параметров, по ходу нами было сделано много упрощений: мы предположили, что асимптотическая оценка распределения уже достигнута, от $w^{\\ast}$ перешли к $\\widehat{w}$, а для полноты чувств ещё и избавились от математического ожидания. В байесовском подходе мы такого себе не позволяем.\n\n{% cut \"Если вам интересно, посмотрите, как это будет выглядеть для линейной регрессии.\" %}\n\nРассмотрим модель линейной регрессии $y\\sim Xw + \\varepsilon$, $\\varepsilon\\sim\\mathcal{N}(0, \\sigma^2)$. Для неё\n\n$$\\log{p(y \\vert X,w)} = -\\frac{N}{2\\log(2\\pi\\sigma^2)} - \\frac{1}{2\\sigma^2}(y - Xw)^T(y - Xw)\n$$\n\nНетрудно убедиться, что\n\n$$\\nabla_w\\log{p(y \\vert X,w)} = \\frac{1}{\\sigma^2}X^T(y - Xw)\n$$\n\n$$\\nabla^2_w\\log{p(y \\vert X,w)} = -\\frac{1}{\\sigma^2}X^TX\n$$\n\nСоответственно,\n\n$$I_N(\\widehat{w}) = \\frac{1}{\\sigma^2}X^TX\n$$\n\nгде $\\widehat{w}$ — это полученная по датасету $X$ оценка весов. Заметим, что $W^TX$ — это с точностью до коэффициента $\\frac{1}{N}$ оценка ковариационной матрицы признаков нашего датасета (элементы $X^TX$ — это скалярные произведения столбцов $X$, то есть столбцов признаков). Можно легко убедиться, что\n\n$$\\frac{1}{\\sigma^2}X^TX = \\frac{1}{\\sigma^2}\\sum_{i=1}^Nx_i^Tx_i\n$$\n\nПо-хорошему, нам надо было бы ещё взять математическое ожидание. Найти его мы не можем, но можем очень наивно оценить как $C = \\frac1N\\sum_{i=1}^Nx_i^Tx_i$. Тогда получаем, что $I_N(\\widehat{w}) = \\frac{N}{\\sigma^2}C$. Таким образом, имея один датасет $X$ и одну посчитанную по нему оценку $\\widehat{w}$, мы можем довольно грубо оценить распределение оценок максимального правдоподобия для заданного $N$ как\n\n$$\\mathcal{N}\\left(\\widehat{w}, \\frac{N}{\\sigma^2}C\\right)\n$$\n\n**Пример в примере**. Давайте рассмотрим задачу аппроксимации функции одной переменной (чьи значения в обучающей выборке искажены нормальным шумом) многочленом степени не выше $3$. Положим в вероятностной модели $\\sigma^2 = 1$. Тогда различный выбор обучающих датасетов будет приводить к различным результатам:\n\n![14](https://yastatic.net/s3/education-portal/media/14_11_8334b6c580_39771752b9.webp)\n\nНо разброс результатов падает с ростом $N$.\n\n**Ещё пример в примере**. Рассмотрим ещё одну задачу регрессии с двумя признаками (в которой всё так же будем полагать $\\sigma^2 = 1$), для которой оценим распределение $w_0$ через первую компоненту $\\mathcal{N}(\\widehat{w}, I_N(\\widehat{w})^{-1})$ для одного конкретного $\\widehat{w}$ и нарисуем несколько различных $\\widehat{w}$, полученных из других датасетов той же мощности:\n\n![14](https://yastatic.net/s3/education-portal/media/14_12_dd76b88160_5fdf85100a.webp)\n\nВидим, что средние оцененного распределения сходятся к истинному значению $-1$; при этом дисперсия падает. Красные крестики не вполне подчиняются синему распределению, но мы от них ждём лишь приближённой согласованности, которая имеет место.\n\n{% endcut %}",
        "handbook": "Учебник по машинному обучению",
        "title": "Байесовский подход к оцениванию",
        "description": "Байесовская статистика. Априорные и апостериорные распределения на параметры моделей. MAP-оценки. Байесовский подход к выбору моделей. Байесовский подход для задачи линейной регресии"
    },
    {
        "path": "/handbook/ml/article/modeli-s-latentnymi-peremennymi",
        "content": "## Зачем нужны модели с латентными переменными\n\nПредположим, что мы делаем анализ данных для банка, и нам предоставили данные о годовых зарплатах клиентов.\n\n![ml](https://yastatic.net/s3/education-portal/media/ml_4_7_1_97ddd4916a_bedbb832da.svg)\n\nВ этом графике заметны три моды, которым, наверное, соответствуют три кластера клиентов. Неопытный аналитик мог бы проигнорировать это и попытаться описать график в отчете для руководства с помощью двух чисел — средней зарплаты и стандартного отклонения зарплат.\n\nОднако данные с гистограммы ниже имеют точно такое же среднее и стандартное отклонение, как и мультимодальные данные выше. Распределение совсем другое, правда?\n\nОчевидно, что графики выглядят совершенно по-разному, и правильная интерпретация первого графика может принести бизнесу дополнительные деньги (скажем, если банк научится предлагать клиентам из каждого кластера более кастомизированные предложения). Так что не надо пытаться описывать мультимодальные данные с помощью унимодальных распределений.\n\n![ml](https://yastatic.net/s3/education-portal/media/ml_4_7_2_98eb1026a6_af084afd19.svg)\n\nПроблема заключается в том, что нам неизвестно, к какому кластеру относится каждый клиент, и неизвестны характеристики кластеров — как же их тогда описать?\n\nДля каждого кластера можно попытаться задать свои параметры (среднее и дисперсию). Но как определить, из какого кластера конкретный клиент в выборке? Более того, один клиент может, например, «на 0.7» относиться к одному кластеру и «на 0.3» к другому.\n\n![ml](https://yastatic.net/s3/education-portal/media/ml_4_7_3_8b8fb6435b_bd310510a2.svg)\n\nКак решать такую задачу «мягкой» кластеризации («мягкой», потому что один объект может относиться к нескольким кластерам)? Мы могли бы действовать итерационно. Сначала зададим начальное приближение на параметры распределений.\n\nНапример, в нашем случае с клиентами банка из графика можно предположить, что среднее для первой кластера 30, для второго — 40, для третьей — 50, а стандартные отклонения у всех равняются, скажем, 10. Зная эти начальные параметры, мы можем для каждого клиента посчитать степень принадлежности к каждому из трёх кластеров (важно не забыть отнормировать эти числа, чтобы их сумма действительно равнялась единице).\n\nДальше мы бы могли пересчитать наши средние и дисперсии, «взвешивая» вклад объектов пропорционально степени их принадлежности к каждому кластеру, и таким образом уточнить средние и дисперсии для всех трёх кластеров. Повторяя эти два шага последовательно, мы получили бы средние и дисперсии кластеров, а для каждого объекта — степени принадлежности к кластерам. Это — EM-алгоритм, подробнее о нём мы поговорим ниже.\n\nКстати, оказывается, что и метод кластеризации K-средних во многом сродни EM-алгоритму (и на самом деле представляет собой его предельный случай). Действительно, мы сначала случайно расставляем центры кластеров.\n\nЗатем мы для каждого объекта пересчитываем расстояние до центра каждого кластера, после чего получаем «вес» объекта в каждом кластере («вес» в том смысле, что чем ближе объект к центру кластера, тем больше этот объект учитывается при пересчете центра этого кластера) через нормировку расстояний.\n\nТеперь, если мы применяем настоящий метод K-средних, то приписываем объект к кластеру с самым большим «весом», после чего опять пересчитываем центры кластеров и потом опять измеряем вес для каждого объекта кластера. Строгое же применение EM-алгоритма даёт «мягкую» версию метода K-средних.\n\n## Смеси распределений\n\nГоворят, что распределение $p(x)$ является **смесью распределений**, если его плотность имеет вид\n\n$$p(x)\n=\n\\sum_{k = 1}^{K} \\pi_k p_k(x),\n\\qquad\n\\sum_{k = 1}^{K} \\pi_k = 1,\n\\qquad\n\\pi_k \\geq 0,\n$$\n\nгде:\n\n- $K$ — число компонент;\n- $\\pi_k$ — вероятности компонент;\n- $p_k(x)$ — функции правдоподобия, то есть функции вероятности компонент (в дискретном случае) или их плотности (в абсолютно непрерывном случае).\n\nПроиллюстрируем это понятие на примере с банком. Будем считать, что распределения компонент смеси принадлежат некоторому параметрическому семейству: $p_k(x) = \\phi ( x \\vert \\theta_k )$ (например, гауссовскому с параметром $\\theta_k = (\\mu_k, \\sigma_k)$).\n\nМы можем говорить, что каждое из распределений $p_k(x)$ задаёт свой кластер, причём каждый кластер имеет некоторую априорную вероятность $\\pi_k$. Если у нас нет дополнительных данных, разумно положить $\\pi_k = \\frac{1}{3}$.\n\nЕсли же нам, к примеру, известно, что какой-нибудь кластер описывает сравнительно малочисленную группу людей, эти вероятности окажутся различными. Таким образом, мы проинтерпретировали нашу **мягкую кластеризацию** в терминах смеси распределений.\n\n## Как генерировать из смеси распределений\n\nРассмотрим следующий эксперимент: сначала из дискретного распределения  $\\{\\pi_1, \\dots, \\pi_K\\}$ выбирается номер $k$, а затем из распределения $\\phi(x \\vert \\theta_k)$ выбирается значение $x$. Покажем, что распределение переменной $x$ будет представлять собой смесь.\n\nВведем **скрытую переменную** $z$, отвечающую за то, к какой компоненте смеси будет относиться очередной $x$. Пусть она представляет собой $K$-мерный бинарный случайный вектор, ровно одна компонента которого равна единице:\n\n$$z \\in \\{0, 1\\}^K,\n\\qquad\n\\sum_{k = 1}^{K} z_k = 1.\n$$\n\nВероятность того, что единице будет равна $k$-я компонента, положим равной $\\pi_k$:\n\n$$p(z_k = 1) = \\pi_k.\n$$\n\nЗапишем распределение сразу всего вектора:\n\n$$p(z) = \\prod_{k = 1}^{K} \\pi_k^{z_k}.\n$$\n\nТеперь, когда номер компоненты смеси известен, сгенерируем $x$ из распределения $\\phi(x \\vert \\theta_k)$:\n\n$$p(x \\vert z_k = 1)\n=\n\\phi(x \\vert \\theta_k),\n$$\n\nили, что то же самое,\n\n$$p(x \\vert z)\n=\n\\prod_{k = 1}^{K}\n\\Bigl[\n    \\phi(x \\vert \\theta_k)\n\\Bigr]^{z_k}.\n$$\n\nПроверим, что $x$ имеет нужное нам распределение. Запишем совместное распределение переменных $x$ и $z$:\n\n$$p(x, z)\n=\np(z) p(x \\vert z)\n=\n\\prod_{k = 1}^{K}\n\\Bigl[\n    \\pi_k \\phi(x \\vert \\theta_k)\n\\Bigr]^{z_k}.\n$$\n\nЧтобы найти распределение переменной $x$, нужно избавиться от скрытой переменной:\n\n$$p(x)\n=\n\\sum_{z} p(x, z).\n$$\n\nСуммирование здесь ведется по всем возможным значениям $z$, то есть по всем $K$-мерным бинарным векторам с одной единицей:\n\n$$p(x)\n=\n\\sum_{z} p(x, z)\n=\n\\sum_{k = 1}^{K}\n\\pi_k \\phi(x \\vert \\theta_k).\n$$\n\nМы получили, что распределение сгенерированной переменной $x$ в описанном эксперименте представляет собой смесь $K$ компонент.\n\n## Модели со скрытыми переменными\n\nРассмотрим вероятностную модель с наблюдаемыми переменными $X$ и параметрами $\\Theta$, для которой задано правдоподобие $\\log p(X \\vert \\Theta)$.\n\nПредположим, что в модели также существуют **скрытые переменные** $Z$, описывающие её внутреннее состояние и, возможно, недоступные для непосредственного наблюдения (как то, к какому из кластеров относится клиент). Тогда правдоподобие $\\log p(X \\vert \\Theta)$ называется **неполным**, а правдоподобие $\\log p(X, Z \\vert \\Theta)$ — **полным**. Они связаны соотношением\n\n$$\\log p(X \\vert \\Theta) = \\log \\Biggl\\{ \\sum_{Z} p(X, Z \\vert \\Theta) \\Biggr\\}.\n$$\n\nНашей основной целью будет создать хорошую модель $X$, то есть оценить параметры $\\Theta$. И оказывается, что с помощью введения скрытых переменных нередко удаётся существенно упростить правдоподобие и эффективно решить задачу.\n\nРассмотрим пример со смесями распределений. В качестве наблюдаемых переменных здесь выступает выборка $X = \\{x_1, \\dots, x_\\ell\\}$, в качестве скрытых переменных $Z = \\{z_1, \\dots, z_\\ell\\}$ — номера компонент, из которых сгенерированы объекты (здесь каждый из $z_i$ — $K$-мерный вектор), в качестве параметров — априорные вероятности и параметры компонент $\\Theta = (\\pi_1, \\dots, \\pi_K, \\theta_1, \\dots, \\theta_K)$.\n\nНеполное правдоподобие выглядит так:\n\n$$\\log p(X \\vert \\Theta) = \\sum_{i = 1}^{l} \\log \\Biggl\\{\\sum_{k = 1}^{K} \\pi_k p(x_i \\vert \\theta_k) \\Biggr\\}.\n$$\n\nПравдоподобие здесь имеет вид **логарифма суммы**. Если приравнять нулю его градиент, то получатся сложные уравнения, не имеющие аналитического решения. Данное правдоподобие сложно вычислять: оно не является выпуклым (а точнее, вогнутым) и может иметь много локальных экстремумов, поэтому применение обычных итерационных методов для его непосредственной максимизации приводит к медленной сходимости.\n\nРассмотрим теперь полное правдоподобие:\n\n$$\\log p(X, Z \\vert \\Theta) = \\sum_{i = 1}^{l}p(x_i, z_i\\vert\\Theta) = \\sum_{i = 1}^{l} \\sum_{k = 1}^{K} z_{ik} \\Bigl\\{ \\log \\pi_k + \\log \\phi(x_i \\vert \\theta_k)\n\\Bigr\\}.\n$$\n\nОно имеет вид **суммы логарифмов**, и это позволяет аналитически найти оценки максимального правдоподобия на параметры $\\Theta$ при известных переменных $X$ и $Z$. В общем случае $Z$ также стараются выбирать таким способом, чтобы распределение $p(X, Z \\vert \\Theta)$ оказалось «лучше» исходного. В каком именно смысле, мы увидим дальше.\n\nПроблема, впрочем, заключается в том, что нам не известны скрытые переменные $Z$, поэтому их необходимо оценивать одновременно с параметрами, что никак не легче максимизации неполного правдоподобия. Осуществить это позволяет **EM-алгоритм**.\n\n## EM-алгоритм\n\nEM-алгоритм решает задачу максимизации полного правдоподобия путём попеременной оптимизации по параметрам и по скрытым переменным.\n\nОпишем сначала **наивный** способ оптимизации. Зафиксируем некоторое начальное приближение для параметров $\\Theta^{\\text{old}}$. При известных наблюдаемых переменных $X$ и параметрах $\\Theta^{\\text{old}}$ мы можем оценить скрытые переменные, найдя их наиболее правдоподобные значения:\n\n$$Z^* = \\underset{Z}{\\operatorname{arg max}} p(Z \\vert X, \\Theta^\\text{old}) = \\underset{Z}{\\operatorname{arg max}} p(X, Z \\vert \\Theta^\\text{old}).\n$$\n\nЗная скрытые переменные, мы можем теперь найти следующее приближение для параметров:\n\n$$\\Theta^\\text{new} = \\underset{\\Theta}{\\operatorname{arg max}} p(X, Z^* \\vert \\Theta).\n$$\n\nПовторяя итерации до сходимости, мы получим некоторый итоговый вектор параметров $\\Theta^\\text{*}$.\n\nДанная процедура, однако, далека от идеальной — и ниже мы предложим решение, которое приводит к более качественным результатам.\n\nВоспользуемся байесовским подходом. Точечные оценки параметров несут меньше информации, чем их распределение; учтём это и будем оптимизировать не $Z$, а условное распределение $Z$.\n\nКак и прежде, зафиксируем вектор параметров $\\Theta^\\text{old}$, но вместо точечной оценки вычислим апостериорное распределение на скрытых переменных $p(Z \\vert X, \\Theta^\\text{old})$, которое будет в некотором смысле оптимальным образом описывать распределение $Z$ при известных $X$ и $\\Theta$. В этом заключается **E-шаг** EM-алгоритма.\n\nОтметим, что вычислить $p(Z \\vert X \\Theta)$ аналитически возможно не для всех распределений, и скрытые переменные стоит подбирать так, чтобы это всё-таки получилось.\n\nТеперь мы должны произвести оптимизацию по $\\Theta$. Для этого возьмём логарифм полного правдоподобия $\\log p(X, Z \\vert \\Theta)$ и усредним его по всем возможным значениям скрытых переменных $Z$:\n\n$$Q(\\Theta, \\Theta^\\text{old}) = \\mathbb{E}_{Z \\sim p(Z \\vert X, \\Theta^\\text{old})} \\log p(X, Z \\vert \\Theta) = \\sum_{Z} p(Z \\vert X, \\Theta^\\text{old}) \\log p(X, Z \\vert \\Theta)\n$$\n\nФормально говоря, мы нашли матожидание логарифма полного правдоподобия по апостериорному распределению на скрытых переменных.\n\nНа **M-шаге** новый вектор параметров находится как максимизатор данного матожидания:\n\n$$\\Theta^\\text{new} = \\underset{\\Theta}{\\operatorname{arg max}} Q(\\Theta, \\Theta^\\text{old}) = \\underset{\\Theta}{\\operatorname{arg max}} \\sum_{Z} p(Z \\vert X, \\Theta^\\text{old}) \\log p(X, Z \\vert \\Theta).\n$$\n\nEM-алгоритм состоит в чередовании E-шага и M-шага.\n\nМожно показать, что такой итерационной процесс всегда не уменьшает правдоподобие и сходится.\n\n{% cut \"В двух словах: почему это работает\" %}\n\nНапомним, что наша цель — найти параметры $\\Theta$, максимизирующие $\\log p(X \\vert \\Theta)$. Преобразуем этот логарифм правдоподобия, введя некоторое (пока произвольное) распределение $q(Z)$ на латентных переменных:\n\n$$\\log p(X \\vert \\Theta) = \\left(\\sum_Zq(Z)dZ\\right)\\cdot \\log p(X \\vert \\Theta) = \n$$\n\n$$= \\sum_Zq(Z)\\log p(X \\vert \\Theta)dZ = \\sum_Zq(Z)\\log{\\frac{p(X, Z \\vert \\Theta)}{p(Z \\vert X, \\Theta)}}dZ\n$$\n\nЗдесь мы применили то, что $p(b) = \\frac{p(a, b)}{p(a\\vert b)}$ в силу равенства $p(a\\vert b) = \\frac{p(a, b)}{p(b)}$. Далее, домножим числитель и знаменатель под логарифмом на $q(Z)$:\n\n$$= \\sum_Zq(Z)\\log{\\frac{p(X, Z \\vert \\Theta)}{p(Z \\vert X, \\Theta)}}dZ = \n\\sum_Zq(Z)\\log{\\frac{p(X, Z \\vert \\Theta)q(Z)}{p(Z \\vert X, \\Theta)q(Z)}}dZ =$$\n\n$$= \\underbrace{\\sum_Zq(Z)\\log{\\frac{p(X, Z \\vert \\Theta)}{q(Z)}}dZ}_{=:\\mathcal{L}(q, \\Theta)} +\n\\underbrace{\\sum_Zq(Z)\\log{\\frac{q(Z)}{p(Z \\vert X, \\Theta)}}dZ}_{=KL(q(Z)\\parallel p(Z \\vert X, \\Theta))}$$\n\nВторое слагаемое — это расстояние Кульбака-Лейблера между распределениями $q(Z)$ и $p(Z \\vert X, \\Theta)$. Так как расстояние Кульбака-Лейблера всегда неотрицательно, мы получаем, что $\\log p(X \\vert \\Theta) \\geqslant \\mathcal{L}(q, \\Theta)$. Первое слагаемое, $\\mathcal{L}(q, \\Theta)$, называется **вариационной нижней оценкой** на $\\log p(X \\vert \\Theta)$, и, максимизируя его, мы будем также увеличивать и всю сумму — поэтому в дальнейшем мы позволим себе ограничиться работой только с ним.\n\nВариационную нижнюю оценку мы будем попеременно оптимизировать по $q$ (да-да, по распределению) и по $\\Theta$.\n\n**E-шаг** состоит в максимизации по $q$ при фиксированных $\\Theta$. Так как\n\n$$\\mathcal{L}(q, \\Theta) = \\log p(X \\vert \\Theta) - KL(q(Z)\\parallel p(Z \\vert X, \\Theta)),\n$$\n\nа $\\log p(X \\vert \\Theta)$ от $q$ не зависит, максимизировать $\\mathcal{L}(q, \\Theta)$ по $q$ — это то же самое, что минимизировать $KL(q(Z)\\parallel p(Z \\vert X, \\Theta))$. Расстояние Кульбака-Лейблера минимально, когда распределения совпадают, то есть мы должны обновить $q$ по правилу\n\n$$q(Z) = p(Z \\vert X, \\Theta)\n$$\n\nНа **M-шаге** мы максимизируем по $\\Theta$ при фиксированном $q$. Преобразуем вариационную нижнюю оценку:\n\n$$\\mathcal{L}(q, \\Theta) = \\sum_Zq(Z)\\log{\\frac{p(X, Z \\vert \\Theta)}{q(Z)}}dZ =\n$$\n\n$$= \\sum_Zq(Z)\\log{p(X, Z \\vert \\Theta)}dZ - \\sum_Zq(Z)\\log{q(Z)}dZ\n$$\n\nЗаметим, что $\\sum_Zq(Z)\\log{q(Z)}dZ$ — это энтропия распределения $q$, и она не зависит от $\\Theta$. Таким образом, нам достаточно максимизировать по $\\Theta$ математическое ожидание\n\n$$\\sum_Zq(Z)\\log{p(X, Z \\vert \\Theta)}dZ = \\mathbb{E}_{Z\\sim q(Z)}\\log{p(X, Z \\vert \\Theta)}\n$$\n\n{% endcut %}\n\n### Жёсткий EM-алгоритм\n\nНе всегда получается подобрать латентные переменные $Z$ так, чтобы $p(Z \\vert X, \\Theta)$ можно было выразить аналитически, то есть на E-шаге не удаётся минимизировать $\\mathcal{L}(q, \\Theta)$ по $q$.\n\nВ такой ситуации иногда приходится брать оптимум не по всему пространству распределений, а только по некоторому семейству — например, параметрическому, в котором оптимизацию можно проводить градиентными методами. В максимально упрощённой ситуации мы возьмём семейство дельта-функций, то есть вместо распределения на $Z$ будем брать просто точечную оценку. Такая модификация EM-алгоритма называется **жёстким EM-алгоритмом**.\n\nВ начале параграфа мы упоминали кластеризацию методом K-средних и отмечали, что EM-алгоритм даёт «мягкую» версию алгоритма: на E-шаге мы не приписываем однозначно точку к какому-то из кластеров (то есть не берём точечную оценку скрытой переменной «номер кластера, к которому принадлежит точка»), а сопоставляем ей вероятности принадлежности каждому из кластеров (то есть распределение на скрытые переменные). Настоящий метод K-средних как раз таки соответствует жёсткому EM-алгоритму.\n\n## Разделение смеси гауссиан\n\nПусть теперь нам известно, что $N$ точек были семплированы из K **разных** гауссовских распределений и нам неизвестно, какая точка из какого распределения пришла в выборку. Нам нужно оценить параметры ($\\mu_1$, $\\sigma_1$) для первого распределения, ($\\mu_2$, $\\sigma_2$) для второго и, соответственно, ($\\mu_k$, $\\sigma_k$) для $k$-го распределения.\n\nЕсли мы знаем, что точка $x_i$ пришла из распределения $z_i$, то её правдоподобие в равно:\n\n$$p(x_i \\mid z_i, \\theta) = \\frac1{\\sqrt{ 2 \\pi }\\sigma_{z_i}} \\exp\\left( -\\frac{ (x_i - \\mu_{z_i})^2 }{2 \\sigma_{z_i}^2} \\right)   \n$$\n\nНапомним, что $z_i$ — это латентная переменная, обозначающая номер гауссианы (от 1 до $K$), из которой была просемплирована точка $x_i$. Например, если точка $x_i$ просемплирована из распределения с номером 3, то в формулу вместо ($\\mu_{z_i}$, $\\sigma_{z_i}$) нужно подставлять $(\\mu_3, \\sigma_3)$.\n\nВоспользуемся EM-алгоритмом для нахождения параметров ($\\mu_{z_i}$, $\\sigma_{z_i}$). Сначала инициализируем их:\n\n$$\\Theta_{\\text{old}}={ \\mu_{1\\_{\\text{old}}}, \\sigma_{1\\_{\\text{old}}}, \\mu_{2\\_{\\text{old}}}, \\sigma_{2\\_{\\text{old}}}, \\ldots, \\mu_{K\\_{\\text{old}}}, \\sigma_{K\\_{\\text{old}}}\\\\}\n$$\n\nЗная $\\Theta\\_{\\text{old}}$, выполним E-шаг: нужно найти $p(Z \\mid X, \\Theta)$ или что то же самое, для каждого объекта $x_i$ найти распределение на вероятности $p(z_i = k \\mid x_i, \\Theta\\_{\\text{old}})$.\n\nКак найти апостериорную вероятность $p(z_i = k \\mid x_i, \\Theta\\_{\\text{old}})$, если мы знаем $x_i$ и у нас есть приближение $\\Theta\\_{\\text{old}}$?\n\nОтвет — по формуле Байеса:\n\n$$p(z_i = k \\mid x_i, \\Theta_{\\text{old}}) = \\frac{p(x_i \\mid z_i = k, \\Theta_{\\text{old}}) \\cdot p(z_i = k) } {p(x_i | \\Theta_{\\text{old}} )} = \\frac {p(x_i \\mid z_i = k, \\Theta_{\\text{old}}) \\cdot p(z_i = k) } { \\sum_{k=1}^K p(x_i \\mid z_i = k, \\Theta_{\\text{old}}) \\cdot p(z_i = k) }\n$$\n\nгде $p(z_i = k)$ — априорная вероятность того, что объекта $x_i$ получен из распределения с номером $k$. На первом шаге априорную вероятность можно положить равной $p(z_i = k) = \\frac{1}{K}$ для всех гауссиан.\n\nВведём обозначение\n\n$$u_{ik} := p(x_i \\mid z_i = k, \\Theta_{\\text{old}}) =  \\frac1{\\sqrt{(2 \\pi)} \\sigma_{k_{\\text{old}}} } \\exp\\left( -\\frac{(x_i - \\mu_{k_{\\text{old}}})^2 }{2 \\sigma_{k_{\\text{old}}}^2} \\right)\n$$\n\n— правдоподобие того, что объект $x_i$ пришел из нормального распределения с параметрами $(\\mu_{k_{\\text{old}}}, \\sigma_{k_{\\text{old}}}^2)$.\n\nТогда по формуле Байеса:\n\n$$p(z_i = k| x_i, \\theta_{\\text{old}}) = \\frac{ u_{ik} \\cdot \\frac{1}{K}} { \\sum_{k=1}^K u_{ik} \\cdot \\frac{1}{K} } \n$$\n\nВот так для каждого объекта $x_i$ по начальному приближению $\\theta_{\\text{old}}$ мы посчитаем распределение $p(z_i )$ — с какими вероятностями объект $x_i$ приходит из той или иной компоненты смеси.\n\nТеперь выведем формулы для М-шага.\n\n$$ \\theta = \\underset{\\Theta}{\\operatorname{arg max}} \\mathbb{E}_{q(Z)} \\log p(X | Z, \\Theta) = \\underset{\\Theta}{\\operatorname{arg max}} \\sum_{i=1}^N \\sum_{k=1}^K p(z_i = k | x_i, \\Theta) \\cdot \\log p(x_i | z_i = k, \\Theta)  \n$$\n\n$$= \\sum_{i=1}^N \\sum_{k=1}^K p(z_i = k | x_i, \\Theta) \\cdot \\left ( \\log \\frac{1}{K} - \\frac{1}{2 \\sigma_k^2} (x_i - \\mu_k)^2 - \\frac{1}{2} \\log \\sigma_k^2 \\right) + const \n$$\n\nЗапишем производную и приравняем к $0$, чтобы найти экстремум:\n\n$$ 0 = \\frac{\\partial \\mathbb{E}_{q(Z)} \\log p(X | Z, \\Theta) }{\\partial \\mu_k} = - \\sum_{i=1}^N p(z_i = k | x_i, \\Theta) \\cdot \\frac{x_i - \\mu_k}{\\sigma_k^2} \n$$\n\nОтсюда\n\n$$\\mu_k = \\frac{ \\sum_{i=1}^N p(z_i = k | x_i, \\theta) \\cdot x_i } {\\sum_{i=1}^N p(z_i = k | x_i, \\theta) } \n$$\n\nМы получили конечную формулу для пересчета $\\mu_k$ по $z_i$ и предыдущему значению $\\theta$. Причем у этой формулы есть простая интерпретация — каждый объект мы взвешиваем с его вероятностью принадлежности к этому классу $p(z_i = k \\mid x, \\theta)$.\n\nТеперь посчитаем производную по $\\sigma_k^2$ (обратите внимание, что именно по квадрату $\\sigma_k$):\n\n$$\\frac{\\partial \\mathbb{E}_{q(Z)} \\log p(X | Z, \\Theta) }{\\partial \\sigma_k^2} = \\sum_{i=1}^N   p(z_i = k | x_i, \\theta) \\cdot \\left( \\frac{(x_i - \\mu_k)^2}{2 \\sigma_k^4} - \\frac{1}{2 \\sigma_k^2} \\right) = 0\n$$\n\nСтало быть,\n\n$$\\sigma_k^2 = \\frac{ \\sum_{i=1}^N  p(z_i = k | x_i, \\Theta) (x_i - \\mu_k)^2 }{ \\sum_{i=1}^N p(z_i = k | x_i, \\Theta) }\n$$\n\nМы снова получили интерпретируемый результат: подсчитывая дисперсию для $k$-ой гауссианы, мы учитываем вес каждого объекта при подсчете среднеквадратичноого отклонения. То есть веса — вероятности происхождения из той или иной компоненты смеси. Сравните эту формулу с формулой для подсчета выборочной дисперсии, где каждый из $N$ объектов вносит одинаковый вклад в дисперсию с весом $\\frac{1}{N}$:\n\n$$\\sigma^2 = \\frac{\\sum_i^N (x_i - \\mu)^2}{N}\n$$\n\nВы можете «пощупать» EM-алгоритм в задаче разделения вероятностной смеси с помощью интерактивной визуализации — попробуйте сделать E и M шаги и последить за изменениями параметров: после одной итераций алгоритма можно выбрать точку на графике и наблюдать за вероятностью её принадлежности к разным кластерам.\n\n## Вероятностный PCA\n\nТеперь давайте рассмотрим простой пример того, как введение латентных переменных может помочь выделять новые информативные признаки в данных.\n\nПредположим, что мы имеем выборку данных $x_i$ (вектор-**строку**), где каждый объект имеет $D$ признаков (предположим, что число $D$ очень большое). Это достаточно типичная ситуация, например, при работе с текстами или изображениями.\n\nТеперь введём следующую вероятностную модель $x_i = z_i W^T + \\varepsilon$, где $z_i$ — латентный вектор-строка меньшей размерности $T$, а $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 E)$, где $E$ — единичная матрица размером $D \\times D$, $\\sigma$ — скаляр больший 0.\n\nЧто означает эта модель? Она означает, что наши сложные многоразмерные данные $x_i$ могут иметь более простое малоразмерное представление $z_i$, а отображение $z_i \\rightarrow x_i$ линейно с точностью до нормально распределенного шума.\n\nЗаметим, что так как $\\varepsilon \\sim  \\mathcal{N}(0, \\sigma^2 E)$, отсюда следует, что $x_i \\sim \\mathcal{N} (z_i W^T,  \\sigma^2 E)$. Зададим априорное распределение на $z_i$ как стандартное нормальное $z_i \\sim \\mathcal{N}(0, E)$ и распишем совместное распределение $(x_i, z_i)$ через условное и априорное:\n\n$$p(x_i, z_i \\vert W, \\sigma) = p(x_i \\vert z_i, W, \\sigma ) p(z_i) \n$$\n\nЧтобы восстановить параметры $W$, $\\sigma$ и латентные переменные $z_i$, снова воспользуемся EM-алгоритмом.\n\n**На E-шаге** мы оцениваем распределение на $z_i$ при фиксированных $W$ и $\\sigma$:\n\nПо формуле Байеса распределение на $z_i$ при условии $x_i$:\n\n$$p(z_i \\vert x_i, W, \\sigma) = \\frac{p(x_i \\vert z_i, W, \\sigma) \\cdot p(z_i)}{p(x_i \\vert W, \\sigma)}\n$$\n\nС точностью до констант и слагаемых, которые не зависят от $z_i$, логарифм правдоподобия равен:\n\n$$\\log p(z_i \\vert x_i, W, \\sigma) \\sim - \\frac{1}{2 \\sigma^2} (x_i - z_iW^T) (x_i - z_i W^T)^T - \\frac{1}{2} z_i z_i^T  \n$$\n\n$$\\log p(z_i \\vert x_i, W, \\sigma) \\sim -\\frac{1}{2 \\sigma^2} z_i W^T W z_i^T - \\frac{1}{2} z_i z_i^T + \\frac{1}{2\\sigma^2} (x_i W z_i^T + z_i W^T x_i^T) \n$$\n\n$$\\log p(z_i \\vert x_i, W, \\sigma) \\sim - \\frac{1}{2 \\sigma^2} z_i (W^T W + \\sigma^2 E) z_i^T + \\frac{1}{2\\sigma^2} (x_i W z_i^T + z_i W^T x_i^T) \n$$\n\nОбозначим $M:= W^T W + \\sigma^2 E$, тогда\n\n$$\\log p(z_i \\vert x_i, W, \\sigma) \\sim -\\frac{1}{2 \\sigma^2} z_i (\\sigma^2 M^{-1})^{-1} z_i^T + \\frac{1}{2} \\left( z_i (\\sigma^2 M^{-1})^{-1} \\cdot M^{-1} W^T x_i^T + x_i W M^{-1} \\cdot (\\sigma^2 M^{-1})^{-1} z_i  \\right) \n$$\n\n$$\\log p(z_i \\vert x_i, W, \\sigma) \\sim -\\frac{1}{2}  (z_i  - x_i W M^{-1}) \\cdot (\\sigma^2 M)^{-1} \\cdot (z_i - x_i W M^{-1})^T\n$$\n\nЕсли теперь взять от этого экспоненту, увидим, что $p(z_i \\vert x_i, W, \\sigma) \\sim \\mathcal{N} (x_i W M^{-1}, \\sigma^2 M)$.\n\n**M-шаг**.\n\nТеперь мы оптимизировать по $W$ и $\\sigma^2$:\n\n$$\\mathbb{E}_{p(Z \\vert X, W, \\sigma)} \\log p(X, Z \\vert W, \\sigma) = \\sum_i^n \\mathbb{E}_{p(z_i \\vert x_i, W, \\sigma)} \\log p(x_i, z_i \\vert W, \\sigma)   \\rightarrow \\min_{W,\\sigma}\n$$\n\nПриравняв производные к $0$, можно найти:\n\n$$W_{\\text{new}} = \\left( \\sum_i^n ( \\mathbb{E} z_i ) x_i^T\\right) \\cdot \\left( \\sum_i^n \\mathbb{E} (z_i^T z_i) \\right)^{-1}\n$$\n\n$$\\sigma_{\\text{new}} = \\frac{1}{ND} \\sum_i^n \\left[  \\vert \\vert x_i \\vert \\vert^2 - 2x_i W_{\\text{new}} \\mathbb{E} z_i^T + \\text{tr} \\left( W_{\\text{new}}^T W_{\\text{new}} \\mathbb{E} (z_i^T z_i)   \\right) \\right]\n$$\n\nВероятностный PCA хорош тем, что:\n\n1. как любая байесовская модель, может служить промежуточным участком в более сложной вероятностной модели;\n\n2. если в данных есть пропуски, то вероятностный PCA легко обобщается и на этот случай с добавлением дополнительных скрытых переменных;\n\n3. так как параметры $W, \\sigma$ и оценки на $z_i$ получаются через итерационный EM-алгоритм, то вероятностный PCA может быть вычислительно эффективнее. Так, в вычислениях и промежуточных формулах нигде не используется матрица $X^T X \\in \\mathcal{R}^{D \\times D}$, и все рассматриваемые матрицы имеют меньший размер.\n\n**Связь с обычным PCA**\n\nКак вероятностный PCA связан с обычным, который мы изучили в теме про разложение матриц?\n\nНапомним, что в обычном SVD-разложении мы полагали, что $x_i \\sim z_i \\hat{\\Sigma} \\hat{V}^T$. Давайте опять положим, что разница между $x_i$ и $z_i \\hat{\\Sigma} \\hat{V}^T$ есть гауссовский шум с нулевым средним $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 E)$:\n\n$$x_i = z_i \\hat{\\Sigma} \\hat{V}^T + \\varepsilon\n$$\n\nили\n\n$$x_i = \\mathcal{N} (z_i \\hat{\\Sigma} \\hat{V}^T , \\sigma^2 E)\n$$\n\nЕсли зададим априорное распределение на $z_i$ как стандартное нормальное $p(z_i) \\sim \\mathcal{N}(0, E)$, тогда $z_i V^T \\sim \\mathcal{N}(0, \\hat{V}^T \\hat{\\Sigma}^2 \\hat{V})$ и соответственно $x_i \\sim \\mathcal{N}(0, \\hat{V}^T \\hat{\\Sigma}^2 \\hat{V} + \\sigma^2 E)$.\n\nТеперь сделаем обратную замену $W^T = \\hat{\\Sigma} \\hat{V}^T$ и убедимся, что оценка максимального правдоподобия в точности равна $\\hat{\\Sigma} \\hat{V}^T$.\n\n$$\\log p(x_i \\vert W, \\sigma) = - \\frac{N}{2} \\log \\det (W^T W + \\sigma^2 E) - \\frac{1}{2} \\sum_i x_i (W^T W + \\sigma^2 E)^{-1} x_i^T + const\n$$\n\n(напомним, что $x_i$ и $z_i$ это вектор-строки). Заметим, что число есть след матрицы, состоящей из этого числа, поэтому можно преобразовать вторую часть, как\n\n$$-\\frac{1}{2} \\sum_i x_i (W^T W + \\sigma^2 E)^{-1} x_i^T = -\\frac{1}{2} \\textit{tr} \\left( \\sum_i x_i ( W^T W + \\sigma^2 E)^{-1} x_i^T  \\right) =\n$$\n\n$$= -\\frac{1}{2} \\textit{tr} \\left( (W^T W + \\sigma^2 E)^{-1} \\cdot \\left( \\sum_i x_i^T x_i \\right) \\right) = \n$$\n\n$$= -\\frac{1}{2} \\textit{tr} \\left( (W^T W + \\sigma^2 E)^{-1} \\cdot XX^T \\right) \n$$\n\nОтсюда следует, что\n\n$$\\log p(x_i \\vert W, \\sigma) = -\\frac{N}{2} \\log \\det (W^T W + \\sigma^2 E) - \\frac{1}{2}  \\textit{tr} \\left( (W^T W + \\sigma^2 E)^{-1} \\cdot XX^T \\right) \n$$\n\nПриравняв производную по $W$ к нулю, найдем:\n\n$$W^T_{\\textit{ML}} = (\\hat{\\Sigma}^2 - \\sigma^2 E)^{\\frac{1}{2}} \\hat{V}^T\n$$\n\nОценка максимума правдоподобия на $\\sigma^2$:\n\n$$\\sigma^2_{\\textit{ML}} = \\frac{1}{D - T} \\sum_{j=T+1}^{D} \\sigma_j^2,\n$$\n\nЭту оценку можно интерпретировать как среднюю потерю дисперсии по всем проигнорированным сингулярным направлениям. Если же $\\sigma^2$ — константа, то при $\\sigma \\rightarrow 0$ получаем обычный PCA.\n\nДругой способ получить обычный PCA — это вместо обычного EM-алгоритма воспользоваться его жёсткой модификацией.\n\n--------\n\nТеперь предлагаем вам потренировать изученный материал на практике. Предлагаем вам выполнить лабораторную работу, которая покрывает большинство тем главы “Вероятностные модели”. Скачайте [ноутбук](https://yastatic.net/s3/ml-handbook/admin/autohw_lm_probability_7de017bf61.ipynb?updated_at=2024-03-07T13:21:16.239Z) с лабораторной работой. В нём вы найдете описания заданий и дополнительные материалы. Задания из лабораторной прикреплены к этому параграфу в виде задач в системе Яндекс Контест. Чтобы проверить себя, отправляйте решения по соответствующим задачам в систему. Успехов в практике!",
        "handbook": "Учебник по машинному обучению",
        "title": "Модели с латентными переменными",
        "description": null
    },
    {
        "path": "/handbook/ml/article/nejronnye-seti",
        "content": "В этом параграфе вы познакомитесь с **нейронными сетями** — семейством моделей, которое начиная с 2012-го постепенно добивается превосходства во всё новых и новых приложениях, во многих став де-факто стандартом.  \n\nОни были придуманы ещё в 70-х, но техническая возможность и понимание того, как обучать нейросети большого размера, появились лишь примерно к 2011 году, и это дало мощный толчок к их развитию. Совокупность нейросетевых подходов и сама наука о нейросетях носит название **глубинного обучения** или **deep learning**.  \n\nГлубинное обучение основано на двух идеях.  \n\n- Во-первых, это стремление к переходу от построения сложных пайплайнов, каждая компонента которых тренируется сама по себе решать кусочек задачи, к end-to-end обучению всей системы, как одного целого. Так, мы можем обучать не каждый слой отдельно, а все вместе, и не учить какие-нибудь линейные модели поверх случайных лесов, а работать с одной цельной моделью\n- Во-вторых, это обучение представлений объектов — информативных признаковых описаний, учитывающих структуру данных, построенных лишь на основе самих данных, зачастую неразмеченных. Это позволяет автоматизировать процесс отбора признаков: теперь вместо того, чтобы руками экспертов искать «более информативное» или «более простое» признаковое описание наших объектов, мы можем получить их автоматически, притом используя не только данные, доступные нам для задачи, но и, к примеру, все тексты мира.\n\nОбучению представлений будет посвящён отдельный параграф, а в этом мы постараемся убедить вас, что нейросети — это гибкий инструмент для решения самых разных задач и для работы с самыми разными типами данных.\n\nНадо признать, впрочем, что современные модели весьма сложны и мало напоминают своих элегантных предшественников из 2012 года. Развитие нейросетей во многом мотивируется нуждами и возможностями индустрии, ростом производительности компьютеров и объёмов доступных данных.  \n\nПри этом теория отчаянно не поспевает за практикой. В глубинном обучении весьма распространён чисто инженерный подход к построению алгоритмов, изобилие деталей, основанных на интуиции и обосновывающихся фразой «просто потому, что так работает, а иначе — нет», поэтому ряд учёных продолжает относиться к нейросетям скептически.  \n\nОднако результаты, достигнутые с их помощью за последние 10 лет, столь впечатляющие, что их нельзя игнорировать. Особенно существенный прогресс был достигнут в области анализа данных, обладающих некоторой внутренней _структурой_: текстов, изображений, видео, облаков точек, графов и так далее.  \n\nТем не менее, есть и подходы к теоретическому осмыслению того, почему нейросети работают так хорошо, и мы познакомим вас с ними в отдельном параграфе, посвящённой теории машинного обучения.  \n\nНо довольно предисловий! Давайте набросаем план нашего вторжения в мир глубинного обучения:  \n\n1. [Первое знакомство с полносвязными нейросетями](https://academy.yandex.ru/handbook/ml/article/pervoe-znakomstvo-s-polnosvyaznymi-nejrosetyami). Вы впервые встретитесь с самой простой нейросетевой архитектурой, узнаете, как строятся и как применяются нейронные сети.  \n\n2. [Обратное распространение ошибки](https://academy.yandex.ru/handbook/ml/article/metod-obratnogo-rasprostraneniya-oshibki). Вы узнаете, как легко и быстро дифференцировать по параметрам сложного вычислительного графа, после чего будете (теоретически) понимать, как обучить несложную нейросеть.  \n\n3. [Тонкости обучения](https://academy.yandex.ru/handbook/ml/article/tonkosti-obucheniya). Нейросети — могущественный, но капризный инструмент, и чем сложнее глубинная модель, тем труднее обучить её. В этом разделе мы начнём знакомить вас с разными приёмами, которые позволяют повысить вероятность успеха, а также с регуляризационными техниками для нейросетей.  \n\n4. [Свёрточные нейросети](https://academy.yandex.ru/handbook/ml/article/svyortochnye-nejroseti). Классический пример структурированных данных — это изображения. В этом параграфе вы познакомитесь с базовым инструментарием для работы с ними — свёртками, пулингом и со свёрточными сетями в целом.\n\nВ первых четырёх главах вы познали основы глубинного обучения, но в основном имели дело с ситуацией, когда и данные, и выходы представляют из себя непритязательные векторы. А что делать, если мы должны работать с чем-то более сложно устроенным? Оказывается, за счёт своей гибкости и возможности сочетать в себе самые разные компоненты нейросети отлично справляются с данными, имеющими однородную структуру (изображениями, текстами, облаками точек $\\ldots$). Для работы с каждым из этих типов данных требуются специфические инженерные решения, и мы постараемся познакомить вас с ними, разверзнув перед вами всю бездну способностей нейросетей!  \n",
        "handbook": "Учебник по машинному обучению",
        "title": "Нейронные сети",
        "description": "Краткий путеводитель по разделу"
    },
    {
        "path": "/handbook/ml/article/pervoe-znakomstvo-s-polnosvyaznymi-nejrosetyami",
        "content": "### Основные определения\n\n**Искусственная нейронная сеть (далее — нейронная сеть)** — это сложная дифференцируемая функция, задающая отображение из исходного признакового пространства в пространство ответов, все параметры которой могут настраиваться одновременно и взаимосвязанно (то есть сеть может обучаться end-to-end).  \n\nВ частном (и наиболее частом) случае представляет собой последовательность дифференцируемых параметрических преобразований.  \n\nВнимательный читатель может заметить, что под указанное выше определение нейронной сети подходят и логистическая, и линейная регрессия. Это верное замечание: и линейная, и логистическая регрессии могут рассматриваться как нейронные сети, задающие отображения в пространство ответов и логитов соответственно.\n\nСложную функцию удобно представлять в виде суперпозиции простых, и нейронные сети обычно предстают перед программистом в виде конструктора, состоящего из более-менее простых блоков (**слоёв**, **layers**). Вот две простейшие их разновидности:\n\n- **Линейный слой** (**linear layer**, **dense layer**) — линейное преобразование над входящими данными. Его обучаемые параметры — это матрица $W$ и вектор $b$: $x \\mapsto xW + b$ ($W \\in \\mathbb{R}^{d \\times k}, x \\in \\mathbb{R}^{d}, b \\in \\mathbb{R}^{k}$). Такой слой преобразует $d$-мерные векторы в $k$-мерные.\n\n- **Функция активации** (**activation function**) — нелинейное преобразование, поэлементно применяющееся к пришедшим на вход данным. Благодаря функциям активации нейронные сети способны порождать более информативные признаковые описания, преобразуя данные *нелинейным* образом. Может использоваться, например, ReLU (rectified linear unit) $\\text{ReLU}(x) = \\text{max}(0, x)$ или уже знакомая вам из логистической регрессии сигмоида $\\sigma(x) = \\frac1{1 + e^{-x}}$. К более глубокому рассмотрению разновидностей и свойств различных функций активации вернёмся позднее.\n\nДаже самые сложные нейронные сети обычно собираются из относительно простых блоков, подобных этим. Таким образом, их можно представить в виде **вычислительного графа** (**computational graph**), где промежуточным вершинам соответствуют преобразования. На иллюстрации ниже приведён вычислительный граф для логистической регрессии.\n![16_1_89d47c2aca.webp](https://yastatic.net/s3/education-portal/media/16_1_89d47c2aca_9e25689e44.webp)\n\nНе правда ли, похоже на слоёный пирог из преобразований? Отсюда и *слои*.\n\nГрафы могут быть и более сложными, в том числе нелинейными:\n![16_2_a93003bf17.webp](https://yastatic.net/s3/education-portal/media/16_2_a93003bf17_fc60402048.webp)\n\nДавайте разберёмся, что тут происходит.\n\nInput — это **вход** нейросети, который получает исходные данные. Обычно требуется, чтобы они имели вид матрицы («объекты-признаки») или тензора (многомерной матрицы). Вообще говоря, входов может быть несколько: например, мы можем подавать в нейросеть картинку и какие-нибудь ещё сведения о ней — преобразовывать их мы будем по-разному, поэтому логично предусмотреть два входа в графе.  \n\nДальше к исходным данным $X^0$ применяются два линейных слоя, которые превращают их в **промежуточные (внутренние, скрытые) представления** $X^1$ и $X^2$. В литературе они также называются **активациями** (не путайте с функциями активации).  \n\nКаждое из представлений $X^1$ и $X^2$ подвергается нелинейному преобразованию, превращаясь в новые промежуточные представления $X^3$ и $X^4$ соответственно. Переход от $X^0$ к двум новым матрицам (или тензорам) $X^3$ и $X^4$ можно рассматривать как построение двух новых (возможно, более информативных) признаковых описаний исходных данных.  \n\nЗатем представления $X^3$ и $X^4$ конкатенируются (то есть признаковые описания всех объектов объединяются).  \n\nДальше следует ещё один линейный слой и ещё одна активация, и полученный результат попадает на **выход** сети, то есть отдаётся обратно пользователю.\n\nНейросеть, в которой есть только линейные слои и различные функции активации, называют **полносвязной** (**fully connected**) нейронной сетью или **многослойным перцептроном** (**multilayer perceptron**, MLP).\n\nПосмотрим, что происходит с размерностями, если на вход подаётся матрица $N\\times d$:\n\n![16_3_a5bc57bada.gif](https://yastatic.net/s3/education-portal/media/16_3_a5bc57bada_99b56bb226.gif)\n\n{% cut \"Примечание о терминологии\" %}\n\nВ литературе, увы, нет единства терминологии.\n\nТак, например, никто не мешает нам объявить «единым и неделимым слоем» композицию линейного слоя и активации (в ознаменование того, что мы почти никогда не используем просто линейный слой без нелинейности). Например, в фреймворке [keras](https://keras.io/) активацию можно указать в [линейном слое](https://keras.io/api/layers/core_layers/dense/) в качестве параметра.\n\nТакже в ряде источников слоями называется то, что мы называем промежуточными представлениями. Нам, впрочем, кажется, что промежуточные результаты $X^i$ правильнее называть именно представлениями: ведь это новые признаковые описания, представляющие исходные объекты. Кроме того, во всех нейросетевых фреймворках слои — это именно преобразования, поэтому и нам кажется правильным объявлять слоями именно преобразования, связывающие промежуточные представления.\n\n{% endcut %}\n\n\nА вот и настоящий пример из реальной жизни. GoogLeNet (она же Inception-v1), показавшая SotA-результат на ILSVRC 2014 (ImageNet challenge), выглядит так: \n\n![16_4_268cfc9ef3.webp](https://yastatic.net/s3/education-portal/media/16_4_268cfc9ef3_32d682d766.webp)\nЗдесь каждый кирпичик — это некоторое относительно простое преобразование, а белым помечены входы и выходы вычислительного графа.\n\nСовременные же сети часто выглядят и ещё сложней, но всё равно они собираются из достаточно простых кирпичиков-слоёв.\n\n**Примечание**. Впрочем, в общем случае нейронная сеть — это просто некоторая сложная функция (или, что эквивалентно, граф вычислений). Поэтому в некоторых (очень нетривиальных) случаях нет смысла разбивать её на слои. \n\nВ качестве иллюстрации ниже приведены структуры агностических нейронных сетей WANN, представленных в работе [Weight Agnostic Neural Networks, NeurIPS 2019](https://weightagnostic.github.io).\n\n![16_5_023febedc9.webp](https://yastatic.net/s3/education-portal/media/16_5_023febedc9_b912763670.webp)\n\n## Forward & backward propagation\n \nИнформация может течь по графу в двух направлениях.\n \nПрименение нейронной сети к данным (вычисление выхода по заданному входу) часто называют **прямым проходом**, или же **forward propagation** (**forward pass**). На этом этапе происходит преобразование исходного представления данных в целевое и последовательно строятся промежуточные (внутренние) представления данных — результаты применения слоёв к предыдущим представлениям. Именно поэтому проход называют прямым. \n\n![16_6_fea341f9c3.webp](https://yastatic.net/s3/education-portal/media/16_6_fea341f9c3_60d08130d5.webp)\n\nПри **обратном проходе**, или же **backward propagation** (**backward pass**), информация (обычно об ошибке предсказания целевого представления) движется от финального представления (а чаще даже от функции потерь) к исходному через все преобразования.  \n\nМеханизм обратного распространения ошибки, играющий важнейшую роль в обучении нейронных сетей, как раз предполагает _обратное_ движение по вычислительному графу сети. С ним вы познакомитесь в следующем [параграфе](https://education.yandex.ru/handbook/ml/article/metod-obratnogo-rasprostraneniya-oshibki).\n\n![16_7_baa8e48487.webp](https://yastatic.net/s3/education-portal/media/16_7_baa8e48487_0545f55a15.webp)\n\n## Архитектуры для простейших задач\n\nКак мы уже упоминали выше, нейросети — это универсальный конструктор, который из простых блоков позволяет собрать орудия для решения самых разных задач. Давайте посмотрим на конкретные примеры. Безусловно, мир намного разнообразнее того, что мы покажем вам в этом параграфе, но с чего-то ведь надо начинать, не так ли?\n\nВ тех несложных ситуациях, которые мы сейчас рассмотрим, архитектура будет отличаться лишь самыми последними этапами вычисления (у сетей будут разные «головы»). Для иллюстрации приведём примеры нескольких игрушечных архитектур для решения игрушечных задач классификации и регрессии на двумерных данных:\n\n![16_8_6ecb784579.webp](https://yastatic.net/s3/education-portal/media/16_8_6ecb784579_4fb31a95f3.webp)\n\n### Бинарная классификация\n\nДля решения задачи бинарной классификации подойдёт любая архитектура, на выходе у которой одно число от $0$ до $1$, интерпретируемое как «вероятность класса 1». Обычно этого добиваются, взяв \n\n$$\\widehat{y} = \\sigma(f(X^m)),$$\n\nгде $f$ — некоторая функция, превращающая представление $X^m$ в число (если $X^m$ — матрица, то подойдёт $f(X^m) = X^mw + b$, где $w$ — вектор-столбец), а $\\sigma$ — наша любимая сигмоида. При этом $X^m$ может получаться как угодно, лишь бы хватало оперативной памяти и не было переобучения.\n\nВ качестве функции потерь удобно брать уже знакомый нам log loss.\n\n### Многоклассовая классификация\n\nРаботая с другими моделями, мы порой вынуждены были выдумывать сложные стратегии многоклассовой классификации; нейросети позволяют это делать легко и элегантно.  \n\nДостаточно построить сеть, которая будет выдавать $K$ неотрицательных чисел, суммирующихся в 1 (где $K$ — число классов); тогда им можно придать смысл вероятностей классов и предсказывать тот класс, «вероятность» которого максимальна.  \n\nПревратить произвольный набор из $K$ чисел в набор из неотрицательных чисел, суммирующихся в 1, позволяет, к примеру, функция\n\n$$\\text{softmax}(x_1,\\ldots,x_K) = \\left( \\frac{e^{x_1}}{\\sum_ie^{x_i}},\\ldots,\\frac{e^{x_K}}{\\sum_ie^{x_i}} \\right)$$\n\nНаиболее популярные архитектуры для многоклассовой классификации имеют вид\n\n$$\\widehat{y} = \\text{softmax}(f(X^m)),$$\n\nгде $f$ — функция, превращающая $X^m$ в матрицу $B\\times K$ (где $B$ — размер батча), а $X^m$ может быть получен любым приятным вам образом.\n\nНо какой будет функция потерь для такой сети? Мы должны научиться сравнивать «распределение вероятностей классов» с истинным (в котором на месте истинного класса стоит 1, а в остальных местах 0). Сделать это позволяет **кросс-энтропия**, она же **negative log-likelihood** — некоторый аналог расстояния между распределениями:\n\n$$\\mathcal{L}(\\widehat{y}, y) = -\\frac1B\\sum_{i=1}^B\\sum_{k=1}^Ky_{ik}\\log{\\widehat{y}_{ik}},$$\n\nгде снова $B$ — размер батча, а $K$ — число классов. Легко видеть, что при $k = 2$ получается та самая функция потерь, которую мы использовали для обучения бинарной классификации.\n\n### (Множественная) регрессия\n\nС помощью нейросетей легко создать модель, которая предсказывает не одно число, а сразу несколько. Например, координаты ключевых точек лица — кончика носа, уголков рта и так далее.  \n\nДостаточно сделать, чтобы последнее представление было матрицей $B\\times M$, где $B$ — размер батча, а $M$ — количество предсказываемых чисел. Особенностью большинства моделей регрессии является то, что после последнего слоя (часто линейного) не ставят функций активации. Вы тоже этого не делайте, если только чётко не понимаете, зачем вам это. В качестве функции потерь можно брать, например, $MSE$ по всей матрице $B\\times M$.\n\n### Всё вместе\n\nЕсли вы используете нейросети, то ваши таргеты могут иметь и различную природу. Например, можно соорудить одну-единственную сеть, которая по фотографии нескольких котиков определяет их количество (регрессия) и породу каждого из них (многоклассовая классификация).  \n\nЛосс для такой модели может быть равен (взвешенной) сумме лоссов для каждой из задач (правда, не факт, что это хорошая идея). Так что, по крайней мере в теории, сетям подвластны любые задачи. На практике, конечно, всё гораздо хитрей: для обучения слишком сложной сети у вас может не хватить данных или вычислительных мощностей.\n\n## Популярные функции активации\n\nДля начала поговорим о том, зачем они нужны. \n\nКазалось бы, можно последовательно выстраивать лишь линейные слои, но так не делают: после каждого линейного слоя обязательно вставляют функцию активации. Но зачем? Попробуем разобраться. \n\nРассмотрим нейронную сеть из двух линейных слоёв. Что произойдёт, если между ними будет отсутствовать нелинейная функция активации?\n\n![16_11_f51987e443.webp](https://yastatic.net/s3/education-portal/media/16_11_f51987e443_18d80b4075.webp)\n\n\n$$\\widehat{y} = X^{out} = X^{1}W^{2} + b^2 = (X^0W^1 + b^1)W^2 + b^2 = $$\n\n$$=  X^0\\color{blue}{W^1W^2} + \\color{green}{b^1W^2 + b^2} = X^0\\color{blue}{\\widetilde{W}} + \\color{green}{\\widetilde{b}}$$\n\nЛинейная комбинация линейных отображений есть линейное отображение, то есть два последовательных линейных слоя эквивалентны одному линейному слою. \n\nДобавление функций активации после линейного слоя позволяет получить нелинейное преобразование, и подобной проблемы уже не возникает. Вдобавок правильный выбор функции активации позволяет получить преобразование, обладающее подходящими свойствами.\n\nВ качестве функции активации может использоваться, например, уже знакомая вам из логистической регрессии сигмоида $\\sigma(x) = \\frac1{1 + \\exp(-x)}$ или ReLU (Rectified linear unit) $\\text{ReLU}(x) = \\text{max}(0, x)$. К более глубокому рассмотрению разновидностей и свойств различных функций активации вернёмся позднее.\n\n**Примечание**. На самом деле бывают ситуации, когда два линейных слоя подряд — это полезно. Например, если вы понимаете, что у вас очень много параметров, а информации в данных не так много, вы можете заменить линейный слой, превращающий $m$-мерные векторы в $n$-мерные, на два, вставив посередине $k$-мерное представление, где $k \\ll m, n$:\n\n![16_12_cd50e0d27f.webp](https://yastatic.net/s3/education-portal/media/16_12_cd50e0d27f_c921999cdf.webp)\n\nС точки зрения линейной алгебры это примерно то же самое, что потребовать, чтобы матрица исходного линейного слоя имела ранг не выше $k$. И с точки зрения сужения «информационного канала» это иногда может сработать. Но в любом случае вы должны понимать, что два линейных слоя подряд стоит ставить, только если вы хорошо понимаете, чего хотите добиться.\n\nВернёмся к функциям активации. Вот наиболее популярные:\n\n![16_9_9688e57c43.webp](https://yastatic.net/s3/education-portal/media/16_9_9688e57c43_44ff70e160.webp)\n\nРассмотрим их подробнее.\n\n### **ReLU**, Rectified linear unit\n\nФормула:\n\t\n$$\n\\text{ReLU}(x) = \\max(0, x),\n$$\n\t\n$$\n\\text{ReLU}: \\mathbb{R} \\to [0, +\\infty).\n$$\n\nReLU это простая кусочно-линейная функция. Одна из наиболее популярных функций активации. В нуле производная доопределяется нулевым значением. \n\nПлюсы:  \n* простота вычисления активации и производной.  \n\nМинусы:  \n* область значений является смещённой относительно нуля;  \n* для отрицательных значений производная равна нулю, что может привести к затуханию градиента.   \n\nReLU и её производная очень просты для вычисления: достаточно лишь сравнить значение с нулём. Благодаря этому использование ReLU позволяет достигать прироста в скорости до четырёх-шести раз относительно сигмоиды. \n\n{% cut \"Более подробно о затухании градиента\" %}\n\nРассмотрим нейронную сеть из нескольких линейных слоёв с сигмоидой в качестве функции активации. Пусть\n\n$$\nX^1 = \\sigma(Z^1) = \\sigma(W^1 X^0),\n$$\n\nгде в качестве $Z^1$ обозначен результат применения линейного слоя. Свободный член, как и ранее, опущен для упрощения выкладок.\n\nРассмотрим график сигмоиды и её производной:\n![16_10_24315262a6.webp](https://yastatic.net/s3/education-portal/media/16_10_24315262a6_85a99cae9e.webp)\n\nНа «хвостах» её производная практически равна нулю (ведь сигмоида представляет собой почти константу). То есть если какое-то значение $Z^1$ было достаточно велико по абсолютной величине (например, $\\vert z^1_k \\vert = 7.4$), то градиент функции потерь для этой компоненты будет домножен на очень малое число и фактически станет равным нулю:\n\n$$\n\\frac{\\partial l}{\\partial W^0_{k, :}} = \\frac{\\partial l}{\\partial X^1_k}\\frac{\\partial X^1_k}{\\partial Z^1_k} \\frac{\\partial Z^1_k}{\\partial W^0_{k,:}} \\approx \\frac{\\partial l}{\\partial X^1_k} \\cdot 0 \\cdot \\frac{\\partial Z^1_k}{\\partial W^0_{k,:}} \\approx 0.\n$$\n\nПолучается, что $k$-ая строка матрицы $W^0$ не будет обновлена: ведь градиент равен нулю. Это может привести к «отмиранию» части весов: неудачное значение параметров приведёт к невозможности их обновления.\n\n**Примечание**. Это одна из причин необходимости нормировки данных и выбора правильной инициализации для начальных значений параметров нейронной сети.\n\nНо помимо явного обнуления градиента есть и вторая проблема: максимальное значение производной сигмоиды составляет $0.25$. То есть она всегда уменьшает значение градиента не менее чем в четыре раза. Если же представить себе глубокую сеть с 20+ слоями, то для каждого следующего (если считать с конца) слоя градиент будет домножаться на число, не превосходящее $0.25$. Так, для переменных из первого слоя коэффициент составит $4^{-20}$.\n\n{% endcut %}\n\n### **Leaky ReLU**\n\nФормула:\n\t\n$$\n\\text{Leaky ReLU}(x) = \\max(\\alpha x, x), \\quad \\alpha = \\text{const}, 0 < \\alpha \\ll 1\n$$\n\n$$\n\\text{Leaky ReLU}: \\mathbb{R} \\to (-\\infty, +\\infty).\n$$\n\t\nГиперпараметр $\\alpha$ обеспечивает небольшой уклон слева от нуля, что позволяет получить более симметричную относительно нуля область значений. Также меньше провоцирует затухание градиента благодаря наличию ненулевого градиента и слева, и справа от нуля.\n\n### **PReLU**, Parametric ReLU\n\nФормула:\n\t\n$$\n\\text{PReLU}(x) = \\max(\\alpha x, x), \\quad 0 < \\alpha \\ll 1\n$$\n\n$$\n\\text{PReLU}: \\mathbb{R} \\to (-\\infty, +\\infty).\n$$\n\t\nАналогична Leaky ReLU, но параметр $\\alpha$ настраивается градиентными методами.\n\n### **ELU**\n\nELU – это гладкая аппроксимация ReLU. Обладает более высокой вычислительной сложностью, достаточно редко используется на практике.\n\n### **Sigmoid**, сигмоида\n\nФормула:\n\t\n$$\n\\sigma(x) = \\frac{1}{1 + \\exp(-x)},\n$$\n\n$$\n\\sigma: \\mathbb{R} \\to (0, 1).\n$$\n\nИсторически одна из первых функций активации. Рассматривалась в том числе и как гладкая аппроксимация порогового правила, эмулирующая активацию естественного нейрона. \n\nПлюсы: \n\nМинусы:\n* область значений смещена относительно нуля;  \n* сигмоида (как и её производная) требует вычисления экспоненты, что является достаточно сложной вычислительной операцией. Её приближённое значение вычисляется на основе ряда Тейлора или с помощью полиномов, Stack Overflow [question 1](https://stackoverflow.com/questions/53419270/how-does-numpy-compute-an-exponential), [question 2](https://stackoverflow.com/questions/9799041/efficient-implementation-of-natural-logarithm-ln-and-exponentiation);  \n* на «хвостах» обладает практически нулевой производной, что может привести к затуханию градиента;  \n* максимальное значение производной составляет $0.25$, что также приводит к затуханию градиента.  \n\t\nНа практике сигмоида редко используется внутри сетей, чаще всего в случаях, когда внутри модели решается задача бинарной классификации (например, вероятность забывания информации в LSTM).\n\n### **Tanh**, гиперболический тангенс\n\nФормула:\n\t\n$$\n\\tanh(x) = \\frac{\\exp(x) - \\exp(-x)}{\\exp(x) + \\exp(-x)},\n$$\n\n$$\n\\tanh: \\mathbb{R} \\to (-1, 1).\n$$\n\t\nПлюсы:  \n* как и сигмоида, имеет ограниченную область значений;  \n* в отличие от сигмоиды, область значений симметрична.  \n\nМинусы:  \n* требует вычисления экспоненты, что является достаточно сложной вычислительной операцией;  \n* на «хвостах» обладает практически нулевой производной, что может привести к затуханию градиента.  \n    \n**Вопрос на подумать**. А почему симметричность области значений может быть ценным свойством?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nРазберём на примере сигмоиды. Пусть оказалось так, что все веса линейных слоёв инициализированы положительными числами. \n\nСигмоида от положительного числа даёт нечто, большее $\\frac12$, и с каждым дальнейшим слоем ситуация может усугубляться, приводя к тому, что сигмоиды будут выдавать всё более близкие к единице значения. Это покарает нас, когда мы начнём считать градиенты: они начнут «затухать».\n\n{% endcut %}\n\n## Немного о мощи нейросетей\n\nРассмотрим для начала задачу регрессии. Ясно, что линейная модель (то есть однослойная нейросеть) может приблизить только линейную функцию, но уже двухслойная нейросеть может приблизить почти что угодно. Есть ряд теорем на эту тему, мы упомянем одну из них. Обратите внимание на год: как мы уже упоминали, нейросети начали серьёзно изучать задолго до того, как они начали превращаться в state of the art.\n\n**Теорема Цыбенко (1989).** Для любой непрерывной функции $f(x):\\mathbb{R}^m\\rightarrow\\mathbb{R}$ и для любого $\\varepsilon > 0$ найдётся число $N$, а также числа $w_1\\ldots,w_N$, $b_1,\\ldots,b_N$ $\\alpha_1,\\ldots,\\alpha_N$, для которых\n\n$$\\left|f(x) - \\sum_{i=1}^N\\alpha_i\\sigma(\\langle x, w_i\\rangle + b_i)\\right| < \\varepsilon$$\n\nдля любых $x$ из единичного куба $[0,1]^m$ в $\\mathbb{R}^m$.\n\nВ сумме из теоремы Цыбенко легко опознать двуслойную нейросеть с сигмоидной функцией активации. В самом деле, сперва мы превращаем $x$ в $\\langle x, w_i\\rangle + b_i$ — это можно представить в виде одной матричной операции (линейный слой!):\n\n$$x\\mapsto x^{(1)} = x\\cdot\\begin{pmatrix}\n\\phantom{\\frac12}w_1 & \\ldots &\nw_N\n\\end{pmatrix} + \\begin{pmatrix}\n\\phantom{\\frac12}b_1 & \\ldots &\nb_N\n\\end{pmatrix},$$\n\nгде $w_i$ — вектор-столбцы, а каждое из $b_i$ прибавляется к $i$-му столбцу, после чего поэлементно берём от $x^{(1)}$ сигмоиду (активация) $x^{(2)} = \\sigma(x^{(1)})$, после чего вычисляем\n\n$$\\sum_{i=1}^N\\alpha_ix^{(2)}_i = \\left(\\alpha_1,\\ldots,\\alpha_N\\right)\\cdot x,$$\n\nи это второй линейный слой (без свободного члена).\n\nПравда, теорема не очень помогает находить такие функции, но это уже другое дело. В любом случае — если дать нейросети достаточно данных, она действительно может выучить почти что угодно.\n\n**Упражнение.** Мы не будем приводить результатов, касающихся классификации, но рекомендуем воспользоваться замечательной [песочницей](https://playground.tensorflow.org). Убедитесь сами, что при использовании одного скрытого слоя из двух нейронов и сигмоиды в качестве функции активации, можно неплохо классифицировать данные со сложной, совсем даже не линейной границей между классами. Вы также можете поиграть с разными функциями активации.\n\nА для получения решения нам необходим метод автоматической настройки всех параметров нейронной сети — **метод обратного распространения ошибки**, или же **error backpropagation**. Рассмотрим его в деталях в следующем параграфе.",
        "handbook": "Учебник по машинному обучению",
        "title": "Первое знакомство с полносвязными нейросетями",
        "description": "Основные понятия глубинного обучения. Базовые слои и функции активации"
    },
    {
        "path": "/handbook/ml/article/metod-obratnogo-rasprostraneniya-oshibki",
        "content": "Нейронные сети обучаются с помощью тех или иных модификаций градиентного спуска, а чтобы применять его, нужно уметь эффективно вычислять градиенты функции потерь по всем обучающим параметрам. Казалось бы, для какого-нибудь запутанного вычислительного графа это может быть очень сложной задачей, но на помощь спешит метод обратного распространения ошибки.\n\n## Метод обратного распространения ошибки (backward propagation)\n\nОткрытие метода обратного распространения ошибки стало одним из наиболее значимых событий в области искусственного интеллекта. В актуальном виде он был [предложен](https://web.stanford.edu/class/psych209a/ReadingsByDate/02_06/PDPVolIChapter8.pdf) в 1986 году Дэвидом Э. Румельхартом, Джеффри Э. Хинтоном и Рональдом Дж. Вильямсом, а также независимо и одновременно красноярскими математиками С. И. Барцевым и В. А. Охониным.\n\nС тех пор для нахождения градиентов параметров нейронной сети используется метод вычисления производной сложной функции, и оценка градиентов параметров сети стала хоть и сложной инженерной задачей, но уже не искусством. Несмотря на простоту используемого математического аппарата, появление этого метода привело к значительному скачку в развитии искусственных нейронных сетей.\n\nСуть метода можно записать одной формулой, тривиально следующей из формулы производной сложной функции: если $f(x) = g_m(g_{m-1}(\\ldots (g_1(x)) \\ldots))$, то $\\frac{\\partial f}{\\partial x} = \\frac{\\partial g_m}{\\partial g_{m-1}}\\frac{\\partial g_{m-1}}{\\partial g_{m-2}}\\ldots \\frac{\\partial g_2}{\\partial g_1}\\frac{\\partial g_1}{\\partial x}$. Уже сейчас мы видим, что градиенты можно вычислять последовательно, в ходе одного обратного прохода, начиная с $\\frac{\\partial g_m}{\\partial g_{m-1}}$ и умножая каждый раз на частные производные предыдущего слоя.\n\n## Backward propagation в одномерном случае\n\nВ одномерном случае всё выглядит особенно просто. Пусть $w_0$ — переменная, по которой мы хотим продифференцировать , причём сложная функция имеет вид\n\n$$f(w_0) = g_m(g_{m-1}(\\ldots g_1(w_0)\\ldots)),\n$$\n\nгде все $g_i$ скалярные. Тогда\n\n$$f'(w_0) = g_m'(g_{m-1}(\\ldots g_1(w_0)\\ldots))\\cdot g'_{m-1}(g_{m-2}(\\ldots g_1(w_0)\\ldots))\\cdot\\ldots \\cdot g'_1(w_0)\n$$\n\nСуть этой формулы такова. Если мы уже совершили прямой проход (forward propagation), значит мы уже знаем\n\n$$g_1(w_0), g_2(g_1(w_0)),\\ldots,g_{m-1}(\\ldots g_1(w_0)\\ldots),\n$$\n\nПоэтому мы можем действовать следующим образом:\n\n* берём производную $g_m$ в точке $g_{m-1}(\\ldots g_1(w_0)\\ldots)$;\n\n* умножаем на производную $g_{m-1}$ в точке $g_{m-2}(\\ldots g_1(w_0)\\ldots)$;\n\n* и так далее, пока не дойдём до производной $g_1$ в точке $w_0$.\n\nПроиллюстрируем это на картинке, расписав по шагам дифференцирование по весам $w_i$ функции потерь логистической регрессии на одном объекте (то есть для батча размера 1):\n\n![17](https://yastatic.net/s3/education-portal/media/17_1_7a336adac8_e7010805ee.webp)\n\nСобирая все множители вместе, получаем:\n\n$$\\frac{\\partial f}{\\partial w_0} = (-y)\\cdot e^{-y(w_0 + w_1x_1 + w_2x_2)}\\cdot\\frac{-1}{1 + e^{-y(w_0 + w_1x_1 + w_2x_2)}}\n$$\n\n$$\\frac{\\partial f}{\\partial w_1} = x_1\\cdot(-y)\\cdot e^{-y(w_0 + w_1x_1 + w_2x_2)}\\cdot\\frac{-1}{1 + e^{-y(w_0 + w_1x_1 + w_2x_2)}}\n$$\n\n$$\\frac{\\partial f}{\\partial w_2} = x_2\\cdot(-y)\\cdot e^{-y(w_0 + w_1x_1 + w_2x_2)}\\cdot\\frac{-1}{1 + e^{-y(w_0 + w_1x_1 + w_2x_2)}}\n$$\n\nТаким образом, сперва совершается forward propagation для вычисления всех промежуточных значений (да, все промежуточные представления нужно будет хранить в памяти), а потом запускается backward propagation, на котором в один проход вычисляются все градиенты.\n\n## Почему же нельзя просто пойти и начать везде вычислять производные?\n\nВ параграфе, посвящённом [матричным дифференцированиям](https://academy.yandex.ru/handbook/ml/article/matrichnoe-differencirovanie), мы поднимаем вопрос о том, что вычислять частные производные по отдельности — это зло, лучше пользоваться матричными вычислениями. Но есть и ещё одна причина: даже и с матричной производной в принципе не всегда хочется иметь дело.\n\nРассмотрим простой пример. Допустим, что $X^r$ и $X^{r+1}$ — два последовательных промежуточных представления $N\\times M$ и $N\\times K$, связанных функцией $X^{r+1} = f^{r+1}(X^r)$. Предположим, что мы как-то посчитали производную $\\frac{\\partial\\mathcal{L}}{\\partial X^{r+1}_{ij}}$ функции потерь $\\mathcal{L}$, тогда\n\n$$\\frac{\\partial\\mathcal{L}}{\\partial X^{r}_{st}} = \\sum_{i,j}\\frac{\\partial f^{r+1}_{ij}}{\\partial X^{r}_{st}}\\frac{\\partial\\mathcal{L}}{\\partial X^{r+1}_{ij}}\n$$\n\nИ мы видим, что, хотя оба градиента $\\frac{\\partial\\mathcal{L}}{\\partial X_{ij}^{r+1}}$ и $\\frac{\\partial\\mathcal{L}}{\\partial X_{st}^{r}}$ — это просто матрицы, в ходе вычислений возникает «четырёхмерный кубик» $\\frac{\\partial f_{ij}^{r+1}}{\\partial X_{st}^{r}}$. Его болезненно даже хранить: уж больно много памяти он требует —м$N^2MK$ по сравнению с безобидными $NM + NK$, требуемыми для хранения градиентов.\n\nПоэтому хочется промежуточные производные $\\frac{\\partial f^{r+1}}{\\partial X^{r}}$ рассматривать не как вычисляемые объекты $\\frac{\\partial f_{ij}^{r+1}}{\\partial X_{st}^{r}}$, а как преобразования, которые превращают $\\frac{\\partial\\mathcal{L}}{\\partial X_{ij}^{r+1}}$ в $\\frac{\\partial\\mathcal{L}}{\\partial X_{st}^{r}}$.\n\nЦелью следующих параграфов будет именно это: понять, как преобразуется градиент в ходе error backward propagation при переходе через тот или иной слой.\n\n**Вы спросите себя**: надо ли мне сейчас пойти и прочитать параграф учебника про матричное дифференцирование?\n\n**Короткий ответ**: Зависит от ваших знаний.\n\n**Длинный ответ**: Найдите производную функции по вектору $x$:\n\n$$f(x) = x^TAx,\\ A\\in Mat_{n}{\\mathbb{R}}\\text{ — матрица размера }n\\times n\n$$\n\nА как всё поменяется, если $A$ тоже зависит от $x$? Чему равен градиент функции, если $A$ является скаляром?\n\nЕсли вы готовы прямо сейчас взять ручку и бумагу и посчитать всё, то вам, вероятно, не надо читать про матричные дифференцирования. Но мы советуем всё-таки заглянуть в этот параграф, если обозначения, которые мы будем дальше использовать, покажутся вам непонятными: единой нотации для матричных дифференцирований человечество пока, увы, не изобрело, и переводить с одной на другую не всегда легко.\n\nА мы же сразу перейдём к интересующей нас вещи: к вычислению градиентов сложных функций.\n\n## Градиент сложной функции\n\nНапомним, что формула производной сложной функции выглядит следующим образом:\n\n$$\\left[D_{x_0} (\\color{#5002A7}{u} \\circ \\color{#4CB9C0}{v}) \\right](h) = \\color{#5002A7}{\\left[D_{v(x_0)} u \\right]} \\left( \\color{#4CB9C0}{\\left[D_{x_0} v\\right]} (h)\\right)\n$$\n\nТеперь разберёмся с градиентами. Пусть $f(x) = g(h(x))$ – скалярная функция. Тогда\n\n$$\\left[D_{x_0} f \\right] (x-x_0) = \\langle\\nabla_{x_0} f, x-x_0\\rangle.\n$$\n\nС другой стороны,\n\n$$\\left[D_{h(x_0)} g \\right] \\left(\\left[D_{x_0}h \\right] (x-x_0)\\right) = \\langle\\nabla_{h_{x_0}} g, \\left[D_{x_0} h\\right] (x-x_0)\\rangle = \\langle\\left[D_{x_0} h\\right]^* \\nabla_{h(x_0)} g, x-x_0\\rangle.\n$$\n\nТо есть $\\color{#FFC100}{\\nabla_{x_0} f} = \\color{#348FEA}{\\left[D_{x_0} h \\right]}^* \\color{#FFC100}{\\nabla_{h(x_0)}}g$ — применение сопряжённого к $D_{x_0} h$ линейного отображения к вектору $\\nabla_{h(x_0)} g$.\n\nЭта формула — сердце механизма обратного распространения ошибки. Она говорит следующее: если мы каким-то образом получили градиент функции потерь по переменным из некоторого промежуточного представления $X^k$ нейронной сети и при этом знаем, как преобразуется градиент при проходе через слой $f^k$ между $X^{k-1}$ и $X^k$ (то есть как выглядит сопряжённое к дифференциалу слоя между ними отображение), то мы сразу же находим градиент и по переменным из $X^{k-1}$:\n\n![17](https://yastatic.net/s3/education-portal/media/17_2_734d32744c_04fe5332ad.webp)\n\nТаким образом слой за слоем мы посчитаем градиенты по всем $X^i$ вплоть до самых первых слоёв.\n\nДалее мы разберёмся, как именно преобразуются градиенты при переходе через некоторые распространённые слои.\n\n## Градиенты для типичных слоёв\n\nРассмотрим несколько важных примеров.\n\n### Пример №1\n\n$f(x) = u(v(x))$, где $x$ — вектор, а $v(x)$ – поэлементное применение $v$:\n\n$$v\\begin{pmatrix}\nx_1 \\\\\n\\vdots\\\\\nx_N\n\\end{pmatrix}\n= \\begin{pmatrix}\nv(x_1)\\\\\n\\vdots\\\\\nv(x_N)\n\\end{pmatrix}$$\n\nТогда, как мы знаем,\n\n$$\\left[D_{x_0} f\\right] (h) = \\langle\\nabla_{x_0} f, h\\rangle = \\left[\\nabla_{x_0} f\\right]^T h.\n$$\n\nСледовательно,\n\n$$\\begin{aligned}\\left[D_{v(x_{0})}u\\right]([D_{x_{0}}v](h))&=\\left[\\nabla_{v(x_{0})}u\\right]^{T}\\left(v^{\\prime}(x_{0})\\odot h\\right)=\\\\&=\\sum_{i}\\left[\\nabla_{v(x_{0})}u\\right]_{i}v^{\\prime}(x_{0i})h_{i}=\\langle\\left[\\nabla_{v(x_{0})}u\\right]\\odot v^{\\prime}(x_{0}),h\\rangle.\\end{aligned}\n$$\n\nгде $\\odot$ означает поэлементное перемножение. Окончательно получаем\n\n$$\\color{#348FEA}{\\nabla_{x_0} f = \\left[\\nabla_{v(x_0)}u\\right] \\odot v'(x_0) = v'(x_0) \\odot \\left[\\nabla_{v(x_0)} u\\right]}\n$$\n\nОтметим, что если $x$ и $h(x)$ — это просто векторы, то мы могли бы вычислять всё и по формуле $\\frac{\\partial f}{\\partial x_i} = \\sum_j\\big(\\frac{\\partial z_j}{\\partial x_i}\\big)\\cdot\\big(\\frac{\\partial h}{\\partial z_j}\\big)$.\n\nВ этом случае матрица $\\big(\\frac{\\partial z_j}{\\partial x_i}\\big)$ была бы диагональной (так как $z_j$ зависит только от $x_j$: ведь $h$ берётся поэлементно), и матричное умножение приводило бы к тому же результату. Однако если $x$ и $h(x)$ — матрицы, то $\\big(\\frac{\\partial z_j}{\\partial x_i}\\big)$ представлялась бы уже «четырёхмерным кубиком», и работать с ним было бы ужасно неудобно.\n\n### Пример №2\n\n$f(X) = g(XW)$, где $X$ и $W$ — матрицы. Как мы знаем,\n\n$$\\left[D_{X_0} f \\right] (X-X_0) = \\text{tr}\\, \\left(\\left[\\nabla_{X_0} f\\right]^T (X-X_0)\\right).\n$$\n\nТогда\n\n$$\\begin{gathered}\n[D_{X_{0}W}g]\\left([D_{X_{0}}\\left(*W\\right)](H)\\right)=[D_{X_{0}W}g]\\left(HW\\right)= \\\\\n=\\mathrm{tr} \\left(\\left[\\nabla_{X_{0}W}g\\right]^{T}\\cdot(H)W\\right)= \\\\\n=\\mathrm{tr} \\left(W[\\nabla_{X_{0}W}(g)]^{T}\\cdot(H)\\right)=\\mathrm{tr} \\left(\\left[[\\nabla_{X_{0}W}g]W^{T}\\right]^{T}(H)\\right) \n\\end{gathered}\n$$\n\nЗдесь через $\\ast W$ мы обозначили отображение $Y \\hookrightarrow  YW$, а в предпоследнем переходе использовалось следующее свойство следа:\n\n$$\t\\text{tr} \\, (A B C) = \\text{tr} \\, (C A B),\n$$\n\nгде $A, B, C$ — произвольные матрицы подходящих размеров (то есть допускающие перемножение в обоих приведённых порядках). Следовательно, получаем\n\n$$\\color{#348FEA}{\\nabla_{X_0} f = \\left[\\nabla_{X_0W} (g) \\right] \\cdot W^T}\n$$\n\n### Пример №3\n\n$f(W) = g(XW)$, где $W$ и $X$ — матрицы. Для приращения $H = W - W_0$ имеем\n\n$$\\left[D_{W_0} f \\right] (H) = \\text{tr} \\, \\left( \\left[\\nabla_{W_0} f \\right]^T (H)\\right)\n$$\n\nТогда\n\n$$\\left[D_{XW_0} g \\right] \\left( \\left[D_{W_0} \\left(X \\ast\\right) \\right] (H)\\right) = \\left[D_{XW_0} g \\right] \\left( XH \\right) = \\\\\n= \\text{tr} \\, \\left( \\left[\\nabla_{XW_0} g \\right]^T \\cdot X (H)\\right) =\n\t\\text{tr}\\, \\left(\\left[X^T \\left[\\nabla_{XW_0} g \\right] \\right]^T (H)\\right)\n$$\n\nЗдесь через $X \\ast$ обозначено отображение $Y \\hookrightarrow XY$. Значит,\n\n$$\\color{#348FEA}{\\nabla_{X_0} f = X^T \\cdot \\left[\\nabla_{XW_0} (g)\\right]}\n$$\n\n### Пример №4\n\n$f(X) = g(softmax(X))$, где $X$ — матрица $N\\times K$, а $softmax$ — функция, которая вычисляется построчно, причём для каждой строки $x$:\n\n$$softmax(x) = \\left(\\frac{e^{x_1}}{\\sum_te^{x_t}},\\ldots,\\frac{e^{x_K}}{\\sum_te^{x_t}}\\right)\n$$\n\nВ этом примере нам будет удобно воспользоваться формализмом с частными производными. Сначала вычислим $\\frac{\\partial s_l}{\\partial x_j}$ для одной строки $x$, где через $s_l$ мы для краткости обозначим $softmax(x)_l = \\frac{e^{x_l}}\t{\\sum_te^{x_t}}$. Нетрудно проверить, что\n\n$$\\frac{\\partial s_l}{\\partial x_j} = \\begin{cases}\ns_j(1 - s_j),\\ & j = l,\\\\\n-s_ls_j,\\ & j\\ne l\n\\end{cases}$$\n\nТак как softmax вычисляется независимо от каждой строчки, то\n\n$$\\frac{\\partial s_{rl}}{\\partial x_{ij}} = \\begin{cases}\ns_{ij}(1 - s_{ij}),\\ & r=i, j = l,\\\\\n-s_{il}s_{ij},\\ & r = i, j\\ne l,\\\\\n0,\\ & r\\ne i\n\\end{cases},$$\n\nгде через $s_{rl}$ мы обозначили для краткости $softmax(X)_{rl}$.\n\nТеперь пусть $\\nabla_{rl} = \\nabla g = \\frac{\\partial\\mathcal{L}}{\\partial s_{rl}}$ (пришедший со следующего слоя, уже известный градиент). Тогда\n\n$$\\frac{\\partial\\mathcal{L}}{\\partial x_{ij}} = \\sum_{r,l}\\frac{\\partial s_{rl}}{\\partial x_{ij}} \\nabla_{rl}\n$$\n\nТак как $\\frac{\\partial s_{rl}}{\\partial x_{ij}} = 0$ при $r\\ne i$, мы можем убрать суммирование по $r$:\n\n$$\\ldots = \\sum_{l}\\frac{\\partial s_{il}}{\\partial x_{ij}} \\nabla_{il} = -s_{i1}s_{ij}\\nabla_{i1} - \\ldots + s_{ij}(1 - s_{ij})\\nabla_{ij}-\\ldots - s_{iK}s_{ij}\\nabla_{iK} =\n$$\n\n$$= -s_{ij}\\sum_t s_{it}\\nabla_{it} + s_{ij}\\nabla_{ij}\n$$\n\nТаким образом, если мы хотим продифференцировать $f$ в какой-то конкретной точке $X_0$, то, смешивая математические обозначения с нотацией Python, мы можем записать:\n\n$$\\begin{aligned}&\\nabla_{X_0}f=\\\\&=-softmax(X_0)\\odot\\mathrm{sum~}(softmax(X_0)\\odot\\nabla_{softmax(X_0)}g,\\mathrm{~axis}=1)+\\\\&softmax(X_0)\\odot\\nabla_{softmax(X_0)}g\\end{aligned}\n$$\n\n## Backward propagation в общем виде\n\nПодытожим предыдущее обсуждение, описав алгоритм **error backward propagation** (**алгоритм обратного распространения ошибки**). Допустим, у нас есть текущие значения весов $W^i_0$ и мы хотим совершить шаг SGD по мини-батчу $X$. Мы должны сделать следующее:\n\n1. Совершить forward propagation, вычислив и запомнив все промежуточные представления $X = X^0, X^1, \\ldots, X^m = \\widehat{y}$.\n2. Вычислить все градиенты с помощью backward propagation.\n3. С помощью полученных градиентов совершить шаг SGD.\n\nПроиллюстрируем алгоритм на примере двухслойной нейронной сети со скалярным output. Для простоты опустим свободные члены в линейных слоях.\n\n![17](https://yastatic.net/s3/education-portal/media/17_3_51099c217b_9aa1983711.webp)\nОбучаемые параметры – матрицы $U$ и $W$. Как найти градиенты по ним в точке $U_0, W_0$?\n\n$$\\nabla_{W_0}\\mathcal{L} = \\nabla_{W_0}{\\left({\\vphantom{\\frac12}\\mathcal{L}\\circ h\\circ\\left[W\\mapsto g(XU_0)W\\right]}\\right)}=\n$$\n\n$$=g(XU_0)^T\\nabla_{g(XU_0)W_0}(\\mathcal{L}\\circ h) = \\underbrace{g(XU_0)^T}_{k\\times N}\\cdot\n\\left[\\vphantom{\\frac12}\\underbrace{h'\\left(\\vphantom{\\int_0^1}g(XU_0)W_0\\right)}_{N\\times 1}\\odot\n\\underbrace{\\nabla_{h\\left(\\vphantom{\\int_0^1}g(XU_0)W_0\\right)}\\mathcal{L}}_{N\\times 1}\\right]$$\n\nИтого матрица $k\\times 1$, как и $W_0$\n\n$$\\nabla_{U_0}\\mathcal{L} = \\nabla_{U_0}\\left(\\vphantom{\\frac12}\n\\mathcal{L}\\circ h\\circ\\left[Y\\mapsto YW_0\\right]\\circ g\\circ\\left[ U\\mapsto XU\\right]\n\\right)=$$\n\n$$=X^T\\cdot\\nabla_{XU^0}\\left(\\vphantom{\\frac12}\\mathcal{L}\\circ h\\circ [Y\\mapsto YW_0]\\circ g\\right) =\n$$\n\n$$=X^T\\cdot\\left(\\vphantom{\\frac12}g'(XU_0)\\odot\n\\nabla_{g(XU_0)}\\left[\\vphantom{\\in_0^1}\\mathcal{L}\\circ h\\circ[Y\\mapsto YW_0\\right]\n\\right)$$\n\n$$=\\ldots = \\underset{D\\times N}{X^T}\\cdot\\left(\\vphantom{\\frac12}\n\\underbrace{g'(XU_0)}_{N\\times K}\\odot\n\\underbrace{\\left[\\vphantom{\\int_0^1}\\left(\n\\underbrace{h'\\left(\\vphantom{\\int_0^1}g(XU_0)W_0\\right)}_{N\\times1}\\odot\\underbrace{\\nabla_{h(\\vphantom{\\int_0^1}g\\left(XU_0\\right)W_0)}\\mathcal{L}}_{N\\times 1}\n\\right)\\cdot \\underbrace{W^T}_{1\\times K}\\right]}_{N\\times K}\n\\right)$$\n\nИтого $D\\times K$, как и $U_0$\n\nСхематически это можно представить следующим образом:\n\n![17](https://yastatic.net/s3/education-portal/media/17_4_b1b2356957_f57438f722.gif)\n\n### Backward propagation для двухслойной нейронной сети\n\nЕсли вы не уследили за вычислениями в предыдущем примере, давайте более подробно разберём его чуть более конкретную версию (для $g = h = \\sigma$)\n\nРассмотрим двуслойную нейронную сеть для классификации. Мы уже встречали её ранее при рассмотрении линейно неразделимой выборки. Предсказания получаются следующим образом:\n\n$$\\widehat{y} = \\sigma(X^1 W^2) = \\sigma\\Big(\\big(\\sigma(X^0 W^1 )\\big) W^2 \\Big).\n$$\n\nПусть $W^1_0$ и $W^2_0$ — текущее приближение матриц весов. Мы хотим совершить шаг по градиенту функции потерь, и для этого мы должны вычислить её градиенты по $W^1$ и $W^2$ в точке $(W^1_0, W^2_0)$.\n\nПрежде всего мы совершаем forward propagation, в ходе которого мы должны запомнить все промежуточные представления: $X^1 = X^0 W^1_0$, $X^2 = \\sigma(X^0 W^1_0)$, $X^3 = \\sigma(X^0 W^1_0) W^2_0$, $X^4 = \\sigma(\\sigma(X^0 W^1_0) W^2_0) = \\widehat{y}$. Они понадобятся нам дальше.\n\nДля полученных предсказаний вычисляется значение функции потерь:\n\n$$l = \\mathcal{L}(y, \\widehat{y}) = y \\log(\\widehat{y}) + (1-y) \\log(1-\\widehat{y}).\n$$\n\nДальше мы шаг за шагом будем находить производные по переменным из всё более глубоких слоёв.\n\n1. Градиент $\\mathcal{L}$ по предсказаниям имеет вид\n\n   $$    \\nabla_{\\widehat{y}}l = \\frac{y}{\\widehat{y}} - \\frac{1 - y}{1 - \\widehat{y}} = \\frac{y - \\widehat{y}}{\\widehat{y} (1 - \\widehat{y})},\n   $$\n   \n   где, напомним, $\\widehat{y} = \\sigma(X^3) = \\sigma\\Big(\\big(\\sigma(X^0 W^1_0 )\\big) W^2_0 \\Big)$ (обратите внимание на то, что $W^1_0$ и $W^2_0$ тут именно те, из которых мы делаем градиентный шаг).\n\n2. Следующий слой — поэлементное взятие $\\sigma$. Как мы помним, при переходе через него градиент поэлементно умножается на производную $\\sigma$, в которую подставлено предыдущее промежуточное представление:\n\n   $$    \\nabla_{X^3}l = \\sigma'(X^3)\\odot\\nabla_{\\widehat{y}}l = \\sigma(X^3)\\left( 1 - \\sigma(X^3) \\right) \\odot \\frac{y - \\widehat{y}}{\\widehat{y} (1 - \\widehat{y})} = \n   $$\n   \n   $$    = \\sigma(X^3)\\left( 1 - \\sigma(X^3) \\right) \\odot \\frac{y - \\sigma(X^3)}{\\sigma(X^3) (1 - \\sigma(X^3))} = \n   $$\n   \n   $$$$\n   \n   $$    \\color{blue}{\\nabla_{W^2_0}l} = (X^2)^T\\cdot \\nabla_{X^3}l = (X^2)^T\\cdot(y - \\sigma(X^3)) = \n   $$\n   \n   $$    = \\color{blue}{\\left( \\sigma(X^0W^1_0) \\right)^T \\cdot (y - \\sigma(\\sigma(X^0W^1_0)W^2_0))}\n   $$\n   \n   Аналогичным образом\n\n   $$    \\nabla_{X^2}l = \\nabla_{X^3}l\\cdot (W^2_0)^T = (y - \\sigma(X^3))\\cdot (W^2_0)^T = \n   $$\n   \n   $$    = (y - \\sigma(X^2W_0^2))\\cdot (W^2_0)^T\n   $$\n   \n   \n\n3. Следующий слой — снова взятие $\\sigma$.\n\n   $$    \\nabla_{X^1}l = \\sigma'(X^1)\\odot\\nabla_{X^2}l = \\sigma(X^1)\\left( 1 - \\sigma(X^1) \\right) \\odot \\left( (y - \\sigma(X^2W_0^2))\\cdot (W^2_0)^T \\right) = \n   $$\n   \n   $$    = \\sigma(X^1)\\left( 1 - \\sigma(X^1) \\right) \\odot\\left(  (y - \\sigma(\\sigma(X^1)W_0^2))\\cdot (W^2_0)^T \\right)\n   $$\n   \n   \n\n4. Наконец, последний слой — это умножение $X^0$ на $W^1_0$. Тут мы дифференцируем только по $W^1$:\n\n   $$    \\color{blue}{\\nabla_{W^1_0}l} = (X^0)^T\\cdot \\nabla_{X^1}l = (X^0)^T\\cdot \\big( \\sigma(X^1) \\left( 1 - \\sigma(X^1) \\right) \\odot (y - \\sigma(\\sigma(X^1)W_0^2))\\cdot (W^2_0)^T\\big) =\n   $$\n   \n   $$    = \\color{blue}{(X^0)^T\\cdot\\big(\\sigma(X^0W^1_0)\\left( 1 - \\sigma(X^0W^1_0) \\right) \\odot (y - \\sigma(\\sigma(X^0W^1_0)W_0^2))\\cdot (W^2_0)^T\\big) }\n   $$\n   \n   \n\nИтоговые формулы для градиентов получились страшноватыми, но они были получены друг из друга итеративно с помощью очень простых операций: матричного и поэлементного умножения, в которые порой подставлялись значения заранее вычисленных промежуточных представлений.\n\n## Автоматизация и autograd\n\nИтак, чтобы нейросеть обучалась, достаточно для любого слоя $f^k: X^{k-1}\\mapsto X^k$ с параметрами $W^k$ уметь:\n\n* превращать $\\nabla_{X^k_0}\\mathcal{L}$ в $\\nabla_{X^{k-1}_0}\\mathcal{L}$ (градиент по выходу в градиент по входу);\n* считать градиент по его параметрам $\\nabla_{W^k_0}\\mathcal{L}$.\n\nПри этом слою совершенно не надо знать, что происходит вокруг. То есть слой действительно может быть запрограммирован как отдельная сущность, умеющая внутри себя делать forward propagation и backward propagation, после чего слои механически, как кубики в конструкторе, собираются в большую сеть, которая сможет работать как одно целое.\n\nБолее того, во многих случаях авторы библиотек для глубинного обучения уже о вас позаботились и создали средства для **автоматического дифференцирования выражений** (**autograd**). Поэтому, программируя нейросеть, вы почти всегда можете думать только о forward-проходе, прямом преобразовании данных, предоставив библиотеке дифференцировать всё самостоятельно.\n\nЭто делает код нейросетей весьма понятным и выразительным (да, в реальности он тоже бывает большим и страшным, но сравните на досуге код какой-нибудь разухабистой нейросети и код градиентного бустинга на решающих деревьях и почувствуйте разницу).\n\n## Но это лишь начало\n\nМетод обратного распространения ошибки позволяет удобно посчитать градиенты, но дальше с ними что-то надо делать, и старый добрый SGD едва ли справится с обучением современной сетки. Так что же делать? О некоторых приёмах мы расскажем в следующем параграфе.",
        "handbook": "Учебник по машинному обучению",
        "title": "Метод обратного распространения ошибки",
        "description": "Как эффективно посчитать градиенты по весам нейронной сети"
    },
    {
        "path": "/handbook/ml/article/tonkosti-obucheniya",
        "content": "Если открыть случайную научную статью по глубинному обучению и попробовать воспроизвести её результаты, можно запросто потерпеть крах, и даже код на github, если он есть, может не помочь.  \n\nА дело в том, что обучение сложной модели — это сложная инженерная задача, в которой успеху сопутствует огромное число разных хаков, и изменение какого-нибудь безобидного параметра может очень сильно повлиять на результат.  \n\nВ этом параграфе мы познакомим вас с некоторыми из таких приёмов.\n\n## Инициализируем правильно\n\nКак вы уже успели заметить, нейронные сети — достаточно сложные модели, чувствительные к изменениям архитектуры, гиперпараметров, распределения данных и другим вещам.  \n\nПоэтому значительную роль играет начальная инициализация весов вашей сети. Стоит отметить, что здесь речь идет именно о начальной инициализации параметров сети, вопрос дообучения (и использования предобученных сетей в качестве backbone) в данном параграфе рассматриваться не будет.\n\nНейронные сети включают в себя различные преобразования, и инициализация по-хорошему также должна зависеть от типа используемого преобразования. На практике вопрос часто остается без внимания, так как в большинстве современных фреймворков уже реализованы методы инициализации, зависящие от используемой функции активации и гиперпараметров слоя, и пользователь может не задумываться об этом. Но всё же важно понимать, какие соображения привели к появлению тех или иных стратегий инициализации.\n\nДавайте разберём несколько методов инициализации и обсудим их свойства.\n\n### Наивный подход №0: инициализация нулем/константой\n\nКазалось бы, инициализация параметров слоя нулями — это достаточно просто и лаконично. Но инициализация нулём (как и любой другой константой) ведёт к катастрофе! Вот пример того, что может получиться:\n\n![18_1_2b5d95c793.webp](https://yastatic.net/s3/education-portal/media/18_1_2b5d95c793_04c574719d.webp)\n\nСтоит, впрочем, отметить, что из-за численных ошибок значения параметров могут всё-таки сдвинуться с мёртвой точки, и тогда нейросеть что-нибудь выучит:\n\n![18_2_c83ea1ee87.webp](https://yastatic.net/s3/education-portal/media/18_2_c83ea1ee87_24cfa5267c.webp)\n\n{% cut \"Математическая иллюстрация того, почему плохо инициализировать нулями\" %}\n\nНам понадобится сеть с хотя бы двумя слоями (иначе ничего не получится).\n\nРассмотрим несколько последовательных скрытых представлений:\n\n* $X^1$;\n* $X^2 = X^1W$, где $W = 0$ — матрица весов, которую инициализировали нулями;\n* $X^3 = h(X^2)$, где $h$ — поэлементная нелинейность;\n* $X^4 = X^3U$, где $U = 0$ — ещё одна инициализированная нулями матрица весов.\n\nПроследим, что происходит во время forward pass.\n\n$$X^2 = X^1\\cdot W = 0$$\n\nПолучилась снова матрица с одинаковыми столбцами, и это сохраняется дальше:\n\n$$X^3 = h(0)$$\n\n$$X^4 = X^3U = 0$$\n\nТеперь рассмотрим обратный проход. Допустим, мы вычислили градиент $\\nabla_{X^4}\\mathcal{L}$. Тогда\n\n$$\\nabla_{U}\\mathcal{L} = (X^3)^T\\nabla_{X^4}\\mathcal{L} = 0,$$\n\nто есть матрица $U$ никак не обновится. Далее,\n\n$$\\nabla_{X^3}\\mathcal{L} = \\nabla_{X^4}\\mathcal{L}U^T = 0,$$\n\n$$\\nabla_{X^2}\\mathcal{L} = \\nabla_{X^3}\\mathcal{L}\\odot h'(X^2) = 0,$$\n\n$$\\nabla_W\\mathcal{L} = (X^1)^T\\nabla_{X^2}\\mathcal{L} = 0,$$\n\nто есть веса $W$ тоже не обновятся. Таким образом, обучение происходить не будет.\n\nА что же будет с однослойной нейросетью? Вспомним, что веса логистической регрессии (нейросети с одним-единственным, последним слоем) можно инициализировать чем угодно, в том числе нулями: функция потерь выпукла, поэтому градиентный спуск сходится из любой точки (по модулю численных эффектов). \n \n{% endcut %}\n\n\nЗдесь также стоит привести цитату из замечательной Deep Learning book (страница 301):  \n\n```\nPerhaps the only property known with complete certainty is that the initial parameters need to “break symmetry” between different units. If two hidden units with the same activation function are connected to the same inputs, then these units must have different initial parameters. If they have the same initial parameters, then a deterministic learning algorithm applied to a deterministic cost and model will constantly update both of these units in the same way.\n```\n\n###  Эвристический подход №1: инициализация случайными числами\n\nЕсли константная инициализация не подходит, можно инициализировать нейросеть случайными числами. Допустим, веса пришли из распределения с нулевым средним и дисперсией $\\sigma^2$, например, из нормального распределения $\\mathcal{N}(0, \\sigma^2)$.\n\nПусть теперь на вход линейному слою с весами $\\mathbf{w}$ размерности $n_{\\text{in}}$ пришел вектор $\\mathbf{x}$ аналогичной размерности. \n\n**Замечание**. Можем считать, что мы рассматриваем лишь одну компоненту следующего промежуточного представления $\\mathbf{z}$.\n\nВсе компоненты $\\mathbf{x}$ распределены одинаковым образом и обладают нулевым средним. Тогда дисперсия их [произведения](https://href.li/?http://en.wikipedia.org/wiki/Variance#Product_of_independent_variables) $y$ имеет вид:\n\n$$\\text{Var}(y) = \\text{Var}(\\mathbf{w}^T\\mathbf{x}) = \\sum_{i=1}^n [ \\mathbb{E}[x_i]^2 \\text{Var}(w_i) + \\mathbb{E}[w_i]^2 \\text{Var}(x_i) + \\text{Var}(w_i)\\text{Var}(x_i)]$$\n\nПервое и второе слагаемые равны нулю так как математические ожидание и весов, и значений $\\mathbf{x}$ равны нулю. \n\n**Замечание**. Стоит заметить, что это будет верно и для промежуточных слоев в случае использования симметричной относительно нуля функции активации, например, `tanh`. \n\nПоскольку все веса пришли из одного распределения, можно выразить дисперсию результата следующим образом:\n\n$$\\text{Var}(\\mathbf{w}^T\\mathbf{x}) = n_{\\text{in}} \\text{Var}(w)\\text{Var}(x),$$\n\nгде $\\text{Var}(x)$ — это дисперсия любой компоненты $\\mathbf{x}$ (как было оговорено ранее, они распределены одинаково), а $\\text{Var}(w) = \\sigma^2$ — дисперсия компоненты $\\mathbf{w}$.\n\nСледовательно, дисперсия результата линейно зависит от дисперсии входных данных с коэффициентом $n_{\\text{in}} \\text{Var}(w)$.\n\nУвеличение дисперсии промежуточных представлений с каждым новым преобразованием (слоем) может вызвать численные ошибки или насыщение функций активации (таких как `tanh` и `sigmoid`), что не лучшим образом скажется на обучении сети.\n\nСнижение дисперсии может привести к почти нулевым промежуточным представлениям (плюс «линейному» поведению `tanh` и `sigmoid` в непосредственной близости от нуля), что тоже негативно повлияет на результаты обучения.\n\nПоэтому для начальной инициализации весов имеет смысл использовать распределение, дисперсия которого позволила бы сохранить дисперсию результата. Например, $\\forall i, w_i \\sim \\mathbb{N}(0, \\frac{1}{n_{\\text{in}}}),$ или же в общем случае \n\n$$\n\\forall i, \\text{Var}(w_i) = \\frac{1}{n_\\text{in}}\n$$\n\nДанный подход часто упоминается как `calibrated random numbers initialization`.  \n\n###  Подход №2: Xavier & Normalized Xavier initialization\n\nЕсли обратиться к предыдущему подходу, можно обнаружить, что все выкладки верны как для «прямого» прохода (forward propagation), так и для обратного (backward propagation). Дисперсия градиента при этом меняется в $n_{\\text{out}} \\text{Var}(w)$ раз, где $n_{\\text{out}}$ — размерность следующего за $\\mathbf{x}$ промежуточного представления.\n\nИ если мы хотим, чтобы сохранялись дисперсии и промежуточных представлений, и градиентов, у нас возникают сразу два ограничения:\n\n$$\\forall i, \\text{Var}(w_i) = \\frac{1}{n_\\text{in}}$$\n\nи\n\n$$\\forall i, \\text{Var}(w_i) = \\frac{1}{n_\\text{out}}.$$\n\nЛегко заметить, что оба этих ограничения могут быть выполнены только в случае, когда размерность пространства не меняется при отображении, что случается далеко не всегда.\n\nВ [работе](https://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf) Understanding the difficulty of training deep feedforward neural networks за авторством Xavier Glorot и Yoshua Bengio в качестве компромисса предлагается использовать параметры из распределения с дисперсией\n\n$$\\forall i, \\text{Var}(w_i) = \\frac{2}{n_\\text{in} + n_\\text{out}}.$$\n\nПодробный вывод данного результата можно найти в оригинальной статье в формулах 2-12. \n\n**Обратите внимание**: эта инициализация хорошо подходит именно для `tanh`, так как в выводе явно учитывается симметричность функции активации относительно нуля.\n\nВ случае использования равномерного распределения $U$ для инициализации весов с учетом описанных выше ограничений мы получим **normalized Xavier initialization**:\n\n$$\n\\forall i, w_i \\sim U\\left[-\\frac{\\sqrt{6}}{\\sqrt{n_\\text{in} + n_\\text{out}}}, \\frac{\\sqrt{6}}{\\sqrt{n_\\text{in} + n_\\text{out}}}\\right].\n$$\n\n**Замечание**. Здесь используется тот факт, что дисперсия непрерывного равномерного распределения $\\text{Var}[U[a, b]] = \\frac{1}{12} (b-a)^2$.\n\nСравнение подобной инициализации для поведения промежуточных представлений (сверху) и градиентов (снизу) проиллюстрированы ниже (иллюстрации из [оригинальной статьи](https://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf)):\n![18_3_57a77dc9b8.webp](https://yastatic.net/s3/education-portal/media/18_3_57a77dc9b8_31a2c41180.webp)\n![18_4_d4389fdff2.webp](https://yastatic.net/s3/education-portal/media/18_4_d4389fdff2_638f7749c0.webp)\n\n\n###  Подход №3: Kaiming initialization\nВы могли обратить внимание, что Xavier initialization во многом опиралась на поведение функции активации `tanh`. Данный тип инициализации и впрямь лучше подходит для нее, но само использование гиперболического тангенса приводит к некоторым сложностям (например, к затуханию градиентов). \n\nВ 2015 году в [работе](https://arxiv.org/abs/1502.01852v1) Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification за авторством Kaiming He, Xiangyu Zhang, Shaoqing Ren и Jian Sun были рассмотрены особые свойства функции активации `ReLU`, в частности, существенно смещенная относительно нуля область значений.\n\nПусть представление на входе было получено после применения данной функции активации к предыдущему представлению $\\mathbf{z}_\\text{prev}$: \n\n$$\\mathbf{x} = \\text{ReLU}(\\mathbf{z}_\\text{prev}),$$\n\nгде  $\\mathbf{z}_\\text{prev}$, в свою очередь, — это выход предыдущего линейного слоя с нулевым средним для каждой компоненты весов, то есть, в частности, $\\mathbb{E}(z_\\text{prev}) = 0$ \n\nВ таком случае дисперсия выхода следующего линейного слоя примет вид:\n$$\\text{Var}(\\mathbf{w}^T\\mathbf{x}) = \\sum_{i=1}^n [ \\mathbb{E}[x_i]^2 \\text{Var}(w_i) + \\mathbb{E}[w_i]^2 \\text{Var}(x_i) + \\text{Var}(w_i)\\text{Var}(x_i)]=$$\n\n$$=\\big(\\mathbb{E}[x_i]^2 + \\mathbb{V}(x_i) \\big)\\mathbb{V}(w_i).$$\n\nВ данном случае первый член не может быть проигнорирован, так как `ReLU` имеет ассиметричную область значений, а значит, распределения $x_i$ будут смещёнными. \n\nС учетом того, что $\\text{Var}(x) = \\mathbb{E}[x_i^2] - \\mathbb{E}[x_i]^2$, выражение выше примет итоговый вид:\n\n$$\n\\text{Var}(\\mathbf{w}^T\\mathbf{x}) = \\text{Var}(\\mathbf{w}^T\\mathbf{x}) = n_\\text{in} \\text{Var}(w_i) \\mathbb{E}(x_i^2).\n$$\n\nС учётом поведения `ReLU` и того, что $\\mathbb{E}(z_\\text{prev}) = 0$, можно сказать, что \n\n$$\n\\mathbb{E}(x_i^2) = \\frac{1}{2}\\text{Var}(z_\\text{prev}),\n$$\n\nто есть\n\n$$\\text{Var}(\\mathbf{w}^T\\mathbf{x}) = \\frac{1}{2}n_\\text{in} \\text{Var}(w_i) \\text{Var}(z_\\text{prev}).\n$$\n\nПолучается, что использование `ReLU` приводит к необходимости инициализировать веса из распределения, чья дисперсия удовлетворяет следующему ограничению:\n\n$$\n\\forall i, \\frac{1}{2}n_\\text{in}\\text{Var}(w_i) = 1.\n$$\n\nНапример, подходит нормальное распределение $\\mathbb{N}(0, \\frac{2}{n_\\text{in}})$.\n\nДанный способ инициализации (и его сравнение с Xavier initialization) проиллюстрирован ниже:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/18_5_6c35dd096e_67edc2d034.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  <a href=\"https://arxiv.org/pdf/1502.01852v1.pdf\">Источник</a>\n  </figcaption>\n</figure>\n\n### Промежуточные выводы\nРассмотренные способы инициализации используют достаточно много предположений, но все-таки они работают и позволяют нейронным сетям в некоторых случаях значительно быстрее сходиться. \n\nПонимание принципов работы даже таких небольших механизмов – ключ к глубокому освоению области глубокого обучения :)\n\n## Методы оптимизации в нейронных сетях\n\nТак как мы договорились, что нейросети представляют собой параметризованные дифференцируемые функции и для каждого параметра мы можем посчитать градиент, то, так же как и линейные модели, их можно настраивать с помощью градиентных методов.  \n\nВ [параграфе](https://academy.yandex.ru/handbook/ml/article/linejnye-modeli) про линейные модели мы под этим подразумевали обычно стохастический градиентный спуск на батчах, и это совершенно подходящий способ и для нейросетей тоже. Но существует множество модификаций и эвристик, позволяющих ускорить его сходимость, познакомиться с которыми вы можете в специальном [параграфе](https://academy.yandex.ru/handbook/ml/article/optimizaciya-v-ml), посвящённом методам оптимизации.\n\n## Регуляризация нейронных сетей\n\nСмысл термина **регуляризация** (англ. *regularization*) гораздо шире привычного вам прибавления $L_1$- или $L_2$-нормы вектора весов к функции потерь. Фактически он объединяет большое количество техник для борьбы с переобучением и для получения более подходящего решения с точки зрения эксперта.  \n\nКаждая из них позволяет навязать модели определённые свойства, пусть даже и ценой некоторого снижения качества предсказания на обучающей выборке. Например, уже знакомая читателю $L_1$- или $L_2$-регуляризация в задаче линейной регрессии (регуляризация Тихонова) позволяет исключить наименее значимые признаки (для линейной модели) или же получить устойчивое (хоть и смещённое) решение в случае мультиколлинеарных признаков.\n\nВ нейронных сетях техники регуляризации можно разделить на три обширные группы: \n* связанные с изменением функции потерь;\n* связанные с изменением структуры сети;\n* связанные с изменением данных.\n\nРассмотрим каждую из них подробнее. \n\n### Регуляризация через функцию потерь\nИзменение функции потерь — классический способ получить решение, удовлетворяющее определённым условиям. В глубинном обучении часто используется техника Weight Decay, очень близкая к регуляризации Тихонова. Она представляет собой аналогичный штраф за высокие значения весов нейронной сети с коэффициентом регуляризации $\\lambda$:\n\n$$\nL_\\text{with regularization} = L_\\text{original} + \\lambda ||\\mathbf{W}||_2\n$$\n\nДанная техника регуляризации была совмещена с методом градиентной оптимизации Adam, в результате чего был получен метод AdamW (описанный в параграфе [параграфе](https://academy.yandex.ru/handbook/ml/article/optimizaciya-v-ml) про методы оптимизации).\n\nТакже достаточно часто в качестве регуляризационного члена встречается энтропия распределения, предсказанного нейронной сетью.  \n\nПредставьте, что вы рекомендуете пользователю товары по истории его взаимодействия с сервисом, семплируя товары для показа в соответствии с распределением предсказанной релевантности. Вам может быть важно, чтобы рекомендации не были фиксированными (менялись при обновлении страницы), ведь это повысит вероятность того, что пользователь найдёт что-то интересное, а вы узнаете о нём что-нибудь новое.  \n\nВ такой ситуации при обучении модели вы можете потребовать, чтобы распределение предсказаний не сходилось к вырожденному, и в качестве дополнительной штрафной функции может выступать энтропия этого распределения. Энтропия дифференцируема, как и сами предсказанные величины, и может быть использована в качестве регуляризационного члена. Для задачи классификации он будет выглядеть следующим образом:\n\n$$\n\\widehat{\\mathbf{p}} = f(x; \\mathbf{\\theta}),\n$$\n\n$$\nL_\\text{with regularization} = L_\\text{original} - \\lambda \\; \\sum_k \\widehat{p}_k \\log \\widehat{p}_k,\n$$\n\nгде $\\lambda$ — коэффициент регуляризации, $\\widehat{\\mathbf{p}}$ — предсказанные вероятности.  \n\nТем самым эксперт привносит своё знание непосредственно в процесс обучения модели в подходящей математической форме: «предсказания должны быть разнообразными» —> «распределение не должно быть вырожденным» —> «энтропия не должна быть слишком низкой».\n\n### Регуляризация через ограничение структуры модели\n\nВнесение подходящих преобразований в структуру сети также может быть хорошим способом добиться желаемых результатов. Огромное влияние на развитие нейронных сетей оказали техники [dropout (2014)](https://jmlr.org/papers/v15/srivastava14a.html) и [batch normalization (2015)](https://arxiv.org/abs/1502.03167), позволившие сделать нейронные сети более устойчивыми к переобучению и многократно ускорить их сходимость соответственно.\n\n**Dropout**\n\nОбратимся к простым полносвязным (FC/Dense) сетям из нескольких слоёв. Каждый из слоёв порождает новое признаковое описание $x^{k}$ объекта $x^{\\text{in}}$, который пришёл на вход:\n\n$$\nx^{k} = f_k(x^{k-1}).\n$$\n\nНо как можно гарантировать, что модель будет эффективно использовать все доступные параметры, а не переобучится под использование лишь небольшого их подмножества, поделив для себя внутреннее представление на сигнал и шум?\n\n$$\nx^{k}_\\text{overfitted} = [\\text{signal}, \\text{noise}]\n$$\n\nДля этого можно было бы случайным образом «выключать» доступ к некоторым координатам внутренних представлений на этапе обучения. Тогда при выключении «полезных» координат произойдёт резкое изменение предсказаний модели, что приведёт к увеличению ошибки, а полученные градиенты этой ошибки укажут, как её исправить с использованием (и изменением) других координат. Сравнение тока информации по исходной модели и по модели с «выключенными» координатами внутренних представлений можно проиллюстрировать с помощью классической картинки:\n\n![18_6_854b5a5ed2.webp](https://yastatic.net/s3/education-portal/media/18_6_854b5a5ed2_4463fadefa.webp)\n\n**Обратите внимание**: «выключать» можно как оригинальные признаки, так и признаки, возникающие на любом другом уровне представления объектов. С точки зрения $(k+1)$-го слоя нейронной сети данные приходят откуда-то извне: при $k = 0$ — из реального мира, а при $k > 1$ — с предыдущих слоёв.\n\nТехнически это осуществляется следующим образом: некоторые координаты внутреннего представления домножаются на ноль. То есть добавляется ещё одно преобразование, которое представляет собой домножение выхода предыдущего слоя на маску из нулей и единиц.\n\n$$\nx^{k+1} = \\frac1{1-p} x^{k} \\odot \\text{mask},\n$$\n\n$$\n\\text{mask}_{i} \\sim \\text{Bernoulli}(1 - p).\n$$\n\nгде $(1-p)$ (вероятность обнуления координаты) — это гиперпараметр слоя. Отметим, что во многих фреймворках для глубинного обучения в качестве параметра слоя указывается именно вероятность обнуления, а не выживания. Данная маска участвует и при подсчёте градиентов:\n\n$$\n\\nabla_{x^{k}}{\\mathcal{L}} = \\frac1{1-p}\\nabla_{x^{k+1}}{\\mathcal{L}} \\odot \\text{mask}\n$$\n\nКак правило, маска генерируется независимо на каждом шаге градиентного спуска. Важно отметить, что на этапе предсказания dropout ничего не меняет, то есть $x^{k+1} = x^k$.\n\nМножитель $\\frac1{1-p}$ нужен для того, чтобы распределение $x^{k+1}$ на этапе предсказания совпадало с распределением на этапе обучения. В самом деле, если даже математическое ожидание $x^k$ было равно нулю, выборочная дисперсия $x^k\\odot\\text{mask}$ ниже, чем у $x^k$: ведь часть значений обнулилась.\n\nНа этапе предсказания dropout «выключается»: внутренние представления используются как есть, без умножения на маску. А чтобы слой знал, обучается он сейчас или предсказывает, в нейросетевых библиотеках в классе слоя обычно реализовано переключение между этими режимами (например, булев флаг `training` в pytorch-модулях).\n\n{% cut \"Примечание\" %}\n\nПолезно провести аналогию с другим алгоритмом, использующим техники ансамблирования и метод случайных подпространств: речь о случайном лесе (Random Forest). При обучении сети на каждом шаге обучается лишь некоторая подсеть (некоторый подграф вычислений из исходного графа). При переходе в режим inference (то есть применения к реальным данным с целью получения результата, а не обучения) активируются сразу все подсети, и их результаты усредняются. Таким образом, сеть с dropout можно рассматривать как ансамбль из экспоненциально большого числа сетей меньшего размера (подробнее можно прочитать [здесь](https://arxiv.org/abs/1706.06859)). Это приводит к получению более устойчивой оценки значений целевой переменной.\n\nВ этом свойстве кроется и главное коварство dropout (как и большинства других техник регуляризации): благодаря получению более устойчивой оценки целевой переменной путём усреднения множества подсетей, эффективная обобщающая способность итоговой сети снижается! В самом деле, пусть при обучении каждый раз модели была доступна лишь половина параметров. В таком случае итоговая модель представляет собой усреднение множества более слабых моделей, в которых вдвое меньше параметров. Её предсказания будут более устойчивы к шуму, но при этом она неспособна выучить столь сложные зависимости, как сеть аналогичной структуры, но без dropout. То есть за более устойчивые предсказания (и получение менее переобученной модели) приходится расплачиваться и меньшей обобщающей способностью.\n\n{% endcut %}\n\nСтоит отметить, что dropout может применяться и к входным данным (то есть слой dropout может стоять первым в сети), и это может приводить к получению более качественных результатов. Например, если в данных множество мультикоррелирующих признаков или присутствует шум, наличие dropout позволит избежать обусловливания модели на лишь их подмножество и позволит учитывать их все. Так, подобный подход может быть использован, если данные представляют собой сильно разреженные векторы высокой размерности (скажем, сведения об интересе пользователя к тем или иным товарам).\n\n**Batch normalization**\n\nПоявление техники batch normalization привело к значительному ускорению обучения нейронных сетей. В данном параграфе мы рассмотрим лишь основные принципы работы batch normalization.  \n\nДискуссия о свойствах и причинах эффективности batch normalization всё ещё ведётся, рекомендуем обратить внимание на [статью](https://arxiv.org/abs/1805.11604) с NeurIPS 2018. Нам, впрочем, кажется, что, несмотря на активную критику в его адрес, полезно знать и предложенное авторами подхода объяснение необходимости batch normalization.\n\n{% cut \"Предложенная авторами мотивация\" %}\n\nОбратимся к механизму обратного распространения ошибки. Пусть мы находимся на этапе обновления параметров $W^{k}$ некоторого $k$-го слоя:\n\n$$\nx^k = f(x^{k-1}, W^{k}),\n$$\n\nгде $f$ — некоторая функция, которая вычисляется на данном слое. В общем случае $W^{k}$ и $x^{k-1}$ не обязательно взаимодействуют линейным образом; функция $f$ может быть и нелинейной. В ходе error backward propagation мы вычисляем градиент:\n\n$$\n\\nabla_{W^{k}}\\mathcal{L} = g(x^{k-1}, x^k, x^{k+1},\\ldots;W^k),\n$$\n\nгде $g$ — некоторая функция, в которой будут участвовать представления со слоёв, начиная с $(k-1)$-го (вычисленные в ходе forward pass и запомненные).  \n\nНовое значение параметров примет вид:\n\n$$\nW^k_{\\text{new}} = W^{k} - \\alpha \\nabla_{W^{k}} \\mathcal{L} = W^{k} - \\alpha g(x^{k-1},x^k,\\ldots)\n$$\n\nПосле обновления параметров $W^{k}$ мы перейдём к обновлению параметров предыдущего слоя $W^{k-1}$ и обновим их аналогичным образом.\n\n**Важно**. Это приведёт к изменению представления, которое пришло на вход $k$-му слою, которое мы не учитываем:\n\n$$\nx^k_{\\text{new}} = f(x^{k-1}, W^{k}_{\\text{new}}) = f(x^{k-1}, W^{k} + \\phi),\n$$\n\nгде $\\phi$ — разница между предыдущими и новыми параметрами $W^{k}$.\n\nТо есть параметры $(k-1)$-го слоя будут обновлены исходя из предположения, что данные приходят из некоторого распределения на $x^k$, которое параметризовалось $W^{k-1}$, но теперь параметры изменились и данные могут __обладать иными свойствами__. Например, может существенно измениться среднее или дисперсия, что может привести, например, к попаданию на «хвосты» функции активации и затуханию градиента.\n\nДо появления batch normalization с этой проблемой боролись достаточно просто: использовали небольшие значения шага обучения (learning rate) $\\alpha$. Благодаря этому изменения были не слишком большими и можно было предположить, что и распределение внутренних представлений поменялось незначительно.\n\n{% endcut %}\n\nИспользование batch normalization гарантирует, что каждая компонента представления на выходе будет иметь контролируемое среднее и дисперсию. Достигается это следующим образом:\n\n1. Сперва идёт собственно слой *batch normalization*, на котором текущий батч приводится к нулевому среднему и единичной дисперсии:\n\n  $$X^{k+1} = \\frac{X^k - \\mu}{\\sqrt{\\sigma}^2 + \\varepsilon},$$\n\n  где $\\mu$ и $\\sigma^2$ — среднее и дисперсия признаков по обрабатываемому батчу, а $\\varepsilon$ — гиперпараметр слоя, небольшое положительное число, добавляемое для улучшения численной устойчивости. Отметим, что $\\mu$ и $\\sigma$, будучи функциями от $X^k$, тоже участвуют в вычислении градиентов. В ходе **предсказания** (или, как ещё говорят, **инференса**, от английского **inference**) используются фиксированные значения $\\mu_{\\ast}$ и $\\sigma_{\\ast}^2$, которые были получены в ходе обучения как скользящее среднее всех $\\mu$ и $\\sigma^2$. Более точно: на каждой итерации forward pass мы вычисляем\n\n  $$\n   \\mu_{\\ast} = \\mu_{\\ast} \\lambda + \\mu (1 - \\lambda)\n  $$\n\n  $$\n  \\sigma^2_{\\ast} = \\sigma^2_{\\ast} \\lambda + \\sigma^2 (1 - \\lambda),\n  $$\n\n  где $\\lambda$ также является гиперпараметром слоя.\n\n2. Далее идёт слой *channelwise scaling*, который позволяет выучить оптимальное шкалирование для всех признаков $X^{k+2}$:\n\n  $$X^{k+2} = \\beta X^{k+1} + \\gamma,$$\n\n  где $\\beta$ и $\\gamma$ — обучаемые параметры, позволяющие настраивать в ходе обучения оптимальные значения матожидания и дисперсии выходного слоя $X^{k+2}$.\n\nНиже приведён алгоритм из оригинальноq [статьи](https://arxiv.org/abs/1502.03167)  2015 года за авторством Сергея Иоффе и Кристиана Сегеди:\n\n![18_7_f3355fcfaf.webp](https://yastatic.net/s3/education-portal/media/18_7_f3355fcfaf_fd4a8794e1.webp)\n\nПричина популярности batch normalization заключается в значительном ускорении обучения нейронных сетей и в улучшении их сходимости в целом. Рассмотрим график из оригинальной статьи:\n\n![18_8_8bc635c7bc.webp](https://yastatic.net/s3/education-portal/media/18_8_8bc635c7bc_b21340d08e.webp)\n\nКак видно на иллюстрации выше, использование batch normalization позволило ускорить обучение в несколько раз и даже добиться лучших результатов, чем SotA-подход 2014 года Inception (структура которого была приведена на одной из иллюстраций в начале этого параграфа).\n\nЗначительное ускорение достигается в том числе благодаря использованию более высокого learning rate: благодаря нормировке связь между слоями не нарушается столь сильно.\n\nСтоит заметить, что причины столь эффективной работы batch normalization до сих пор являются поводом для дискуссий и строгого теоретического объяснения эффекта от batch normalization ещё нет. Несмотря на это, он перевернул область глубинного обучения и вошёл в стандартный инструментарий при обучении нейронных сетей.\n\n**Примечание**: стоит заметить, что в настоящее время существуют и другие способы нормировать промежуточные представления: instance normalization, layer normalization и так далее.\n\nВ завершение рекомендуем ознакомиться со [статьёй](https://kratzert.github.io/2016/02/12/understanding-the-gradient-flow-through-the-batch-normalization-layer.html)  о работе метода обратного распространения ошибки в слое batch normalization.\n\n### Регуляризация через изменение данных\n\nВнесение изменений в данные (аугментация данных) также является популярной техникой регуляризации. Рассмотрим её на примере.  \n\nПусть перед нами фотография самолёта. Добавим мелкодисперсный шум к изображению. Мы всё ещё сможем увидеть на фотографии самолёт, но, с точки зрения модели машинного обучения (в данном случае — нейронной сети), полученное изображение является новым объектом!  \n\nПовернём изображение самолёта на 10 градусов по часовой стрелке. В нашем распоряжении ещё одно изображение с известной целевой меткой (например, меткой класса «самолёт»), в котором присутствует поворот. Таким образом, внесение новых данных позволяет дать модели понять, какие преобразования над данными являются допустимыми, и она уже будет более устойчивой к наличию небольшого шума в данных или к поворотам (к которым чувствительна операция свёртки).  \n\nВдобавок аугментации позволяют значительно увеличить объём обучающей выборки. Особую популярность аугментации приобрели в области компьютерного зрения. В качестве примера приведём отличную [библиотеку](https://github.com/albumentations-team/albumentations), позволяющую производить аугментацию изображений.\n\nСтоит обратить внимание, что используемые аугментации должны быть адекватны решаемой задаче. Инвертирование цветов на фотографии, внесение значительного количества шумов или переворот изображения могут привести и к негативным результатам (по сути, просто сделают выборку более зашумлённой или даже заставят сеть учиться на данных, которые она никогда не встретит в реальности), так как обобщающая способность сети ограниченна. Можно сказать, что аугментированные данные должны принадлежать к той же генеральной совокупности, что и оригинальный датасет.\n\nИтак, эксперт может привнести своё понимание задачи и на уровне аугментации данных: если данное преобразование является допустимым (то есть преобразованный объект мог бы попасть в обучающую выборку и самостоятельно — как фотография с другого устройства или запись речи другого человека с опечаткой), то модель должна быть устойчива к данным с подобными преобразованиями.",
        "handbook": "Учебник по машинному обучению",
        "title": "Тонкости обучения",
        "description": "Инициализация весов. Регуляризация нейросетей. Dropout и Batchnorm"
    },
    {
        "path": "/handbook/ml/article/svyortochnye-nejroseti",
        "content": "В этом параграфе мы на примере задачи распознавания изображений познакомимся со свёрточными нейронными сетями, уже ставшими стандартом в области. Для начала мы разберёмся, с какого рода данными придётся работать, затем попробуем решить задачу «в лоб» при помощи знакомых вам полносвязных сетей и поймём, чем это чревато. А после чего рассмотрим свёртки и попробуем выработать нужную интуицию.\n\n## Формат данных\n\nКартинки в большинстве случаев представляют собой упорядоченный набор пикселей, где каждый пиксель — это вектор из трех «каналов»: интенсивность красного, интенсивность зелёного, интенсивность синего.\n\n![2_rgb_rooster_1_9610445be0.svg](https://yastatic.net/s3/education-portal/media/2_rgb_rooster_1_9610445be0_11cb0f9215.svg)\n\nКаждая интенсивность характеризуется числом от 0 до 1, но для привычных нам изображений этот интервал равномерно дискретизирован для экономии памяти, чтобы уместиться в 8 бит (от 0 до 255). При этом нулевая интенсивность (0, 0, 0), соответствует чёрному цвету, а максимальная интенсивность (255, 255, 255) — белому.\n\nКогда мы наблюдаем изображение на мониторе компьютера, мы видим эти пиксели «уложенными» в строки одинаковой длины (человек не сможет воспринять картинку, вытянутую в один вектор). Длину каждой такой строки называют шириной `W` картинки, а количество строк — высотой `H`. Резюмирую, мы можем рассматривать картинку, как тензор `HxWx3`, состоящий из чисел uint8.\n\n![1_rgb_split_rooster_1_72ea43ba3f.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_1_72ea43ba3f_b7355dedf3.svg)\n\nСуществует множество разных форматов хранения картинок: вместо трех интенсивностей мы можем использовать триплет «оттенок, насыщенность, интенсивность», а сами картинки хранить, например, как тензор `CxHxW`.\n\n## MLP\n\nНаверное, самый простой способ построить нейронную сеть для решения задачи классификации на наших данных — это «развернуть» нашу картинку в вектор, а затем использовать обычную многослойную сеть с кросс-энтропией в качестве лосса.\n\nОднако, такой подход имеет несколько недостатков.\n\n### Недостаток №1: количество параметров\n\nВ первом слое у нас получается `HxWxCxCout` параметров, где Cout — это количество нейронов в первом слое. Если поставить `Cout` слишком маленьким, мы рискуем потерять много важной информации, особенно, если рассматривать картинки размером, например, 1920x1080.  \n\nЕсли же выставить Cout большим, рискуем получить слишком много параметров (а это только первый слой), а с этим и все вытекающие проблемы — переобучение, сложность оптимизации и так далее.  \n\n### Недостаток №2: структура данных никак не учитывается. \n\nЧто здесь имеется в виду под «структурой»? Попробуем объяснить на примере. Для этого рассмотрим картинку щеночка:\n\n![puppy_a1d259493d.webp](https://yastatic.net/s3/education-portal/media/puppy_a1d259493d_708f608dce.webp)\n\nЕсли мы сдвинем картинку на несколько пикселей, то мы все еще будем уверены в том, что это щенок:\n\n![shifted_puppy_c27db8708f.webp](https://yastatic.net/s3/education-portal/media/shifted_puppy_c27db8708f_ca16064a3b.webp)\n\nТочно также мы останемся неизменны в своем мнении, если картинку отмасштабировать:\n\n![scaled_puppy_d6c7abac44.webp](https://yastatic.net/s3/education-portal/media/scaled_puppy_d6c7abac44_a80f12b60e.webp)\n\nили повернуть/развернуть:\n\n![rotated_puppy_523e9847b2.webp](https://yastatic.net/s3/education-portal/media/rotated_puppy_523e9847b2_31bef7bb3c.webp)\n<br>\n![flipped_puppy_a8a6029dce.webp](https://yastatic.net/s3/education-portal/media/flipped_puppy_a8a6029dce_c8300e6bd9.webp)\n\t\nПолучается, что нейронная сеть должна «сама» понять, что ее ответ должен быть инвариантен к описанным преобразованиям. Но, обычно, это достигается за счет увеличения количества нейронов в скрытых слоях (как мы можем помнить из _universal approximation theorem_), что и так для нас — головная боль из-за первого пункта.\n\nС частью этих проблем нам поможет новый «строительный блок» — свёртка. О ней в следующем разделе.\n\n## Свёртки\n\nСтрогое определение свёртки мы дадим ниже, а вначале разберёмся в мотивации.\n\nДавайте попробуем решить хотя бы проблему инвариантности к сдвигу. Щенок может быть где угодно на картинке, и мы не можем наверняка сказать, в какой части изображения наша модель «лучше всего» научилась видеть щенков. Поэтому для надёжного предсказания будет логично посдвигать картинку на все возможные смещения (пустоты заполним нулями):\n\n![gif_shift_template_35384897e9.svg](https://yastatic.net/s3/education-portal/media/gif_shift_template_35384897e9_16cdab70dc.svg)\n\nЗатем для каждого смещения мы предскажем вероятность наличия щенка на картинке. Получившиеся предсказания можно уже агрегировать как удобно: среднее, максимум и так далее.\n\nДавайте взглянем на эту операцию под другим углом. Рассмотрим картинку, размером в 3 раза превышающую оригинальную, в центре которой находится наше изображение щеночка:\n\n![padded_puppy_3bd370a19b.webp](https://yastatic.net/s3/education-portal/media/padded_puppy_3bd370a19b_83e0aba93a.webp)\n\nВозьмём окно размером с исходную картинку, и будем его сдвигать на все возможные смещения внутри нового изображения:\n\n![gif_conv_template0_fbf83244f0.svg](https://yastatic.net/s3/education-portal/media/gif_conv_template0_fbf83244f0_c38899448f.svg)\n\nЛегко видеть, что получается то же самое, как если бы мы картинку сдвигали относительно окна.\n\nПредставим себе самую простую модель, основанную на данном принципе — что-то вроде ансамбля линейных. Каждую из сдвинутых картинок вытянем в вектор и скалярно умножим на вектор весов (для простоты один и тот же для всех сдвигов) — получим линейный оператор, для которого есть специальное имя — **свёртка**.  \n\nЭто один из важнейших компонент в **свёрточных** нейронных сетях. Веса свёртки, упорядоченные в тензор (в нашем случае размерности `HxWx3`), составляют её **ядро**. Область картинки, которая обрабатывается в текущий момент, обычно называется **окном свёртки**.  \n\n**Обратите внимание**, что обычно такие свёртки называются двумерными — так как окно свёртки пробегает по двум измерениям картинки (при этом все цветовые каналы участвуют в вычислениях).  \n\nСледующая картинка поможет разобраться (внимание: на ней _нет_ изображения весов оператора):\n\n![11_image_tensor_conv_cdaf6d395d_f54b12323d.svg](https://yastatic.net/s3/education-portal/media/11_image_tensor_conv_cdaf6d395d_f54b12323d_a3d8bf4b65.svg)\n\nКаждый «кубик» на картинке — это число. Большой черный тензор слева — это изображение щеночка $X$. Фиолетовым на нем выделено окно, из которого мы достаем все пиксели и разворачиваем в вектор (аналогично операции flatten в numpy) $v$.  \n\nДалее этот вектор умножается на вектор весов класса «щенок» $w_1$, и получается число $k_1$ — логит интересующего класса. Добавив остальные классы, получим матрицу весов $W$ — прямо как в мультиномиальной логистической регрессии. Эту операцию мы повторяем для каждого возможного сдвига окна свёртки.\n\nРезультаты домножения удобно бывает скомпоновать в двумерную табличку, которую при желании можно трактовать, как некоторую новую картинку (в серых тонах, потому что канал уже только один). Воспользуемся этим, чтобы получше осознать, что происходит в ходе свёртки.\n\n**Вопрос на подумать**. Какой геометрический смысл имеет свёртка с ядром\n\n$$B_1 = \\frac19\\begin{pmatrix}1 & 1 & 1\\\\ 1 & 1 & 1\\\\ 1 & 1 & 1\\end{pmatrix}?$$\n\nА с ядром\n\n$$B_2 = \\begin{pmatrix}-1 & -1 & -1\\\\ -1 & 8 & -1\\\\ -1 & -1 & -1\\end{pmatrix}?$$\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nПервая свёртка усредняет каждый пиксель с соседними, и изображение размывается. Смысл второй можно грубо описать так: пиксели из однородных участков изображения слабеют, тогда как контрастные точки, напротив, усиливаются. Можно сказать, что такая свёртка выделяет границы. Проиллюстрируем работу этих ядер на примере небольшого изображения в серых тонах:\n\n![conv_examples_7a0dba822d.webp](https://yastatic.net/s3/education-portal/media/conv_examples_7a0dba822d_10b47a420f.webp)\n\nВ донейросетевую эпоху различные свёртки играли существенную роль в обработке изображений, и сейчас мы видим, почему.\n\n{% endcut %}\n\n**Вопрос на подумать**. На краях картинок из ответа к предыдущему вопросу заметны тёмные рамки. Что это такое? Откуда они берутся?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nИх появление связано с особенностями обработки свёртками краёв изображения. Вообще, есть несколько стратегий борьбы с краями. Например:\n\n* Дополнить изображение по краям нулями. Когда мы будем рассматривать окна свёртки с центрами в крайних пикселях, они будут захватывать эти нули. Такая свёртка будет превращать изображение размером `HxWx3` в изображение размером `HxW`, без уменьшения размера. Но так как нули соответствуют чёрному цвету, это будет вносить определённые изменения в крайние пиксели результата. Именно благодаря этому у картинок из предыдущего вопроса на подумать по краям появились тёмные рамки.\n* Разрешить только такие окна, которые целиком лежат внутри изображения. Это будет приводить к падению размера. Например, для окна размером `5x5` картинка размером `HxWx3` превратится в картинку размером `(H-2)x(W-2)`.\n\n{% endcut %}\n\nРешив проблему обеспечения устойчивости к сдвигу картинки и имея на руках наш огромный свёрточный фильтр, давайте попробуем теперь справиться с первой проблемой — количество параметров. Самое простое, что можно придумать, — это уменьшить размер окна с `HxW` до, допустим, `kxk` (обычно нечётное и $k \\in [3,11]$). В этом случае получается радикальное снижение количества параметров и сложности вычислений.\n\n![gif_small_conv_template_a2dd681565.svg](https://yastatic.net/s3/education-portal/media/gif_small_conv_template_a2dd681565_6ce335cf1b.svg)\n\nК сожалению, с таким подходом возникает новая проблема: предсказание для какого-то окна никак не учитывает контекст вокруг него. Получается, мы можем получить разумные предсказания только в случае, если распознаваемый объект обладает признаками, которые «помещаются» в окно свёртки (например, лого автомобиля при классификации марок машин), либо объекты заметно отличаются по своей текстуре (шерсть кошки vs кирпич, например).  \n\nНа картинке ниже сделана попытка изобразить проблему:\n\n![very_small_conv_4bdde25018.webp](https://yastatic.net/s3/education-portal/media/very_small_conv_4bdde25018_dab7fdba0b.webp)\n\nОбласть картинки, на которую «смотрит» наша нейронная сеть, назвается **receptive field** — и про него приходится часто думать в задачах компьютерного зрения.  \n\nДавайте и мы подумаем, как его можно было бы увеличить, не увеличивая размер ядра. Вспомним, что в нашей нейронке сейчас есть только один слой, сразу предсказывающий класс. Выглядит так, что мы можем применить уже знакомую технику стекинга слоев: пусть на первой стадии мы делаем $C_1$ разных свёрток с фильтрам размером `kxk`. Результаты каждой свёртки можно упорядочить в виде новой «картинки», а из этих «картинок» сложить трёхмерный тензор. Получаем так называемую карту признаков размером `HxWxC_1`.  \n\nПрименим к ней поэлементно нелинейность и воспользуемся `K` новыми свёртками для получения предсказаний для каждого пикселя. На таком шаге получается, что наш receptive field для финальных нейронов вырос от `kxk` до `(2k-1)x(2k-1)` (пояснение на [картинке](#fig:receptive_field)).  \n\nПовторяя такую операцию, мы можем добиться, чтобы наши финальные нейроны уже могли «видеть» почти всю нужную информацию для хорошего предикта. Более того, у нас возникает меньшее количество параметров и падает сложность вычислений в сравнении с использованием одной большой полносвязной сети. \n\nКак это схематично выглядит:\n\n![15_conv_composition_e686591745_b5d7657ff6.svg](https://yastatic.net/s3/education-portal/media/15_conv_composition_e686591745_b5d7657ff6_01f88a670a.svg)\n\nПромежуточный тензор $L_1$, полученный при помощи $C_1$ свёрток, можно себе представить, как новую картинку, у которой уже $C_1$ каналов.\n\nНа следующей картинке можно отследить, как меняется receptive field в зависимости от глубины:\n\n![16_receptive_field_fbd1c12519_af58719882.svg](https://yastatic.net/s3/education-portal/media/16_receptive_field_fbd1c12519_af58719882_dc46e45295.svg)\n\nНа картинке схематично изображен «плоский» двумерный тензор (количество каналов = 1), к которому последовательно применили три свёртки 3x3. В каждом случае рассматривается пиксель в центре. Каждый соответствующий тензор помечен, как $L_i$. Если рассматривать первую свёртку ($X\\to L_1$), то размер receptive field равен размеру е окна = 3.  \n\nРассмотрим вторую свёртку $L_1 \\to L_2$. В ее вычислении участвуют пиксели из квадрата 3х3, причём каждый из них, в свою очередь, был получен при помощи предыдущей свёртки $X \\to L_1$. Получается, что receptive field композиции свёрток $X\\to L_1\\to L_2$ — это объединение receptive fields свёртки $X\\to L_1$ по всем пикселям из окна свёртки $L_1\\to L_2$, образуя новый, размером 5x5. Аналогичные рассуждения можно повторить и для всех последующих свёрток.\n\nЕщё один способ увеличить receptive field — это использовать dilated convolution, в которых окно свёртки (то есть те пиксели картинки, на которые умножается ядро) не обязано быть цельным, а может идти с некоторым шагом (вообще говоря, даже разным по осям `H` и `W`).  \n\nПроиллюстрируем, как будет выглядеть окно для обычной свёртки и для свёртки с шагом `dilation=2`:\n\n![dilated_convolution_f480c5e9be.svg](https://yastatic.net/s3/education-portal/media/dilated_convolution_36bafd970d.webp)\n\nЕсли установить параметр `dilation=(1,1)`, получится обычная свёртка.\n\nИтак, свёртки помогли нам решить сразу две проблемы: устойчивости к сдвигу и минимизации числа параметров. Теперь давайте попробуем определить оператор более формально.\n\n### Формальное определение свёртки\n\n![18_conv_def_142fec410a_2b151b5c5f.svg](https://yastatic.net/s3/education-portal/media/18_conv_def_142fec410a_2b151b5c5f_23ec612516.svg)\n\n**Вопрос на подумать**. Пусть у нас есть тензор размером `HxWxC_{in}`, к которому одновременно применяется $C_{out}$ свёрток, размер окна каждой равен `kxk`. Посчитайте количество обучаемых параметров. Как изменится формула, если к свёртке добавить смещение (bias)? Во сколько раз изменится количество параметров, если увеличить размер окна в 2 раза? А если увеличить количество каналов $C_{in}$ и $C_{out}$ в два раза? А если увеличить размер входного тензора в 2 раза по высоте и ширине?\n\n**Вопрос на подумать**. Оцените количество операций сложений-умножений для предыдущего упражнения. Как оно поменяется, если увеличить в два раза размер окна? Количество каналов? Размер входного тензора?\n\n**Вопрос на подумать**. Пусть последовательно применяется $N$ свёрток $k \\times k$. Посчитайте размер receptive field для последнего оператора.\n\n### Свёртки не только для изображений\n\nНетрудно видеть, что аналоги двумерной свёртки можно определить и для тензоров другой размерности, в любой ситуации, когда для нас актуально поддерживать устойчивость модели к сдвигам данных. Например, это актуально для работы с текстами. Обычно текст разбивается на последовательные токены (например, на слова или какие-то subword units), и каждому из этих токенов ставится в соответствие вектор (более подробно об этом вы можете почитать в параграфе про работу с текстами или в [разделе](https://lena-voita.github.io/nlp_course/word_embeddings.html) про вложения слов учебника по NLP Лены Войта).\n\n![cnn_word_1_a7eae439ca.svg](https://yastatic.net/s3/education-portal/media/cnn_word_1_a7eae439ca_e7becfd688.svg)\n\nПредставим теперь, что мы хотим определить, позитивно или негативно окрашен этот текст. Мы можем предположить, что эмоциональная окраска локальна и может проявляться на любом участке текста, и тогда нам нужна модель, которая может «посмотреть» отдельно на каждый последовательный фрагмент текста некоторой длины. И здесь тоже может сработать свёртка:\n\n![cnn_word_c294cce45a.svg](https://yastatic.net/s3/education-portal/media/cnn_word_c294cce45a_13a54daa9b.svg)\n\nСуществуют свёртки и для тензоров более высокой размерности, например, для видео (где прибавляется ещё координата «время»).\n\n### Поворот, отражение, масштабирование\n\nА что делать с остальными проблемами: поворотом, отражением, масштабированием? К сожалению, на момент написания параграфа (вторая половина 2021 года), автору не было известно об успешном опыте решения этих проблем в архитектуре сети. При этом оказывается, что приведенного оператора уже достаточно, чтобы нейронная сеть могла хорошо обобщать на невиданные ранее картинки (лишь бы свёрток было больше и сеть глубже).\n\nВ качестве потенциально интересного (но пока не проявившего себя на практике) направления исследований можно упомянуть капсульные нейросети. Кроме того, вам может быть интересно познакомиться с [геометрическим глубинным обучением](https://geometricdeeplearning.com/lectures/). В качестве короткого введения рекомендуем посмотреть вот этот [keynote с ICLR 2021](https://www.youtube.com/watch?v=w6Pw4MOzMuo), которое ставит своей целью исследование общих принципов, связывающих устойчивость к различным преобразованием и современные нейросетевые архитектуры (авторы сравнивают свои идеи с эрлангенской программой Феликса Кляйна — отсюда название).\n\n## Свёрточный слой и обратное распространение ошибки\n\nПоговорим о том, как через свёрточный слой протекают градиенты. Нам нужно будет научиться градиент по выходу превращать в градиент по входу и в градиент по весам из ядра.\n\nНачнём с иллюстрации для одномерной свёртки с одним входным каналом, ядром длины $3$ с дополнением по бокам нулями. Заметим, что её можно представить в виде матричного умножения:\n\n$$(x_1,\\ldots,x_d) \\ast (w_{-1},w_0,w_1) = $$\n\n$$= (0,x_1,\\ldots,x_d,0) \\cdot\\begin{pmatrix}\nw_{-1} &  & & & \\\\\nw_0 & w_{-1}  & & &  \\\\\nw_1 & w_0  & w_{-1} & &  \\\\\n& w_1  & w_0  & \\ddots &  \\\\\n&  & w_1  & \\ddots & w_{-1}  \\\\\n&  &   & \\ddots & w_0  \\\\\n&  &   &  & w_1 \\\\\n\\end{pmatrix} = $$\n\n$$= (x_1,\\ldots,x_d) \\cdot\\begin{pmatrix}\nw_0 & w_{-1} &  & & & & \\\\\nw_1 & w_0 & w_{-1}  & & & &  \\\\\n& w_1 & w_0  & w_{-1} & &&  \\\\\n& & w_1  & w_0  & \\ddots & &  \\\\\n& &  & w_1  & \\ddots & w_{-1} &  \\\\\n& &  &   & \\ddots & w_0 & w_{-1}  \\\\\n& &  &   &  & w_1 & w_0 \\\\\n\\end{pmatrix} = $$\n\nОбозначим последнюю матрицу через $\\widehat{W}$, а ядро свёртки через $W$. Что происходит с градиентом при переходе через матричное умножение, мы уже отлично знаем. Градиент по весам равен\n\n$$\\nabla_{X_0}\\mathcal{L} = \\nabla_{X_0\\ast W}\\mathcal{L}\\cdot\\widehat{W}^T$$\n\nРазберёмся, что из себя представляет умножение на $\\widehat{W}^T$ справа. Эта матрица имеет вид\n\n$$\\begin{pmatrix}\nw_0 & w_1 &  & & & & \\\\\nw_{-1} & w_0 & w_1  & & & &  \\\\\n& w_{-1} & w_0  & w_1 & &&  \\\\\n& & w_{-1}  & w_0  & \\ddots & &  \\\\\n& &  & w_{-1}  & \\ddots & w_1 &  \\\\\n& &  &   & \\ddots & w_0 & w_1  \\\\\n& &  &   &  & w_{-1} & w_0 \\\\\n\\end{pmatrix}$$\n\nОна тоже соответствует свёртке, только:\n\n* с симметричным исходному ядром $(w_1, w_0, w_{-1})$;\n* с дополнением вектора $\\nabla_{X_0\\ast W}$ нулями (это как раз соответствует неполным столбцам: можно считать, что «выходящие» за границы матрицы и отсутствующие в ней элементы умножаются на нули).\n\n**Вопрос на подумать**. Поменяется ли что-нибудь, если исходный вектор не дополнять нулями?\n\n### Общий случай\n\nРассмотрим теперь двумерную свёртку, для простоты нечётного размера и без свободного члена\n\n$$(X\\ast W)_{ijc} = \\sum_{p=1}^{c_{\\text{in}}}\\sum_{k_1 = -k}^k\\sum_{k_2=-k}^kW^{c}_{k+1+k_1, k+1+k_2, p}X_{i + k_1, j + k_1, p}$$\n\n1. Продифференцируем по $X_{stl}$:\n\t\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial X_{stl}} = \\sum_{i, j, c}\\frac{\\partial (X\\ast W)_{ijc}}{\\partial X_{stl}}\\cdot\\frac{\\partial\\mathcal{L}}{\\partial(X\\ast W)_{ijc}}\n$$\n\nРазберёмся с производной $\\frac{\\partial (X\\ast W)_{ijc}}{\\partial X_{stl}}$. Во всей большой сумме из определения свёртки для $(X\\ast W)_{ijc}$ элемент $X_{stl}$ может встретиться в позициях $X_{i+k_1, j+k_2, l}$ при $i + k_1 = s$, $j + k_2 = t$ и всевозможных $c$, причём это возможно лишь если $k_1 = s - i\\in\\{-k,\\ldots,k\\}$, $k_2 = t - j\\in\\{-k,\\ldots,k\\}$ (для всех остальных $(X\\ast W)_{ijc}$ производная по $X_{stl}$ нулевая). Соответствующий коэффициент при $X_{stl}$ будет равен $W_{k + 1 + k_1, k + 1 + k_2, c}$. Таким образом, производная будет иметь вид:\n\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial X_{stl}} = \\sum_{c=1}^{c_{\\text{out}}}\\sum_{k_1=-k}^k\\sum_{k_2=-k}^kW_{k + 1 + k_1, k + 1 + k_2, c}\\cdot\\frac{\\partial\\mathcal{L}}{\\partial(X\\ast W)_{s - k_1, t - k_2, c}}\n$$\nЛегко заметить, что это тоже свёртка, но поскольку индексы $k_1, k_2$ в $W$ и в $\\frac{\\partial\\mathcal{L}}{\\partial(X\\ast W)}$ стоят с разными знаками, получаем, что\n$$\n\\color{blue}{\\nabla_{X}\\mathcal{L} = W\\text{[::-1,::-1,:]}\\ast\\nabla_{X\\ast W}\\mathcal{L}}\n$$\n\n2. Продифференцируем по $W^q_{ab}$:\n\t\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial W^q_{ab}} = \\sum_{i, j, c}\\frac{\\partial (X\\ast W)_{ijc}}{\\partial W^q_{ab}}\\cdot\\frac{\\partial\\mathcal{L}}{\\partial(X\\ast W)_{ijc}}\n$$\n\nВ формуле для $(X\\ast W)_{ijc}$ элемент $W^q_{ab}$ может встретиться в позициях $W^q_{k + 1 + k_1, k + 1 + k_2}$, для $k + 1 + k_1 = a$, $k + 1 + k_2 = b$, с коэффициентами $X_{i + k_1, j + k_2, p}$ (для любых $p$). Значит, производная будет иметь вид:\n\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial W^q_{ab}} = \\sum_{p=1}^{c_{\\text{in}}}\\sum_{i=1}^H\\sum_{j=1}^WX_{a - k - 1, b - k - 1, p}\\cdot\\frac{\\partial\\mathcal{L}}{\\partial(X\\ast W)_{a - k - 1, b - k - 1, q}}\n$$\n\nВ этой формуле тоже нетрудно узнать свёртку:\n\n$$\\color{blue}{\\nabla_{W}\\mathcal{L} = X\\ast\\nabla_{X\\ast W}\\mathcal{L}}$$\n\n**Вопрос на подумать**. Если всё-таки есть свободные члены, как будет выглядить градиент по $b_c$?\n\n## Остальные важные блоки свёрточных нейронных сетей\n\nНаигравшись с нашими мысленными экспериментами, давайте обратимся к опыту инженеров и исследователей, который копился с 2012 года – [alexnet](https://proceedings.neurips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf). Он поможет нам разобраться  с тем, как эффективней всего строить картиночные нейронки. Здесь будут перечислены самые важные (на момент написания и по мнению автора) блоки.\n\n### Max pool\n\nКаждая из $C$ свёрток очередного свёрточного слоя — это новая карта признаков для нашего изображения, и нам, конечно, хотелось бы, чтобы таких карт было побольше: ведь это позволит нам выучивать больше новых закономерностей.  \n\nНо для картинок в высоком разрешении это может быть затруднительно: слишком уж много будет параметров. Выходом оказалось использование следующей эвристики: сначала сделаем несколько свёрток с $C_1$ каналами, а затем как-нибудь уменьшим нашу карту признаков в 2 раза и одновременно увеличим количество свёрток во столько же.  \n\nПосчитаем, как в таком случае изменится число параметров: было $H \\times W \\times K \\times K \\times C_1 \\times C_1$, стало $(H/2) \\times (W/2) \\times K \\times K \\times (C_1 \\times 2) \\times (C_1 \\times 2) = H \\times W \\times K \\times K \\times C_1 \\times C_1$, то есть, ничего не изменилось, а количество фильтров удвоилось, что приводит к выучиванию более сложных зависимостей.\n\nОсталось разобраться, как именно можно понижать разрешение картинки. Тривиальный способ — взять все пиксели с нечетными индексами. Такой подход будет работать, но, как может подсказать здравый смысл, выкидывать пиксели — значит терять информацию, а этого не хотелось бы делать.\n\nЗдесь есть много вариантов: например, брать среднее/максимум по обучаемым весам в окне `2x2`, которое идет по карте признаков с шагом 2. Экспериментально выяснилось, что максимум — хороший выбор, и, в большинстве архитектур, используют именно его. Обратите внимание, что максимум берется для каждого канала независимо.\n\nЕще одно преимущество — увеличение receptive field. Получается, что он увеличивается в 2 раза:\n\n![21_maxpool_b19a0a26b2_dbd86d51dd.svg](https://yastatic.net/s3/education-portal/media/21_maxpool_b19a0a26b2_dbd86d51dd_acdf90632c.svg)\n\nОперация понижения разрешения со взятием максимума в окне называется **max pooling**, а со взятием среднего — **average pooling**.\n\n**Вопрос на подумать**. Как будет преобразовываться градиент во время error backpropagation для maxpool с окном и шагом 2x2? А для average pool? \n\nКстати, ещё один способ уменьшать размер карт признаков по ходу применения свёрточной сети — использование **strided convolution**, в которых ядро свёртки сдвигается на каждом шаге на некоторое большее единицы число пикселей (возможно, разное для осей `H` и `W`; обычная свёртка получается, если установить параметр `stride=(1,1)`).\n\n![gif_conv_template1_5c2a2c90c6.svg](https://yastatic.net/s3/education-portal/media/gif_conv_template1_5c2a2c90c6_8f14127d42.svg)\n\n### Global average pool\n\nКак свёрточные слои, так и пулинг превращают картинку в «стопку» карт признаков. Но если мы решаем задачу классификации или регрессии, то в итоге нам надо получить число (или вектор логитов, если речь про многоклассовую классификацию).  \n\nОдин из способов добиться этого — воспользоваться тем, что свёртка без дополнения нулями и пулинг уменьшают размер карты признаков, и в итоге при должном терпении и верном расчёте мы можем получить тензор `1x1xC` (финальные, общие признаки изображения), к которому уже можно применить один или несколько полносвязных слоёв. Или же можно, не дождавшись, пока пространственные измерения схлопнутся, «растянуть» всё в один вектор и после этого применить полносвязные слои (именно так, как мы не хотели делать, не правда ли?). Примерно так и происходило в старых архитектурах (alexnet, vgg).\n\n**Вопрос на подумать**. Попробуйте соорудить конструкцию из свёточных слоёв и слоёв пулинга, превращающую изображение размера `128x128x3` в тензор размера `1x1xC`.\n\nНо у такого подхода есть как минимум один существенный недостаток: для каждого размера входящего изображения нам придётся делать новую сетку.\n\nПозднее было предложено следующее: после скольких-то свёрточных слоёв мы будем брать среднее вдоль пространственных осей нашего последнего тензора и усреднять их активации, а уже после этого строить MLP. Это и есть Global Average Pooling. У такого подхода есть несколько преимуществ:\n\n1. радикально меньше параметров;\n2. теперь мы можем применять нейронку к картинку любого размера;\n3. мы сохраняем «магию» инвариантности предсказаний к сдвигам.\n\n![23_globalpool_8b3ea2ca37_797f26c48e.svg](https://yastatic.net/s3/education-portal/media/23_globalpool_8b3ea2ca37_797f26c48e_55f0fc2755.svg)\n\n\n### Residual connection\n\nОказывается, что, если мы будем бесконтрольно стекать наши свёртки, то, несмотря на использование relu и batch normalization, градиенты все равно будут затухать, и на первых слоях будут почти нулевыми. Интересное решение предлагают авторы архитектуры resnet: давайте будем «прокидывать» признаки на предыдущем слое мимо свёрток на следующем:\n\n![24_residual_bb9168282a_b20cdede5b.svg](https://yastatic.net/s3/education-portal/media/24_residual_bb9168282a_b20cdede5b_7417348fb7.svg)\n\nТаким образом получается, что градиент доплывет даже до самых первых слоев, что существенно ускоряет сходимость и качество полученной модели. Вопрос: почему именно сумма? Может, лучше конкатенировать? Авторы densenet именно такой подход и предлагают (с оговорками), получая результаты лучше, чем у resnet. Однако, такой подход получается вычислительно сложным и редко используется на практике.\n\n## Регуляризация\n\nНесмотря на наши ухищрения со свёртками, в современных нейронных сетях параметров все равно оказывается больше, чем количество картинок. Поэтому часто оказывается важным использовать различные комбинации регуляризаторов, которых уже стало слишком много, чтобы все описывать в этом параграфе, так что мы рассмотрим лишь несколько наиболее важных.\n\n### Классические\n\nПочти все регуляризаторы, которые использовались в классической машинке и полносвязных сетях, применимы и здесь: l1/l2, dropout и так далее.\n\n**Вопрос на подумать**. Насколько разумно использовать dropout в свёрточных слоях? Как можно модифицировать метод, чтобы он стал «более подходящим»?\n\n### Аугментации\n\nЭто один из самых мощных инструментов при работе с картинками. Помогает, даже если картинок несколько тысяч, а нейронная сеть с миллионами параметров. Мы уже выяснили, что смещение\\поворот\\прочее не меняют (при разумных параметрах) факта наличия на картинке того или иного объекта.  \n\nНа самом деле, есть огромное множество операций, сохраняющих это свойство:\n\n1. сдвиги, повороты и отражения;\n2. добавление случайного гауссового шума;\n3. вырезание случайно части картинки (cutout);\n4. перспективные преобразования;\n5. случайное изменение оттенка\\насыщенности\\яркости для всей картинки;\n6. и многое другое.\n\nПример хорошой библиотеки с аугментациями: [Albumentations](https://github.com/albumentations-team/albumentations).\n\n### Label smoothing\n\nЧасто оказывается, что нейронная сеть делает «слишком уверенные предсказания»: 0.9999 или 0.00001. Это становится головной болью, если в нашей разметке есть шум — тогда градиенты на таких объектах могут сильно портить сходимость.  \n\nИсследователи пришли к интересной идее: давайте предсказывать не one-hot метку, а ее сглаженный вариант. Итак, пусть у нас есть $K$ классов:\n\n$$y_{ohot}=(0, 0, \\dots, 1, \\dots, 0)$$\n\n$$y_{ls}=\\left(\\frac{\\varepsilon}{k-1},\\frac{\\varepsilon}{k-1}, \\dots, 1-\\varepsilon,\\frac{\\varepsilon}{k-1}, \\dots, \\frac{\\varepsilon}{k-1}\\right)$$\n\n$$\\sum_i y^i_{ohot}=\\sum_i y^i_{ls}=1$$\n\nОбычно берут $\\varepsilon=0.1$. Тем самым модель штрафуется за слишком уверенные предсказания, а шумные лейблы уже не вносят такого большого вклада в градиент.\n\n### Mixup\n\nСамый интересный вариант. А что будет, если мы сделаем выпуклую комбинацию двух картинок и их лейблов:\n\n![ml_6_1_b4c9489f19.svg](https://yastatic.net/s3/education-portal/media/ml_6_1_b4c9489f19_1770e11a3e.svg)\n\nгде $\\alpha$ обычно семплируется из какого-нибудь Бета распределения. Оказывается, что такой подход заставляет модель выучивать в каком-то смысле более устойчивые предсказания, так как мы форсируем некую линейность в отображении из пространства картинок в пространство лейблов. На практике часто оказывается, что это дает значимое улучшение в качестве модели.\n\n## Бонус №1: знаковые архитектуры в мире свёрточных нейронных сетей для задачи классификации изображений\n\nДисклеймер: это мнение _одного_ автора. Приведённые в этом разделе вехи связаны преимущественно с архитектурами моделей, а не способом их оптимизации.\n\nЗдесь перечислены знаковые архитектуры, заметно повлиявшие на мир свёрточных нейронных сетей в задаче классификации картинок (и не только). К каждой архитектуре указана ссылка на оригинальную статью, а также комментарий автора параграфа с указанием _ключевых_ нововведений. Значение метрики error rate на одном из влиятельных датасетов [imagenet](https://image-net.org/) указано для финального ансамбля из нейросетей, если не указано иное.\n\nЗачем это полезно изучить (вместе с чтением статей)? Основных причин две:\n\n1. Общее развитие. Полезно понимать, откуда взялись и чем мотивированы те или иные компоненты.\n2. Этот вопрос задают на собеседовании, когда не знают, что еще спросить :)\n\n### lenet (1998)\n\n[Ссылка на статью](http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf)\n\n7 слоев\n\nПервая свёрточная нейронная сеть, показавшая SOTA (State Of The Art) результаты на задаче классификации изображений цифр MNIST. В архитектуре впервые успешно использовались свёрточные слои с ядром `5x5`. В качестве активации использовался tanh, а вместо max pool в тот момент использовался average.\n\n### alexnet (2012)\n\n[Ссылка на статью](https://proceedings.neurips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf)\n\n11 слоев\n\nПервая CNN (Convolutional Neural Network), взявшая победу на конкурсе imagenet. Автор предложил использовать ReLU вместо сигмоид (чтобы градиенты не затухали) и популяризовал max-pool вместо average. Что самое важное, обучение модели было перенесено на несколько GPU, что позволило обучать достаточно большую модель за относительное небольшое время (6 дней на двух видеокартах того времени). Также автор обратил внимание, что глубина нейросети важна, так как выключение хотя бы одного слоя стабильно ухудшало качество на несколько процентов. \n\n### network in network (2013)\n\n[Ссылка на статью](https://arxiv.org/pdf/1312.4400.pdf)\n\nВ статье не привели интересных SOTA результатов, но зато ввели два очень популярных впоследствии модуля. Первый — это GAP (Global Average Pooling), который стоит после последнего свёрточного слоя и усредняет все активации вдоль пространственных осей. Второй — стекинг `1x1` свёрток поверх `3x3`, что эквивалентно тому, что вместо линейной свёртки используется полносвязный слой.\n\n### vgg (2014)\n\n[Ссылка на статью](https://www.robots.ox.ac.uk/~vgg/publications/2015/Simonyan15/simonyan15.pdf)\n\n19 слоев\n\nАвторы предложили декомпозировать большие свёртки (`5x5`, `7x7` и выше) на последовательное выполнение свёрток `3x3` с нелинейностями между ними. Впоследствии, за нечастым исключением, свёртки `3x3` стали стандартом в индустрии (вместе со свёртками `1x1`).\n\n### googleLeNet aka Inception (2014)\n\n[Ссылка на статью](https://arxiv.org/pdf/1409.4842.pdf)\n\n22 слоя\n\nВвели inception слой, просуществовавший довольно продолжительное время. Сейчас сам слой уже не используется, но идея лежащая в его основе, эксплуатируется. Идея следующая: будем параллельно применять свёртки с разным пространственными размерами ядер, чтобы можно было одновременно обрабатывать как low-, так и high-level признаки. Еще полезной для сообщества оказалась идея с dimensionality reduction: перед тяжелой операцией поставим свёртку 1x1, чтобы уменьшить количество каналов и кратно ускорить вычисление.\n\n### batch normalization (2015)\n\n[Ссылка на статью](https://arxiv.org/pdf/1502.03167.pdf)\n\nАвторы внедрили вездесущую batch normalization, которая стабилизирует сходимость, позволяя увеличить шаг оптимизатора и скорость сходимости. Применив идею к архитектуре inception, они превзошли человека на imagenet.\n\n### kaiming weight initialization (2015)\n\n[Ссылка на статью](https://arxiv.org/pdf/1502.01852.pdf)\n\n\nВ статье предложили использовать инициализацию весов, берущую во внимание особенность активации ReLU (в предыдущих работах предполагалось, что $Var[x] = \\mathbb{E}[x^2]$, что, очевидно, нарушается для $\\hat{x} = max(0, x)$). Применение этой и других «свистелок» на VGG19 позволило существенно уменьшить ошибку на imagenet.\n\n### ResNet (2015)\n\n[Ссылка на статью](https://arxiv.org/pdf/1512.03385.pdf)\n\n152 слоя\n\nАрхитектура, которая на момент написания этого параграфа до сих пор бейзлайн и отправная точка во многих задачах. Основная идея — использование skip connections, что позволило градиенту протекать вплоть до первых слоев. Благодаря этому эффекту получилось успешно обучать очень глубокие нейронные сети, например, с 1202 слоями (впрочем, результаты на таких моделях менее впечатляющие, чем на 152-слойной). После этой статьи также стали повсеместно использоваться GAP и уменьшение размерности свёртками `1x1`.\n\n### MobileNet (2017)\n\n[Ссылка на статью](https://arxiv.org/pdf/1704.04861.pdf)\n\nОчень популярная модель для быстрого инференса (на мобильных устройствах или gpu). По качеству хоть и немного проигрывает «монстрам», но в индустрии, оказывается, зачастую этого достаточно (особенно если брать последние варианты модели).  \n\nОсновная деталь — это использование depthwise convolutions: параллельный стекинг свёрток `3x3x1x1` — то есть таких, в которых вычисление для каждого $с_{\\text{out}}$ канала просходит только на основе признаков одного $c_{\\text{in}}$ канала. Чтобы скомбинировать фичи между каналами, используется классическая `1x1` свёртка.\n\n### EfficientNet (2019)\n\n[Ссылка на статью](https://arxiv.org/pdf/1905.11946.pdf)\n\nОдна из первых моделей, полученных при помощи NAS (Neural Architecture Search), которая взяла SOTA на imagenet. После этого, модели, где компоненты подбирались вручную, уже почти не показывали лучших результатов на классических задачах.\n\n## Бонус №2: не классификацией единой\n\nСвёрточными нейронными сетями можно решать большой спектр задач, например:\n\n1. Сегментация. Если убрать в конце слои GlobalAveragePool или flatten, то можно делать предсказания для каждого пикселя в отдельности (подумайте, что делать, если в сети есть maxpool) — получаем сегментацию картинки. Проблема — долгая и дорогая разметка.\n2. Детекция. Часто намного дешевле получить разметку объектов обрамляющими прямоугольниками. Здесь уже можно для каждого пикселя предсказывать размеры прямоугольника, который обрамляет объект, к которому принадлежит пиксель. Проблемы — нужен этап агрегации прямоугольников + много неоднозначностей во время разметки + много эверистик на всех этапах + данных нужно больше.\n3. Понимание видео. Добавляем в тензор новый канал — временной, считаем четырехмерные свёртки — и получаем распознавание сцен на видео.\n4. Metric learning. Часто мы не можем собрать все интересующие нас классы, например, в задаче идентификации человека по лицу (или товара на полке). В этом случае используют такой трюк: научим модель в некотором смысле (обычно по косиносному расстоянию) разделять эмбеддинги существующих классов (уникальных людей). Если на руках была репрезентативная выборка, то модель, скорее всего (а обычно — всегда), выучит генерировать дискриминативные эмбеддинги, которые уже позволят различать между собой ранее невиданные лица.\n5. и многое другое\n\n## Итого\n\nМы разобрались, что для картинок эффективно использовать свёрточные фильтры в качестве основных операторов. Выяснили, какие основные блоки есть почти в каждой картиночной нейронной сети и зачем они там нужны. Разобрались, какие методы регуляризаторы сейчас самые популярные и какая за ними идея. \n\nИ наконец — рассмотрели знаковые архитектуры в мире свёрточных нейронных сетей.",
        "handbook": "Учебник по машинному обучению",
        "title": "Свёрточные нейросети",
        "description": null
    },
    {
        "path": "/handbook/ml/article/nejroseti-dlya-raboty-s-posledovatelnostyami",
        "content": "В этом разделе вы познакомитесь с нейросетями для работы с данными, имеющими вид последовательностей некоторых токенов. Это может быть музыка или видео, временные ряды или траектория движения робота, последовательности аминокислот в белке или много чего ещё, но одним из самых богатых источников таких данных является Natural Language Processing (NLP).\n\nКак следует из названия, Natural Language Processing (обработка естественного языка) — это область data science, посвященная анализу текстов, написанных на естественных (человеческих) языках. С задачами обработки текста мы встречаемся каждый день, например, когда просим Siri или Алису включить любимую песню или добавить напоминание в календарь, когда используем автодополнение при вводе поискового запроса или проверяем орфографию и пунктуацию с помощью специальных программ.\n\nВот ещё несколько примеров задач, относящихся к обработке естественного языка:\n\n* классификация документов (по темам, рубрикам, жанрам и так далее);\n* определение спама;\n* определение частей речи;\n* исправление орфографических ошибок и опечаток;\n* поиск ключевых слов, синонимов / антонимов в тексте;\n* распознавание именованных сущностей (имен, названий географических объектов, дат, номеров телефонов, адресов);\n* определение эмоциональной окраски текста (sentiment analysis);\n* поиск релевантных документов по запросу, а также их ранжирование;\n* задача суммаризации (автоматическое составление краткого пересказа текста);\n* автоматический перевод с одного языка на другой (машинный перевод);\n* диалоговые системы и чат-боты;\n* вопросно-ответные системы (выбор ответа из нескольких предложенных вариантов или вопросы с открытым ответом);\n* кроме того, к NLP также относят задачу распознавания речи (Automated Speech Recognition, ASR).\n\nДля работы с такими данными есть несколько возможных режимов:\n\n1. **Many-to-one**. На вход подается последовательность объектов, на выходе один объект. Пример 2: классификация текстов или видео. Пример 2: тематическая классификация. По предложению нефиксированной длины генерируем вектор вероятностей упоминания заранее фиксированных тем во входном предложении. Размерность выходного вектора постоянна и равна количеству тем.\n2. **One-to-many**. На вход подается один объект, на выходе последовательность объектов. Пример: генерация заголовка к изображению (image captioning).\n3. **Many-to-many**. На входе и выходе последовательности нефиксированной длины. Примеры: машинный перевод, суммаризация текста, генерация заголовка к статье.\n4. **Синхронизированный вариант many-to-many**. На входе и выходе последовательности одинаковой длины, токены входной явно сопоставлены соответствующим токенам выходной. Пример: генерация покадровых субтитров к видео, PoS-tagging (part of speech tagging, для каждого слова в предложении предсказываем, что это за часть речи).\n\n![sec](https://yastatic.net/s3/education-portal/media/sec_architectures_b7bc32c3d6_1_b98e97b208_f99654e141.svg)\n\nМы начнём с архитектур, в которых размер выхода предсказуемым образом зависит от размера входа: many-to-one и синхронизованном варианте many-to-many — но в итоге доберёмся и до остальных.\n\n## Word Embeddings\n\nПеред тем, как рассказать об архитектурах, которые часто используются для работы с текстами, надо разобраться, каким образом можно кодировать текстовые данные: ведь нужно их превратить во что-то векторное, прежде чем подавать на вход нейросети. К векторизации текстов есть два базовых подхода:\n\n* векторизовать текст целиком, превращая его в один вектор;\n* векторизовать отдельные структурные единицы, превращая текст в последовательность векторов.\n\nПервые, статистические подходы к векторизации следовали первому подходу и рассматривали текст как неупорядоченный набор («мешок») токенов (обычно токенами являются слова). Тем самым, тексты «Я не люблю ML» и «Я люблю не ML» получали одинаковые векторизации, то есть по ходу терялась существенная информация. Поэтому мы лишь коротко упомянем о них.\n\n{% cut \"Немного о статистических подходах\" %}\n\nСамый очевидный вариант так и называется — Bag-of-Words («мешок слов»). Текст предлагается представить в виде вектора частот встречаемости каждого токена, кроме элементов заранее заданного списка «стоп-слов», в которые обычно включают самые вездесущие токены: личные местоимения, артикли и так далее.\n\nЧуть более усложненной версией является TF-IDF (Term Frequency-Inverted Document Frequency). Этот подход использует не только информацию из текста, но и пытается соотнести её с *контекстом* — остальными текстами из имеющейся у нас коллекции $D$. Представление текста $d$ состоит из произведений $TF(t, d)\\cdot IDF(t, D)$ по всем токенам $t$. Разберёмся отдельно с каждым из сомножителей:\n\n* $TF(t,d) = \\dfrac{n_t}{\\sum_k n_k}$, где $n_t$ — число вхождений токена $t$ в документ, а в знаменателе стоит общее число слов в данном документе $d$. Это частота вхождения токена в документ.\n* $IDF(t,D) = \\log \\dfrac{\\vert D \\vert}{\\vert\\{d_i \\in D \\vert t \\in d_i\\}\\vert}$, где $\\{d_i \\in D \\vert t \\in d_i\\}$ — число документов в текстовой коллекции $D$, в которых встречается слово $t$. Этот множитель штрафует компоненты, отвечающие слишком распространённым токенам, и повышает вес специфических для отдельных текстов (и, вероятно, информативных) слов.\n\n{% endcut %}\n\nОбратимся теперь к другому подходу и подумаем, как сопоставить векторы (**эмбеддинги**) словам.\n\nДопустим, что у нас одно и то же слово будет представлено одним и тем же вектором во всех текстах и в любых позициях. Как заключить в векторе его смысл, содержающуюся в нём информацию? Ответ предвосхищает одну из основных идей обучения представлений: нужно использовать *контекст*. Если, читая книгу на иностранном языке, вы встречаете незнакомое слово, вы нередко можете угадать его значение по контексту, что оно значит. Можно сказать, что смысл слова — это те слова, которые встречаются с ним рядом.\n\nОдним из воплощений такого подхода является Word2vec. Впервые он был предложен Т.Миколовым в 2013 году в [статье](https://arxiv.org/abs/1301.3781) Efficient Estimation of Word Representations in Vector Space.\n\nДля обучения авторы предложили две стратегии: Skip-gram и CBOW (Сontinuous bag-of-words):\n\n* В архитектуре CBOW модель учится предсказывать данное (центральное) слово по контексту (например, по двум словам перед данным и двум словам после него).\n* В архитектуре Skip-gram модель учится по слову предсказывать контекст (например, каждого из двух соседей слева и справа);\n\n![cbow](https://yastatic.net/s3/education-portal/media/cbow_vs_skipgram_e3e32c275b_pngcbow_vs_skipgram_e3e32c275b_64c438dc03_0b778979eb.svg)\n\nАвторы предложили для каждого слова $w$ обучать два эмбеддинга: $\\color{#FFC100}{v_u}$ и $\\color{#97C804}{v_{w}}$, первое из которых используется, когда $w$ является центральным, а второе — когда оно рассматривается, как часть контекста. В модели CBOW при фиксированном контексте $\\color{#97C804}{\\text{context}}$ вычисляются логиты\n\n$$logits_u = \\langle\\sum_{w\\in\\color{#97C804}{\\text{ context }}}\\color{#97C804}{v_{w}},\\color{#FFC100}{v_u}\\rangle\n$$\n\nпосле чего «вероятности» всевозможных слов $u$ быть центральным словом для контекста $\\color{#97C804}{\\text{context}}$ вычисляются как $\\text{softmax}(logits)$. Модель учится с помощью SGD на кросс-энтропию полученного распределения с истинным рапределением центральных слов.\n\n![CBOW](https://yastatic.net/s3/education-portal/media/CBOW_a659160b42_1_ee8406db0b_a4873a5818.svg)\n\nВ модели Skip-gram по данному центральному слову $u$ для каждой позиции контекста $\\color{#97C804}{\\text{context}}$ независимо предсказывается распределение вероятностей. В качестве функции потерь выступает сумма кросс-энтропий распределений слов контекста с их истинными распределениями.\n\n![Skip](https://yastatic.net/s3/education-portal/media/Skip_gram_b385df32ae_2_ba3f7892c2_56dcf3930a.svg)\n\nРазмерность эмбеддинга в каждой из архитектур — это гиперпараметр и подбирается эмпирически. В оригинальной [статье](https://arxiv.org/abs/1301.3781) предлагается взять размерность эмбеддинга 300. Полученные представления центральных слов могут дальше использоваться в качестве эмбеддингов слов, которые сохраняют семантическую связь слов друг с другом.\n\nМы не будем здесь останавливаться подробно на деталях работы Word2vec и его современных модификациях и предложим читателю обратиться к соответствующей лекции в [учебнике](https://lena-voita.github.io/nlp_course/word_embeddings.html) Лены Войта по NLP. А мы лишь продемонстрируем, что он работает.\n\n**Примеры**. Возьмём несколько слов и посмотрим, как выглядят топ-10 слов, ближайших к ним в пространстве эмбеддингов (обученных на одном из датасетов Quora Questions с помощью word2vec):\n\n1. **quantum**: electrodynamics, computation, relativity, theory, equations, theoretical, particle, mathematical, mechanics, physics;\n2. **personality**: personalities, traits, character, persona, temperament, demeanor, narcissistic, trait, antisocial, charisma;\n3. **triangle**: triangles, equilateral, isosceles, rectangle, circle, choke (догадаетесь, почему?), quadrilateral, hypotenuse, bordered, polygon;\n4. **art**: arts, museum, paintings, painting, gallery, sculpture, photography, contemporary, exhibition, artist.\n\n**Вопрос на подумать**. В реальных текстах наверняка будут опечатки, странные слова и другие подобные неприятности. Word2vec же учится для фиксированного словаря. Что делать, если на этапе применения вам попадается неизвестное слово? Да и вообще, хорошо ли учить вложения для редких слов или слов с нетривиальными опечатками, которые, может быть, только раз встретятся в тексте?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nНачнём с последнего вопроса: наверное, не очень хорошо. Словарь может получиться слишком большим и займёт всю оперативную память мира. Нередко для достаточно редких слов вовсе не учат специального эмбеддинга, вместо этого для всех них обучая представление одного единственного токена `UNK` (unknown). В таком случае и всем незнакомым словам, встреченным на этапе применения, также можно сопоставить этот же эмбеддинг.\n\nВ реальных сервисах, имеющих дело с текстами (например, в автоматических переводчиках) зачастую вовсе не имеют дела со словами, предпочитая дополнительно разбивать их на subword units. Самым популярным на данный момент решением является BPE (Byte pair encoding). Верхнеуровневая идея состоит в том, что мы фиксируем размер словаря (обычно не очень большой, несколько тысяч или десятков тысяч единиц), добавляем в него все символы, после чего повторяем, пока словарь не заполнится:\n\n* находим самую часто встречающуюся вместе пару токенов;\n* добавляем их конкатенацию в словарь.\n\nБолее подробно о BPE вы можете прочитать в [учебнике](https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html#bpe) Лены Войта.\n\n{% endcut %}\n\n**Вопрос на подумать**. В некоторых случаях всё же полезно уметь строить эмбеддинги не отдельных слов, а текстов (например, для поиска похожих документов). Можете ли вы, вдохновившись идеей word2vec, придумать более тонкий способ сделать это, чем BoW или TF-IDF?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nСамый простой способ это сделать — сложить или усреднить эмбеддинги отдельных слов, но так мы теряем их порядок, и вместе с ним значительную часть смысла (очень похоже на bag-of-words, не так ли?). Другой подход, развивающий идеи word2vec, был предложен в другой<a href=\"https://arxiv.org/abs/1405.4053\"> статье</a> Т. Миколова и носит название doc2vec. Он также имеет CBOW-подобную и Skip-gram-подобную версии. Остановимся на первой. Если в оригинальном CBOW мы предсказывали центральное слово по контексту, то теперь добавляется ещё дополнительный вектор $\\color{#5002A7}{v_{document}}$, уникальный для каждого документа и кодирующий присутствующую в нём смысловую специфику:\n\n![doc2vec](https://yastatic.net/s3/education-portal/media/doc2vec_eff509e41a_4789671af6.webp)\n\n{% endcut %}\n\n## Рекуррентные нейронные сети\n\nИтак, мы представили текст в виде последовательности векторов, соответствующих словам или их кусочкам. Как с ней работать? Один из вариантов мы уже рассматривали: можно посмотреть на последовательность из $k$ векторов размерности $d$ как на «изображение» $k\\times 1$ с $d$ «каналами», после чего использовать уже знакомые нам свёрточные нейросети, только с одномерными свёртками вместо двумерных.\n\nВ каких-то случаях это действительно будет работать, но всё же есть несколько сомнительных моментов:\n\n* Хотя изображения тоже могут быть разного размера, всё же в датасете редко попадаются рядом картинки $1920\\times 1080$ и $3\\times 3$, а среди, скажем, отзывов на ресторан могут попадаться как труды, сопоставимые по размеру с «Войной и миром», так и безликие «Да, вроде норм». И если обработать слишком длинное предложение нам поможет (с потерей информации, конечно) global pooling, слишком короткое может что-нибудь поломать, особенно если мы забываем про паддинг.\n* Слегка философское соображение. Изображение однородно, в нём нет предпочтительных направлений, тогда как текст пишется и читается последовательно. Нам может показаться, что это стоит использовать: при обработке очередного токена обращаться к предыдущим, как к его контексту.\n\nВ последнем соображении уже непосредственно видна идея рекуррентных нейронных сетей (recurrent networks, RNN):\n\n![ecurrent](https://yastatic.net/s3/education-portal/media/ecurrent_many_to_many_08a3506cd8_fb323d4098_5eecbe06a7.svg)\n\nДавайте разберёмся, что тут происходит. Чтобы хранить информацию о предыдущих токенах, мы вводим понятие внутренней памяти или **скрытого состояния** (**hidden state**, векторы $\\color{#5002A7}{h_n}$). В простейшем случае оно выражается одним вектором фиксированной размерности. На каждом (дискретном) шаге в сеть подаются данные (например, эмбеддинг токена), при этом происходит обновление скрытого состояния.\n\nПример:\n\n$$\\color{#5002A7}{h_n} = \\text{tanh}(\\color{#5002A7}{h_{n-1}}\\color{#292183}{W_1} +  \\color{#97C804}{x_n}\\color{#292183}{W_2})\n$$\n\nпосле чего по скрытому состоянию предсказывается выходной сигнал, к примеру, следующим образом:\n\n$$\\color{#FFC100}{y_n} =  \\color{#5002A7}{h_n}\\color{#292183}{W_3}\n$$\n\nОбратите внимание, что веса $\\color{#292183}{W_i}$ одинаковы на всех итерациях, то есть вы можете представлять себе, что очередные $\\color{#97C804}{x_n}$ и $\\color{#5002A7}{h_{n-1}}$ подаются на вход одного и того же слоя, зацикленного на себе.\n\nРекуррентную сеть можно обучать на ошибку, равную суммарному отклонению по всем выходных сигналам $\\color{#FFC100}{y_n}$ нашей сети.\n\n**Вопрос на подумать**. Как инициализировать веса $\\color{#292183}{W_i}$ мы, наверное, понимаем (про это можно почитать в [параграфе](https://academy.yandex.ru/handbook/ml/article/tonkosti-obucheniya) про тонкости обучения нейросетей). А как инициализировать начальное скрытое состояние $\\color{#5002A7}{h_0}$? Можно ли инициализировать его нулём?\n\n{% cut \"Ответ (не открывайте сразу; сначала подумайте сами!)\" %}\n\nВажно разобраться, что в данном случае значит «инициализировать». Сравнение с инициализацией $\\color{#292183}{W_i}$ не работает, поскольку $\\color{#5002A7}{h_0}$ пока не объявлялся обучаемым параметром (хотя его, конечно, можно и обучать, если очень хочется). Можно всегда полагать $\\color{#5002A7}{h_0}$ нулём: как во время обучения, так и во время применения. И так действительно можно делать: в конце концов, скрытое состояние хранит информацию о предыдущих элементов последовательности, а до первого шага никакой информации нет.\n\n{% endcut %}\n\nНетрудно представить себе и нейросеть с несколькими рекуррентными слоями: первый слой RNN будет принимать на вход исходную последовательность, вторая RNN — выходы первой сети, третья — выходы второй и т.д. Такие сети называют глубокими рекуррентными сетями.\n\nВот пример схему глубокой рекуррентной сети:\n\n![recurrent](https://yastatic.net/s3/education-portal/media/recurrent_many_layers_a91371b370_b5fae618d9_210eb6cabb.svg)\n\nВы, наверное, заметили, что описанная выше архитектура RNN решает синхронизованную версию задачи many-to-many. Её, впрочем, легко переделать для решения задачи many-to-one: достаточно убрать все выходы, кроме последнего:\n\n![recurrent](https://yastatic.net/s3/education-portal/media/recurrent_many_to_one_94825f5fbf_b9c2eb6d43_a53a1c465e.svg)\n\n### Bidirectional RNN\n\nСтандартная RNN учитывает только предыдущий контекст. Но ведь слово в предложении связано не только с предыдущими, но и с последующими словами. В таких случаях имеет смысл использовать двунаправленную рекуррентную сеть (bidirectional RNN, BRNN).\n\nКак следует из названия, в bidirectional RNN есть две рекуррентных подсети: прямая (forward, токены в нее подаются от первого к последнему) и обратная (backward, токены подаются в обраттном порядке).\n\nВот пример такой архитектуры:\n\n![recurrent](https://yastatic.net/s3/education-portal/media/recurrent_bidirectional1_f474990a9d_ca882b2008_25a0ba0240.svg)\n\nКонечно, формула для $\\color{#FFC100}{y_n}$ может быть и другой. Например, выходы обеих рекуррентных сетей могут агрегироваться путем усреднения, или суммирования, или любым другим способом.\n\nОбратите внимание, что двунаправленная рекуррентная сеть работает с входом фиксированного размера, и по-прежнему не может решать не синхронизованный вариант задачи many-to-many. Backward RNN должна точно знать, где заканчивается входная последовательность, чтобы начать её обрабатывать с конца. Зато такая архитектура может помочь в решении задачи определения именованных сущностей или частей речи, использоваться в качестве энкодера в машинном переводе и так далее.\n\n### Взрыв и затухание градиента в RNN\n\nПри всех неоспоримых плюсах описанной выше глубокой рекуррентной архитектуры, на практике обычно используется её модифицированный вариант, который позволяет бороться с проблемой затухания или зашкаливания (взрыва) градиентов. Давайте разберёмся подробнее, почему она возникает.\n\nРассмотрим функцию потерь $\\mathcal{L}_n = L(y_n, \\hat{y}_n)$, измеряющую отклонение предсказанного $n$-го выхода от истинного (напомним, что архитектура many-to-many обучается на $\\sum_{n=1}^N \\mathcal{L}_n$, а архитектура many-to-one — на $\\mathcal{L}_N$). Выход $y_n$ зависит от скрытого состояния $h_n$, а то, в свою очередь, от всех $h_i, i < n$. Обновление градиента при переходе через преобразование $h_i = \\text{tanh}(h_{i-1}W_1 + x_iW_2)$ имеет, как мы хорошо знаем, вид\n\n$$\\nabla_{h_{i-1}}L = \\left(\\nabla_{h_{i-1}}L\\right)W_1^T\\odot \\text{tanh}'(h_{i-1}W_1 + x_iW_2) = \n$$\n\nТо есть в ходе вычисления $\\nabla_{W_1}\\mathcal{L}_n$ мы $(n-1)$ раз будем умножать на $W_1^T$. Если у $W_1^T$ есть собственные значения, по модулю большие $1$, и нам не посчастливится попадать в их окрестность, градиент будет стремиться к бесконечности («взрываться»).\n\nТакие градиенты делают обучение нестабильным, а в крайнем случае значения весов могут стать настолько большими, что произойдет численное переполнение, и значения весов перестанут обновляться. Если же у $W_1^T$ есть маленькие собственные значения, градиент может затухать. В любом случае, эти проблемы делают получение информации от далеких по времени состояний затруднительным.\n\nТеоретические выкладки о том, почему RNN без модификаций не могут достаточно хорошо учитывать долговременные зависимости, появились ещё в 90х. Их можно прочесть в [статье](http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf) Y.Bengio, 1994 или [диссертации](http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf)  Josef Hochreiter, 1991.\n\nНо как бороться с этой проблемой?\n\nПростым инженерным решением является **gradient clipping**. Эта техника устанавливает максимально возможное значение градиента и заменяет все значения выше выбранного порога на это значение. При обратном распространении ошибки пробрасывается «ограниченный» градиент:\n\n$$\\|\\nabla \\mathcal{L}\\|_{clip} =\n\\begin{cases}\n\t\\|\\nabla\\mathcal{L}\\|,\\ \\text{if}\\ \\|\\nabla \\mathcal{L}\\| < \\tau \\\\\n       \t\\tau,\\ \\text{otherwise}\n\\end{cases}$$\n\nгде $\\tau$ — гиперпараметр, подбираемый порог.\n\nНо сам по себе **gradient clipping** это довольно грубый инструмент. Поэтому были придуманы сложные модификации рекуррентных сетей, позволяющие им выучивать длинные зависимости.\n\n### LSTM\n\nВдохновение при написании этого параграфа черпалось из [статьи](https://colah.github.io/posts/2015-08-Understanding-LSTMs) в блоге исследователя Кристофера Олаха, из него же взяты иллюстрации.\n\nСеть с долговременной и кратковременной памятью (Long short term memory, LSTM) частично решает проблему исчезновения или зашкаливания градиентов в процессе обучения рекуррентных сетей методом обратного распространения ошибки. Эта архитектура была [предложена](http://www.bioinf.jku.at/publications/older/2604.pdf) Hochreiter & Schmidhuber в 1997 году. LSTM построена таким образом, чтобы учитывать долговременные зависимости.\nРассмотрим подробнее архитектуру LSTM.\n\nВсе рекуррентные сети можно представить в виде цепочки из повторяющихся блоков. В RNN таким блоком обычно является один линейный слой с гиперболическим тангенсом в качестве функции активации. В LSTM повторяющийся блок имеет более сложную структуру, состоящую не из одного, а из четырех слоев. Кроме скрытого состояния $h_n$, в LSTM появляется понятие состояния блока (cell state, $c_n$).\n\nCell state $c_n$ будет играть роль внутренней, закрытой информации LSTM-блока, тогда как скрытое состояние $h_n$ теперь становится передаваемым наружу (не только в следующий блок, но и на следующий слой или выход всей сети) значением. LSTM может добавлять или удалять определенную информацию из cell state с помощью специальных механизмов, которые называются **gates** (ворота или вентили в русскоязычной литературе).\n\nРассмотрим этот механизм подробнее.\n\nОсновное назначение вентиля — контролировать количество проходящей через него информации. Для этого матрица, проходящая по каналу, который контролирует вентиль, поточечно умножается на выражение вида\n\n$$\\sigma(W_1 h_{n-1} + W_2 x_n)\n$$\n\nСигмоида выдает значение от $0$ до $1$. Оно означает, какая доля информации сможет пройти через вентиль. Рассмотрим типы гейтов в том порядке, в каком они применяются в LSTM.\n\n**Forget gate** (вентиль забывания). Он позволяет на основе предыдущего скрытого состояния $h_{t-1}$ и нового входа $x_t$ определить, какую долю информации из $c_{n-1}$ (состояния предыдущего блока) стоит пропустить дальше, а какую забыть.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/img6_18a64eb712_39fef32627.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    LSTM: вентиль забывания.<a href=\"https://colah.github.io/posts/2015-08-Understanding-LSTMs\">Источник</a>\n  </figcaption>\n</figure>\n\nДоля $f_t$ сохраняемой информации из $c_{t-1}$ вычисляется следующим образом:\n\n$$f_t = \\sigma(h_{t-1} W^f_1 + x_t W^f_2 + b_f)\n$$\n\nДальше $f_t$ поэлементно умножается на $c_{t-1}$.\n\nСледующий шаг — определить, что нового мы внесём в cell state. Для этого у нас есть отличная кандидатура — уже привычное:\n\n$$\\tilde{C_t} = \\text{tanh}(h_{t-1}W^С_1 + x_tW^C_2 + b_c)\n$$\n\nНо мы не уверены, что вся эта информация достаточно релевантна и достойна переноса в cell state, и хотим взять лишь некоторую её долю. Какую именно — поможет узнать наш следующий персонаж.\n\n**Input gate** (вентиль входного состояния). Вычислим\n\n$$i_t = \\sigma(h_{t-1}W^i_1 + x_tW^i_2 + b_i)\n$$\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/img7_de3b5ff967_3d4bc6d106.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    LSTM: вентиль входного состояния. <a href=\"https://colah.github.io/posts/2015-08-Understanding-LSTMs\">Источник</a>\n  </figcaption>\n</figure>\n\nи умножим почленно на $\\tilde{c_t}$, чтобы получить информацию, которая поступит в cell state от $h_{t-1}$ и $x_t$. А именно, новое состояние cell state будет равно:\n\n$$c_t = f_t \\odot c_{t-1} + i_t \\odot \\tilde{c_t}\n$$\n\nгде $\\odot$ — это поэлементное умножение. Первое слагаемое отвечает за «забывание» нерелевантной информации из $c_{t-1}$, а второе — за привнесение новой, релевантной.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/img8_2d75ae0b16_a128461583.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    LSTM: обновление состояния блока. <a href=\"https://colah.github.io/posts/2015-08-Understanding-LSTMs\">Источник</a>\n  </figcaption>\n</figure>\n\nКак мы уже отмечали, роль выходного вектора LSTM-блока будет играть $h_n$. Он вычисляется по cell state с помощью последнего вентиля.\n\n**Output gate** (вентиль выходного состояния). Он отвечает на вопрос о том, сколько информации из cell state следует отдавать на выход из LSTM-блока. Доля вычисляется следующим образом:\n\n$$o_t = \\sigma(h_{t-1}W^o_1 + x_tW^o_2 + b_o)\n$$\n\nТеперь пропускаем cell state через гиперболический тангенс, чтобы значения были в диапазоне от $-1$ до $1$, и умножаем полученный вектор на o_n, чтобы отфильтровать информацию из cell state, которую нужно подать на выход:\n\n$$h_t = o_t \\odot \\text{tanh}(c_t)\n$$\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/img9_dda717d896_3c3f8599f2.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    LSTM: вентиль выходного состояния. <a href=\"https://colah.github.io/posts/2015-08-Understanding-LSTMs\">Источник</a>\n  </figcaption>\n</figure>\n\nОписанная архитектура выглядит несколько сложно. Кроме того, вычисление четырех различных типов гейтов может быть вычислительно невыгодным. Поэтому были разработаны различные вариации LSTM, одна из самых популярных (Gated Recurrent Unit, GRU) освещена ниже.\n\n#### Gated Recurrent Unit (GRU)\n\nGated Recurrent Unit был предложен в [статье](https://arxiv.org/pdf/1406.1078v3.pdf) Cho et al. в 2014 году. GRU объединяет input gate и forget gate в один **update gate**, также устраняет разделение внутренней информации блока на hidden и cell state. Вот общий вид GRU-блока:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/img10_27a924e83a_a86b927eeb.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    GRU. <a href=\"https://colah.github.io/posts/2015-08-Understanding-LSTMs\">Источник</a>\n  </figcaption>\n</figure>\n\nВнимательно посмотрев на структуру LSTM, можно заметить, что функции forget gate и input gate похожи. Первый механизм определяет, какие значения $c_{t-1}$ надо забыть, а второй — какие значения нового вектора $\\tilde{c_t}$ нужно использовать для обновления старого cell state $c_{t-1}$. Давайте объединим эти функции воедино: грубо говоря, будем забывать только те значения, которые собираемся обновить. Такую роль в GRU выполняет update gate ($z_t$):\n\n$$z_t = \\sigma(h_{t-1}W^z_1 + x_tW^z_2 + b_z)\n$$\n\nНовый тип гейта, который появляется в GRU — **reset gate** ($r_t$). Он определяет, какую долю информации из $h_{t-1}$ с прошлого шага надо «сбросить», инициализировать заново.\n\n$$r_t = \\sigma(h_{t-1}W^r_1 + x_tW^r_2 + b_r)\n$$\n\nТеперь мы вычисляем потенциальное обновление для скрытого состояния\n\n$$\\tilde{h}_n = tanh((r_t\\odot h_{t-1})W^h_1 + x_tW^h_2 + b_{h})\n$$\n\nи, наконец, решаем, что из старого забыть, а что из нового добавить:\n\n$$h_t = (1 - z_t) \\odot h_{t-1} + z_t \\odot \\tilde{h}_t\n$$\n\nВ итоге GRU имеет меньше параметров, чем LSTM (в GRU нет output gate) и при прочих равных, быстрее учится. GRU и LSTM показывают сопоставимое качество на многих задачах, включая генерацию музыки, распознавание речи, многие задачи обработки естественного языка.\n\nМодификации RNN, которые помогают лучше моделировать долгосрочные зависимости (LSTM, GRU) — важная веха развития нейросетей в NLP. Следующий большой этап в развитии — механизм внимания — мы рассмотрим чуть ниже.\n\n## Seq2seq\n\nВы, должно быть обратили внимание, что мы пока не касались задач, связанных с порождением последовательностей (синхронизованный варианты many-to-many не в счёт).\n\nДействительно: имевшиеся у нас пока инструменты не позволяли генерировать последовательности произвольной длины. Но как тогда переводить с одного языка на другой? Ведь мы не знаем, какой должна быть длина перевода фразы, да и однозначного соответствия между словами исходного предложения и его перевода обычно нет.\n\nЕстественным решением для задачи sequence-to-sequence (seq2seq) является использование архитектуры **энкодер-декодер**, состоящей из кодировщика (**энкодера**) для кодирования информации об исходной последовательности в **контекстном векторе** (context vector) и декодировщика (**декодера**) для превращения закодированной энкодером информации в новую последовательность.\n\n![prob](https://yastatic.net/s3/education-portal/media/prob_ML_1_NN_copy_653b463de1_b4f83f4eda.svg)\n\nОчевидным выбором на роль энкодера и декодера являются рекуррентные сети, например, LSTM. Простейшая архитектура будет иметь вид:\n\n![Teacher](https://yastatic.net/s3/education-portal/media/Teacher_forcing_crop_fbebd95d04_89999c96e1.gif)\n\nРассмотрим подробнее энкодер и декодер.\n\nЭнкодер читает входное предложение токен за токеном и обрабатывает их с помощью блоков рекуррентной сети. Hidden state последнего блока становится контекстным вектором. Часто энкодер читает предложение в обратном порядке. Это делается для того, чтобы последний токен, который видит энкодер, совпал (или примерно совпал) с первыми токенами, которые будет генерировать декодер. Таким образом, декодеру проще начать процесс воссоздания предложения. Несколько первых правильных токенов сильно упрощают процесс дальнейшей генерации.\n\nАрхитектура декодера аналогична энкодеру. При этом каждый блок декодера должен учитывать токены, сгенерированные к текущему моменту, и также информацию о предложении на исходном языке. Вектор скрытого состояния в нулевом блоке декодера ($g_0$) инициализируется с помощью контекстного вектора.\n\nТаким образом, декодер получит сжатое представление исходного предложения. Предложение генерируется следующим образом: в первый блок подаем метку начала последовательности (например, <BOS>-токен, begin of sentence), на выходе первого блока получаем первый токен новой последовательности, и затем подаем его на вход следующего блока декодера. Повторяем аналогичную процедуру до тех пор, пока не сгенерируется метка конца последовательности (например, <EOS>, end of sentence) или не будет достигнута максимально возможная длина предложения. Таким образом, декодер работает в режиме языковой модели, генерируя предложение токен за токеном и учитывая предыдущий контекст.\n\nРазумеется, энкодер может быть и более сложным. Например, можно использовать многослойную двунаправленную сеть, лишь бы выходом её был один вектор контекста. С декодером сложнее: он должен порождать слова по одному, в одном направлении.\n\nДалее мы очень коротко остановимся на нетривиальных моментах обучения и применения такой модели.\n\n### Тонкости применения\n\nВ предыдущих разделах мы не останавливались подробно на том, что происходит с выходами $y_n$, но сейчас всё-таки попробуем разобраться. Если мы решаем задачу машинного перевода, то на очередном этапе декодер выдаёт нам условное распределение\n\n$$p(y_n\\mid x, y_{<n})\n$$\n\nна словах (или каких-то subword unit, например, BPE), из которого мы будем выбирать самое вероятное слово $y_n$ и подавать его на вход следующего блока. Но эта, жадная, стратегия может и подвести. Легко представить себе ситуацию, в которой самое вероятное на данный момент слово приведёт дальше к менее вероятной подпоследовательности:\n\n![why](https://yastatic.net/s3/education-portal/media/why_beam_search_0fc77ca043_849022bc86_f40d132234.svg)\n\nЧтобы справиться с этим, на этапе применения модели используют **beam search**. В каждый момент времени мы поддерживаем некоторое количество $B$ самых вероятных гипотез, на $n$-м шаге пытаясь продолжать все сохранённые, а из продолжений выбирая топ-$B$ по метрике\n\n$$\\prod_{t=1}^np(y_t\\mid x, y_{<t})\n$$\n\n![beam](https://yastatic.net/s3/education-portal/media/beam_search_cc5e683c74_24ea396a53_0f1d106ca2.gif)\n\nЧисло $B$ нет смысла делать большим (это и вычислительно будет тяжко, и может привести к более плохим результатам), можете брать в пределах $10$.\n\n### Тонкости обучения\n\nКак уже было сказано выше, на каждом шаге декодер предсказывает распределение вероятностей $p(y_n\\mid x, y_{<n})$. Вся модель учится на сумму по всем $n$ кросс-энтропиям этих распределений с истинными $y_n$.\n\nОдна из сложностей такого обучения состоит в том, что единожды ошибившись и предсказав неправильный $\\widehat{y}_n$ вместо истинного $y_n$, модель скорее всего и следующие токены предскажет неверно, а это сделает всё дальнейшее обучение малополезным: ведь мы будем учить декодер предсказывать правильное продолжение неправильного начала. Одним из способов борьбы с этим является **teacher forcing**. Суть его в том, что на этапе обучения мы подаём на вход декодера не предсказанный им на предыдущем этапе токен, а истинный:\n\n![teacher](https://yastatic.net/s3/education-portal/media/teacher_forcing_a7ff9db2da_c679a636d5_1309a466d6.svg)\n\n### А как же one-to-many?\n\nУ нас остался лишь один неразобранный тип задач: one-to-many. К счастью, чтобы с ним справиться, ничего нового не нужно: достаточно уже знакомой модели энкодер-декодер, лишь с корректировкой энкодера.\n\nРассмотрим для примера задачу генерации подписей к изображениям (image captioning). Если мы уже умеем как-то превращать картинки в векторы, то эти векторы мы можем напрямую подавать в декодер в качестве векторов контекста:\n\n![one](https://yastatic.net/s3/education-portal/media/one_to_many1_ebca52150a_49f363a9ac_e4ce962093.svg)\n\nБолее подробно о том, как строить векторизации для изображений, вы узнаете в параграфе про [обучение представлений](https://academy.yandex.ru/handbook/ml/article/obuchenie-predstavlenij).\n\nА если у вас есть все данные мира, то вы можете в качестве энкодера взять свёрточную нейросеть и обучать её вместе с декодером end-to-end:\n\n![one](https://yastatic.net/s3/education-portal/media/one_to_many2_260aa93598_04b35d18d3_a5dd66af79.svg)\n\n## Механизм внимания (attention)\n\nКак человек переводит предложения с одного языка на другой? Обычно переводчик уделяет особое внимание слову, которое записывает в данный момент. Хочется сообщить аналогичную интуицию нейронным сетям. Рассмотрим, как можно реализовать такой механизм на примере машинного перевода.\n\nВнимательно посмотрим на seq2seq модель для машинного перевода. Вся информация о предложении на исходном языке заключена в контекстном векторе, но разные слова в предложении могут иметь разную смысловую значимость и следовательно, должны учитываться с разными весами. Кроме того, при генерации разных частей перевода следует обращать внимание на разные части исходного предложения. Например, первое слово переведенной фразы нередко связано с первыми словами в предложении, поданном на вход энкодеру, а порой одно слово перевода передаёт смысл нескольких слов, разбросанных по исходному предложению (вдруг кто-нибудь сталкивался с отделяемыми приставками в немецком?).\n\n**Механизм внимания** (**attention**) реализует эту интуицию путем предоставления декодеру информации обо всех токенах исходного предложения на каждом шаге генерации. Рассмотрим классическую модель внимания, предложенную Bahdanau et al. в 2014 году.\n\nОбозначим скрытые состояния энкодера $(h_0, h_1, …, h_n)$, а скрытые состояния декодера $(s_0, s_1, …, s_m)$. Важно отметить, что $h_n = s_0$, это контекстный вектор. На каждом шаге декодера будем считать **attention scores**, умножая $s_i$ на вектор скрытого состояния каждого блока энкодера  $(h_0, h_1, …, h_n)$. Таким образом, получаем $n$ значений, указывающих, насколько каждый из токенов c номерами $(0...n)$ из исходного предложения важен для генерации токена $i$ из перевода:\n\n$$e_i = [\\langle s_i, h_0\\rangle, \\langle s_i, h_1\\rangle, …, \\langle s_i, h_n\\rangle] =\n$$\n\n$$=[s_ih_0^T,\\ldots,s_ih_n^T]\n$$\n\n(здесь $s_i$ и $h_j$, как обычно, являются строками, так что $s_ih_j^T$ — скаляр).\n\nТеперь превращаем эти значения в attention distribution, применив к ним softmax:\n\n$$\\alpha_i = \\text{softmax}(e_i)\n$$\n\nИспользуем $\\alpha_i$ в качестве весов для нахождения окончательного вектора внимания $a_i$:\n\n$$a_i = \\sum_{j=0}^{n}\\alpha_jh_j\n$$\n\nТеперь в декодере на шаге i вместо вектора скрытого состояния $(h_0, h_1, ..., h_n)$ будем использовать вектор $[s_i, a_i]$ -- конкатенацию скрытого состояния блока и соответствующего attention вектора. Таким образом, на каждом шаге декодер получает информацию о важности всех токенов входного предложения. Данная схема вычисления attention представлена на следующем рисунке.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/self_attention_calculation_b1dc069cb7_10215a20fb.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Вычисление attention в seq2seq модели\n  </figcaption>\n</figure>\n\nСуществует много разных видов механизмов внимания, например:\n\n1. Базовый dot-product, рассмотренный ранее: $e_i = [s_ih_j^T]_{j=0}^n$\n2. Мультипликативный: $e_i = [s_iWh_j^T]_{j=0}^n$, где $W$ — обучаемая матрица весов.\n3. MLP: $e_{ij} = \\text{tanh}(h_jW_1 + s_iW_2) v$, где $W_1$, $W_2$ — обучаемые матрицы весов, $v$ — обучаемый вектор весов\n\nВажной особенностью механизма внимания является то, что его веса несут в себе информацию о связях слов в двух языках, участвующих в переводе. Визуализировав веса механизма внимания, получаем таблицу взаимосвязей между словами:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/bernoulli_entropy_copy_4_68b411bd14_48253cbcf3.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Пример визуализации весов attention\n  </figcaption>\n</figure>\n\nВесьма логично, что слово *dogs* теснее всего связано со словом *собак*, а слову *очень* соответствуют целых два слова: *very* и *much*.\n\n## Self-attention\n\nВ предыдущем разделе мы обсуждали применение механизма внимания во время работы декодера, но оказывается, что и энкодеру это может быть полезно.\n\n**Механизм внутреннего внимания** (**self-attention**) используется, чтобы посмотреть на другие слова во входной последовательности во время кодирования конкретного слова. Изначально этот механизм был представлен в [статье](https://arxiv.org/abs/1706.03762) Attention is all you need как элемент архитектуры «**трансформер**» (Transformer).\n\nЭффективность трансформера демонстировалась на примере задачи машинного перевода. Сейчас трансформеры и self-attention обрели огромную популярность и используются не только в NLP, но и в других областях (например, в компьютерном зрении: [Vision Transformer](https://arxiv.org/pdf/2010.11929.pdf), [Video Transformer](https://arxiv.org/pdf/1906.02634.pdf), [Multimodal Transformer for Video Retrieval](https://arxiv.org/pdf/2007.10639.pdf) и так далее).\n\nБолее подробный обзор архитектуры Трансформер оставим [курсу](https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html) Лены Войта по NLP, а пока остановимся на механизме внутреннего внимания. Пусть на вход нейросети пришли два предложения «Мама мыла раму. Она держала в руках тряпку». Местоимение «она» относится к маме или к раме? Для человека это очень простой вопрос, но для модели машинного обучения — нет. Self-attention помогает выучить взаимосвязи между токенами в последовательности, моделируя «смысл» других релевантных слов в последовательности при обработке текущего токена.\n\nЧто происходит внутри self-attention-модуля? Для начала, из входного вектора (например, эмбеддинга каждого токена) формируются три вектора: Query (запрос), Key (ключ) и Value (значение). Они получаются с помощью умножения входного вектора на матрицы $W_Q$, $W_K$ и $W_V$, веса которых учатся вместе со всеми остальными параметрами модели с помощью обратного распространения ошибки.\n\nВыделение этих трех абстракций нужно, чтобы разграничить эмбеддинги, задающие «направление» внимания (query, key) и смысловую часть токена (value). Вектор query задает модальность «начальной точки» механизма внутреннего внимания (от какого токена направлено внимание), вектор key — модальность «конечной точки» (к какому токену направлено внимание). Таким образом, один и тот же токен может выступать как «начальной», так и «конечной» точкой направления внимания: self-attention вычисляется между всеми токенами в выбранном фрагменте текста.\n\nПроцесс происходит так: по очереди фиксируется каждый токен (становится query) и просчитывается степень его связанности со всеми оставшимися токенами. Для этого поочередно key-вектора всех токенов скалярно умножаются на query-вектор текущего токена. Полученные числа будут показывать, насколько важны остальные токены при кодировании query токена в конкретной позиции.\n\nДальше полученные числа надо нормализовать и пропустить через софтмакс, чтобы получить распределение. Затем подсчитывается взвешенная сумма value векторов,где в качестве весов используются полученные на предыдущем шаге вероятности. Полученный вектор и будет выходом слоя внутреннего внимания для одного токена. Изложенную выше схему вычисления self-attention вектора для одного токена можно представить простой схемой:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/self_attention_calculation_b1dc069cb7_10215a20fb.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Вычисление self-attention для одного токена. <a href=\"http://jalammar.github.io/illustrated-transformer/\">Источник</a>\n  </figcaption>\n</figure>\n\nНа практике self-attention не вычисляется для каждого токена по отдельности, вместо этого используются матричные вычисления. Например, вместо вычисления query, key и value векторов для каждого токена, настакаем эмбеддинги входных токенов в матрицу $X$ и посчитаем матрицы $Q = W_Q * X$, $K = W_K * X$ и $V = W_V * X$.\n\nЗатем происходит повторение описанных в предыдущем абзаце шагов, только для матриц. Посчитаем итоговую матрицу $Z$, подав матрицы Q, K и V в формулу:\n\n$$Z=softmax(\\frac{Q\\dot{K}^T}{\\text{norm const}})\\dot{V}\n$$\n\nВ оригинальной [статье](https://arxiv.org/pdf/1706.03762.pdf) Vaswani et al., 2017 в качестве нормализующей константы выбрали число 8 (квадратный корень размерности key-векторов). Нормализация приводила к более стабильным градиентам в процессе обучения.\n\nИнтересно, что обычно используют параллельно несколько self-attention блоков. Такая схема называется multi-head self-attention. Вычисление self-attention происходит несколько раз с разными матрицами весов, затем полученные матрицы конкатенируются и умножаются на еще одну матрицу весов $W_O$ (см. схему).\n\nЭто позволяет разным self-attention головам фокусироваться на разных взаимосвязях, например, одна голова может отвечать за признаковые описания, другая за действия, третья за отношения «объект-субъект». Разные головы могут вычисляться параллельно, при этом входная матрица эмбеддингов отображается в разные подпространства представлений, что значительно обогащает возможности внутреннего внимания моделировать взаимосвязи между словами. В виде формулы вычисление multihead self-attention можно представить так:\n\n$MultiHead(Q,K,V) = Concat(head_1, head_2, ..., head_n) \\dot W^O$,\\\nгде $head_i(Q,K,V)=softmax(\\frac{Q\\dot{K}^T}{\\text{norm const}})\\dot{V}$\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/multi_head_self_attention_f9cd5dbd2e_06bc861586.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Схема вычисления multi-head self-attention.  <a href=\"http://jalammar.github.io/illustrated-transformer/\">Источник</a>\n  </figcaption>\n</figure>\n\nЕсть много реализаций self-attention ([PyTorch](https://pytorch.org/docs/stable/generated/torch.nn.MultiheadAttention.html), TensorFlow). Также советуем ознакомиться с [jupyter-ноутбуком](http://nlp.seas.harvard.edu/2018/04/03/attention.html) от Гарвардской NLP-группы, в котором представлена реализация архитектуры «трансформер» с подробными объяснениями. Еще один отличный источник, позволяющий подробнее разобраться с self-attention и трансформером, - это [статья](https://jalammar.github.io/illustrated-transformer/) Jay Alammar под названием «Illustrated Transformer».\n\n## Особенности работы с текстами\n\n### Предобработка текстов\n\nПеред тем, как применять описанные выше архитектуры (или даже использовать простые подходы, вроде TF-IDF или word2vec),  нужно разобраться, как делать предобработку текстов.\n\nПервым делом надо научиться представлять связный текст в виде последовательности. Для начала имеет смысл разбить текст на предложения, а дальше уже на слова или символьные n-граммы. Этот процесс называется токенизацией. Можно делать токенизацию вручную, например, с помощью регулярных выражений, или воспользоваться готовыми методами из библиотеки NLTK.\n\nПредставим, что мы получили упорядоченный список слов, из которых состоит текст. Но это еще не все. Обычно тексты содержат разные грамматические формы одного и того же слова. Привести все словоформы к начальной форме можно с помощью лемматизации.  Лемматизация - это алгоритм приведения слова к его начальной форме с использованием морфологическего анализа и знаний об особенностях конкретного языка.\n\nПример работы лемматизатора:\n«собаки, собака, с собакой, собаками -\\> собака»\n\nДругой способ приведения всех словоформ к одной форме - это стемминг. Стемминг — это более грубый процесс на основе эвристик, который действует без знания контекста, словарей и морфологии. Стеммер не поймет, что слова с чередованием имеют один и тот же корень (только если прописать в явном виде такую эвристику) или что слова «есть», «буду» и «был» - это формы глагола «быть». Стемминг - менее аккуратный процесс по сравнению с лемматизацией, зато гораздо более быстрый.\n\nЕще один важный этап предобработки текстов - это удаление стоп-слов. Стоп-словами называют междометия, союзы, предлоги, артикли, в общем все слова, которые будут вносить шум в работу алгоритма машинного обучения. Иногда дополнительно убирают слова общей лексики, оставляя только специфические термины. Универсального списка слов не существует, но для начала можно использовать список стоп-слов из библиотеки NLTK.\n\n### Аугментации для текстов\n\nАугментации данных часто используются, чтобы увеличить количество данных в обучающей выборке, а также повысить обобщаемость модели. И если для компьютерного зрения аугментации относительно простые и могут выполняться на лету (масштабирование, обрезка, вращение, добавление шума и т.д.), то для текстов в виду грамматической структуры, синтаксиса и особенностей языка все не так просто.\n\nАугментации текста менее «автоматические», в идеале нужно понимать смысл фразы и иметь под рукой отлично работающий механизм перефразирования. Рассмотрим несколько популярных способов аугментации текстовых данных:\n\n1. Обратный перевод. Переводим исходный текст на какой-то язык, и затем переводим его обратно. Это помогает сохранить контекст, но при этом получить синонимичную формулировку.\n2. Замены слова на синонимичное/близкое по смыслу. Для этого можно использовать словари синонимов либо искать близкое слово в пространстве эмбеддингов, минимизируя расстояние между соответствующими векторами. В качестве таких эмбеддингов можно взять привычный word2vec, [fasttext](https://fasttext.cc/) или контекстуализированные эмбеддинги на основе претренированных моделей ([BERT](https://arxiv.org/abs/1810.04805), [ELMO](https://arxiv.org/abs/1802.05365), [GPT-2](https://openai.com/blog/gpt-2-1-5b-release/)/[GPT-3](https://arxiv.org/abs/2005.14165) и так далее).\n3. Вставка синонима слова в случайное место в предложении.\n4. Замена сокращения на полное наименование и обратно. Для английского языка этот способ более актуален, чем для русского.\n5. Случайная вставка/удаление/замена/перемена местами слов в предложении.\n6. Случайная перестановка местами предложений.\n7. Случайное изменение букв на произвольные/ближайшие на клавиатуре, добавление/исправление орфографических и пунктуационных ошибок, изменение регистра.\n8. [MixUp](https://arxiv.org/abs/1905.08941) для текстов. В задаче классификации смешиваем признаковые описания двух объектов и с такими же весами смешиваем их метки классов, получаем новый объект с признаками $x_{ij}$ и меткой класса $y_{ij}$:\n\n$$x_{ij} = \\lambda x_i + (1 - \\lambda) x_j\n$$\n\n$$y_{ij} = \\lambda y_i + (1 - \\lambda) y_j\n$$\n\nДля текстов признаковые описания можно смешивать на уровне слов (выбирать ближайшее слово в пространстве word embeddings) или на уровне предложений. Еще один вариант: сэмплировать слова из двух разных текстов с вероятностями $\\lambda$ и $1-\\lambda$.\n9\\. Аугментации с использованием синтаксического дерева предложения.\n10\\. Генерация текста языковыми моделями. Например, генерация текста с помощью упоминавшейся ранее модели GPT-3.\n\nПодробнее про некоторые методы аугментации текстов можно почитать в [статье](https://arxiv.org/abs/1901.11196) Easy Data Augmentation (EDA). Многие из описанных выше и в статье методов реализованы в библиотеке [NLPAug](https://github.com/makcedward/nlpaug), использование которой сильно упрощает задачу аугментации текстовых данных на практике.",
        "handbook": "Учебник по машинному обучению",
        "title": "Нейросети для работы с последовательностями",
        "description": null
    },
    {
        "path": "/handbook/ml/article/grafovye-nejronnye-seti",
        "content": "## Введение\n\nНаряду с обработкой табличных, текстовых, аудио данных и изображений, в глубинном обучении довольно часто приходится решать задачи на данных, имеющих **графовую** структуру. К таким данным относятся, к примеру, описания дорожных и компьютерных сетей, социальных графов и графов цитирований, молекулярных графов, а также графов знаний, описывающих взаимосвязи между сущностями, событиями и абстрактными категориями.\n\n![graph_examples_d518b5ab5c.webp](https://yastatic.net/s3/education-portal/media/graph_examples_d518b5ab5c_1819e5c6d3.webp)\n\nВ этом параграфе мы с вами познакомимся с основными задачами, которые возникают при обработке графов, а также поговорим о **графовых свертках** и **графовых нейронных сетях** — специальном классе обучаемых преобразований, способных принимать в качестве входа графы и решать задачи на них.\n\n## Описание графовых данных\n\nГраф $G=(V, E)$ принято представлять двумя множествами: множеством $V$, содержащим вершины и их признаковые описания, а также множеством $E$, содержащим связи между вершинами (то есть рёбра) и признаковые описания этих связей. Для простоты математических выкладок и изложения дальнейшего материала давайте считать, что мы всегда работаем с ориентированными графами. Если граф содержит ненаправленное ребро, мы его заменяем на пару направленных ребер. Кроме того, давайте обозначать окрестность вершины как $N(v)=\\{\\hat{v}\\vert(\\hat{v}, v) \\in E\\}$.\n\n![2_rgb_split_rooster_d20d157ef7.svg](https://yastatic.net/s3/education-portal/media/2_rgb_split_rooster_d20d157ef7_03b8cb7672.svg)\n\n\nГрафовые данные довольно разнообразны. Они могут отличаться между собой в следующих моментах:\n\n* По размеру, т.е. *количеству вершин и/или ребер*.\n* По *наличию признаковых описаний вершин и рёбер*. В зависимости от решаемой задачи, графы могут содержать информацию только в вершинах, только в ребрах, либо же и там и там.  \n* Кроме того, графы могут быть **гомо- и гетерогенными** — в зависимости от того, имеют ли вершины и ребра графа одну природу либо же нет. \n\nНапример, социальные графы содержат огромное количество вершин и ребер, часто измеряющееся в тысячах, содержат информацию в вершинах и очень редко в ребрах, а также являются гомогенными, так как все вершины имеют один тип. В то же время, молекулярные графы — это пример графов с, как правило, средним количеством вершин и ребер; вершины и связи в молекулярных графах имеют признаковое описание (типы атомов и ковалентных связей, а также информацию о зарядах и т.п.), но при этом также являются гомогенными графами. К классу гетерогенных графов относятся, например, графы знаний, описывающие некоторую систему, различные сущности в ней и взаимодействия между этими сущностями. Вершины (сущности) и связи (ребра) такого графа могут иметь различную природу: скажем, вершинами могут быть сотрудники и подразделения компании, а рёбра могут отвечать отношениям «Х работает в подразделении Y», «X и Z коллеги» и так далее.\n\n![1_rgb_split_rooster_94ec31a0a3.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_94ec31a0a3_5089b8a719.svg)\n\n\n## Задачи на графах\n\nРазнообразие графовых данных закономерно породило множество разнообразных задач, которые решаются на этих данных.\n\nСреди них можно встретить классические постановки классификации, регрессии и кластеризации, но есть и специфичные задачи, не встречающиеся в других областях — например, задача восстановления пропущенных связей внутри графа или генерации графов с нужными свойствами. Однако даже классические задачи могут решаться на различных *уровнях*: классифицировать можно весь граф (**graph-level**), а можно отдельные его вершины (**node-level**) или связи (**edge-level**).\n\n![1_rgb_split_rooster_1_40fb5a1496.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_1_40fb5a1496_82899b6adb.svg)\n\nТак, в качестве примера *graph-level* задач можно привести классификацию и регрессию на молекулярных графах. Имея датасет с размеченными молекулами, можно предсказывать их принадлежность к лекарственной категории и различные химико-биологические свойства. \n\n\n![1_rgb_split_rooster_2_b78144bcb1.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_2_b78144bcb1_f7faaa0c8f.svg)\n\n\nНа *node-level*, как правило, классифицируют вершины одного огромного графа, например, социального. Имея частичную разметку, хочется восстановить метки неразмеченных вершин. Например, предсказать интересы нового пользователя по интересам его друзей.\n\n![1_rgb_split_rooster_3_1_dad355ba22.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_3_1_dad355ba22_889c0bacf0.svg)\n\nЧасто бывает такое, что граф приходит полностью неразмеченным и хочется *без учителя* разделить на компоненты. Например, имея граф цитирований, выделить в нем подгруппы соавторов или выделить области исследования. В таком случае принято говорить о *node-level* кластеризации графа.\n\n![graph_clustering_684c9b863f.webp](https://yastatic.net/s3/education-portal/media/graph_clustering_684c9b863f_677385fa41.webp)\n\nНаконец, довольно интересна задача предсказания пропущенных связей в графе. В больших графах часто некоторые связи отсутствуют. Например, в социальном графе пользователь может добавить не всех знакомых в друзья. А в графе знаний могут быть проставлены только простые взаимосвязи, а высокоуровневые могут быть пропущены.  \n\n![1_rgb_split_rooster_4_d2140019b4.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_4_d2140019b4_bc419c7590.svg)\n\nВ конце, хотелось бы отметить очень важные особенности всех задач, связанных с графами. Алгоритмы решения этих задач должны обладать двумя свойствами.\n\n- Во-первых, графы в датасетах, как правило, могут отличаться по размерам: как по количеству вершин, так и по количеству связей. Алгоритмы решения задач на графах должны уметь принимать графы различных размеров.\n- Во-вторых, алгоритмы должны быть инварианты к перестановкам порядка вершин. То есть если взять тот же граф и перенумеровать его вершины, то алгоритмы должны выдавать те же предсказания с учетом этой перестановки.\n\n## Графовые нейронные сети\n\nРазвитие глубинного обучения повлияло на подходы к решению задач на графовых данных. Был предложен концепт **графовых нейронных сетей**, которые в последнее время либо полностью заменили классические алгоритмы обработки графов, либо породили мощные синергии с этими алгоритмами.\n\n![1_rgb_split_rooster_5_d0b351ce6e.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_5_d0b351ce6e_edfded2077.svg)\n\nГрафовые нейронные сети по принципу работы и построения идейно очень похожи на сверточные нейронные сети. Более того, забегая немного вперед, графовые нейроные сети являются *обобщением* сверточных нейронных сетей.\n\nНа вход графовой нейронной сети подается граф. В отличие от сверточных нейронных сетей, которые требуют, чтобы все картинки в батче были одинакового размера, графовые нейронные сети допускают разные размеры у объектов батча. Кроме того, в отличие от картинок, у которых информация довольно однородна (это, как правило, несколько цветовых каналов) и хранится в пикселях, у графов информация может также храниться в вершинах и/или ребрах. Причем в одних задачах информация может быть только в вершинах, в других только в ребрах, а в третьих и там, и там. Сама информация может быть довольно разнородной: это могут быть и вещественные значения, и дискретные значения, в зависимости от природы графа и от типа решаемой задачи. Поэтому, довольно часто первым слоем в графовых нейронных сетях идут Embedding слои, которые переводят дискретные токены в вещественные векторы.\n\n\n$$h^{n}_{0} = Emb(V),\\quad h^{e}_{0} = Emb(E)$$\n\n\nОднако, сама суть работы у графовых и сверточных сетей совпадает. В графовой нейронной сети по очереди применяются слои, которые собирают информацию с соседей  и обновляют информацию в вершине. То же самое делают и обычные свертки. Поэтому такие слои и называются **графовыми свертками**. Графовая свертка принимает на вход граф со скрытыми состояниями у вершин и ребер и выдает тот же граф, но уже с обновленными более информативными скрытыми состояниями. \n\nВ отличие от сверточных нейронных сетей, при обработке графа pooling слои вставляют редко, в основном в graph-level задачах, при этом придумать разумную концепцию графового пулинга оказалось нелегко. Если вам станет интересно, вы можете познакомиться с несколькими вариантами графовых пулингов в следующих статьях:\n\n* [Learning Spectral Clustering](https://www.di.ens.fr/~fbach/nips03_cluster.pdf)\n* [Kernel k-means, Spectral Clustering and Normalized Cuts](https://www.cs.utexas.edu/users/inderjit/public_papers/kdd_spectral_kernelkmeans.pdf)\n* [Weighted Graph Cuts without Eigenvectors](https://www.cs.utexas.edu/users/inderjit/public_papers/multilevel_pami.pdf)\n\nВ большинстве же архитектур пулинги не используются, и структура графа на входе и выходе графовой нейронной сети совпадает.\n\n![1_rgb_split_rooster_6_29a3696ede.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_6_29a3696ede_a4f5668691.svg)\n\n\n\nПолученная после череды сверток информация с вершин и ребер в конце обрабатывается с помощью полносвязных сетей для получения ответа на задачу. Для node-level классификации и регрессии полносвязная сеть применяется к скрытым состояниям вершин $h^{n}_{K}$, а для edge-level, соответственно, к скрытым состояниям ребер $h^{e}_{K}$. Для получения ответа на graph-level уровне информация с вершин и ребер сначала агрегируется с помощью <b>readout</b> операции. На месте readout операции могут располагаться любые инвариантные к перестановкам операции: подсчет максимума, среднего или даже обучаемый self-attention слой.\n\n\n![gnn_classification_af4200451c.webp](https://yastatic.net/s3/education-portal/media/gnn_classification_af4200451c_d7d5b98042.webp)\n\nКак говорилось ранее, графовые нейронные сети являются обобщением сверточных. Если представить пиксели изображения вершинами графа, соединить соседние по свертке пиксели ребрами и предоставить относительную позицию пикселей в информации о ребре, то графовая свертка на таком графе будет работать так же, как и свертка над изображением.\n\n![gnn_cnn_f56ac106b0.webp](https://yastatic.net/s3/education-portal/media/gnn_cnn_f56ac106b0_b8a2d0408a.webp)\n\nК графовым нейронным сетям, как и к сверточным, применим термин **receptive field**. Это та область графа, которая будет влиять на скрытое состояние вершины после N сверток. Для графов receptive field после N графовых сверток — это все вершины и ребра графа, до которых можно дойти от фиксированной вершины не более чем за N переходов. Знание receptive field полезно при проектировании нейронной сети - имея представление о том, с какой окрестности вершины надо собрать информацию для решения задачи, можно подбирать нужное количество графовых сверток.\n\n![receptive_field_b6f6d395f3.webp](https://yastatic.net/s3/education-portal/media/receptive_field_b6f6d395f3_4406384972.webp)\n\nМногие техники стабилизации обучения и повышения обобщаемости, такие как Dropout, BatchNorm и Residual Connections, применимы и к графовым нейронным сетям. Однако стоит помнить про их особенности. Эти операции могут независимо применяться (или не применяться) к вершинам и ребрам. Так, если вы применяете Dropout, то вы вправе поставить для вершин и для рёбер различные значения dropout rate. Аналогично и для Residual Connections - они могут применяться только для вершин, только для ребер или же и там и там.\n\n\nКроме того, стоит иметь ввиду, что графы различных размеров будут неравноценно влиять на среднее и дисперсию в BatchNorm слое. Более стабильной альтернативой BatchNorm в обработке графов, например, являются [LayerNorm](https://arxiv.org/pdf/1607.06450.pdf) и [GraphNorm](https://arxiv.org/pdf/2009.03294.pdf), которые производят нормировку активаций по каждому графу независимо. \n\nLayerNorm, по сути, применяет BatchNorm для каждого графа: \n\n$$\n\\mathbf{x}^{\\prime}_i = \\frac{\\mathbf{x} -\n        \\textrm{E}[\\mathbf{x}]}{\\sqrt{\\textrm{Var}[\\mathbf{x}] + \\epsilon}}\n        \\odot \\gamma + \\beta\n$$\n\nA вот GraphNorm содержит несколько обучаемых параметров и является более гибким вариантом нормализации:\n\n$$\\mathbf{x}^{\\prime}_i = \\frac{\\mathbf{x} - \\alpha \\odot\n        \\textrm{E}[\\mathbf{x}]}\n        {\\sqrt{\\textrm{Var}[\\mathbf{x} - \\alpha \\odot \\textrm{E}[\\mathbf{x}]]\n        + \\epsilon}} \\odot \\gamma + \\beta$$\n\n## Парадигмы построения графовых сверток\n\nВажно отметить, что в отличие от свертки, применяемой для изображений, являющейся четко определенной операцией, графовая свертка представляет собой именно концепт, абстрактную операцию, обновляющую скрытые представления объектов графа, используя доступную информацию с соседей и ребер. На практике, конкретный механизм графовой свертки разрабатывается для конкретной задачи, и различные реализации графовых сверток могут очень сильно отличаться между собой. И если зайти на сайты популярных фреймворков глубинного обучения на графах (например, [PyG](https://www.pyg.org)), то можно обнаружить десятки различных реализаций графовых сверток.\n\nВо-первых, графовые свертки отличаются между собой по тому набору информации, которые они могут использовать. Есть свертки, которые используют только скрытые представления вершин, игнорируя информацию на ребрах. Существуют свертки, которые по разному обрабатывают информацию от ребер различного типа. А есть свертки, которые используют информацию с ребер и вершин, обновляя одновременно и те и другие. \n\nВо-вторых, и что более важно, графовые свертки можно разделить на два семейства, которые отличаются математической парадигмой, в которой они работают. Есть spatial (пространственный) и spectral (спектральный) подходы. Пространственные свертки основываются на message-passing парадигме, в то время как спектральные работают с графовым лапласианом и его собственными векторами. \n\nНа практике, спектральные свертки чаще применяются и показывают лучшие результаты в задачах связанных с обработкой одного большого графа, где важно понимать относительное месторасположение вершины в этом большом графе. Например, графа соцсетей или графа цитирований. Пространственные свертки показывают хорошие результаты в остальных задачах, где для решения задачи важно находить локальные подструктуры внутри графа.\n\nНесмотря на принципиальную противоположность этих двух подходов, активно предпринимаются попытки их совмещения в одну парадигму, например, в этой [работе](https://arxiv.org/pdf/2107.10234.pdf).\n\nДавайте разберемся с этими двумя парадигмами.\n\n![gnn_family_107283d83b.webp](https://yastatic.net/s3/education-portal/media/gnn_family_107283d83b_680ac24afd.webp)\n\n### Пространственная парадигма\n\nПространственная (spatial) парадигма основывает на алгоритме передачи сообщений (message passing) между вершинами графа.\n\nКонцепт этого подхода заключается в следующем - каждая вершина графа имеет внутреннее состояние. Каждую итерацию это внутреннее состояние пересчитывается, основываясь на внутренних состояниях соседей по графу. Каждый сосед влияет на состояние вершины, так же как и вершина влияет на состояния соседей.\n\n![1_rgb_split_rooster_7_4a73b7b411.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_7_4a73b7b411_89853ccf75.svg)\n\nИтерация работы Message passing подхода для одной вершины можно описать следующим абстрактным алгоритмом. Для каждой вершины $v$ собираются все тройки $(x_v, x_w, e_{wv})$ состоящие из скрытых представлений текущей вершин $x_v$ и ее соседа $x_w$, а также из типа ребра $e_{wv}$,соединяющего текущую вершину и её соседа. Ко всем этим тройкам применяется обучаемое преобразование $M$ (от слова message), которая считает сообщение — информацию, которая идет от соседа к вершине. Посчитанные сообщения агрегируются в одно, обозначаемое $m_v$. Сообщения могут быть сагрегированы любой ассоциативной операцией, например взятием поэлементного минимума, максимума или среднего. Далее, агрегированное сообщение и текущее внутреннее состояние вершины подаются на вход обучаемой операции $U$ (от слова update), которая обновляет внутреннее состояние вершины. \n\nКонкретные имплементации операций $M, U$ непосредственно зависят от алгоритма и той задачи, которую он решает. \n\n![1_rgb_split_rooster_8_9253c51bed.svg](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_8_9253c51bed_335a7a5c8a.svg)\n\nОдним из самых известных классических алгоритмов, построенных на пространственной парадигме, является PageRank. Алгоритм [PageRank](https://ru.wikipedia.org/wiki/PageRank) проходит по графу веб страниц и выставляет каждой веб-странице значение ее \"важности\" $PG$, которое впоследствии можно использовать для ранжирования поисковой выдачи. Формула подсчета PageRank выражается через коэффициент затухания $d$, а также значения PageRank соседей $N(A)$ вершины и количество исходящий ссылок из этих соседей $LN(A)$ следующим образом:\n\n$$ PR(A) = (1 - d) + d \\sum_{B \\in N(A)} \\frac{PR(B)}{LN(B)} $$\n\nВ такой постановке операции подсчета сообщений $M$ и операции обновления $U$ имеют следующий вид:\n\n$$ M(B) = \\frac{PR(B)}{LN(B)} \\\\\nm_{a} = \\sum_{B \\in N(A)} M(B) \\\\\nU(A) = (1 -d) + d  m_{a} \\\\\nPR(A) = U(A) $$\n\nГрафовые свертки, работающие на парадигме передачи сообщений, как правило делают $M$ и $U$ обучаемыми преобразованиями.\n\nРассмотрим несколько конкретных примеров архитектур.\n\n#### GraphSAGE\n\nСвертка [GraphSAGE](https://arxiv.org/abs/1706.02216) работает по следующему принципу. Для каждой вершины вычисляется набор скрытых представлений соседних вершин $h_w^t$, из которых идут связи в текущую. Далее, собранная информация агрегируется с помощью некоторой коммутативной операции $AGGR$ в вектор фиксированного размера. В качестве операции агрегации авторы предлагают использовать операции взятия средних или максимальных значений скрытых представлений объектов из набора. Далее агрегированный вектор объединяется со скрытым представлением вершины $h_v^t$, они домножаются на обучаемую матрицу $W$ и к результату умножения поэлементно применяется сигмоида. Обучаемые параметры данного слоя, как и в случае GCN, содержат только одну матрицу.\n\n$$m_v^{t+1}=AGGR (\\{h_w^t,w \\in N(v)\\})\\\\\nh_v^{t+1}=\\sigma(W^{t+1} CONCAT(m_v^{t+1},h_v^t))$$\n\nДанная свертка использует только скрытые представления вершин, однако уделяет больше внимания локальному окружению вершины, нежели её глобальному положению во всем графе. Авторы показали высокое качество данной архитектуры в задачах, связанных с выучиванием представлений вершин, однако использование данной свертки можно встретить и в других задачах, связанных с обработкой графов, не содержащих дополнительной информации о рёбрах.\n\n#### GAT\n\nСвертка [GAT](https://arxiv.org/abs/1710.10903) (Graph ATtention) является развитием идеи GraphSAGE. В качестве механизма агрегации эта архитектура предлагает использовать механизм внимания, у которого матрицы преобразования для ключей, значений и запросов совпадают и обозначены в формуле буквой $W$. Как и в GraphSAGE, агрегированное сообщение проходит через сигмоиду, но не домножается перед этим на обучаемую матрицу.\n\n$$\\alpha_{v*}=softmax(act(a^T\nCONCAT(Wh_v^t,Wh_∗^t)))\\\\\nh_v^{t+1}=\\sigma\\left(\\sum_{w \\in N(v)} [\\alpha_{vw} Wh_w^t] \\right)$$\n\nЗдесь act — некоторая функция активации. Как и в случае механизма внимания для последовательностей, в момент обновления представления для вершины $v$ attention «смотрит» на все остальные вершины $w$ и генерирует веса $\\alpha_{vw}$, которые указывают, информация из каких вершин $w$ «важнее» для нас.\n\nБлагодаря мощности и гибкости механизм внимания, эта свертка показала отличные результаты на множестве задач и является одной из самых популярных сверток. По умолчанию, эта свертка, как и GraphSAGE, использует только признаки вершин, однако, в некоторых проектах можно встретить модификации свертки, в которых механизм внимания учитывает ещё и для информацию ребер.\n\n#### RGCN\n\nНаконец, есть специально разработанные свертки для обработки графов, ребра которых могут быть нескольких типов. Одна из них называется [RGCN](https://arxiv.org/abs/1703.06103) (Relational Graph Convolutional Networks). Она суммирует скрытые представления соседей, однако каждое представление соседа домножается на матрицу, зависящую от типа ребра, которое соединяет соседа с текущей вершиной. Если в графе присутствует ребра $N$ типов, то данная свертка будет учить $N$ матриц - по одной для каждого типа связи.\n\n$$h_v^{t+1}=\\sigma\\left(\\sum_{r \\in R}\\sum_{w \\in N_r(v)} \\frac{1}{c_{i,r}}\nW_r^l  h_w^t + W_0^l h_v^t\\right)$$\n\n### Спектральная парадигма\n\nПротивоположностью пространственной парадигме является спектральная (spectral) парадигма. В своей постановке спектральная парадигма опирается на анализ процесса диффузии сигнала внутри графа и анализирует матрицы, описывающих граф — матрицу смежности и матрицу, которая называется Лапласианом графа.\n \n![spectral_dec5f54b96.webp](https://yastatic.net/s3/education-portal/media/spectral_dec5f54b96_579b110e73.webp)\n\nЛапласиан графа — это матрица $L=D-A$, где $D$ — диагональная матрица, хранящая в $i$-й диагональной ячейке количество исходящих из $i$-й вершины рёбер, а $A$ — матрица смежности графа, $(i,j)$-й элемент которой равен числу рёбер, соединяющих $i$-ю и $j$-ю вершину.\n\nЛапласиан графа имеет неотрицательные собственные значения. Количество нулевых собственных значений всегда совпадает с количеством компонент связности. Потрясающим свойством Лапласиана является то, что его собственные векторы, соответствующие положительным собственным значениям, в порядке возрастания собственных значений, описывают разрезы графа — его разделения пополам таким образом, чтобы между разделенным половинами было как можно меньше ребер. \n\nТак, собственный вектор, соответствующий наименьшему положительному собственному значению, будет описывать кластеризацию графа на два подграфа. Все индексы, соответствующие положительным элементам вектора задают вершины, которые должны оказаться в первом кластере, а отрицательные элементы будут соответствовать вершинам, которые должны оказаться во втором кластере. \n\nЭтим свойством Лапласиана графа пользуются для того, чтобы проводить кластеризацию графа без учителя. Для этого надо:\n\n1. Посчитать Лапласиан $L$ матрицы $A$\n2. Посчитать $k$ собственных векторов, соответствующих наименьшим собственным значениям\n3. Сформировать из них матрицу размера $N \\times k$, каждая строка которой описывает вершину $k$ признаками\n4. Кластеризовать объекты, описываемые этой матрицей (например, c помощью K-Means)\n\nТаким образом, спектральный подход отлично подходит для того, чтобы находить в графе  компоненты,  вершины которых связаны друг с другом и имеют похожие свойства.\n\n\n\n#### GCN\n\nСвертка [GCN](https://arxiv.org/abs/1609.02907), основанная на спектральной парадигме, использует только скрытые состояния вершин $h$ и матрицу смежности $A$ — она учитывает лишь наличие или отсутствие ребра в графе, но не признаки ребер. \n\nС математической точки зрения, GCN очень проста и представляет собой один шаг итеративного процесса поиска собственных значений Лапласиана графа: мы берем скрытые представления вершин и домножаем их на нормированную матрицу смежности — матрицу $A$, домноженную слева и справа на матричный корень матрицы $D$. Этот шаг применяется ко всем каналам скрытого представления вершины. После этого шага, обновленные скрытые представления ещё домножаются на обучаемую матрицу $\\theta$:\n\n$$h^{t+1} = \\theta D^{-1/2} (A + I) D^{−1/2} h^{t}$$\n\nЗдесь $h^{j}$ — это матрица размера (число вершин)$\\times$(длина вектора представления), то есть к каждому «каналу» представлений свёртка применяется отдельно. Если же мы хотим работать с несколькими каналами, то есть вместо $h^{t}$ у нас матрица $H^{t}$ размера (число вершин)$\\times$(число каналов), и ещё добавить нелинейность $f$, формула переписывается следующим образом:\n\n$$H^{t+1} = f\\left(D^{-1/2} (A + I) D^{−1/2} H^{t}\\Theta\\right).$$\n\nАвторы данной свертки показали отличное качество работы в задачах классификации вершин графов цитирования и графа знаний. Однако, различные модификации данной свертки применяются и в других задачах, например, для выучивания векторных представлений вершин и для кластеризации вершин графа.\n\n{% cut \"Математическая интуиция за формулами\" %}\n\nПопробуем пояснить подробнее, откуда берётся такая формула для обновления $h^t$.\n\nПусть $h$ — некоторый скалярный «сигнал» на графе, который мы запишем в виде вектора (длина которого равна числу вершин графа).\n\nМы будем работать не с обычным Лапласианом, а с нормализованным, равным $\\widetilde{L} = D^{-1/2} L D^{−1/2} = I - D^{-1/2} A D^{−1/2}$. Нормализованный лапласиан — симметричная матрица, так что у него есть ортонормированный базис $u_1,u_2,\\ldots$ из собственных векторов. Запишем базис $u_i$ в (ортогональную) матрицу $U$. Тогда произведение $U^Th$ — это вектор, состоящий из координат сигнала $h$ в базисе $u_i$. Казалось бы, мы делаем тривиальные вещи из линейной алгебры, но на самом деле мы занимается анализом Фурье, а именно:\n\n* $u_i$ — гармоники;\n* $U^Th$ — коэффициенты Фурье;\n* умножение на $U^T$ — преобразование Фурье;\n* умножение на $U$ — обратное преобразование Фурье.\n\nДействительно, преобразование Фурье — это, грубо говоря, всего лишь разложение по какому-то удобному ортонормированному базису. В данном случае — по базису $u_i$. \n\nВ мире функций, функциональных свёрток и обычного преобразования Фурье $\\mathcal{F}$ свёртка удовлетворяет такому соотношению:\n\n$$g\\ast h = \\mathcal{F}^{-1}\\left(\\mathcal{F}(g)\\odot\\mathcal{F}(h)\\right),$$\n\nгде $\\odot$ — поэлементное умножение. То есть при переходе в мир коэффициентов Фурье свёртка функций превращается в поэлементное умножение векторов.\n\nДля графов кажется логичным свёртку двух сигналов $g$ и $h$ определить похожим образом:\n\n$$g\\ast h = U\\left((U^Tg)\\odot(U^Th)\\right) = U\\theta U^Th,$$\n\nгде через $g_{\\theta}$ мы обозначили диагональную матрицу с диагональю $U^Tg$.\n\nИтак, мы дали новое определение свёртки на графе — через лапласиан и его собственные векторы. Проблема в том, что вычислять $u_i$ очень долго. Поэтому мы линеаризуем задачу. Рассмотрим свёртку $h\\ast g$ как функцию от нормализованного лапласиана $\\widetilde{L}$ и разложим её в ряд Тейлора в точке $I$ (единичная матрица):\n\n$$g\\ast h\\approx \\theta'_0h + \\theta'_1(\\widetilde{L} - I)h$$\n\nТеперь для простоты ещё больше огрубим модель и предположим, что $\\theta'_0 = -\\theta'_1$ (обозначим это число буквой $\\theta$). Тогда остаётся\n\n$$g\\ast h\\approx \\theta(I + D^{-1/2} A D^{−1/2})h$$\n\nА для улучшения численной устойчивости мы перепишем это так:\n\n$$g\\ast h\\approx \\theta D^{-1/2} (I + A) D^{−1/2}h$$\n\nПолучилась та самая формула, которую вы видели выше.\n\nБолее подробно о том, как устроен анализ Фурье на графах, вы можете прочитать, например, в [этой статье](https://arxiv.org/pdf/1211.0053.pdf). Кроме того, рекомендуем заглянуть в [оригинальную статью про GCN](https://arxiv.org/abs/1609.02907) за более подробным изложением вывода формул.\n\n{% endcut %}",
        "handbook": "Учебник по машинному обучению",
        "title": "Графовые нейронные сети",
        "description": null
    },
    {
        "path": "/handbook/ml/article/nejroseti-dlya-oblakov-tochek",
        "content": "Облако точек — это неструктурированный набор векторов вида $(x, y, z)$. Опционально каждой точке может также соответствовать вектор $f$, который содержит дополнительные признаки, например, RGB цвет точки, интенсивность полученного сенсором сигнала и т.д.\n\n![ml_6_4_1_1c33d89642.svg](https://yastatic.net/s3/education-portal/media/ml_6_4_1_1c33d89642_c8dff90440.svg)\n\nОблака точек возникают во многих задачах из реального трёхмерного мира и позволяют нам понять, как он выглядит. Например, беспилотный автомобиль воспринимает окружающие его объекты в виде облака точек и строит между ними безопасный маршрут. Современные смартфоны с помощью сенсоров, которые возвращают облака точек, способны восстановить точную геометрию окружающего пространства.\n\nИнтуитивно кажется, что облака точек похожи на трёхмерные изображения, но есть важное отличие: облако точек — это неупорядоченный, неструктурированный массив, и чтобы извлечь из него пространственную структуру, нужно ещё постараться.  \n\nПоэтому, мы не сможем напрямую использовать для работы с облаками точек архитектуры, созданные для изображений. В этом параграфе мы расскажем о том, как извлекать признаки из облаков точек и какие end-to-end архитектуры существуют для популярных задач: классификации и сегментации.  \n\nНо прежде, чем мы переедем к описанию конкретных архитектур, давайте разберёмся, откуда берутся облака точек.\n\n## Сенсоры для получения облаков точек\n\n### LiDAR\nОдин из самых популярных сенсоров для получения облаков точек — это LiDAR. Принцип его действия состоит в следующем: посылается луч, он отражается от поверхности и возвращается на детектор. Зная скорость света и время, за которое луч вернулся, мы можем посчитать расстояние до объекта.\n\n![lidar_point_cloud_33ff1c6eca.webp](https://yastatic.net/s3/education-portal/media/lidar_point_cloud_33ff1c6eca_0096d52a15.webp)\n\nБлагодаря используемой технологии у каждой точки помимо позиции $(x, y, z)$ будет известна ещё интенсивность. Она показывает, насколько сильным был отклик от поверхности. Например, от стекол или снега мы можем ожидать околонулевой мощности отражения, в то время как от дорожных знаков отражение будет очень сильным. Таким образом, интенсивность может оказаться важным признаком при построении предсказательной модели над облаками.\n\nБольшим преимуществом лидара является способность получать отклик на расстоянии 200 метров и больше при сохранении высокой точности.\n\n### Камера RGB-D\n\nRGB-D камера — это камера, которая способна возвращать глубину каждого пикселя помимо RGB значения. Зная глубину и математическую модель камеры, мы можем восстановить облако точек. Большим преимуществом такого сенсора является наличие цвета для каждой точки. Это может быть полезно при построении моделей сегментации, детекции и так далее.\n\nRGB-D камеры, как правило, обладают меньшей точностью, чем LiDAR. Также такие сенсоры не позволяют оценивать глубину дальше 10-15 метров.\n\n### RGB-камеры\n\nОблако точек можно получить и с помощью обычной камеры, если воспользоваться алгоритмами компьютерного зрения для вычисления глубины. Существуют алгоритмы оценки глубины по одному кадру (monocular depth estimation), оценки глубины по нескольким кадрам (multi view stereo), восстановление облака точек окружающих объектов с помощью движения камеры (Structure From Motion). В зависимости от алгоритма, камеры и среды качество итоговых облаков может различаться. В каждом отдельном практическом приложении нужно смотреть, насколько тот или иной сенсор (или метод получения облака точек) подходит для задачи.\n\n\n## Архитектуры для обработки облаков точек\n\nВ этой части мы рассмотрим различные подходы к построению нейросетей для работы с облаками точек. Мы обсудим детали архитектур, их минусы и плюсы, а также варианты использования этих архитектур в приложениях.\n\n### PointNet\n\nДавайте подумаем как, именно мы можем обрабатывать облака точек.\n\nВо-первых мы можем применять некоторую функцию, например, MLP (полносвязную нейросеть) к вектору признаков каждой точки нашего облака.  \n\nПроблема с таким подходом в том, что мы работаем не с облаком, а с отдельными точками. У такой архитектуры не будет пространственного контекста. В терминах CNN, receptive field каждой точки будет равен 1 — это эквивалентно свёрточной архитектуре, где все ядра размера 1x1.\n\nЗначит нам нужен некий механизм, с помощью которого точки смогут обмениваться информацией друг с другом. Таких механизмов можно придумать много: это и построение графа над облаком, и пересылка сообщений между вершинами, это может быть механизм внимания.  \n\nАвторы архитектуры [PointNet](https://arxiv.org/pdf/1612.00593.pdf) предложили максимально простой механизм: имея для каждой точки некоторый вектор признаков $f_i \\in \\mathbb{R}^p$, давайте применим к этим векторам некоторую глобальную агрегацию AGGR, например, GlobalAveragePooling или GlobalMaxPooling:  \n\n$$\\text{AGGR}:\\ ({f_i}_{i=1}^n) \\mapsto f \\in \\mathbb{R}^p$$\n\nТаким образом из набора векторов для точек мы получим общий вектор признаков, описывающий всё облако.\n\n![ml_6_4_2_c2f224bb96.svg](https://yastatic.net/s3/education-portal/media/ml_6_4_2_c2f224bb96_382fb840d4.svg)\n\nПолученный вектор описывает облако в целом, но точки при таком подходе по-прежнему не обмениваются информацией: ни одна из них не «знает», что происходит вокруг.\n\nЧтобы исправить недостатки двух описанных выше подходов, объединим их, рассмотрев следующий базовый «слой» преобразования облака:\n\n* Агрегируем векторы признаков точек $f_i$, получаем общий вектор признаков $f$ для облака в целом;\n* Для каждой точки конкатенируем её вектор признаков с вектором признаков облака и строим новый вектор признаков $g_i = \\text{concat}(f_i, f)$;\n* Применим MLP к вектору признаков каждой точки: $f'_i = \\text{MLP}(g_i)$.\n\nТакие слои можно применять последовательно, формируя сколь угодно глубокую архитектуру.\n\nТеперь, если мы хотим решить задачу классификации над облаком, мы можем взять очередной вектор $f$, полученный после агрегации всех векторов признаков точек, применить к нему MLP, получить логиты и обучать полученную сеть на cross-entropy loss.\n\nЕсли же мы хотим решить задачу сегментации (то есть классификации для каждой точки), мы можем точно после очередного слоя применить MLP с необходимыми размерами к каждому вектору $f_i$ и получить логиты.\n\nАвторы архитектуры PointNet предложили ещё одно небольшое усложнение описанной выше архитектуры. Давайте внимательно посмотрим на схему из статьи:\n\n![point_net_model_ef646172ed.webp](https://yastatic.net/s3/education-portal/media/point_net_model_ef646172ed_40b8897e9f.webp)\n\nСиний прямоугольник наверху соответствует одному описанному выше «слою», но вместо одного MLP здесь последовательность двух MLP, между которыми вставлена операция feature transform. Эта операция состоит в следующем:\n\n* с помощью дополнительной сети по облаку в целом строим матрицу;\n* эта матрица умножается на вектор признаков каждой из точек.\n\nТем самым точки дополнительно обмениваются информацией. Во многих последующих статьях эту часть не включают, и практика показывает, что для PointNet это не ключевой элемент архитектуры, и им можно пренебречь.\n\nPointNet — это достаточно простая архитектура. Она использует геометрию облака, потому что координаты точек входят в векторы признаков, но работает не с локальной окрестностью точки, а со всем облаком в целом. Если мы обратимся к аналогиям с изображениями, то такая архитектура будет эквивалентна CNN со свёртками размера всего изображения. Такая архитектура с трудом улавливает локальные паттерны и детали, и именно это будет основным направлением дальнейшего улучшения этой архитектуры.\n\n### PointNet++\n\nПродолжением статьи PointNet стала статья [PointNet++](https://arxiv.org/pdf/1706.02413.pdf) от той же научной группы. Новая архитектура развивает идею локальности, о который мы писали в предыдущем параграфе.\n\nДавайте подумаем, каким образом мы можем получить локальные, зависящие только от окрестности точки операции над облаком точек. Первым делом нам необходимо понять, что такое локальность. В облаке точек очевидным решением кажется определить окрестность точки исходя из евклидового расстояния между точками — как шар некоторого радиуса — и проводить операции внутри этого шара.\n\nКакие операции мы будем проводить внутри шара? У нас уже есть PointNet, который по произвольному набору точек может построить вектор, описывающий этот набор в целом. С его помощью мы можем описать многослойную архитектуру, напоминающую энкодер свёрточной сети, каждый слой которой будет выглядеть следующим образом:\n\n1. сэмплируем $N$ ключевых точек в облаке, где $N$ меньше размера облака (как правило в несколько раз);\n2. вокруг каждой ключевой точки фиксируем шар радиуса $R$;\n3. для каждого шара находим все точки, которые в нём лежат;\n4. запускаем PointNet с одними и теми же весами для каждого шара;\n5. получаем новое облако из $N$ точек, где каждой точке присвоен вектор признаков, полученный из PointNet.\n\nДалее мы можем повторять эту процедуру, пока у нас не останется одна точка, то есть один вектор признаков для всего облака в целом. Полученный эмбединг можно использовать для решения различных задач.\n\n\n![ml_6_4_3_4a76819408.svg](https://yastatic.net/s3/education-portal/media/ml_6_4_3_4a76819408_26b7e39379.svg)\n\nОбсудим детали реализации этой архитектуры.\n\nВ качестве алгоритма сэмплирования предлагается Farthest Point Sampling (FPS). Он заключается в том, что мы жадно сэмплируем точку, которая максимально удалена от текущего насэмплированного множества. Этот процесс мы повторяем, пока не наберём достаточное количество точек. Благодаря FPS мы можем в некоторой степени гарантировать, что покроем равномерно все облако и не пропустим какие-то мелкие, но удалённые от основного облака объекты. В этом ценное отличие FPS от случайного сэмплирования, при котором детали, содержащие мало точек, могут быть легко потеряны.\n\nВыбор радиуса шара зависит, как правило, от плотности облака. Стоит посмотреть, сколько примерно точек попадает в каждую окрестность, и исходя из этого фиксировать радиус. Также этот параметр можно подобрать с помощью валидации. Для удобства реализации фиксируют не только радиус, но и максимальное количество объектов внутри шара.  \n\nЭто делается для того, чтобы при реализации архитектуры можно было манипулировать тензорами, избегая итерации по всем точкам каждого шара. Например, мы фиксируем количество шаров $N$, количество точек внутри шара $K$ и размерность вектора признаков для каждой точки $P$. Тогда размер тензора будет: $N \\times K \\times P$. Если в окрестности шара оказалось больше точек, чем мы заранее определили, то возьмем ближайшие $K$. В случае, если точек в тензоре меньше, чем $K$, тензор паддится нулями до нужного размера.\n\nВнутри каждого слоя веса PointNet одинаковы для всех шаров. На окрестностях с одинаковой локальной структурой мы хотим получать одинаковые результаты, поэтому мы не можем использовать абсолютные значения $(x, y, z)$.  \n\nВ этом плане мы хотим, чтобы наши слои были похожи на свёртки, результат работы которых тоже не зависят от положения пикселя на изображении. Чтобы этого добиться, координаты $(x, y, z)$ каждой точки преобразуются в локальные координаты $(x - \\overline{x}, y - \\overline{y}, z - \\overline{z})$, где $(\\overline{x}, \\overline{y}, \\overline{z})$ — координаты центра шара.\n\nОтдельно стоит обсудить, как получить поточечные признаки для решения задачи сегментации. Нам предстоит обратить энкодер и получить архитектуру декодера. Для этого каждый раз, когда мы делаем downsampling облака, то есть переход от вектора для каждой точки к общему вектору для некоторой окрестности, мы будем запоминать, какие точки принадлежали к какому шару.  \n\nВ процессе upsampling, то есть перехода от вектора окрестности к поточечным векторам, мы будем конкатенировать вектор окрестности с исходными векторами признаков точек. После каждой операции upsampling мы можем запускать MLP, чтобы точка, получив информацию с более глубокого уровня, могла извлечь оттуда информацию.\n\n### Воксельные архитектуры\n\nМы разобрали архитектуру PointNet++, которая построена на обработке локальных окрестностей точек, определённых исходя из евклидового расстояния. У этой архитектуры есть свои проблемы.  \n\nВо-первых, поиск ближайших соседей и FPS — это медленные процедуры. В результате могут возникнуть проблемы, когда мы захотим использовать такую сеть в real-time приложениях.  \n\nВо-вторых, в зависимости от расстояния до сенсора у нас может меняться паттерн разреженности: если вблизи сенсора в шаре радиуса $\\epsilon$ мы можем найти в среднем 100 точек, то, как правило, чем больше расстояние до наблюдателя — тем меньше точек мы будем находить в таком же объёме. Это усложняет обучение и может привести к тому, что с расстоянием качество будет сильно деградировать.\n\nДавайте попробуем напрямую применить свёрточные нейронные сети в нашей задаче. Идея следующая: возьмём прямоугольный параллелепипед, который накрывает интересующую нас область пространства. Далее разобьём этот прямоугольный параллелепипед на значительно меньшие прямоугольные параллелипипеды одинакового размера. Назовем эти прямоугольные параллелепипеды **вокселями**. В результате внутри каждого вокселя окажется некоторый набор точек. Нам нужно каким-то образом превратить точки внутри каждого вокселя в один вектор. После этого мы можем применить обычные свёрточные сети и решать любые задачи.\n\nЧтобы из набора точек внутри вокселя получить вектор признаков, мы можем просто применить PointNet. Таким образом, мы получим тензор размера $H\\times W \\times L \\times P$, где первые три размерности пространственные, а последняя размерность — размерность вектора признаков.\n\nДалее мы можем использовать 3D-свёртки для того, чтобы обработать этот тензор. Но проблема в том, что ядро в 3D-свёртках имеет на одну размерность больше, чем в 2D-свёртках, что делает их дорогими для вычисления.\n\n![ml_6_4_5_19d87b7f08.svg](https://yastatic.net/s3/education-portal/media/ml_6_4_5_19d87b7f08_3770a74047.svg)\n\nВ статьях были предложены различные подходы для того, чтобы ускорить эту архитектуру. Часто размерность по высоте и размерность признаков объединяют в одну: тензор размерности $W\\times L\\times H\\times P$ превращается в тензор размерности $W\\times L\\times (H\\times P)$, как будто мы смотрим на него сверху (bird’s eye view). Для работы с ними мы можем использовать 2D-свёртки.\n\n![ml_6_4_4_f15d8f8d19.svg](https://yastatic.net/s3/education-portal/media/ml_6_4_4_f15d8f8d19_a75c28fbbe.svg)\n\nЕщё одним популярным трюком является использование высокой степени разреженности этого тензора: большое количество «столбиков» не содержат ни одной точки. Давайте возьмём все «столбики», содержащие хотя бы одну точку; предположим, что их $B$ штук. Соберём из них тензор размера $B\\times (H\\times P)$ и применим к нему линейный слой, который уменьшит число каналов, то есть высоту «столбиков».  \n\nПолучится тензор $B\\times N$ для выбранного нами $N < H\\times P$. Его столбцы мы снова расставим на их исходные места, получив тензор $W\\times L\\times N$. «Столбики» этого тензора, которые соответствуют пустым «столбикам» исходного тензора $W\\times L\\times (H\\times P)$, мы заполним нулями.\n\nВоксельный подход очень популярен в задаче детекции, потому что позволяет напрямую переиспользовать некоторые подходы к 2D детектированию. Но у него есть и недостатки. Например, нельзя сколько угодно плотно покрыть вокселями сколь угодно большой объём, потому что это напрямую влияет на размер тензора, а значит — на время работы, что может быть критично в real-time приложениях. В итоге мы можем потерять какие-то важные удалённые объекты или не справиться с мелкими деталями.\n\n\n### Архитектуры с цилиндрической проекцией\n\nОсновная проблема воксельных архитектур — это неспособность обрабатывать облака произвольного размера и дальности. У вас может быть самый лучший LiDAR в мире, который видит на 300 метров во все стороны, но если ваша архитектура не будет способна обрабатывать полученное облако точек в режиме реального времени, то такой сенсор бесполезен.\n\nЧтобы преодолеть эту проблему, мы можем воспользоваться тем фактом, что лидар сканирует окрестность из одной точки. Давайте окружим сенсор виртуальным цилиндром и спроецируем все точки на этот цилиндр. Далее цилиндр можно развернуть в прямоугольник и получить представление с которым могут работать свёрточные сети.\n\nОбычно точки параметризуют двумя углами:\n\n* pitch — наклон по вертикали,\n* yaw — угол по горизонтали.\n\nМы можем дискретизовать эти углы и таким образом получить для каждой точки координаты пикселя, в который она должна быть помещена. В каналы нашего тензора мы можем записать: расстояние до точки, интенсивность сигнала, абсолютную высоту точки. Далее такое представление может быть обработано любой 2D архитектурой.\n\n![frontal_projection_0a5a37da5b.webp](https://yastatic.net/s3/education-portal/media/frontal_projection_0a5a37da5b_fc0c5685e1.webp)\n\nВажно отметить, что такое представление не будет работать для других методов получения облаков точек. Лидар сканирует окрестность из одной точки, и потому в направлении каждого луча у нас будет только одна точка. Это означает, что мы не видим за препятствиями. В то время облака, полученные, например, с помощью Structure from Motion, в направлении одного луча могут содержать несколько точек, что лишает нас возможности без потерь спроецировать всё облако на 2D холст.\n\nТакое представление снимает проблему с производительностью, так как размер обрабатываемых данных не зависит от разброса облака. Но, к сожалению, появляются новые проблемы.\n\nВо-первых, объекты, которые находятся далеко друг от друга в трёхмерном пространстве, могут оказаться рядом в этой проекции — в итоге, информация о таких объектах будет смешиваться, и в результате границы в задаче сегментации могут получиться размытыми. Воксельные- или PointNet-архитектуры не имеют этой проблемы — в них далёкие друг от друга объекты не будут так сильно взаимодействовать.\n\nВо-вторых, объекты при таком представлении будут иметь разные размеры в зависимости от расстояния, и модели придётся адаптироваться к этому. Воксельные и PointNet архитектуры, опять же, лишены этой проблемы, так как их представления инвариантны к переносу.\n\nОбе эти проблемы могут приводить к существенной деградации качества. Именно поэтому архитектуры, построенные на цилиндрической проекции, часто проигрывают другим архитектурам по качеству.\n\n\n### Объединение информации с облака и изображения\n\nВ некоторых приложениях у нас может быть несколько различных сенсоров: например, лидар и камера. Тогда возникает задача: построить архитектуру, которая использует информацию с обоих сенсоров.  \n\nКонечно, мы бы могли отдельно подготовить архитектуру для работы с изображением, отдельно архитектуру для работы с облаком и затем каким-то образом объединить результаты. Минус такого подхода в том, что нам требуется в два раза больше вычислительных мощностей, а нейронные сети никак не делятся информацией на промежуточных слоях. Возможно, нейронная сеть могла бы извлечь более богатые представления из объединенных данных. Например, разрешить некоторую неопределённость в облаке с помощью изображений.\n\nОказывается, что задача смешивания различных сенсоров очень непростая, и в литературе долгое время не могли для задачи 3D детекции получить результаты, которые бы превосходили только лидарный подход. Мы обсудим идеи, как именно можно смешивать изображения и 3D информацию.\n\nПрежде чем мы перейдем к описанию подходов, давайте обсудим одну важную техническую деталь. Смешивание информации с разных сенсоров всегда предполагает, что сенсоры скалиброваны. Это означает что нам известна матрица перехода из системы координат одного сенсора в систему координат другого. Таким образом, у нас есть необходимая информация, для того, чтобы спроецировать лидарную точку на плоскость изображения.\n\nАрхитектура, которая первой показала действительно значительный прирост качества при смешивании сенсоров, называется [PointPainting](https://arxiv.org/pdf/1911.10150.pdf). Идея была следующей:\n\n* Делаем сегментацию изображения;\n* Для каждой лидарной точки найдём соответствующий ей пиксель на изображении и присвоим этой точке соответствующий класс из сегментации;\n* Для архитектуры, которая работает с облаком точек, этот класс будет еще одним дополнительным признаком на входе.\n\nВажно отметить, что сопоставление точки класса не будет идеальным, например, из-за того, что камера и лидар находятся не в одной точке.\n\n![point_painting_98332dd991.webp](https://yastatic.net/s3/education-portal/media/point_painting_98332dd991_bdbaa7c1d9.webp)\n\nИдея очень простая, но при этом позволяет сильно улучшить метрики. Проблема в том, что данный подход не решает проблему возросших вычислений при обработке данных с двух сенсоров. Более того, мы передаем в 3D архитектуру лишь одно число для каждой точки и теряем много информации об изображении.\n\nДругой подход был описан в статье [LaserNet++](https://arxiv.org/pdf/1904.11466.pdf). Авторы используют цилиндрическую проекцию для обработки облака. Перед началом обработки они пропускают изображение через небольшую свёрточную сеть, получая в результате некоторый вектор признаков в каждом пикселе.  \n\nДалее для каждой лидарной точки находим соответствующий пиксель на изображении и добавляем его признаки к признакам точки. Отличие от PointPainting в том, что в данном подходе обе нейронные сети обучаются end-to-end. Это позволяет нам извлечь более богатое представление из изображения.\n\nВ статье авторы сообщают о росте метрик на in-house наборе данных. К сожалению, на открытых данных этот подход не смог продемонстрировать превосходства над lidar-only моделями.\n\n![laser_net_plus_4ac43808f3.webp](https://yastatic.net/s3/education-portal/media/laser_net_plus_4ac43808f3_d50c122ff8.webp)\n\nВ этом параграфе мы разобрали основные идеи работы с облаками точек. Верхнеуровнево все архитектуры можно разделить на следующие группы:\n\n- Облако как граф (PointNet и многие другие архитектуры);\n- Вокселизация (VoxelNet, PointPillars и другие);\n- Проекция лидарного облака на 2D поверхность (RangerNet, LaserNet, LaserNet++ и другие).\n\nКаждый подход имеет свои плюсы и минусы и выбор конкретного подхода должен быть обусловлен решаемой задачей.",
        "handbook": "Учебник по машинному обучению",
        "title": "Нейросети для облаков точек",
        "description": null
    },
    {
        "path": "/handbook/ml/article/transformery",
        "content": "Наверное, ни один из рассказов про современные нейросети не обойдётся без упоминания трансформер-моделей: в самом деле, почти все нашумевшие достижения в глубинном обучении последних лет так или иначе опираются на эту архитектуру. Что же в ней такого особенного и почему трансформеры успешно применяются в самых разных задачах? \n\nДавайте разбираться. \n\n## Зачем нам внимание\n\nДля начала вспомним, что основным подходом для работы с последовательностями до 2017 года (выхода оригинальной статьи про архитектуру «трансформер») было использование рекуррентных нейронных сетей, или RNN. Однако у такого подхода есть несколько известных минусов:\n\n- Во-первых, RNN содержат всю информацию о последовательности в скрытом состоянии, которое обновляется с каждым шагом. Если модели необходимо «вспомнить» что-то, что было сотни шагов назад, то эту информацию необходимо хранить внутри скрытого состояния и не заменять чем-то новым. Следовательно, придется иметь либо очень большое скрытое состояние, либо мириться с потерей информации.\n- Во-вторых, обучение рекуррентных сетей сложно распараллелить: чтобы получить скрытое состояние RNN-слоя для шага $i+1$, вам необходимо вычислить состояние для шага $i$. Таким образом, обработка батча примеров длиной $1000$ должна потребовать $1000$ последовательных операций, что занимает много времени и не очень эффективно работает на GPU, созданных для параллельных вычислений.\n\nОбе этих проблемы затрудняют применение RNN к по-настоящему длинным последовательностям: даже если вы дождетесь конца обучения, ваша модель по своей конструкции будет так или иначе терять информацию о том, что было в начале текста. Хочется иметь способ «читать» последовательность так, чтобы в каждый момент времени можно было обратиться к произвольному моменту из прошлого за константное время и без потерь информации. Таким способом и является лежащий в основе трансформеров механизм self-attention, о котором далее пойдет речь. Как мы узнаем позже, благодаря своей универсальности и масштабируемости этот механизм оказался применим к множеству задач помимо обработки естественного языка.\n\nНиже приведено устройство архитектуры «трансформер» из оригинальной [статьи](https://arxiv.org/pdf/1706.03762.pdf):\n\n![ml_transformery_1_d962e897a7.svg](https://yastatic.net/s3/education-portal/media/ml_transformery_1_d962e897a7_29a7a070f1.svg)\n\nСлева на схеме представлено устройство энкодера. Он по очереди применяет к исходной последовательности $N$ блоков:\n\n![ml_transformery_1_c190108d7e.svg](https://yastatic.net/s3/education-portal/media/ml_transformery_1_c190108d7e_0cf50c39c9.svg)\n\nКаждый блок выдаёт последовательность такой же длины. В нём есть два важных слоя, multi-head attention и feed-forward. После каждого из них к выходу прибавляется вход (это стандартный подход под названием residual connection) и затем активации проходят через слой layer normalization: на рисунке эта часть обозначена как “Add & Norm”. \n\nУ декодера схема похожая, но внутри каждого из $N$ блоков два слоя multi-head attention, в одном из которых используются выходы энкодера.\n\nДавайте подробнее обсудим каждую из составляющих частей этого механизма.\n\n## Слой внимания\n\nПервая часть transformer-блока — это слой self-attention. От обычного внимания его отличает то, что выходом являются новые представления для элементов той же последовательности, что мы подали на вход, причем каждый элемент этой последовательности напрямую взаимодействует с каждым. \n\nЕсли говорить более подробно, то в вычислении внимания для последовательности будет участвовать три обучаемых матрицы $W_Q,\\ W_K,\\ W_V$. Представление $x_i$ каждого элемента входной последовательности мы умножаем на $W_Q,\\ W_K,\\ W_V$, получая вектор-строки $q_i, k_i, v_i$ ($i$ — номер элемента), которые соответственно называются *запросами*, *ключами* и *значениями* (query, key и value). Их роли можно условно описать следующим образом:\n\n- $q_i$ — запрос к базе данных;\n- $k_i$ — ключи хранящихся в базе значений, по которым будет осуществляться поиск;\n- $v_i$ — сами значения.\n\n![queries_keys_values_7a1ffcfa39.webp](https://yastatic.net/s3/education-portal/media/queries_keys_values_7a1ffcfa39_0b5b83a4c4.webp)\n\nБлизость запроса к ключу можно определять, например, с помощью скалярного произведения:\n\n$$\\text{self-attention weights}_i=\\text{softmax}\\left(\\frac{q_ik_1^T}{C},\\frac{q_ik_2^T}{C},\\ldots\\right),$$\n\nгде $C$ — некоторая нормировочная константа. Именно так и делали в исходной статье; в качестве нормировочной константы брался корень $\\sqrt{d_k}$ из размерности ключей и значений. Теперь мы складываем значения $v_i$ с полученными коэффициентами. Это и будет выходом слоя self-attention. В векторизованном виде можно записать:\n\n$$\\text{self-attention}(Q, K, V)=\\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)V,$$\n\nгде $Q$, $K$, $V$ — матрицы запросов, ключей и значений соответственно, в которых по строкам записаны $q_i$, $k_i$, $v_i$, а $\\text{softmax}$ берётся построчно.\n\n### Особенности слоя внимания в декодере\n\nКак мы уже упоминали выше, в декодере один из attention-слоёв является слоем кросс-внимания (cross-attention), в котором запросы берутся из выходной последовательности, а ключи и значения — из входной (то есть из результатов работы энкодера).\n\n![decoder_attention_03be436fa1.webp](https://yastatic.net/s3/education-portal/media/decoder_attention_03be436fa1_b4c942b0ae.webp)\n\nТакже стоит учитывать, что в описанном выше виде внимания каждый токен будет «смотреть» на всю последовательность, что нежелательно для декодера. Действительно, на этапе генерации мы будем порождать по одному токену за шаг, и доступ к последующим шагам на этапе обучения приведёт к утечке информации в декодере и низкому качеству модели. Чтобы избежать этой проблемы, при обучении к вниманию нужно применять авторегрессивную маску, вручную обращая в $-\\infty$ веса до softmax для токенов из будущего, чтобы после softmax их вероятности стали нулевыми. Как можно увидеть на рисунке внизу, эта маска имеет нижнетреугольный вид.  \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/ml_transformery_4_5594f40524_c4d9db63fd.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://nlp.seas.harvard.edu/annotated-transformer/\">Источник</a>\n  </figcaption>\n</figure>\n\n### Multi-head attention\n\nОдин набор $Q$, $K$ и $V$ может отражать только один вид зависимостей между токенами, и матрицы извлекают лишь ограниченный набор информации из входных представлений. Чтобы скомпенсировать эту неоптимальность, авторы архитектуры предложили подход с несколькими «головами» внимания (multi-head attention): по сути вместо одного слоя внимания мы применяем несколько параллельных с разными весами, а потом агрегируем результаты. Рисунок ниже показывает, как выглядит multi-head attention:\n\n![ml_transformery_2_4254512be8.svg](https://yastatic.net/s3/education-portal/media/ml_transformery_2_4254512be8_ffdde2ee96.svg)\n\n### Эффективность\n\nПодход к обработке последовательностей целиком через внимание позволяет избавиться от такого понятия, как скрытое состояние, обновляющееся рекуррентно: каждый токен может напрямую «прочитать» любую часть последовательности, наиболее полезную для предсказания. В частности, отсутствие рекуррентности означает, что мы можем применять слой ко всей последовательности одновременно, так как матричные умножения прекрасно параллелятся.\n\nОднако стоит помнить о затратах памяти и времени: поскольку каждый элемент последовательности взаимодействует с каждым, легко показать, что сложность self-attention составляет $O(n^2)$ по длине последовательности, а простые реализации, формирующие полную матрицу внимания, будут расходовать ещё и $O(n^2)$ памяти. С оптимизацией вычислительной сложности внимания связано множество работ как инженерного, так и архитектурного плана: в частности, есть подходы, которые позволяют сократить время работы self-attention до линейного или существенно уменьшают константы за счёт учёта иерархии памяти GPU.\n\nНапример, на графиках ниже сравнивается время работы и потребление памяти трансформера со стандартным вниманием и с механизмом из [статьи](https://arxiv.org/abs/2004.05150) Longformer:\n\n![longformer_plots_1aa1cd4475.webp](https://yastatic.net/s3/education-portal/media/longformer_plots_1aa1cd4475_cc09216035.webp)\n\n## Полносвязный слой и нормализация\n\nВторая часть трансформерного блока называется feed-forward network (FFN) и представляет собой два обычных полносвязных слоя, применяемых независимо к каждому элементу входной последовательности. В последних архитектурах размер промежуточного представления (то есть выхода первого слоя) бывает весьма большим — в 4 раза больше выходов блока.  \n\nИз-за этого вычислительной стоимостью FFN не стоит пренебрегать: несмотря на квадратичную асимптотику внимания, в больших моделях или на коротких последовательностях FFN может занимать существенно больше времени по сравнению с self-attention. В виде формулы применение FFN можно представить так:\n\n$$\n\\text{FFN}(x)=\\text{act}\\left(xW_1+b_1\\right)W_2+b_2,\n$$\n\nПромежуточные активации $\\text{act}$ в FFN бывают разными: начиналось всё с широко известной ReLU, но в какой-то момент сообщество перешло на [GELU (Gaussian Error Linear Unit)](https://arxiv.org/abs/1606.08415v4) с формулой $x\\Phi(x)$, где $\\Phi$ — функция распределения стандартной нормальной случайной величины.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/ml_transformery_5_e006e36b24_685f47dccb.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Сравнение ReLU, ELU и GELU. <a href=\"https://arxiv.org/abs/1606.08415v4\">Источник</a>\n  </figcaption>\n</figure>\n\nСкажем ещё пару слов о layer normalization: как было показано в [ряде](https://arxiv.org/abs/2002.04745) [работ](https://aclanthology.org/2020.emnlp-main.463/), их положение внутри residual-ветки довольно важно. В стандартной архитектуре используется формулировка PostLN, где нормализация применяется после остаточной связи. Однако такое применение нормализации оказывается довольно нестабильным при обучении моделей с большим числом слоёв: вместо этого предлагается использовать PreLN (справа на рисунке снизу), где нормализация применяется ко входу residual-ветки.\n\n![ml_transformery_6_94683ebb85.svg](https://yastatic.net/s3/education-portal/media/ml_transformery_6_94683ebb85_fc02da13f3.svg)\n\n## Кодирование позиций\n\nВнимательный читатель может заметить, что все операции внутри трансформер-блока, строго говоря, инвариантны к порядку элементов в последовательности. Например, результат внимания зависит от скалярных произведений между эмбеддингами токенов, но расположение этих токенов внутри текста значения не имеет. Таким образом, итоговые представления каждого токена на выходе из модели будут одинаковыми вне зависимости от порядка слов, что вряд ли нас устроит. Как с этим справиться?\n\nНа помощь приходит такая вещь, как позиционные эмбеддинги. Это вспомогательные представления, которые прибавляются к обычным эмбеддингам токенов входной последовательности и позволяют слоям внимания различать одинаковые токены на разных местах.  \n\nИсторически первым подходом были фиксированные эмбеддинги, однозначно кодирующие позицию тригонометрическими функциями (ниже $pos$ — номер позиции, $i$ — индекс элемента в векторе, кодирующем эту позицию, $d$ — размерность эмбеддинга):\n\n$$\n\\begin{align*}\n\\textrm{PE}_{(pos,2i)}&=\\sin\\left(\\frac{pos}{10000^{2i/d}}\\right),\\\\\n\\textrm{PE}_{(pos,2i+1)}&=\\cos\\left(\\frac{pos}{10000^{2i/d}}\\right).\n\\end{align*}\n$$\n\nС момента появления архитектуры «трансформер», однако, появилось множество других способов кодировать позиции токенов. Например, можно просто сделать позиционные эмбеддинги обучаемыми наряду с эмбеддингами токенов. Иной подход — напрямую учесть тот факт, что нам важны не абсолютные позиции токенов, а расстояние между ними, и обучать [*относительные*](https://arxiv.org/abs/1803.02155) позиционные представления: подобный подход заметно улучшает качество на чувствительных к порядку слов задачах, а его более современные [модификации](https://arxiv.org/abs/2108.12409) регулярно используются в самых мощных моделях.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/positional_embeddings_6582114cd8_750074ea6f.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  Позиционное кодирование ALiBi: метод добавляет необучаемые константы к весам внимания в зависимости от расстояния между токенами ключа и значения. \n    <a href=\"https://arxiv.org/abs/2108.12409\">Источник</a>\n  </figcaption>\n</figure>\n\n## Про BERT и GPT\n\nНесомненно, трансформер-модели не были бы так интересны, если бы практически все задачи NLP сейчас не решались бы с помощью этой архитектуры. Главными факторами, повлиявшими на бурный рост популярности идеи self-attention, послужили два семейства хорошо всем известных архитектур — BERT и GPT, которые в некотором роде являются энкодером и декодером трансформера, которые зажили своей жизнью.\n\nМодель **GPT** (**Generative Pretrained Transformer**) хронологически [появилась](https://openai.com/research/language-unsupervised) раньше. Она представляет собой обычную языковую модель, реализованную в виде последовательности слоев декодера трансформера.  \n\nВ качестве задачи при обучении выступает обычное предсказание следующего токена (то есть многоклассовая классификация по словарю). Важно, что в качестве маски внимания как раз выступает нижнетреугольная матрица: в противном случае возникла бы утечка в данных из-за того, что токены из «прошлого» будут видеть «будущее». Полученную модель можно использовать для генерации текстов и всех задач, которые на это опираются. Даже ChatGPT, обученная на специальных инструкциях, по своей сути незначительно отличается от базовой модели.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/ml_transformery_7_24995dbcc6_060b20218a.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Иллюстрация задачи при обучении GPT. <a href=\"https://twitter.com/MishaLaskin/status/1481767762141888512\">Источник</a>\n  </figcaption>\n</figure>\n\nКак понятно из названия, модель **Bidirectional Encoder Representations from Transformers** (или **BERT**) отличается от GPT двунаправленностью внимания: это значит, что при обработке входной последовательности все токены могут использовать информацию друг о друге.  \n\nЭто делает такую архитектуру более удобной для задач, где нужно сделать предсказание относительно всего входа целиком без генерации, например, при классификации предложений или поиске пар похожих документов. Важно, что при этом BERT не учится генерировать тексты с нуля: одна из его задач при обучении — это masked language modeling (предсказание случайно замаскированных слов по оставшимся, изображено на рисунке ниже), а вторая — next sentence prediction (предсказание по паре текстовых фрагментов, следуют они друг за другом или нет).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/bert_a4e464d873_4038d8fbdc.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  Пример masked language modeling.\n  </figcaption>\n</figure>\n\nЗаметим, что самое ключевое отличие в моделях BERT и GPT (а не в задачах для обучения или применениях) можно свести к использованию разных видов внимания, изображенных на рисунке снизу.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/bert_vs_gpt_1d8df8bea4_9539ededda.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  Отличия между вниманием в BERT и GPT. <a href=\"https://arxiv.org/abs/1810.04805\">Источник</a>\n  </figcaption>\n</figure>\n\n## Тонкости обучения\n\nК сожалению, если вы просто напишете код Transformer-нейросети и попробуете сразу обучить что-то содержательное, используя привычные для других архитектур гиперпараметры, то вас с большой вероятностью постигнет неудача. Оптимизационный процесс для таких моделей зачастую требуется изменить, и недостаточное внимание к этому может повлечь за собой существенные потери в итоговом качестве или вообще привести к нестабильному обучению.\n\nПервый момент, на который стоит обратить внимание, — размер батча для обучения. Практически все современные Transformer-модели обучаются на больших батчах, которые для самых больших языковых моделей могут достигать миллионов токенов. Разумеется, ни одна современная GPU не может обработать столько данных за один шаг: на помощь приходят распределенное обучение и чуть более универсальный [трюк](https://sebastianraschka.com/blog/2023/llm-grad-accumulation.html#what-is-gradient-accumulation) с аккумуляцией градиентов по микробатчам.  \n\nТакже в последних статьях зачастую прибегают к [увеличению размера батча](https://openreview.net/forum?id=B1Yy1BxCZ) по ходу обучения: идея заключается в том, что на ранних этапах важнее быстрее совершить много шагов градиентного спуска, а на поздних становится важнее иметь точную оценку градиента.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/training_hours_5890f926f3_0b80856616.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  Размер батча может играть большую роль даже для сравнительно маленьких моделей. <a href=\"https://arxiv.org/abs/1804.00247\">Источник</a>\n  </figcaption>\n</figure>\n\n</figure>\n\nВторой немаловажный фактор — выбор оптимизатора и расписания для learning rate. Обучить трансформер стандартным SGD, скорее всего, не выйдет: в оригинальной статье в качестве оптимизатора использовался Adam, и де-факто он остаётся стандартом до сих пор.  \n\nОднако стоит заметить, что для больших размеров батча Adam порой работает плохо: из-за этого порой приходится прибегать к алгоритмам наподобие [LAMB](https://arxiv.org/abs/1904.00962), нормализующим обновления весов для каждого слоя.\n\n## Трансформеры не для текстов\n\nРазумеется, успех этого семейства архитектур на множестве текстовых задач не мог остаться незамеченным для исследователей в других доменах. Одним из наиболее ярких примеров областей, в которой Transformer-модели нашли новое приложение, несомненно, является компьютерное зрение.  \n\nК примеру, [архитектура](https://arxiv.org/abs/2010.11929) ViT (Vision Transformer) в свое время побила рекорды качества по классификации изображений, задействуя идею self-attention для картинок, разделенных на множество «лоскутных» (patches) сегментов квадратной формы.  \n\nКак пишут авторы статьи, идея использовать Transformer-архитектуру в зрении пришла к ним после наблюдения за успехами таких моделей в NLP: использование такого общего подхода, как self-attention, позволяет избежать необходимости явно закладывать в архитектуру особенности задачи (это ещё называют inductive bias) при достаточном времени обучения, числе параметров и размере выборки.\n\n![Vi_T_c7f1bfbedc.webp](https://yastatic.net/s3/education-portal/media/Vi_T_c7f1bfbedc_e047c467f5.webp)\n\nТакже именно на трансформерах базируется генеративная часть DALL-E — модели, положившей начало активным исследованиям последних лет в генерации изображений по тексту. Концептуально DALL-E довольно проста: её можно рассматривать как авторегрессивную «языковую модель», генерирующую изображение по одному «визуальному токену» за шаг. \n\nПрименяют трансформеры и к обучению с подкреплением: ярким примером является [работа](https://arxiv.org/abs/2106.01345) Decision Transformer, в которой предлагают использовать авторегрессивное моделирование с использованием этой архитектуры для построения агента.  \n\nАвторы показали, что такой же подход, который используют для генерации текстов, можно использовать для предсказания действий в динамической среде: как показано на рисунке ниже, модель последовательно принимает стандартные тройки из закодированных состояний, текущих действий и наград и в качестве ответа на каждом шаге выдаёт следующее действие.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/ml_transformery_8_5f6f1a3105_1ba6071898.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n  Архитектура Decision Transformer. <a href=\"https://arxiv.org/abs/2106.01345\">Источник</a>\n  </figcaption>\n</figure>",
        "handbook": "Учебник по машинному обучению",
        "title": "Трансформеры",
        "description": null
    },
    {
        "path": "/handbook/ml/article/obuchenie-predstavlenij",
        "content": "Объекты, с которыми работает машинное обучение, очень разнообразны и часто состоят из большого количества низкоуровневых сигналов: это может быть цвет отдельного пикселя, амплитуда звукового сигнала в отдельно взятый момент времени или буква в тексте.  \n\nКаждый из таких слабых сигналов в отдельности несёт крайне мало информации про объект, но все вместе слабые сигналы складываются в музыку, изображение или текст.  \n\nВ _сыром_ виде такие объекты сложно анализировать, поэтому наша цель — находить _хорошие_ представления данных, удобные для анализа и решения разных задач. Любой способ построения признакового описания объекта мы будем назвать алгоритмом построения представлений, а настройку такого алгоритма по данным — обучением.\n\nТак, все методы понижения размерности, например, SVD — это методы обучения представлений, а методы обучения представлений часто можно проинтерпретировать как методы понижения размерности. \n\nПредставим, что нам хочется уметь искать похожие музыкальные треки и использовать эту технологию в музыкальном сервисе для функции «играть похожие треки». \n\nКаждый трек в нашей базе хранится в формате WAV с частотой 44kHz и длится 3 минуты. Другими словами, трек будет описываться вектором из 7920000 чисел (44000 Hz * 60 секунд * 3 минуты).\n\nОднако небольшие изменения треков (сдвиг по времени, изменение громкости) могут соответствовать существенному изменению положения вектора представлений в пространстве. Поэтому простые расстояния в таком пространстве, вероятно, не будут отражать представление людей о схожести треков. Искать похожие треки, используя такие, _сырые_ представления, проблематично, и необходимо научится строить представления, с помощью которых будет удобно решать разные высокоуровневые задачи.   \n\nВыученные представления или модели для вычисления представлений можно использовать для:  \n\n- Поиска изображений: по представлению изображения искать похожие изображения. \n- Рекомендаций: по представлениям пользователя определять наиболее интересные фильмы или товары. \n- Чат-ботов: по представлению диалога уметь продолжать диалог, отвечать на вопросы и так далее.\n- Систем видеосвязи: уметь восстанавливать кадры по компактным представлениям, сохраняя высокое качество картинки. \n- и многого другого.\n\nДля каждой из этих задач будут свои хорошо отлаженные трюки, однако ключевых идей, которые часто переиспользуются, повторяются и модифицируются, не очень много. Мы постараемся рассказать про такие идеи. \n\n**Предупреждение:** перед прочтением этой главы стоит освежить в памяти главу про\n<a href=\"https://academy.yandex.ru/handbook/ml/article/nejronnye-seti\">нейронные сети</a>.\n\n## Нейронные сети и выучивания представлений\n\nНейронные сети можно рассматривать, как механизм автоматического выучивания представлений, поэтому современные методы выучивания представлений существенно сконцентрированы на использовании нейросетей.  \n\nНапомним, что нейронная сеть состоит из набора дифференцируемых преобразований, примененных друг за другом к объекту $x$ для получения предсказания целевой переменной $y$. Обычно преобразования содержат обучаемые параметры, которые настраиваются в процессе обучения по данным.  \n\nПреобразования в литературе часто называют слоями. Результат применения преобразования к его входу мы будем называть скрытыми представлениями или активациями.  \n\n### Representations \n\nАктивации любого слоя можно использовать как представления объекта. Представления с разной глубины нейронной сети будут обладать разными свойствами.  \n\nРассмотрим свёрточные нейронные сети для изображений. Активации первых слоёв обычно видят только маленькие части исходной картинки, другими словами, имеют маленький _receptive field_. Такие активации могут реагировать — принимать большие значения — только на низкоуровневые детали, маленькие фрагменты изображения.  \n\nПо мере увеличения глубины receptive field становится больше, а активации начинают реагировать на более высокоуровневые абстракции, такие как формы и части объектов. Активации последних слоёв имеют большой receptive field и реагируют на уже на объекты и группы объектов. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/lecun_feat_level_8318bd67b3_33d314f27b.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://youtu.be/cWzi38-vDbE?t=312\">Источник</a>\n  </figcaption>\n</figure>\n\nНа изображении ниже показаны части картинок (патчи), каждая группа из 9 изображений максимизирует значение определенной активации в обученной нейронной сети. Размер патча зависит от receptive field активации, а максимизация ведется по датасету реальных изображений:  выбираем топ-9 патчей из датасета по значению активации. \n\nДля активаций, взятых с ранних слоев, нейроны реагируют на низкоуровневые детали. По мере увеличения глубины нейроны начинают реагировать на более высокоуровневые объекты.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Zeiler2013_ef78a7d040_4f0d0156c3.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1311.2901\">Источник</a>\n  </figcaption>\n</figure>\n\nБольшая часть методов, которые мы рассмотрим ниже, за исключением матричной факторизации (в зависимости от того, как на это взглянуть), будут использовать активации нейросети в качестве представлений. Поэтому, обучить представления и обучить нейросеть это почти синонимы. Большинство отличий будет состоять в том, как эти нейронные сети обучаются и какую архитектуру имеют. \n\n### Дообучение \n\nНейронные сети можно обучать из случайной инициализации, а можно стартовать с вектора весов, обученного на внешнем датасете.  \n\nК примеру, если вы решаете задачу классификации изображений, часто инициализация части вашей нейронной сети весами, предобученными на популярном датасете ImageNet, ускорит и улучшит обучение.  \n\nТакой процесс называется fine-tuning («дообучение» / «файнтюнинг»):\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/finetune_da81330a6f_e5b55838c9.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://d2l.ai/chapter_computer-vision/fine-tuning.html\">Источник</a>\n  </figcaption>\n</figure>\n\n\nКак можно усложнять эту схему:\n- Добавлять в модель много новых, обучающихся с нуля слоёв (на картинке мы добавляем один, но можно и больше);\n- Не обязательно копировать все слои, можно копировать только сколько-то первых.\n- Дообучать как все веса модели, так и какую-то часть. К примеру, можно заморозить скопированные слои и дообучать только новые части модели.\n- Для файнтюнинга часто используют постепенное увеличение (warm-up) learning rate на первых эпохах обучения. Это позволяет сетке «привыкнуть» к новой задаче и архитектуре. Пример:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/warmup_cosine_schedule_6935e2bddd_d2c763f3ce.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://huggingface.co/transformers/main_classes/optimizer_schedules.html\">Источник</a>\n  </figcaption>\n</figure>\n\n### Prior\n\nВ некотором смысле хорошая инициализация работает как праер на функции, которые могут быть выучены после дообучения.  \n\nПоэтому дообучение часто требует в разы меньше данных, чем обучение со случайной инициализации.  \n\n## Supervised обучение\n\n### Обучение представлений через решение supervised задачи\n\nОбучение представлений через решение supervised задач — это простой и популярный способ обучения представлений. Рассмотрим его на примере задачи поиска изображений (image retrieval) \n\n**Задача**: Рассмотрим задачу поиска изображений. Каждое изображение хочется закодировать вектором признаков (представлением) так, чтобы вектора признаков похожих изображений были близки. \n\n**При чем тут обучение представлений?** Image retrieval часто рассматривается как задача обучения представлений. Хочется получить алгоритм, который по изображению выдаст вектор (представление объекта) так, чтобы близость векторов по какой-то простой (скажем, евклидовой) метрике означала схожесть объектов.  \n\n**Идея**: Возьмём активации с последнего слоя из нейросети, предобученной на большом размеченном датасете. \nДля задач зрения почти всегда имеется ввиду предобучение на задаче классификации. Также мы предполагаем, что высокоуровневая разметка собрана человеком.\n\n**Почему такие представления могут адекватно решать задачу поиска изображений?** Классификационная сеть будет неявно поощрять, чтобы у похожих изображений векторы активаций тоже были близки. К примеру, перед последнем слоем классификационной сети активации кошек и собак должны быть распознаны линейными классификаторами — активации картинок одного класса должны быть близки друг к другу. А за счет похожих паттернов визуально похожие коты будут находиться ближе друг к другу, чем непохожие.\n\n#### Решение\nДля начала нам нужно обучить нейросеть на большом размеченном датасете картинок/текста/звука/... (_pretext problem_)  \n\nОбычно лучше всего работает предобучение на задачах классификации. Почему так происходит? Пока непонятно. Возможно, это связано с тем, что для классификации удобнее собирать датасеты, а возможно это хорошие свойства задачи или CrossEntropy функции потерь.  \n\n- Для изображений часто используется предобучение на датасете [ImageNet](https://www.image-net.org/) — классификация на 1000 классов, 1.3M изображений в обучающей выборке, ~ 150 GiB.  \n- Для текстов, обычно решают задачу языкового моделирования, на набирающем популярность датасет [The Pile](https://pile.eleuther.ai/) ~ 825 GiB.  \n\nЗатем мы дообучаем нейросеть на более похожем на нашу задачу размеченном датасете <span style=\"color:gray\"> (если такой есть; если нет пропускаем этот шаг)</span>.  \n\nПосле — оставляем только первые $L$ слоёв. Aктивации слоя $L$ берём в качестве представлений объектов   \n\nАгрегируем активации по пространственным координатам, чтобы получить _вектор_ для каждого объекта. Часто используется покомпонентное среднее или максимум (скажем, глобальный пулинг для изображений).  \n\nНаконец, используем признаки или предобученные веса для решения целевой задачи (_downstream problem_).\n\n#### Об алгоритме\n\nSupervised подход можно применять для различных типов данных. Всё, что нужно — это большой размеченный датасет, хоть и отдалённо, но похожий на целевые данные. Для музыки это может быть задача классификации жанра, для видео — задача классификация действий, для текста — классификация тематик.\n\n#### Достоинства и недостатки\n\n👍 Благодаря выученным представлениям мы сможем решать целевую задачу, не имея для неё большого датасета;\n👎 Нужен большой размеченный датасет, близкий для целевой задачи;\n👎 Оптимальные представления для датасета, на котором мы предобучаемся, могут сколь угодно плохо подойти для целевой задачи. К примеру, представления, полученные на ImageNet, плохо подойдут для медицинских изображений (<a href=\"https://arxiv.org/abs/1902.07208\">Raghu2019</a>).\n\n#### Эксперименты\n\nНа рисунке ниже показан пример того, как представления помогают решать задачу поиска. Запрос находится в самом левом столбике. Зеленым отмечены верно найденные изображения, красным — неверно найденные, синим — изображения из стоп-листа.\n\nКак видно, система вполне неплохо решает задачу поиска изображений. Подробнее про такой подход для поиска изображений можно почитать в работах  (<a href=\"https://link.springer.com/content/pdf/10.1007/978-3-319-10590-1_38.pdf\">Babenko 2014</a>, <a href=\"https://openaccess.thecvf.com/content_iccv_2015/papers/Babenko_Aggregating_Local_Deep_ICCV_2015_paper.pdf\">Babenko 2015</a>). \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/babenko2015_140d789f33_4d5d979f52.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://openaccess.thecvf.com/content_iccv_2015/papers/Babenko_Aggregating_Local_Deep_ICCV_2015_paper.pdf\">Источник</a>\n  </figcaption>\n</figure>\n\n#### Советы\n\n<a href=\"https://arxiv.org/abs/1912.11370\">Статья</a> Big Transfer (BiT): General Visual Representation Learning (Kolesnikov at el. 2019) даёт ряд важных советов, о том, на что именно стоит обратить внимание при supervised обучении c целью переноса представлений и весов модели на новые задачи.\n\nРассмотрим их подробнее.\n\n- **Большие и разнообразные датасеты**: Увеличение размера pretex-датасета вносит существенный вклад в качество решения downstream задачи. Авторы продемонстрировали, что при предобучении переход от 1М изображений (ImageNet) к 14М изображений (ImageNet21k) к 300M изображений (JFT), стабильно улучшает качество дообучения на новой задаче с маленьким числом размеченных примеров. Да, тут мы заходим на территорию, когда ImageNet рассматривается как маленький датасет. \n\n- **Большие pretext модели**: Увеличение датасета при недостаточном размере модели может навредить. Нужно одновременно иметь большие модели и большие датасеты. Одно из возможных объяснений такое: с увеличением датасета модель должна предсказывать правильные ответы на трейне для огромного числа точек. При этом нельзя работать очень плохо хоть на каких-то точках, ведь когда гибкости недостаточно, моделька настраивается «так себе» во многих областях пространства, что может ухудшить финальное качество алгоритма.    \n- **Долгое обучение**: Большие модели требуют много шагов оптимизации.  \n\n{% cut \"Оговорка\" %}\n\nБольшие модели часто учатся на десятках, сотнях или даже тысячах вычислителей, таких как GPU и TPU, и требуют много памяти для обучения. Как правило, это происходит из-за большого размера моделей: на один вычислитель часто помещаются только маленькие минибатчи (1-10 примеров). Маленькие минибатчи работают плохо с популярной Batch Normalization или требуют дорогой синхорнизации между вычислителями. \n\nВ статье [(Kolesnikov at el. 2019)](https://arxiv.org/abs/1912.11370) Batch Normalization заменяется на Group Normalization, которая позволяет использовать батчи маленького размера на каждом отдельном вычислительном девайсе.<a href=\"https://paperswithcode.com/method/group-normalization\"> Group Normalization </a> используется в комбинации c <a href='https://paperswithcode.com/method/weight-standardization'> Weight Standardization </a>, что позволяет улучшить обучение.\n\n{% endcut %}  \n\n### Обучение метрических эмбедингов с использование разметки (triplet loss)\n\n**Мотивация:** После supervised обучения расстояния между эмбеддингами не обязаны хорошо отражать треубуемую для решения нашей задачи _«похожесть»_. Поэтому хочется, чтобы _«похожесть»_ моделировалась известным расстоянием (к примеру евклидовым).\n\nДля этого была [предложена](https://arxiv.org/abs/1503.03832) триплетная фунция потерь или **triplet loss** (Schroff at el. 2015). Триплетный лосс обучается на тройках объектов (якорный объект, негативный к якорному, позитивный к якорному). Информация о позитивных и негативных объектах – это один из видов разметки. Этот лосс может использоваться как для обучения с нуля, так и для дообучения.  \n\nОтметим, что объекты не обязательно должны быть из одного домена: к примеру, якорный объект может быть картинкой, а позитивные и негативые объекты текстами. Таким образом, мы сможем находить «подходящие» тексты к картинкам и наоборот. \n\n#### Как будет устроено обучение\n\n- рассмотрим тройки объектов $(\\text{obj}_i,  \\text{pos}_i, \\text{neg}_i)$, где $\\text{pos}_i$ — позитивный пример к $\\text{obj}_i$, $\\text{neg}_i$ — негативный пример к $\\text{obj}_i$\n- будем притягивать $emb(\\text{obj}_i)$ и $emb(\\text{pos}_i)$ и отталкивать $emb(\\text{obj}_i)$ и $emb(\\text{neg}_i)$\n- одним из популярных лоссов для решения такой задачи является triplet loss:\n\n$$L=\\sum_i^N\\left[\\left\\|emb_\\theta(\\text{obj}_i)-emb_\\theta(\\text{pos}_i)\\right\\|_2^2 - \\left\\|emb_\\theta(\\text{obj}_i)-emb_\\theta(\\text{neg}_i)\\right\\|_2^2+\\alpha\\right]_+.$$\n\n- $emb$ представляется нейронной сетью $emb_\\theta(\\cdot)$\n- $\\alpha$ — параметер зазора — в некотором смысле усложняет задачу:\n\t- при $alpha=0$ достаточно, чтобы позитивный эмбединг был ближе якорному, чем негативный;\n\t- с параметром $alpha=0.5$ мы начинаем требовать, чтобы позитивный был ближе, чем негативный, как минимум на $0.5$.\n- лосс $L$ оптимизируем по параметрам $\\theta$.\n\n![triplet_15aa014e42.webp](https://yastatic.net/s3/education-portal/media/triplet_15aa014e42_01339a3157.webp)\n\n{% cut \"Почему бы просто не притягивать позитивные примеры? Нужны ли нам негативные?\" %}\n\nЕсли будем только притягивать, то любой константный вектор будет хорошим решением. К примеру $emb(x) = [1,\\dots, 1]$.\n\n{% endcut %}  \n\n#### Алгоритм формирования троек\n\nОбучение с триплет лоссом сильно зависит от алгоритма формирования троек. \nЕсли формировать тройки случайно, то большинство троек будут слишком легкими, не информативными. Негативные объекты будет слишком легко отличить от позитивных, поэтому обучающего сигнала от таких троек будет мало. \n\nПоэтому хочется собрать наиболее сложные тройки из всех объектов в датасете или минибатче.  \n\nТакой процесс называется hard negative/positive mining и часто используется для обучения с триплетной функцией потерь. \n\n🧪 **_Примеры_**:\n#### Примеры\n- Диалоговая система: \n  - $\\text{obj}_i$ — фраза;\n  - $\\text{pos}_i$ — подходящий ответ;\n  - $\\text{neg}_i$ — ответ не в тему.\n- Верификация лица: \n  - $\\text{obj}_i$ — лицо которое хотим верифицировать;\n  - $\\text{pos}_i$ — тот же человек, что и в $\\text{obj}_i$, но с других ракукрсов, в другом освещении, ...;\n  - $\\text{neg}_i$ — лица других людей.\n\n![triplet_2_dea8ab1697.webp](https://yastatic.net/s3/education-portal/media/triplet_2_dea8ab1697_0f2d5e2fa5.webp)\n\n#### Достоинства и недостатки\n\n👍 Обучение метрических эмбедингов (metric learning), в отличие от supervised подхода, использует информацию о метрике, что позволяет выучить более релевантные представления для целевой задачи. \n\n👎 Все еще требует разметки (на тройки объектов).\n\n👎 Обучение с триплетным лоссом часто ведет себя нестабильно (еще нестабильнее, чем обучение нейросетей для других задач).\n\n## Self-supervised обучение\n\nВ этом разделе мы хотим показать, что нейронные сети и представления можно предобучать без рукотвороной разметки.  \n\n**_Мотивация_** Мы разобрали supervised предобучение нейронных сетей и их использование для извлечения признаков. Однако supervised подходы не всегда эффективны. Supervised обучение требует больших размеченных датасетов. \n\nРазметка данных — это трудоёмкий и дорогой процесс, на выходе от которого всё равно получается шумная, и зачастую смещенная разметка. Поэтому от ручной разметки данных хочется уйти или хотя бы постараться её минимизировать. \n\nЭтого можно добиться, если научиться использовать неразмеченные данные для предобучения. Неразмеченные данные генерируются в огромном количестве, и их значительно проще собирать. Это позволит нам обучаться на  **огромных** коллекциях данных, размер которых был бы недостижим при необходимости сбора разметки.  \n\nТакже в каждом объекте, изображении, звуке или тексте содержится **в разы больше информации, которую можно учитывать при обучении**, чем закодировано в одном таргете.  \n\nК примеру, один из тысячи классов можно закодировать всего десятью битами, а изображение содержит мегабайты внутренней полезной информации, котрую можно использовать для обучения. Поэтому подходы, которые могут обучаться без разметки, но с использованием внтурненнией информации, потенциально могут выучивать более хорошие представления, чем supervised подходы. \n\n💡Основная идея self-supervised обучения — обучение через решение синтетических supervised задач (pretext problems), источником разметки в которых является сам объект (текст, изображение, или видео). Отсюда и приставка \"self\" в названии подхода.\n\n### Примеры pretext задач\n\n1. предсказание объекта по его компактному описанию;\n2. предсказание слова по контексту;\n3. предсказание закрытой части изображения по открытой;\n4. предсказание будущих кадров по прошлым. \n\nЕсли всё это кажется вам supervised-задачами, вы правы! Приставлка self- означает отсутствие внешней разметки.\n\nПризнаки и веса, выученные для решения, казалось бы, бесполезных pretext задач, на практике работают как очень хороший претрейнинг для решения supervised задач (downstream problems). Это позволяет достигать отличного качества, используя в сотни раз меньше размеченных данных по сравнению с чисто supervised подходами. \n\nОсталось ответить на вопрос: какие pretext задачи использовать?  \n\nУниверсального ответа нет, но оказывается, что многие pretext задачи используют контекст для обучения. Подробнее об этом расскажем далее.\n\n### Использование контекста для обучения\n\nПочему контекст так важен для обучения? Обучение людей, как и обучение алгоритмов, неразрывно связано с использованием контекста.  \n\nПри изучении иностранного языка часто прибегают к упражнениям вида «Вставте правильные слова в текст». Чтобы выполнить такое упражнение, человеку нужно учитывать контекст и предсказывать значения незнакомых слов, если это необходимо для понимания текста. \n\n![context_lang_9296220c0c.webp](https://yastatic.net/s3/education-portal/media/context_lang_9296220c0c_8b99244d22.webp)\n\nПредложенная профессором Южно-Калифорнийского университета [Стивином Крашенйном](https://en.wikipedia.org/wiki/Stephen_Krashen) «гипотезы входного материала» (input hypothesis) предполагают, что для эффективного изучения языка человеку нужно читать и слушать текст, который немного превышает его текущий уровень. Скажем, содержит 10-15% незнакомых слов, но при этом остается понятным. Такой способ обучения требует восстановления значения незнакомых слов из контекста.\n\nВизуальный контекст также широко используется при обучении детей. Вы можете помнить упражнения, в которых нужно было найти лишний предмет, закончить рисунок или раскрасить изображение. Такие задания требуют учета визуального контекста для решения задачи: важно уметь понимать принадлежность разных рисунков к одной группе, генерировать изображение, наблюдая только некоторую его часть и так далее. \n\n![context_vison_56ec078727.webp](https://yastatic.net/s3/education-portal/media/context_vison_56ec078727_cc7f1cfa3b.webp)\n\nSelf-supervised обучение представлений и моделей глубокого обучения использует похожие идеи обучения из контекста. \n\nК примеру, модель  word2vec [(Mikolov et al. 2013)](https://arxiv.org/abs/1301.3781) и BERT [(Devlin et al. 2018)](https://arxiv.org/abs/1810.04805) выучивают эмбединги слов, решая задачу предсказания слов по контексту. С философией word2vec вы уже познакомились в [параграфе](https://academy.yandex.ru/handbook/ml/article/beta-nejroseti-dlya-raboty-s-posledovatelnostyami) про нейросети для работы с последовательностями.\n\nА некоторые модели для картинок решают пазлы [(Doersch](https://arxiv.org/abs/1505.05192), [Noroozi et al. 2017)](https://arxiv.org/abs/1603.09246), дополняют изображения или звуки [(van den Oord et al. 2018)](https://arxiv.org/abs/1807.03748), раскрашивают фотографии [(Zhang et al. 2016)](https://arxiv.org/abs/1603.08511) и ищут похожие объекты [(Chen et al. 2020)](https://arxiv.org/abs/2002.05709). \n\nПоследнюю из них — SimCLR – мы подробно разберём ниже. \n\n### Self-supervised предобучение для изображений \n\nSimCLR — метод, который первым продемонстрировал, что self-supervised предобучение может достигать того же качества что и supervised обучение.  \n\nОн основан на контрастивной функции потерь (**contrastive loss**), и в некотором смысле решает задачу поиска похожих объектов.  \n\nТакже мы разберем метод self-supervised предобучения для vision tranformer, который, в некотором смысле, дорисовывает картинку, а также демонстрирует, что методы self-supervised предобучения для изображений и текстов во многом похожи.  \n\nСтоит отметить, что pretext задачи, которые мы будем обсуждать ниже, не являются «серебряной пулей».  \n\nИзвестно, что такие задачи работают как хороший претрейнинг. Другими словами, позволяют получить хорошее качество для некоторых downstream задач (классификация, детекция, сегментация) после дообучения на небольшом количестве размеченных примеров.  \n\nХорошего понимания, почему эти методы работают, в области пока нет. Скорее всего, разные типы задач (downstream problems) будут требовать разных методов претрейнинга, но это мы поймём только в ближайшие несколько лет. \n\n#### A Simple Framework for Contrastive Learning of Visual Representations (SimCLR)\n\nSimCLR решает синтетическую задачу поиска похожих  изображений. Вот как он работает на верхнем уровне:  \n\n1. Для каждого изображения в минибатче генерируются две аугментации;\n2. Выбирается одно из изображений; одна из его аугментаций считается запросом, вторая — позитивным ответом, аугментации остальных объектов — негативными примерами;\n3. Цель модели — для каждого «запроса» найти позитивный пример.  \n4. Выученные веса могут быть использованны для «дообучения»/«файнтюнинга» сети под финальную задачу.  \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/simclr_simple_80aaea53a0_073ffd6638.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Иллюстрация задачи SimCLR для одного запросса из минибатча\n  </figcaption>\n</figure>\n\n{% cut \"А вот как работает SimCLR на низком уровне\" %}\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/simclr_3ee8844008_a6cda5e945.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://generallyintelligent.ai/understanding-self-supervised contrastive-learning.html\">Источник</a>\n  </figcaption>\n</figure>\n\n\n{% endcut %}\n\n#### Лосс \n\nSimCLR оптимизирует контрастив лосс (contrastive loss), который фактически является кросс энтропией на positive-negative разметке:\n\n$$L_{positive}^{query}=-log\\frac{\\exp\\left(sim(emb(query),emb(positive))\\right)}{\\sum_{z\\in\\mathrm{Neg}(query)}\\exp\\left(sim(emb(query),emb(z))\\right)},$$\n\nгде $sim(\\cdot,\\cdot)$ — это косинусное расстояние, a лосс $L$ работает следующим образом: \n\n- Контрастивная функция потерь $L_{positive}^{query}$ притягивает друг к другу эмбединги запроса $emb(\\color{#5180e6}{\\textit{query}})$ и позитивного примера $emb(\\color{#72bd44}{\\textit{positive}})$, в то же самое время отталкивая эмбединги негативных примеров $emb(\\color{#fd0007}{z})$;\n- Максимум $sim(\\color{#5180e6}{\\textit{query}}, \\color{#72bd44}{\\textit{positive}})$ будет достигается в точке $\\color{#5180e6}{\\textit{query}}=\\color{#72bd44}{\\textit{positive}}$, поэтому эмбединги аугментаций одной и той же картинки будут притягиваться;\n- Знаменатель требует, чтобы негативные эмбединги были далеко от запроса.\n\n**Интуиция**: На контрастивную функцию потерь можно смотреть как на поиск ответа по запросу, который ведется только среди всех эмбедингов в текущем минибатче. Такая задача требует сохранения информации про контент на изображении (что, вообще говоря, не очень просто) и в то же время понижения размерности, так как эмбединги $f(\\cdot)$ обычно имеют сравнительно низкую размерность. \n\n**Размер минибатча**: Размер минибатча влияет на количество отрицательных примеров. Чем больше отрицательных примеров — тем более сложную задачу мы ставим перед нейросетью. Существует некоторый баланс между сложностью задачи и качеством выученных представлений. Слишком простые задачи (то есть маленькие батчи) обычно не позволяют выучить хороших представлений: простая задача может хорошо решаться даже с помощью «плохих» представлений. Поэтому SimCLR обучается хорошо только на очень больших мини-батчах (с тысячами примеров). \n\n#### Что нам нужно иметь перед началом обучения\n\n- неразмеченный датасет изображений $X = {x_0, ..., x_N}$\n- операцию аугментации изображения $aug(x_j)$\n- энкодер $f_\\theta(\\cdot): Image \\to R^M$ (типичные значения M~2048)\n- проекция $g_\\psi(\\cdot): R^M \\to R^K$  (типичные значения K~128)\n\n✍️ В примере сверху $emb (x) = g \\odot f (x)$\n\n#### Как мы обучаемся\n\n1. Семплируем мини-батч объектов $\\hat{Х} \\sim X$;\n\n2. Для каждого объекта в минибатче $\\hat{Х}$:  \n\t— Cемплируем две аугментации ${v}_i, {v^\\prime}_i = aug(\\hat{Х}_i), aug(\\hat{Х}_i)$;  \n\n\t— Вычисляем эмбединги $y_i, y^\\prime_i =  f_\\theta(v_i), f_\\theta(v^\\prime_i)$;  \n\n\t— Вычисляем проекции  $z_i, z^\\prime_i =  g_\\psi(v_i), g_\\psi(v^\\prime_i)$;  \n\n3. Вычисляем contrastive loss $\\mathcal{L}=\\sum_i l^{z_i}_ {z^\\prime_i} + \\sum_i l^{z^\\prime_i}_{z_i}$, используя $sim(\\cdot,\\cdot) = \\frac{u^Tv}{\\|\\|u\\|\\|\\ \\|\\|v\\|\\|}$.\n\n\t$$l_p^q=-log\\frac{\\exp(sim(q,p))}{\\sum_{z_i,z_i'\\neq q}[\\exp(sim(q,z_j))+\\exp(sim(q,z_j'))]}$$\n\n\t— В $\\mathcal{L}$ два слагаемых из-за того, что в паре (изображение, аугментация), вообще говоря, любой элемент можно выбрать в качестве запроса (другой тогда будет позитивным примером). Тем самым из одного мини-батча картинок мы можем сделать два мини-батча для обучения SimCLR.  \n\n\t— Функция потерь $\\mathcal{L}$ вычисляется для низкоразмерных проекций $z_i, z^\\prime_i  \\in R^K$.\n\n4. Делаем шаг по градиенту $\\nabla_{\\theta,\\psi} \\mathcal{L}$, повторяем с шага 1 пока не сойдёмся; \n\n5. Используем $f_{\\theta}(\\cdot)$ для генерации эмбедингов или файнтюнинга под supervised задачу. \n\n#### Почему это вообще работает?\n\nТочно никто не знает, но приведем следующую гипотезу:\n\nКонтрастивная функция потерь требует различать аугментации разных изображений. При этом эмбеддинги должны содержать информацию о контенте изображения, чтобы осуществлять поиск аугментаций одинаковых изображений по ключу. Этот процесс позволяет создать представления изображений, сохраняющие достаточно много информации про контент, чтобы решать не только задачу поиска аугментаций, но и другие задачи.\n\n#### Результаты\n\nПретрейнинг, который мы обсудили выше, позволяет эффективно дообучать модели и получать качество, сравнимое с supervised обучением, используя в 100 раз меньше размеченных примеров. \n\n![simclrv2_7e663fa0ad.PNG](https://yastatic.net/s3/education-portal/media/simclrv2_7e663fa0ad_88ce6f57eb.PNG)\n\nОговорка в том, что эти результаты получены второй весрсией метода SimCLRv2 [(Chen at. el, 2020)](https://arxiv.org/pdf/2006.10029.pdf).\nSimCLRv2 TLDR; модели больше, глубже сеть проекции, улучшение качества происходит за счет дистиляции.\n\n\n{% cut \"Немного вопросов и ответов про SimCLR\" %}\n\n**Какие аугментации выбрать?** \n\nАвторы предлагают использовать resize random crop, random flip, color distortions, Gaussian blur. Такая комбинация была найдена небольшим перебором. Для разных данных оптимальный набор аугментаций может получаться разным.\n\t\n![sim_clr_augs_e5e2164aa3.PNG](https://yastatic.net/s3/education-portal/media/sim_clr_augs_e5e2164aa3_6de7de26af.PNG)\n\n**Сложно ли такое учится?**\n\nДа, но сложности в основном технические. Вы быстро оказываетесь наедине c размером батча 2048 на ImageNet (не забудьте ещё, что на каждую картинку 2 аугментации, поэтому реальный размер батча 4048). Даже с не самой большой сеткой, например, ResNet50 (25М параметров) приходится использовать не один десяток ГПУ с 32 Гб памяти в каждой и долго ждать, пока всё обучится. Процесс чтения 2k картинок с диска тоже может занимать намного больше времени, чем вы предпологали, а одновременное вычисление 4k аугментаций быстро создает bottleneck в CPU. Но если у вас много GPU, батч успевает грузиться быстро, и аугментации не упираются в CPU, так что основные сложности позади.  \n\n**Можно ли обойтись без contrastive loss/негативных примеров?** \n\nДа можно: так делают авторы [статьи](https://arxiv.org/pdf/2006.07733.pdf) \"Bootstrap your own latent: A new approach to self-supervised Learning\" (Grill et al.). Но пока метод достаточно новый, и его рано добавлять в учебник. Если вам очень хочется узнать про этот метод, рекомендуем посмотреть разбор с анализом на [канале](https://youtu.be/YPfUiOMYOEE) Yannic Kilcher.\n\n{% endcut %}  \n\n#### Vision Transformer и BERT-like обучение\n\nОдна из самых популярных self-supervised задач в NLP — это предсказание замаскированных токенов (masked tokens prediction [Devlin at el. 2019](https://arxiv.org/pdf/1810.04805.pdf)). При обучении такая модель (обычно transformer) видит текст, в котором некоторые токены заменены на специальный токен [MASK]; задача модели — правильно предсказать замаскированные токены по контексту.  \n\nОказывается, такой претрейнинг позволяет очень хорошо адаптировать модель для решения разных задач, таких как классификация текстов, используя при этом мало размеченных примеров. \n\n{% cut \"Оговорка\" %}\n\nНа самом деле, модель будет способна не только предсказывать замаскированные токены, но и для оригинальных предсказывать «более логичные», на её взгляд замены: например, с её помощью можно исправлять опечатки. Это можно использовать на этапе обучения модели, чтобы показывать ей, что токена [MASK] может и не быть в тексте. Это может оказаться полезным на этапе файнтюнинга, где уже нет маскировки токенов.  \n\nПодробнее про Transformer, BERT, и masked tokens prediction можно прочитать в курсе [NLP for You](https://lena-voita.github.io/nlp_course.html).\n \n{% endcut %}\n\nМожно ли использовать такой self-supervised подход для изображений? Оказывается, что да! В этом помогает vision transformer.\n\nВ последнее время модели на основе **vision transformer** (ViT) [(Dosovitskiy at el. 2020)](https://arxiv.org/pdf/2010.11929.pdf) бурно развиваются и  компьютерного зрения. \n\n![vit_6c038fe6ea.webp](https://yastatic.net/s3/education-portal/media/vit_6c038fe6ea_eb16e4b2cc.webp)\n\nВ supervised режиме для задачи классификации vision transformer обучается следующим образом:\n1. Изображение нарезается на квадратные патчи одинакового размера;\n2. Затем патчи вытягиваются в последовательность;\n3. Каждый патч вытягивается в столбец пикселей;\n4. Каждый стобец проецируется обучаемой матрицей; \n5. К каждому вектору с шага 4 добавляются positional encoding (без позиционных эмбеддингов трансформер не учитывает позицию токена в последовательности, а positional encoding кодирует позицию токена и позволяют трансформеру учитывать эту информацию);\n6. Векторы с шага 5 подаются в трансформер;\n7. Классификационный токен на выходе предсказывает распределение на классы;\n8. Вычисляется кросс-энтропия, делается шаг по её градиенту.\n\nViT не используют локальные операции, такие как свёртки. Как следствие, такие модели требуют заметно больше данных и параметров для обучения (300M изображений по сравнению со стандартным размером размеченного датасета 1.3М). Но оказывается, что **BERT-like self-supervised обучение применимо и для моделей vision transformer**, и позволяет обучать их без использовния гиганских датасетов. \n\nКакие self-supervised задачи на замаскированных патчах решают авторы статьи:\n1. Предсказание среднего цвета в замаскированном патче;\n2. Предсказание патча низкого разрешения и одновременное предсказание цвета;\n3. Предсказание патча высокого разрешения разрешение с использованием $L^2$-лосса.\n\nВо всех случаях обучается и файнтюнится вся сеть целиком. Этот интересный пример показывает, что pretext-задачи придуманные, для NLP-сетей могут быть применены и к задачам зрения.  \n\n## Послесловие\nГлубинное обучение — в существенной степени наука о представлениях сложных объектов. В этом параграфе мы лишь слегка затронули несколько важных тем: supervised предобучение, self-supervised предобучение, и metric learning. Self-supervised предобучение — это важный новый раздел глубинного обучения, который,  вероятно, поможет серьезно сократить количество необходимой разметки во многих приложениях. Генеративные модели VAE/inverse-GANs также широко используются для получения и обработки представлений. О них вы сможете прочитать в следующих параграфах. \n\n## Почитать по теме\n1. [Contrastive Representation Learning](https://lilianweng.github.io/lil-log/2021/05/31/contrastive-representation-learning.html), Lilian Weng, May 2021.\n2. [Self-Supervised Representation Learning](https://lilianweng.github.io/lil-log/2019/11/10/self-supervised-learning.html), Lilian Weng, Nov 2019.\n3. [Самообучение (Self-Supervision)](https://dyakonov.org/2020/06/03/%D1%81%D0%B0%D0%BC%D0%BE%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-self-supervision/), Александр Дьяконов, Июнь 2020.\n4. [_Self-Supervised Learning \\| ICLR_](https://youtu.be/8TTK-Dd0H9U), Yann LeCun, May 2020.\n5. [_Self-Supervised Learning \\| UC Berkeley, CS294-158 Deep Unsupervised Learning_](https://youtu.be/dMUes74-nYY), Aravind Srinivas, Spring 2020.\n6. [_Unsupervised Representation Learning \\| DeepMind x UCL_](https://youtu.be/f0s-uvvXvWg).",
        "handbook": "Учебник по машинному обучению",
        "title": "Обучение представлений",
        "description": "Обучение представлений"
    },
    {
        "path": "/handbook/ml/article/distillyaciya-znanij",
        "content": "В этом параграфе вы познакомитесь с продвинутой техникой машинного обучения, получившей название дистилляции знаний. Дистилляция знаний (knowledge distillation) — это способ обучения в первую очередь нейросетевых моделей машинного обучения, направленный на передачу знаний от модели-учителя к модели-ученику.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_30_f40ffa108f_4980246392.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/2006.05525\">Источник</a>\n  </figcaption>\n</figure>\n\nСлишком абстрактное определение? Соглашусь, но в последние годы дистилляция знаний как поле исследований сильно разрослась и стала включать в себя множество новых и, возможно, даже неожиданных сценариев применения. Так, авторы [статьи 2020 года](https://arxiv.org/abs/2006.00555) утверждают, что смогли добиться примерной инвариантности выходов полносвязной сети к сдвигу входа-картинки с помощью дистилляции в неё знаний из сверточной сети.  \n\nТаким образом получается, что дистилляция знаний может применяться для того, чтобы передавать так называемые inductive biases от одной сети к другой. Схожие доводы встречаются и в статьях безумно популярного на момент написания данного параграфа направления трансформеров для компьютерного зрения.  \n\nТак, использование дистилляции знаний [оказалась](https://arxiv.org/abs/2012.12877) важным компонентом для получения хорошего качества предсказания на ImageNet от ViT без использования дополнительных данных. Впоследствии данный подход [использовался](https://arxiv.org/abs/2104.01136) и в других трансформерах для компьютерного зрения, например, в LeViT.\n\nТем не менее, среди всего разнообразия применений дистилляции знаний наиболее ярко выделяется одно — сжатие моделей.\n\n## Сжатие моделей\n\nЗадача сжатия моделей проистекает из следующего наблюдения. Неоднократно было замечено, что в широком диапазоне практически значимых задач машинного обучения точность предсказания модели существенно зависит от её размера. При этом зачастую данная зависимость выглядит достаточно тривиально: последовательное увеличение размеров модели позволяет последовательно улучшать точность её предсказаний.  \n\nОднако такой безграничный рост приводит к ряду проблем, связанных с практическим применением итоговых моделей. Сюда относятся рост времени обучения больших моделей и повышенные аппетиты таких моделей к размерам и качеству обучающей выборки. Кроме того, большие модели нередко требуют более дорогостоящего вычислительного оборудования для эффективного применения, особенно если мы говорим об обработке большого количества запросов в сжатые сроки. А для некоторых сценариев, таких как предсказание в реальном времени и/или на мобильных устройствах, применение большой модели может оказаться вовсе невозможным.\n\nЭти проблемы породили каждая свою ветвь исследований. Так в последние годы де-факто стандартным способом обучения даже относительно компактных моделей стало использование mixed-precision training, которое позволяет ускорить обучение более или менее любых сетей на современных графических процессорах, при этом практически без потерь в итоговом качестве. Для борьбы с недостатком обучающих данных была предложена целая плеяда методов self-supervised pretraining, и новые появляются до сих пор. Сжатие моделей же концентрируется на решении проблем, связанных с этапом применения уже обученных моделей.\n\nКак можно догадаться из названия, задача сжатия моделей заключается в том, чтобы взять большую модель, и сжать её в как можно более компактную модель при этом по возможности минимально пожертвовав качеством предсказания.  \n\nИсторически задачу сжатия моделей пытались решать множеством разных способов. Классическим примером здесь может служить прунинг, где модель обучается специальным образом (например, с использованием L2 регуляризации) так, чтобы часть весов в итоге можно было занулить и исключить из итоговой модели.  \n\nОднако методы данного семейства, как правило, страдают от двух основных проблем.  \n\n- Во-первых, простое удаление части весов каждого из слоёв обычно показывает лишь незначительное ускорение в применении итоговой модели за исключением случаев использования специализированной аппаратуры\n- Во-вторых, наивный прунинг нередко приводит к существенной просадке в качестве предсказания сжатой модели, причём соотношение степени сжатия и качества итоговой модели едва ли возможно контролировать. Чтобы обойти данные ограничения, и была предложена техника дистилляции знаний.\n\n## Хинтоновская дистилляция знаний\n\nПервой статьёй, в которой можно встретить дистилляцию знаний в современном виде является [статья](https://arxiv.org/abs/1503.02531)  Хинтона и др. 2014 года. \n\nВ ней авторы рассматривают задачу классификации картинок и предлагают использовать предсказания большой заранее обученной модели-учителя в качестве новой, *мягкой*, разметки, которую будет пытаться повторить компактный ученик. \n\n### Формулировка\n\nАвторы предлагают использовать дивергенцию Кульбака-Лейблера между предсказаниями учителя и ученика в качестве дополнительного слагаемого к стандартной функции потерь — кросс-энтропии между предсказанием ученика и *жёсткой* разметкой:\n\n$$\n\\mathcal{L}_{KD} = \\frac1N \\sum_{i=1}^N \\left( - \\sum_{j=1}^K y_{ij} \\log p_{ij} + \\lambda D_{KL}(\\mathbf{p}_i \\| \\mathbf{q}_i) \\right) =\n$$\n\n$$\n= \\frac1N \\sum_{i=1}^N \\left( - \\sum_{j=1}^K y_{ij} \\log p_{ij} + \\lambda \\sum_{j=1}^K q_{ij} \\log \\frac{q_{ij}}{p_{ij}} \\right) \\sim\n$$\n\n$$\n\\sim - \\frac1N \\sum_{i=1}^N \\left( \\sum_{j=1}^K y_{ij} \\log p_{ij} + \\lambda \\sum_{j=1}^K q_{ij} \\log p_{ij} \\right)\n$$\n\nЗдесь через $\\mathcal{L}_{KD}$ обозначена функция потерь для дистилляции знаний. Под $N$ подразумевается число объектов, а под $K$ — классов, представленных в обучающей выборке. Через $y_{ij}$ обозначена жёсткая разметка:\n\n$$\ny_{ij} = \\begin{cases}\n1, & \\text{если $i$-ый объект принадлежит $j$-ому классу}, \\\\\n0, & \\text{в противном случае}.\\end{cases}\n$$\n\nЧерез $p_{ij}$ обозначены вероятности классов, предсказанные моделью-учеником, а через $q_{ij}$ — моделью-учителем. Коэффициент $\\lambda$ позволяет настраивать баланс между решением исходной задачи и повторением предсказаний учителя.\n\nВ последнем переходе учтено, что логарифм частного раскладывается в разность логарифмов, после чего один из членов можно исключить, поскольку он не зависит от оптимизируемых значений $p_{ij}$. В дальнейшем для упрощения выкладок под $\\mathcal{L}_{KD}$ будет подразумеваться именно последнее выражение.\n\n### Мотивация\n\nСвой выбор функции потерь авторы мотивируют следующим образом. Широко известным фактом является то, что при классификации картинок на достаточно больших и разнообразных датасетах большие нейронные сети стабильно показывают лучшие результаты по сравнению с компактными. Однако также хорошо известно, что даже сравнительно небольшие нейронные сети способны приближать очень широкий спектр функций.  \n\nВ таком случае можно предположить, что проблема обучения компактных сетей заключается не в том, что компактная модель не способна приблизить ту же функцию, что и большая, а в том, что компактная модель не способна самостоятельно выучить данную функцию из исходных данных. В таком случае потенциально мы можем подтолкнуть компактную модель к выучиванию более информативного представления путем модификации функции потерь.  \n\nКак этого добиться? Давайте возьмем заведомо более информативное представление, выученное большой моделью-учителем, и добавим в функцию потерь слагаемое, которое будет учить модель-ученика повторять его. В случае решения задачи классификации KL-дивергенция является именно таким слагаемым.\n\nЕсть и другой способ взглянуть на хинтоновскую дистилляцию знаний. Минимизация $\\mathcal{L}_{KD}$ отличается от стандартного обучения, тем, что мы дополнительно минимизируем расстояние между предсказаниями ученика и учителя. От стандартной разметки такая целевая переменная отличается наличием так называемых *теневых знаний* (dark knowledge), которые состоят из вероятностей принадлежности объекта ко всем классам, помимо истинного.  \n\nБлагодаря теневым знаниям модели-ученику во время обучения доступна дополнительная информация о взаимоотношениях между представленными в обучающей выборке классами, а также схожести отдельных объектов и классов.  \n\nЧтобы проверить данную гипотезу, авторы проводят следующий эксперимент. Сначала они обучают модель-учителя классифицировать картинки на датасете [MNIST](http://yann.lecun.com/exdb/mnist/). После этого авторы обучают компактную модель-ученика с помощью ранее полученного учителя на тех же данных, но опуская при этом все картинки цифры $3$. После этого авторы показывают, что, если исправить коэффициент сдвига для данного класса в последнем слое сети-ученика с помощью небольшой валидационной выборки, сеть способна верно определить $98.6\\%$ картинок тройки, несмотря на то, что во время обучения она не видела ни одного примера.  \n\nТакже косвенным подтверждением данной гипотезы можно считать и тот факт, что при использовании довольно популярной сейчас [техники сглаживания разметки (label smoothing)](https://arxiv.org/abs/1906.02629), эффективность дистилляции знаний заметно падает. Именно теневые знания на данный момент являются де-факто стандартным объяснением эффекта Хинтоновской дистилляции знаний.\n\n### Использование температуры при подсчете KL-дивергенции\n\nВ качестве дополнительной эвристики авторы также предлагают перед взятием KL-дивергенции сглаживать распределения учителя и ученика с помощью температуры $T$, то есть вместо $\\mathbf{p}_i$ и $\\mathbf{q}_i$ считать KL-дивергенцию между $\\mathbf{p}_i^T$ и $\\mathbf{q}_i^T$, где:\n\n$$\\mathbf{p}_i^T = \\text{softmax}\\left(\\frac{\\mathbf{z}_i}{T}\\right)$$\n\nЗдесь с помощью $\\mathbf{z}_i$ обозначены логиты классов, предсказанные моделью-учеником. Формула для $\\mathbf{q}_i^T$ выглядит аналогично.\n\nЗачем нужна температура? Давайте рассмотрим формулу дополнительного слагаемого функции потерь. Для простоты выкладок я ограничусь функцией потерь для единственного объекта под номером $i$, а также опущу постоянный множитель $\\frac{\\lambda}{N}$, который также не существенен для данного повествования.\n\n$$L_i = - \\sum_{j=1}^K q_{ij} \\log p_{ij}$$\n\nВспомним, что коэффициенты $q_{ij}$ приходят из предобученной модели-учителя, а значит являются константными с точки зрения процесса оптимизации.  \n\nВ таком случае несложно видеть, что мы имеем дело с чем-то очень близким к стандартной кросс-энтропийной функции потерь, но таргет $y_{ij}$ — это уже не one-shot закодированные номера классов, а что-то более интересное. В таком случае компоненты предсказания ученика, которые отвечают классам, оценённым учителем, как наиболее вероятные, получат большие веса и сформируют каркас итоговой функции потерь.  \n\nВ то же время все прочие компоненты получат околонулевые коэффициенты и влияния на функцию потерь практически не окажут. В какой-то степени эффект от этого может быть позитивным. Действительно, так как для преобразования предсказания нейронной сети в распределение вероятностей мы используем $\\text{softmax}$, итоговая модель не может предсказать строго нулевую вероятность. Поэтому типичное предсказание обученной сети содержит в себе множество практически нулевых значений.  \n\nПри этом порядок между данными значениями определяется в первую очередь не похожестью объекта на представителей данных классов, а конкретным исходом стохастического процесса обучения данной модели. В таком случае нам вовсе не хотелось бы вынуждать ученика воспроизводить данный порядок, если ценой тому будет ухудшение точности предсказания истинного класса.\n\nС другой стороны, нейронные сети являются зачастую излишне уверенными в себе классификаторами: их предсказание часто содержит ярко выраженный максимум, вероятность которого близка к единице даже в тех случаях, когда модели стоило бы усомниться. К сожалению, для нас это значит, что при дистилляции знаний из такой модели мы рискуем попасть в ситуацию, что итоговые веса $q_{ij}$ настолько малы для всех классов, кроме истинного, что наше дополнительное слагаемое по сути повторяет стандартную кросс энтропию и не способно внести хоть сколь-нибудь заметный вклад в обучение модели-ученика.  \n\nЭтот эффект можно нивелировать путем сглаживания предсказания учителя таким образом, чтобы сделать распределение $q_{ij}$ ближе к равномерному, для чего, собственно и используется температура.\n\nВ таком случае функция потерь задается следующим образом:\n\n$$L_{KD} = - \\frac1N \\sum_{i=1}^N \\left( \\sum_{j=1}^K y_{ij} \\log p_{ij} + \\lambda \\sum_{j=1}^K q_{ij}^T \\log p_{ij}^T \\right)$$\n\nНо в данную формулу незаметно закралась одна неприятная деталь. Давайте рассмотрим градиент второго слагаемого в скобках. Как и в прошлый раз, для простоты выкладок я ограничусь случаем единственного объекта под номером $i$ и опущу константный множитель $\\frac{\\lambda}{N}$:\n\n$$L_i = - \\sum_{j=1}^K q_{ij}^T \\log p_{ij}^T$$\n\nЗдесь легко узнаётся формула кросс-энтропийной функции потерь, градиент которой по логитам считается следующим образом:\n\n$$\\frac{\\partial L_i}{\\partial z_{ik}} = \\frac{1}{T} (p_{ik}^T - q_{ik}^T)$$\n\n\n{% cut \"Доказательство формулы для градиента кросс-энтропийной функции потерь.\" %}\n\nТак как мы будем искать частную производную функции потерь по логитам, давайте сначала выразим через них саму функцию потерь:\n\n$$L_i = - \\sum_{j=1}^K q_{ij}^T \\log p_{ij}^T =$$\n\n$$= - \\sum_{j=1}^K q_{ij}^T \\log \\frac{\\exp(z_{ij}/T)}{\\sum\\limits_{l=1}^K \\exp(z_{il}/T)} =$$\n\n$$= \\sum_{j=1}^K \\left(q_{ij}^T \\log \\sum_{l=1}^K \\exp(z_{il}/T) - q_{ij}^T \\log \\exp(z_{ij}/T)\\right) =$$\n\n$$= \\sum_{j=1}^K \\left(q_{ij}^T \\log \\sum_{l=1}^K \\exp(z_{il}/T) - q_{ij}^T z_{ij} / T\\right)$$\n\nТеперь мы готовы брать производную:\n\n$$\\frac{\\partial L_i}{\\partial z_{ik}} = \\sum_{j=1}^K \\left( q_{ij}^T \\frac{1}{\\sum\\limits_{l=1}^K \\exp(z_{il}/T)} \\frac{1}{T} \\exp(z_{ik}/T) - \\frac{1}{T} q_{ik}^T \\right) =$$\n\n$$= \\frac{1}{T} \\left(p_{ik} \\sum_{j=1}^K q_{ij}^T - q_{ik}\\right)$$\n\nПоскольку $q_{ij}^T$ для каждого фиксированного $i$ является вектором вероятностей, то $\\sum_{j=1}^K q_{ij}^T = 1$, откуда мы и получаем искомую формулу.\n\n{% endcut %}\n\nМожно видеть, что при изменении температуры $T$ баланс между слагаемыми функции потерь (качеством решения задачи и качеством повторения предсказания учителя) нарушается. Действительно, если раньше мы настраивали его путём выбора подходящего коэффициента $\\lambda$, то теперь мы приходим к тому, что при изменении температуры коэффициент $\\lambda$ необходимо также менять: иначе при взятии градиента одно слагаемое функции потерь будет разделено на $T$, а другое останется неизменным.  \n\nРазумным кажется ввести множитель $T$ в формулу для $\\mathcal{L}_{KD}$ явным образом. Однако прежде, чем мы сделаем это, давайте ещё раз внимательно посмотрим на получившийся градиент:\n\n$$\\frac{\\partial L_i}{\\partial z_{ik}} = \\frac{1}{T} (p_{ik}^T - q_{ik}^T) = \\frac{1}{T} \\left(\\frac{\\exp(z_{ik}/T)}{\\sum_{l=1}^K \\exp(z_{il}/T)} - \\frac{\\exp(v_{ik}/T)}{\\sum_{l=1}^K \\exp(v_{il}/T)}\\right),$$\n\nгде через $v_{ij}$ обозначены логиты, предсказанные моделью-учителем.\n\nДавайте теперь устремим $T$ к бесконечности. Раскладывая экспоненты в ряд Тейлора до первого слагаемого, получаем:\n\n$$\\frac{\\partial L_i}{\\partial z_{ik}} \\approx \\frac{1}{T} \\left(\\frac{1 + z_{ik}/T}{N + \\sum_{l=1}^K z_{il}/T} - \\frac{1 + v_{ik}/T}{N + \\sum_{l=1}^K v_{il}/T}\\right)$$\n\nВспомним теперь, что результат применения преобразования $\\text{softmax}$ не зависит от сдвига на константу, поэтому на выходе из нейронной сети мы можем вычитать из логитов среднее значение таким образом, чтобы $\\sum_{l=1}^K z_{il} = \\sum_{l=1}^K v_{il} = 0$. В таком случае, предыдущая формула упрощается до:\n\n$$\\frac{\\partial L_i}{\\partial z_{ik}} \\approx \\frac{1}{NT^2} (z_{ik} - v_{ik})$$\n\nИз этой формулы следует два вывода.  \n\n- Во-первых, можно видеть, что для соблюдения баланса второе слагаемое в $\\mathcal{L}_{KD}$ правильнее будет домножить не на $T$, а на $T^2$.  \n- Во-вторых, в данной формуле можно узнать градиент квадратичной функции потерь между векторами логитов.  \n\nТо есть при стремлении температуры $T$ к бесконечности градиент второго слагаемого в $\\mathcal{L}_{KD}$ стремится к градиенту квадрата нормы разности между логитами модели-ученика и модели-учителя.\n\nТаким образом, мы приходим к финальной версии функции потерь:\n\n$$L_{KD} = - \\frac1N \\sum_{i=1}^N \\left( \\sum_{j=1}^K y_{ij} \\log p_{ij} + \\lambda T^2 \\sum_{j=1}^K q_{ij}^T \\log p_{ij}^T \\right)$$\n\nОписанная выше статья произвела настоящий фурор в 2014 году. Дистилляция знаний путем минимизации KL-дивергенции между предсказаниями ученика и учителя хорошо зарекомендовала себя на практике и породила целый ряд исследований, направленных на использование и усовершенствование предложенного подхода.  \n\nВместе с методом прижилось и понятие теневых знаний, и его довольно часто можно встретить в статьях, посвящённых данной тематике. Кроме того, зародилась традиция изучения дистилляции знаний на примере задачи классификации картинок.  \n\nДальше по ходу параграфа мы ещё не раз столкнёмся с тем, что авторы различных методов часто прилагают результаты экспериментов на таких датасетах, как [CIFAR-10, CIFAR-100](https://www.cs.toronto.edu/~kriz/cifar.html), [ImageNet](https://www.image-net.org) и так далее.  \n\nТем не менее, сети для работы с данными других модальностей тоже дистиллируют, и начнем мы с разбора статьи, которая использует предложенный метод для решения задачи языкового моделирования (language modelling).\n\n### DistilBERT как пример хинтоновской дистилляции\n\nОдним из наиболее выдающихся примеров применения Хинтоновской дистилляции можно считать модель [DistilBERT](https://arxiv.org/abs/1910.01108), которая сохраняет 97% качества модели BERT (согласно бенчмарку [GLUE](https://arxiv.org/abs/1804.07461)), используя при этом на 40% меньше параметров и требуя на 60% меньше времени при применении. При этом столь выдающийся результат авторы получают, используя хинтоновский подход практически без изменений.\n\nПо аналогии с тем, как это делалось для модели-учителя (в роли которого выступает BERT), авторы обучают свою модель решать задачу маскированного языкового моделирования. В дополнение к хинтоновской функции потерь использовалось ещё косинусное расстояние между итоговыми векторными представлениями токенов, полученными с помощью ученика и учителя, *разворачивая* представлений ученика в сторону направлений, задаваемых представлениями модели-учителя.\n\nЕщё одна интересная деталь в этой статье — способ инициализации модели-ученика. Действительно, в качестве архитектуры для своей сети, авторы решили переиспользовать архитектуру самого BERT, но с уменьшенным вдвое числом слоёв для ускорения.  \n\nАвторы замечают, что большинство операций, которые используются в трансформерах, уже достаточно хорошо оптимизированы во всех популярных библиотеках, поэтому изменение размера внутренних представлений оказывает существенно меньшее влияние на итоговое время применения сети, нежели изменение количества слоёв. Поэтому в статья фокусировалась на сжатии модели именно в глубину, оставляя ширину неизменной. \n\nПоскольку веса слоёв модели-ученика имеют при таком подходе такие же размерности, что и веса слоёв модели-учителя, последние можно использовать при инициализации. Ровно так авторы и поступают, копируя веса каждого второго слоя исходной модели для инициализации DistilBERT. \n\nМожет показаться, что умная инициализация не критична и наихудшим следствием использования более примитивной стратегии будет всего лишь увеличение времени, требуемого для обучения модели-ученика. Но авторы провели ablation study и выяснили, что обучение без умной инициализации приводит к потере почти $4.8$ процентных пункта итоговой метрики (обученная без неё модель сохраняет лишь $92.2\\%$ качества модели-учителя).\n\nДля сравнения, исключение из функции потерь кросс-энтропии между предсказанием ученика и истинной разметки приводит к потере лишь $0.4$ процентных пункта итоговой метрики, а исключение KL-дивергенции приводит к потере $3.8$ процентных пункта.\n\nИнтересно, что двумя годами позднее вышла независимая [статья](https://arxiv.org/abs/2106.05945), авторы которой показали, что хинтоновская дистилляция — это очень сложная оптимизационная задача со множеством локальных минимумов, которые сильно усложняют поиск глобального. \n\nПоскольку статья была написана независимо другими авторами, конкретный пример DistilBERT там не изучается, однако в целом авторы приходят к выводу, что умная инициализация может быть ключевым элементом для успеха дистилляции знаний.\n\n## Дополнительные источники знаний для дистилляции\n\nНесмотря на широкий успех хинтоновского подхода, дистилляция знаний им не ограничивается. \n\nОдно из наиболее очевидных направлений улучшения предложенного метода — это использование дополнительных способов передачи знаний от модели-учителя к модели-ученику. Действительно, в хинтоновской постановке единственный канал передачи знаний — это выходы с последнего слоя модели-учителя. \n\nОднако в случае нейронных сетей это отнюдь не единственный доступный нам источник информации. Например, можно использовать веса модели-учителя для умной инициализации, как при обучении DistilBERT. К сожалению, поскольку дистилляция знаний практически всегда сопряжена со сжатием модели, не всегда получается непосредственно использовать веса учителя, и в каждом отдельном случае приходится изобретать специализированные трюки. \n\nПо этой причине DistilBERT — это единственная известная автору этого параграфа модель, в которой удалось добиться улучшения результатов благодаря использованию весов модели-учителя для умной инициализации.\n\nТем не менее, в нейронных сетях можно найти и другие источники информации. Хинтоновская дистилляция использует только выходы с последнего слоя сети. Почему бы нам дополнительно не использовать выходы промежуточных слоев? И действительно, [исследования показывают](https://arxiv.org/abs/1412.6550), что использование выходов промежуточных слоев позволяет улучшить результаты дистилляции знаний.\n\nДля получения прироста качества авторы предлагают выбрать один или несколько промежуточных слоев модели-учителя, сопоставить каждому из них промежуточный слой модели-ученика, после чего использовать квадрат нормы разности выходов итоговых пар слоев в качестве дополнительного слагаемого к хинтоновской функции потерь.\n\nК сожалению, несмотря на кажущуюся прямолинейность данного подхода, здесь возникают две сложности.\n\n### Сложность №1\n\nМы явным образом предполагаем наличие заранее выбранных пар слоёв, оставляя за бортом вопрос о том, каким образом их собственно стоит выбирать. Поскольку дополнительные слагаемые функции потерь по сути обучают модель-ученика повторять промежуточные представления модели-учителя, разумным кажется сохранять порядок слоёв: слои из середины модели-учителя сопоставлять со слоями из середины модели-ученика, а слои, находящиеся ближе к концу модели-учителя, — со слоями, находящимися ближе к концу модели-ученика.\n\nВ частности, авторы оригинальной статьи просто берут средний слой в каждой из моделей и используют их в качестве своей единственной пары, однако это в большей степени связано с тем, что статья была написана в 2014 году и рассматривала достаточно маленькие по современным меркам модели. Более свежие статьи, как правило, работают с более глубокими сетями, а потому используют большее количество пар слоёв. \n\nТак, авторы следующей работы [рассматривают](https://arxiv.org/abs/1612.03928) глубокие сверточные сети с промежуточными связями (residual connections) и предлагают разбивать каждую из моделей на группы блоков с промежуточной связью таким образом, чтобы итоговое количество групп совпало. Пример такой разбивки можно видеть на картинке ниже.\n\nЗдесь к каждой группе относится по три блока в модели-учителе и по два блока в модели-ученике. После этого выходы каждой такой группы можно сопоставить друг другу и использовать для дистилляции знаний.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_36_98f8d5dccd_5060fc72dc.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1612.03928\">Источник</a>\n  </figcaption>\n</figure>\n\nПосле того, как пары слоёв были выбраны, перед нами может возникнуть и второе препятствие.\n\n### Сложность №2\n\nЧто, если выходы выбранных слоёв различаются по размерам? Такая ситуация запросто может случиться, ведь мы хотим, чтобы модель-ученик была поменьше, а один из способов сжатия — как раз уменьшение количества нейронов в полносвязных слоях.\n\nВ таком случае авторы оригинальной статьи [предлагают](https://arxiv.org/abs/1412.6550) использовать дополнительное преобразование, чтобы придать выходам модели-ученика нужные размеры (например, линейный слой).\n\nТакие слои обучаются совместно с моделью-учеником, а после исключаются из сети при применении. В более поздних работах встречаются и другие, более продвинутые преобразования.  \n\nНесмотря на кажущуюся интуитивность дистилляции промежуточных выходов, практическое применение это метода, к сожалению, осложняется необходимостью выбора целого ряда гиперпараметров. Скажем, оптимальные тактики выбора пар слоёв для дистилляции или дополнительных преобразований для выравнивания размерностей выходов до сих пор являются предметами активных исследований, точно так же, как и функции потерь для оптимизации.\n\n## Иерархия методов дистилляции знаний\n\nВыше мы рассмотрели два подхода к дистилляции знаний: хинтоновскую дистилляцию и дистилляцию промежуточных представлений. Как мы уже упоминали ранее, в последние годы область применения дистилляции знаний сильно разрослась, и новые методы появляются день ото дня.\n\nЭто породило довольно естественное желание систематизировать предложенные методы в некоторую иерархию. Мы рассмотрим две классификации методов:\n\n- по режиму дистилляции,\n- по области применения.\n\n### Режимы дистилляции знаний\n\nРазличные подходы к дистилляции знаний принято делить по так называемым режимам. Выделяют три основных режима дистилляции знаний: offline-, online- и самодистилляция.\n\n#### Offline-дистилляция знаний\n\nВсе рассмотренные выше статьи так или иначе следуют некоторой общей схеме: в качестве учителя используется большая заранее обученная модель, знания из которой дистиллируются в ученика, в то время как сам учитель остается неизменным. Дистилляция в таком режиме получила название offline-дистилляции знаний.\n\nНо что делать, если большой предобученный учитель для вашей задачи не доступен? Что если модель-учитель не помещается на доступную нам видеокарту, из-за чего обучение или вовсе невозможно, или требует в десятки раз больше времени, по сравнению с обучением желаемой модели-ученика? Что, если набор данных, описывающий вашу задачу, невелик, и большая модель может переобучиться на нём, делая дистилляцию знаний как минимум неэффективной, а возможно и вредной для итогового качества ученика?  \n\nТут на помощь приходит online-дистилляция знаний.\n\n#### Online дистилляция знаний\n\nВ качестве альтернативы авторы [этой статьи](https://arxiv.org/abs/1706.00384) предлагают брать в качестве учителя модель такой же архитектуры, что и ученик, и обучать обе модели одновременно.  \n\nТо есть вместо одной модели мы случайно инициализируем две, после чего на каждом шаге обучения для каждой из моделей мы минимизируем $\\mathcal{L}_{KD}$, где в качестве учителя выступает другая модель.  \n\nВ таком случае в начале обучения градиент дистилляционного члена не будет иметь какого-то чёткого направления, а обучение обеих моделей будет происходить преимущественно за счет минимизации обычной функции потерь. На поздних же этапах обучения в дело включится и KL-дивергенция, что позволит дополнительно повысить качество каждой из моделей.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/dml_ebbd86d63c_123acde9f5.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1706.00384\">Источник</a>\n  </figcaption>\n</figure>\n\nПочему данный подход работает? Широко известно, что в ряде задач ансамблирование нескольких одинаковых нейронных сетей, одинаково обученных на одних и тех же данных, но из разных случайных инициализаций, [дает прирост](https://arxiv.org/abs/2012.09816) в итоговой метрике.  \n\nЭтот факт подталкивает нас к выводу о том, что в зависимости от инициализации одна и та же нейронная сеть вычленяет из данных разные закономерности. Опираясь на данный вывод, авторы вышеупомянутой статьи утверждают, что в предложенной постановке каждая из моделей в процессе обучения может воспользоваться информацией, которая иначе была бы доступна только модели, стартовавшей из другой инициализации.\n\nАвторы проводят ряд экспериментов с моделями разных размеров, обучая их на датасетах CIFAR-100 и [Market-1501](https://ieeexplore.ieee.org/document/7410490), и показывают, что использование даже одной дополнительной модели позволяет добиться заметного улучшения в качестве предсказаний обучаемой модели.  \n\nТак на датасете CIFAR-100 совместное обучение ансамбля из двух моделей практически во всех экспериментах дает прирост в $1--2$ процентных пункта к итоговой точности предсказания, причем метод позволяет достигнуть положительного эффекта даже для самой большой из рассмотренных моделей при её совместном обучении с самой малой моделью. Кроме того, авторы проводят ряд экспериментов, в которых сравнивают offline-дистилляцию большей модели в меньшую с их совместным обучением и показывают, что предложенный метод позволяет добиться лучших результатов.\n\nOnline-постановка естественным образом обобщается на случай большего числа моделей в обучаемом ансамбле. В таком случае в качестве дистилляционного слагаемого авторы предлагают минимизировать среднее значение KL-дивергенций от текущей модели до предсказаний каждой из других моделей в ансамбле, поскольку минимизация KL-дивергенции до усредненных вероятностей приводит к худшему результату.  \n\nПри этом авторы в своих экспериментах показывают, что увеличение числа моделей в ансамбле приводит к улучшению результатов обучения. Кроме того авторы отмечают, что для ускорения обучения можно достаточно эффективно использовать несколько видеокарт, поскольку на каждом шаге между устройствами передавать необходимо только результаты предсказания.\n\n#### Самодистилляция\n\nВ качестве отдельного режима дистилляции знаний принято выделять также самодистилляцию (self distillation), при которой учитель и ученик являются одной и той же моделью. Самодистилляция включает в себя две основные группы методов.\n\nПервая группа методов направлена на использование информации, которая накапливается в модели во время обучения, для дополнительного улучшения качества предсказаний той же самой модели. Методы данной группы являются как бы продолжением идей online дистилляции знаний, поскольку учитель и ученик обучаются одновременно.  \n\nХороший пример метода из данной группы можно найти в [этой статье](https://arxiv.org/abs/1905.08094), где авторы пытаются заставить представления менее глубоких слоёв быть эквивалентными представлениям более глубоких слоёв. А именно, авторы предлагают разделить сеть на несколько частей ($4$ в статье) и после каждой такой части добавить небольшую предсказательную голову. Все такие головы обучаются путем минимизации суммы трёх слагаемых:\n\n- кросс-энтропии с истинной разметкой; \n- KL-дивергенции с предсказаниями полной сети;\n- квадратичной функции потерь между промежуточными представлениями данной головы и выходом последней части сети.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/byot_85061c03aa_4a95b5f9f5.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1905.08094\">Источник</a>\n  </figcaption>\n</figure>\n\n\nТаким образом авторы добиваются от ResNet50 $81.04\\%$ точности предсказания на тестовой выборке CIFAR-100 с минимальным замедлением обучения.  \n\nДля сравнения, стандартное обучение такой же сети позволяет добиться лишь $77.68\\%$ точности предсказания, а дистилляция из ResNet152 (которая, в свою очередь, показывает точность предсказания в $79.21\\%$) позволяет улучшить данный показатель лишь до $79.31\\%$.  \n\nПри этом обучение в предложенном режиме занимает $5.87$ часов (обычное обучение занимает $4.03$ часа), а дистилляция из ResNet152 занимает уже $12.31$ часов без учета обучения модели учителя (что требует дополнительных $14.67$ часов).\n\nВторая группа методов по сути заключается в offline дистилляции из обученной модели в новую модель такой же архитектуры. То есть мы выбираем некоторую архитектуру нейронной сети, обучаем одну модель стандартным образом, а затем обучаем точно такую же модель из новой случайной инициализации с использованием хинтоновской дистилляции из ранее обученной модели.  \n\nСтоит заметить, что с хинтоновской точки зрения данное действие едва ли способно улучшить итоговое качество модели. Действительно, будучи точно такой же моделью, ученик обладает идентичной способностью к обучению, а значит учитель едва ли может предоставить ему какую-либо дополнительную информацию во время обучения.  \n\nПоэтому такая самодистилляция изначально была предложена как метод изучения процесса хинтоновской дистилляции знаний, поскольку в такой постановке у задачи минимизации KL-дивергенции гарантированно есть глобальный минимум, причем мы даже знаем точку, в которой он достигается. В частности именно с помощью данного метода авторы [ранее упомянутой статьи](https://arxiv.org/abs/2106.05945) демонстрируют, что хинтоновская дистилляция знаний является сложной оптимизационной задачей.\n\nТем удивительнее, что авторы статьи 2018 года [обнаружили](https://arxiv.org/abs/1805.04770), что самодистилляция в предложенной выше постановке позволяет получить прирост в обобщающей способности итоговой модели. Так, они проводят ряд экспериментов с моделями [DenseNet](https://arxiv.org/abs/1608.06993) и [Wide-ResNet](http://www.bmva.org/bmvc/2016/papers/paper087/index.html) на датасете CIFAR-100 и показывают, например, что самодистилляция DenseNet-112-33 позволяет повысить точность предсказания на тестовой выборке с $81.75\\%$ до $83.05\\%$.\n\nВопрос об источнике прироста качества в данном случае до сих пор в значительной степени открыт. Авторы статьи приписывают данный эффект комбинации умного сглаживания разметки и внесения в обучение информации о взаимоотношении классов в датасете. Но на наш взгляд эксперименты, которые предъявляют в статье в качестве доказательства этих гипотез, едва ли можно назвать убедительными.\n\nВозможно, здесь в очередной раз проявляется то, что одинаковые модели могут вычленять из одних и тех же данных разные закономерности в зависимости от случайной инициализации, и дистилляция одной такой модели в другую позволяет ученику увидеть ранее недоступные ему связи. \n\nТакже хочется обратить внимание на интересную [статью](https://arxiv.org/abs/2002.05715), вышедшую в 2020 году. В ней показывается, что в случае обучения с L2-регуляризацией предложенная выше самодистилляция производит неявный отбор признаков.\n\nНу и раз мы проходили мимо самодистилляции, здесь никак нельзя не упомянуть [статью](https://arxiv.org/abs/1911.04252) 2019 года, которая в течении практически года держала почетный статус SOTA на датасете ImageNet.\n\nЕё авторы предлагают подход, который во многом очень близок к описанному выше. Они обучают модель на исходном наборе данных, после чего используют её для разметки новых данных, взятых в данном случае из стороннего обширного набора данных JFT-300M (закрытый набор данных, который нередко упоминается в статьях от Google).\n\nПосле этого авторы отбрасывают картинки, для которых модель дает неуверенные предсказания, чтобы избежать данных out-of-domain. Кроме того, они выравнивают размеры классов, чтобы избежать связанных с этим спецэффектов (согласно авторам статьи, модели меньшего размера показали себя более чувствительными к данной оптимизации).\n\nТаким образом, авторы получают большое количество дополнительных шумно размеченных данных, на которых, совместно с основным набором, они обучают новую модель. Эту модель, в свою очередь, можно использовать для получения новой разметки для дополнительных данных, с помощью которых обучается следующая модель, и такие итерации можно продолжать произвольное количество раз.\n\nВ качестве разметки авторы предлагают использовать мягкую разметку, задаваемую моделью-учителем, но и бинаризованная разметка показывает схожие результаты на данных in-domain. Ключевая деталь здесь — что предсказание на новых данных производится без аугментаций, в то время как ученик учится воспроизводить разметку уже с высоким уровнем аугментации данных, а также с применением других техник регуляризации, таких как dropout и stochastic depth.\n\nАвторы утверждают, что ученик обучается лучше переносить свои знания на новые данные. Предложенный метод позволил авторам добиться от модели [EfficientNet-L2](https://arxiv.org/abs/1905.11946) точности предсказания в $88.4\\%$ на тестовом наборе данных ImageNet, существенно улучшив результат исходной модели в $85.5\\%$ и обновив мировой рекорд.\n\n### Области применения дистилляции знаний\n\n#### Сжатие генеративных состязательных сетей\n\nПодавляющее большинство рассмотренных выше статей так или иначе ограничиваются задачей классификации картинок. Такой выбор, хоть и не является случайным, всё же несёт больше исторический, нежели практический характер.\n\nНа самом деле, многие предложенные выше методы достаточно тривиально могут быть обобщены и на другие задачи машинного обучения. Например, метод дистилляции промежуточных представлений по сути вовсе никак не зависит от природы итоговых выходов модели, а потому может использоваться при сжатии практически любой модели.\n\nВ частности данный метод может быть использован для сжатия генеративных состязательных сетей. Так авторы довольно популярной статьи в данной области [демонстрируют](https://arxiv.org/abs/2003.08936) $9$-, $10$- и даже $29$-кратное ускорение для ряда популярных pix2pix генеративных сетей, при этом не теряя в качестве генерации.\n\nКак уже упоминалось ранее, авторы используют дистилляцию промежуточных представлений: модель-ученик учится минимизировать L2-расстояние между своим промежуточным представлением и промежуточным представлением модели-учителя. Но, так как данные представления имеют различное количество каналов (ученик выучивает более сжатое представление) авторы используют дополнительную свертку 1х1 над представлением ученика для сопоставления тензоров друг с другом.\n\nПомимо дистилляции промежуточных представлений, авторы также пользуются наличием модели-учителя для того, чтобы получить парную картинку в случае обучения на неспаренных данных (как это происходит, например, в CycleGAN).  \n\nПарная картинка используется для минимизации L1 нормы разности с предсказанием модели. Кроме того, авторы во время обучения минимизируют и стандартную для генеративных состязательных сетей функцию потерь, при этом для модели-ученика используется такой же дискриминатор, что и для модели-учителя, что позволяет авторам инициализировать веса с помощью весов оригинального дискриминатора.\n\nТаким образом авторы предлагают следующий рецепт для сжатия генеративных состязательных сетей. Сначала необходимо обучить модель-учителя. После этого нужно сконструировать сжатый генератор-ученика, скопировать (вместе с весами) дискриминатор и обучить получившуюся систему с помощью минимизации взвешенной суммы трёх функций потерь: \n\n- Стандартной функции потерь генеративных состязательных сетей.\n- L1-расстояния между предсказанием генератора и парной картинки. При этом если в данных парной картинки нет, вместо неё используется результат генерации моделью-учителем.\n- L2-расстояния между промежуточными представлениями двух генераторов. \n\nЭтот метод хорошо себя зарекомендовал на практике и получил широкое распространение в своей нише.\n\n#### Дистилляция знаний при квантизации моделей\n\nЕщё одно интересное применение дистилляции знаний — улучшение результатов квантизации моделей. Техника квантизации нейронных сетей заключается в том, чтобы перевести часть весов или даже всю сеть из полной точности (как правило, float32) во float8 или даже float4.\n\nПомимо очевидной экономии памяти, такое представление нередко позволяет использовать специальные ядра современных графических ускорителей или специальные регистры процессоров для достижения существенного ускорения при применении квантизованных моделей.\n\nК сожалению, бесплатный сыр бывает только в мышеловке. Сжатое представление на то и называется сжатым, что является менее богатым, нежели полная точность. Поэтому большинство весов сети приходится изменять при сжатии, чтобы они попали на более грубую сетку. Разумеется изменения каждого отдельного веса может показаться незначительным, однако когда все веса сети незначительно изменяются, итоговый результат подсчетов может оказаться вовсе неузнаваемым.\n\nЧтобы смягчить данный эффект, модель принято доучивать после квантизации. И вот здесь на помощь приходит дистилляция знаний: например, из сети полной точности в квантизованного ученика. Ровно к такой схеме приходят авторы [этой статьи](https://arxiv.org/abs/1711.05852).\n\nИтоговая схема выглядит следующим образом: мы обучаем сеть в полной точности, квантизуем ее веса и доучиваем ее в квантизованном виде с использованием дистилляции знаний из сети в полной точности.\n\n#### Дистилляция знаний за пределами сжатия моделей\n\nХочется отметить, что сжатие моделей — это хоть и основное, но всё же не единственное применение дистилляции знаний. Так, раньше в этом параграфе уже упоминалась самодистилляция, которая позволяет получать прирост в обобщающей способности обучаемой модели без использования моделей большего размера.\n\nСамодистилляцией, однако, примеры применения дистилляции знаний без сжатия модели не ограничиваются. Так, в 2020 году был [предложен](https://arxiv.org/abs/2006.07733) метод BYOL-предобучения без учителя, основанный на дистилляции знаний.\n\nМетод BYOL направлен на предобучение моделей компьютерного зрения и основан на идее так называемого контрастивного предобучения (contrastive pretraining). Суть методов данного семейства заключается в том, чтобы обучать модель выдавать схожие представления для различных аугментаций одной и той же картинки.\n\nДействительно, случайные патчи, вырезанные из фотографии автомобиля, скорее всего также являются фотографиями автомобиля. При этом, если в наших данных присутствует достаточное количество фотографий различных автомобилей, мы можем надеяться на то, что модель выучит некоторое общее понимание концепта автомобиля даже несмотря на то, что мы можем вовсе не знать, на каких конкретно картинках автомобили присутствовали, а на каких - нет.\n\nОднако если мы хотим добиться от такой модели осмысленных представлений сначала нам необходимо преодолеть проблему коллапса представлений.  \n\nДействительно, у предложенной выше задачи есть тривиальное решение, в котором выход обучаемой сети не зависит от ее входа. В таком случае представления для произвольных аугментаций любой картинки будут совпадать, то есть функция потерь окажется нулевой. Тем не менее сами представления при этом окажутся совершенно бесполезными.\n\nПоэтому различные методы контрастивного обучения отличаются в первую очередь как раз способами борьбы с проблемой коллапса представлений. Так, авторы метода BYOL часто сравнивают свои результаты с довольно свежим на момент написания статьи методом [SimCLR](https://arxiv.org/abs/2002.05709), в котором предлагается обучать модель одновременно минимизируя расстояния между парами представлений для различных аугментаций одной картинки и максимизируя расстояния между представлениями для различных картинок.  \n\nПри этом, для повышения эффективности такого обучения, во время генерации батча данных авторы сначала выбирают некоторое количество картинок из набора данных, затем для каждой картинки производят две различные случайные аугментации, после чего полученные картинки используются для создания одной *позитивной пары*, расстояние между представлениями которой будет минимизироваться, а также для создания множества *негативных пар* с аугментациями других картинок в батче, расстояния между представлениями которых будут максимизироваться.\n\nАвторы BYOL подвергают данный подход критике, показывая, что для эффективного обучения SimCLR требует большого размера батча, а также довольно агрессивных аугментаций. В противном же случае качество обучаемых представлений заметно падает. Авторы BYOL объясняют данный эффект тем, что сам подход использования негативных пар является субоптимальным, поскольку требует аккуратного выбора негативных примеров. Поэтому свой метод авторы конструируют таким образом, чтобы модель обучалась только на позитивных парах картинок.\n\nВ таком случае каким образом авторам удается решить проблему коллапса представлений? Для этого, вместо минимизации расстояния между представлениями обучаемой сети для двух аугментаций одной картинки, авторы обучают свою модель минимизировать расстояние между представлением обучаемой (online) сети для одной аугментации и представлением для второй аугментации, которое задается уже другой, целевой (target) сетью. То есть в некотором смысле здесь происходит дистилляция знаний из целевой сети в обучаемую.\n\nПоследней важной деталью является природа целевой сети. Авторы BYOL замечают, что даже использование произвольно инициализированной сети в качестве целевой для предложенного выше метода обучения приводит к выучиванию обучаемой моделью осмысленных представлений.  \n\nПодробнее, линейный классификатор, обученный на основе выученных таким образом представлений картинок из набора данных ImageNet показывает $18.8\\%$ тестовой точности предсказания, в то время как использование представлений задаваемых самой целевой сетью позволяет добиться лишь $1.4\\%$ точности. Мотивированные данным наблюдением, авторы предлагают в качестве целевой использовать такую же сеть, что и обучаемая.  \n\nПри этом:\n\n- градиенты не текут через целевую модель, и она не обновляется на шаге градиентного спуска;\n- обучаемая модель заканчивается дополнительным двухслойным перцептроном, который используется для преобразования её финальных представлений в представления целевой модели;\n- веса целевой модели не меняются на шаге градиентного спуска, а вместо этого они обновляются между шагами с помощью экспоненциального сглаживания весов обучаемой модели:\n\n$$\\xi \\mapsto \\tau\\xi + (1 - \\tau)\\theta,$$\n\nгде, следуя обозначениям из статьи, мы обозначили через $\\xi$ и $\\tau$ веса целевой и обучаемой моделей соответственно, а $\\tau$ — вещественный параметр.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_31_3b7e513b94_b630bc04df.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/2006.07733\">Источник</a>\n  </figcaption>\n</figure>\n\n\nПредложенный метод позволяет авторам добиться уже $79.6\\%$ тестовой точности от линейного классификатора на наборе данных ImageNet, заметно превосходя предложенные ранее методы self-supervised предобучения, и практически преодолевая разрыв между self-supervised и supervised обучением классификаторов на основе ResNet.\n\nСтоить заметить, что сценарии применения дистилляции знаний отнюдь не ограничиваются выше рассмотренными. На данный момент уже существует множество различных подходов и алгоритмов, так или иначе связанных с дистилляцией знаний, и их количество растет день ото дня.  \n\nДанный параграф не ставит своей целью полный обзор таких методов. Вместо этого всем заинтересовавшимся я рекомендую обратить внимание на довольно исчерпывающий [обзор](https://arxiv.org/abs/2006.05525) от 2020 года. Здесь можно найти множество ссылок на актуальные к тому моменту статьи, в числе которых присутствует и большинство статей, упомянутых в этом параграфе.\n\n### Открытые проблемы\n\nЗавершим параграф упоминанием открытых проблем в области дистилляции знаний. \n\nДействительно, несмотря на впечатляющие результаты, дистилляция знаний всё же не является идеальным методом, и ряд вопросов до сих пор остаются без ответа.\n\nНапример, с ростом популярности дистилляции знаний [выяснилось](https://arxiv.org/abs/1910.01348), что использование учителя с большей обобщающей способностью не всегда приводит к улучшению обобщающей способности ученика. В какой-то степени данный эффект можно списать на то, что компактная модель-ученик упирается в пределы своего качества предсказания, и тогда использование более умного учителя уже не приносит дополнительной пользы.\n\nНо это не объясняет, почему использование более точной модели в качестве учителя может приводить даже к ухудшению итоговой точности модели-ученика. В чём причина данного эффекта и как выбрать оптимального учителя для фиксированного ученика, до сих пор открытый вопрос.\n\nИ как уже упоминалось ранее, дистилляция знаний из одной сети в точно такую же нередко [приводит](https://arxiv.org/abs/1805.04770) к росту обобщающей способности ученика по сравнению со своим учителем. С точки зрения хинтоновской теории, которая является де-факто стандартным способом объяснения дистилляции знаний, это звучит абсурдно. \n\nМодель-ученик гарантированно способна приблизить ту же функцию, что и модель-учитель. Тем не менее, этого не происходит, а модель-ученик выучивает свое собственное представление, которое нередко качественно превосходит представление учителя. Данный факт уже сложно объяснить в парадигме передачи знаний от учителя к ученику, потому что здесь ученик оказывается в состоянии получить больше знаний, нежели учитель способен передать. Несмотря на то, что на данную тему написана уже не одна статья, исчерпывающего объяснения пока нет.\n\nТак или иначе, дистилляция знаний неоспоримо работает и является основным практическим подходом к сжатию нейросетевых моделей на данный момент.",
        "handbook": "Учебник по машинному обучению",
        "title": "Дистилляция знаний",
        "description": null
    },
    {
        "path": "/handbook/ml/article/vvedenie-v-generativnoe-modelirovanie",
        "content": "До этого вы изучали модели машинного обучения, которые в основном предсказывают какие-то характеристики объектов.Например, метки класса или регрессионные метки. Подобные задачи называют дискриминативным моделированием.\n\nВ то же время, существуют обратные задачи, в которых по какой-то характеристике нужно создать объект или оценить плотность распределения объектов. Это называется генеративным моделированием — его нюансы мы и рассмотрим в этом разделе. \n\nОбучение генеративных моделей существенно сложнее обучения дискриминативных моделей. Последние работают с намного более простыми распределениями. Например, предсказать вероятность конкретной цифры, нарисованной на картинке, гораздо проще, чем создать картинку с нужной цифрой. При этом генеративные модели в последние годы достигли невероятных успехов и позволяют генерировать изображения, которые трудно отличить от настоящих фотографий.\n\n\n![generative_vs_discriminative_models_593f8fe604.webp](https://yastatic.net/s3/education-portal/media/generative_vs_discriminative_models_593f8fe604_cc2dc8db48.webp)\n\nГенеративные модели помогают решать множество задач, которые мы рассмотрим далее. Самая основная задача — это приближение распределения данных и генерация новых данных. \n\nДопустим у нас есть набор картинок с нарисованными от руки числами. Будем считать, что мы получили этот набор из генеральной совокупности (то есть из всех возможных изображений). Нам бы хотелось так или иначе смоделировать распределение этой генеральной совокупности.\n\nМы можем это сделать двумя подходами:\n\n1. Явное моделирование. В этом случае мы построим и как-то оценим функцию плотности распределения данных $p(x)$. Из этого распределения мы сможем семплировать новые объекты. Примеры таких моделей: авторегрессионные модели (например, [PixelCNN++](https://arxiv.org/pdf/1701.05517.pdf), [Video Transformer](https://arxiv.org/pdf/1906.02634.pdf)), [диффузионные модели](https://education.yandex.ru/handbook/ml/article/diffuzionnye-modeli), модели на основе нормализующих потоков и [вариационные автокодировщики](https://education.yandex.ru/handbook/ml/article/variational-autoencoder-(vae)).\n2. Неявное моделирование. При неявном моделировании мы доступ к функции плотности не получим. Но мы сможем из этого распределения сэмплировать новые объекты. В случае нашего примера с нарисованными числами мы сможем генерировать такие изображения. Примерами таких моделей являются [генеративно-состязательные сети](https://education.yandex.ru/handbook/ml/article/generativno-sostyazatelnye-seti-(gan)).\n\nРассмотрим дискриминативные и генеративные задачи чуть более формально. При дискриминативном моделировании для объекта $x$ и характеристики $y$ мы обычно хотим получить плотность распределения $p(y \\mid x)$.\n\nПри генеративном моделировании ставится противоположная задача: восстановить плотность $p(x)$ или $p(x \\mid y)$. В качестве $y$ тут может выступать как метка класса, так и другой объект. Например, если мы хотим уметь генерировать изображения на основе текстового описания, то изображения будут являться $x$, а текст — $y$.\n\n\n\n## Интерполяции в латентном пространстве\n\nБольшинство моделей генеративного моделирования позволяют семплировать новые объекты. Как правило, в результате обучения генеративной модели мы получаем генератор — функцию, которая на выходе выдаёт объект. \n\nВ таких моделях, как генеративные состязательные нейронные сети, диффузионные модели, вариационные автокодировщики, генератор на вход принимает вектор случайных значений из простого вероятностного распределения (например, нормального или равномерного). Получается, что $x = G(z)$, где $x$ — объект, $G$ — функция генератора, а $z$ — вектор случайных значений. Пространство, в котором располагается $z$, называется латентным.\n\nОбычно распределение $z$ задаётся ещё до обучения модели и не меняется в процессе. Поскольку мы знаем распределение, мы можем семплировать из него сколько угодно разных $z$.\n\nРассмотрим два вектора $z_1$ и $z_2$ из латентного пространства и два соответствующих им сгенерированных объекта $x_1 = G(z_1)$ $x_2 = G(z_2)$. Так как $z_1$ и $z_2$ — это две точки в латентном пространстве, между ними можно провести линию.  \n\nТочки, лежащие на этой линии, будут так же принадлежать этому пространству. Если двигаться по этой линии и использовать точки с неё в качестве входа для генератора, то можно получить плавно изменяющийся сгенерированный объект.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/interpolation_example_f6ce073e6a_d71e9e4faf.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Пример изображений, полученных с помощью интерполяции в латентном пространстве.\n    <a href=\"https://arxiv.org/abs/1707.05776\">Источник</a></p>\n  </figcaption>\n</figure>\n\n\nВ примере выше мы рассмотрели движение вдоль линии, однако на практике интерполяция может быть по более сложной траектории.  \n\nМанипуляции с латентным пространством позволяют не только создавать плавные переходы между объектами, но так же редактировать объекты. Обычно в таких случаях требуется найти направления в латентном пространстве, которое отвечает за нужное свойство сгенерированных объектов.  \n\nНапример, направление, отвечающее за цвет волос или улыбку человека. Подробнее такие методы мы рассмотрим в параграфах про конкретные модели.\n\n## Применения генеративных моделей\n\nЗачем может понадобиться генерировать новые данные или восстанавливать их плотность? Самый простой пример – это аугментация набора данных, которая мешает переобучению и улучшает обобщаемость модели.\n\nПростые аугментации данных (случайные сдвиги, повороты, масштабирование, изменения цвета и контраста) активно используются почти во всех методах машинного обучения. Генеративные же модели представляют собой более сложный вид аугментации данных, который способен существенно расширить датасет, или обогатить его совершенно новыми элементами. \n\nНапример, генеративную модель, которая переносит стиль одного изображения на другое (style transfer), можно использовать для обучения более робастных моделей классификации. В [статье](https://www.nature.com/articles/s41598-019-52737-x) Sandfort et al. используют аугментацию генеративными нейросетями, чтобы улучшить качество сегментации компьютерной томографии. \n\nПомимо этого, у генеративных моделей есть ряд других применений для редактирования изображений. Их используют, чтобы повысить разрешение картинок (задача super-resolution). \n\nНа изображении ниже оригинальную картинку (original) сначала сжали в четыре раза, а потом попробовали восстановить до исходных размеров разными методами. Видно, что метод SRGAN, метод на основе генеративных состязательных нейронных сетях работает гораздо лучше бикубической интерполяции (bicubic), которая обычно применяется по умолчанию и смазывает картинку. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/superresolution_f3c0eb057c_af074e8b4e.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1609.04802\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nС помощью генеративных моделей можно закрашивать пропущенные куски изображений. Это полезно, когда мы хотим удалить с фото других людей, и нам нужно закрасить участки, образовавшиеся после их удаления. Эта функция представлена в некоторых современных смартфонах.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/inpainting_lama_cb60a0cc2f_9f287d916a.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/2109.07161\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nВ последние несколько лет хорошо стали работать модели, которые генерируют изображения на основе их текстового описания. Среди таких моделей:\n\n- Stable Diffusion ([Демо](https://huggingface.co/spaces/stabilityai/stable-diffusion)). Модель с открытым [исходным кодом](https://github.com/CompVis/stable-diffusion)\n- [DALLE 2](https://openai.com/dall-e-2/). Доступ по платному API\n- [Midjourney](https://www.midjourney.com/). Доступ через Discord\n- [Imagen](https://imagen.research.google/)\n\n![stable_diffusion_1_1_137e2f686a.webp](https://yastatic.net/s3/education-portal/media/stable_diffusion_1_1_137e2f686a_1d77b97e70.webp)\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stable_diffusion_2_1_f10c87953c_870d4758eb.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Примеры генерации изображений из текстового описания. Модель stable diffusion\n    <a href=\"https://github.com/CompVis/stable-diffusion\">Источник</a></p>\n  </figcaption>\n</figure>\n\nПоявились даже специальные базы изображений, сгенерированных нейронными сетями: [Lexica](https://lexica.art/), [Openart](https://openart.ai/).\n\n\nДоступность таких моделей приводит к появлению множества приложений:\n- [Иллюстрации для книг](https://www.reddit.com/r/midjourney/comments/x4kk0r/i_created_a_graphic_novel_using_mj_and_now_its_on/)\n- [Создание логотипов](https://jacobmartins.com/posts/how-i-used-dalle2-to-generate-the-logo-for-octosql/)\n- [Создание дизайнов помещений](https://interiorai.com/)\n- [Генерация тату](https://www.tattoosai.com/)\n\nКроме этого, некоторые модели позволяют совместить несколько задач и делать закрашивание изображения на основе текстового описания. Например, удалять какую-то область и говорить модели, что там должно быть нарисовано.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stable_diffusion_inpainting_1_fd77de9693_aabc45e095.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Пример закрашивания части изображения на основе текстового описания.\n    <a href=\"https://github.com/runwayml/stable-diffusion\">Источник</a></p>\n  </figcaption>\n</figure>\n\nНа основе этой технологии появились редакторы изображений с генеративными моделями внутри: [Neural love](https://neural.love/), [Photoroom](https://www.photoroom.com/), [ZMO](https://www.zmo.ai/). \n\nСовременные генеративные модели достигли очень хорошего качества и уже стали использоваться в реальных задачах, о которых мы вам рассказали. В следующих параграфах этой главы мы рассмотрим основные методы генеративного обучения более детально.",
        "handbook": "Учебник по машинному обучению",
        "title": "Введение в генеративное моделирование",
        "description": null
    },
    {
        "path": "/handbook/ml/article/variational-autoencoder-(vae)",
        "content": "В машинном обучении есть довольно широкая область, посвящённая обучению генеративных моделей. Их задача — выучить распределение, из которого могли бы быть насемплированы объекты обучающей выборки.\n\nОбученная генеративная модель способна семплировать из выученного распределения новые объекты, не принадлежащие исходным данным. Чаще всего это связано с задачей генерации новых изображений: от изображений рукописных чисел до замены лиц на видео с помощью deepfake.\n\nМодель, о которой пойдёт речь в данном параграфе, называется «Вариационный автоэнкодер» или VAE (variational autoencoder). Она относится к семейству генеративных моделей. Коротко расскажем, что вас ждёт дальше.\n\n- В разделах «Постановка задачи» и «Обучение VAE» мы опишем построение и обучение VAE в классическом описании. Этих двух разделов достаточно для общего представления о VAE. \n- Раздел «Обзор статей» для первоначального понимания не обязателен, но может быть интересен тем, кто захочет узнать о недавних интересных работах, связанных с VAE. \n\nПрежде чем двинуться дальше — небольшое напоминание: большинство картинок в тексте кликабельны, и при клике вы сможете перейти к источнику, из которого была заимствована картинка.\n\n## Постановка задачи\n\nДавайте представим себе, что нам нужно нарисовать лошадь. Как бы мы это сделали?\n\nНаверное, сначала наметили бы общий силуэт лошади, её размер и позу, а затем стали бы добавлять детали: гриву, хвост, копыта, выбирать окраску шерсти и так далее. Кажется, что в процессе обучения рисованию мы учимся выделять для себя основной набор каких-то **факторов**, наиболее важных для генерации нового изображения: общий силуэт, размер, цвет и тому подобное, а во время рисования уже просто подставляем какие-то **значения** факторов.\n\nПри этом одинаковые сочетания одних и тех же факторов могут привести к разным картинкам — ведь нарисовать что-то два раза абсолютно одинаково вы, скорее всего, не сможете.\n\nПопробуем формализовать описанный выше процесс. Пусть у нас есть датасет $D$ в многомерном пространстве исходных данных $X^N$, — объектов, которые мы желаем генерировать, — и пространство $Z^M$ **скрытых (латентных) переменных** меньшей размерности, которыми кодируются скрытые факторы в данных. Тогда генеративный процесс состоит из двух последовательных стадий (см. картинку ниже):\n\n1. Семплирование $z \\in Z^M$ из распределения $p(z)$ (красное)\n2. Семплирование $x \\in X^N$ из распределения $p(x \\| z)$ (синее)\n\n![1.](https://yastatic.net/s3/education-portal/media/lvm_diagram_ce53ef5812_fdf30bc1e1.webp)\n\nТо есть, рассуждая в терминах рисования картинок с лошадками, мы сначала мысленно семплируем некоторое $z$ (размер, форму, цвет, ...), затем дорисовываем все необходимые детали, то есть семплируем из распределения $p(x \\| z)$, и в итоге надеемся, что получившееся будет напоминать лошадку.\n\nТаким образом, построить генеративную модель в нашем случае — значит уметь семплировать с помощью описанного двустадийного процесса объекты, близкие к объектам из обучающей выборки $D$. \n\nГоворя более формально, нам бы хотелось, чтобы наша модель максимизировала правдоподобие $p(x)$ элементов обучающего множества $D$ при описанной процедуре генерации: \n\n$$\np(x) = \\int \\limits_{Z^M} p(x | z) p(z) dz \\to \\max\n$$\n\nПредположим, что совместное распределение $p(x, z)$ параметризовано некоторым параметром $\\theta \\in \\Theta$ и выражается непрерывной по $\\theta$ функцией при каждых фиксированных $x$ и $z$:\n\n$$\np_\\theta(x, z) = p(x, z | \\theta) \\in C(\\Theta)\n$$\n\nТогда\n\n$$\np_\\theta(x, z) = p(x| z, \\theta) p(z | \\theta) = p_\\theta(x | z) p_\\theta(z),\n$$\n\nи мы можем записать следующую задачу оптимизации:\n\n$$\n\\begin{equation}\n    p_\\theta(x) = \\int \\limits_{Z^M} p_\\theta(x | z) p_\\theta(z) dz \\to \\max_{\\theta \\in \\Theta} \\tag{1}\n\\end{equation}\n$$\n\nРешив её, мы построим нашу генеративную модель.\n\n**Замечание 1**. После приведённой выше аналогии с обучением рисованию может ошибочно показаться, что в скрытые переменные всегда заложен некоторый хорошо интерпретируемый смысл. Но на практике это всё же не обязано быть так: те скрытые переменные, которые мы найдём, могут как иметь простую интерпретацию, так и не иметь. С помощью объяснений выше мы прежде всего хотели проиллюстрировать понятие «скрытые переменные».\n\n**Замечание 2**. Может показаться, что $p(x)$ нам откуда-то уже известно, и тогда не ясно, зачем все эти сложности с введением латентных переменных и интегралами. На самом деле, мы действительно можем построить [статистическую оценку](https://en.wikipedia.org/wiki/Density_estimation) $\\hat p(x)$ по данным $D$ и даже пытаться генерировать новые данные с помощью таких моделей (как, например, делается [тут](https://scikit-learn.org/stable/modules/density.html)). Но у статистических методов есть разные ограничения, наиболее серьёзным из которых представляется проклятие размерности: чем больше измерений у ваших данных, тем больше разнообразных примеров вам нужно для построения адекватной оценки $\\hat p(x)$. О проклятии размерности мы поговорим чуть подробнее далее.\n\n**Замечание 3**. Также может возникать вопрос — а зачем вообще нужно вводить латентные переменные, моделировать совместное распределение $p(x, z)$, а целевое распределение $p(x)$ определять как маргинализацию $p(x, z)$ по $z$? Почему такой подход в принципе должен работать? Ответ состоит в том, что, даже имея относительно простые выражения для $p(z)$ и $p(x \\| z)$, можно описать достаточно сложное распределение $p(x)$, что достаточно наглядно проиллюстрировано в примере ниже.\n\n{% cut \"Пример: смесь гауссиан\" %}\n\nПредставьте себе, что у вас есть таблица с конечным числом строк, в $k$-й строке которой записано два числа — среднее $\\mu_k$ и дисперсия $\\sigma^2_k$ нормального распределения. Пусть на индексах строк этой таблицы определено дискретное распределение $p(z)$, такое что:\n\n$$\n    p(z = k) = \\lambda_k\n$$\n\nПусть мы насемплировали индекс $k$, взяли параметры распределения из соответствующей ему строки и насемплировали с этими параметрами объект $x$. Распределение, из которого был получен $x$, равно:\n\n$$\n    p(x | z = k) = \\mathcal{N}(\\mu_k, \\sigma_k^2)\n$$\n\nРаспределение $p(x)$ получается маргинализацией совместного распределения $p(x, z)$ по $z$:\n\n$$\n    p(x) =  \\sum_{k = 1}^K p(x, z = k) = \\sum_{k = 1}^K p(x | z = k) p(z = k) = \\sum_{k = 1}^K \\lambda_k \\mathcal{N}(\\mu_k, \\sigma_k^2)\n$$\n\nПолучилось, что $p(x)$ описывается смесью гауссиан и имеет более сложный вид, чем $p(z)$ и $p(x \\| z)$:\n\n![2](https://yastatic.net/s3/education-portal/media/discrete_gaussian_mixture_757e189f6f_eb17ce766e.webp)\n\nЯсно, что чем больше гауссиан в нашей сумме, тем более сложную форму может иметь $p(x)$. Так, имея простые $p(z)$ и $p(x \\| z)$, мы можем моделировать сложные мультимодальные распределения. А теперь представим себе, что априорное распределение $p(z)$ имеет уже не дискретные, а непрерывные значения. Рассмотрим, например, такой случай:\n\n$$\n    p(z) = \\mathcal{N}(0, 1),\n$$\n\n$$\n    p(x | z) = \\mathcal{N}(\\mu(z), \\sigma^2(z))\n$$\n\nРаспределение $p(x)$, аналогично случаю с дискретным априорным распределением, будет получено интегрированием $p(x, z)$ по $z$ и будет как бы «бесконечной» смесью гауссиан:\n\n![2](https://yastatic.net/s3/education-portal/media/infinite_gaussian_sum_40324553c2_29d8e7bc3f.webp)\n\nС этим разобрались. В следующей главе продолжим говорить о задаче оптимизации, о которой мы начали разговор чуть выше — не теряйтесь!\n\n{% endcut %}\n\n## Обучение VAE\n\nПрежде чем пытаться решать задачу оптимизации  [$ (1) $](#eq:main_problem), давайте подумаем, а как мы вообще могли бы посчитать такой интеграл? Первое, что приходит на ум, — попробовать получить его приближённое значение методом Монте-Карло:\n\n$$\np_\\theta(x) = \\int \\limits_{Z^M} p_\\theta(x | z) p_\\theta(z) dz = \\mathbb{E}_{z \\sim p_\\theta(z)} [p_\\theta(x | z)] \\approx \\frac{1}{K} \\sum_k p_\\theta(x | z_k),\n$$\n\nгде в последнем переходе мы используем сэмплы $z_k \\sim p_\\theta(z)$. Однако, если $z \\in Z^M$ и $M$ — достаточно большое, мы столкнёмся с *проклятием размерности* — количество семплов, необходимых для того, чтобы хорошо покрыть $Z^M$, растёт экспоненциально с ростом $M$:\n\n![3](https://yastatic.net/s3/education-portal/media/curse_of_dimensionality_9ba358f72a_d8f618cf0a.webp)\n\nЕсть ли способ как-то сократить число необходимых семплов для подсчёта  [$ (1) $](#eq:main_problem)? На самом деле, часто оказывается, что далеко не все возможные $z$ отображаются в элементы $D$, и вклад большинства $z$ в оценку $p_\\theta(x \\| z)$ практически нулевой. Это наводит на мысль, что для каждого $x$ нам может пригодиться знание распределения $q(z \\| x)$ таких $z$, которые являются прообразами $x$. Мы можем предположить, что распределение $q$ параметризовано некоторым семейством параметров $\\Phi$:\n\n$$\nq(z | x) = q_{\\phi}(z | x), \\phi \\in \\Phi\n$$\n\nЗная распределение $q_\\phi(z \\| x)$, мы могли бы семлировать уже только из него, а не из всего $p_\\theta(z)$, и, если распределение $q$ окажется достаточно хорошим, число необходимых семплов значительно сократится.\n\nО том, как построить $q_\\phi$, мы поговорим позже. Сейчас стоит обратить внимание на то, что процессы семплирования из распределений $q_\\phi(z \\| x)$ и $p_\\theta(x \\| z)$ взаимно обратны друг к другу: первое отображает элементы датасета в подмножество латентного пространства $Z^M$, то есть действует как *энкодер*, а второе отображает латентные переменные в подмножество $X^N$, то есть действует как *декодер*:\n\n![2](https://yastatic.net/s3/education-portal/media/autoenc_pic_b9155df393_020bce3d93.webp)\n\nТак как оба эти распределения будут участвовать в обучении VAE, возникает аналогия между VAE и [моделями-автоэнкодерами](https://en.wikipedia.org/wiki/Autoencoder#:~:text=Machine%20learninganddata%20mining.%20v.%20t.,network%20to%20ignore%20signal%20“noise”), имеющими похожую структуру.\n\n### Вывод функции потерь\n\nСейчас у нас всё готово для того, чтобы записать общий вид функции потерь для обучения вариационного автоэнкодера. Напомним, что мы обучаем модель путём максимизации правдоподобия $p_{\\theta}(x)$ по $\\theta$. Для удобства мы перейдём к логарифму правдоподобия:\n\n$$\n\\log p_{\\theta}(x) = \\log \\int_{Z^M} p_{\\theta}(x | z) p_{\\theta}(z) d z \\to \\max_{\\theta \\in \\Theta}\n$$\n\nОптимизировать напрямую это выражение тяжело из-за проклятия размерности, обсуждавшегося в прошлом разделе. Чтобы победить проклятие размерности, мы хотели бы заменить семплирование из априорного распределения $p_{\\theta}(z)$ на семплирование из $q_\\phi(z \\| x)$, для чего придётся осуществить некоторый трюк. Для любого $q_\\phi(z \\| x)$, отличного от нуля для всех $z \\in Z^M$, мы можем выписать следующую цепочку равенств:\n\n$$\n\\log p_\\theta(x) = \\mathbb E_{q_\\phi(z | x)} [\\log p_\\theta (x)] = \\\\\n$$\n\n$$\n= \\mathbb E_{q_\\phi(z | x)} \\left[ \n    \\log \\left( \n        \\frac{p_\\theta (x, z)}{p_\\theta(z | x)} \n    \\right) \n\\right] = \\\\\n$$\n\n$$ \n= \\mathbb E_{q_\\phi(z | x)} \\left[ \n    \\log \\left( \n        \\frac{p_\\theta (x, z)}{q_\\phi(z | x)} \\frac{q_\\phi(z | x)}{p_\\theta(z | x)}\n    \\right) \n\\right] = \\\\\n$$\n\n$$ \n= \\underbrace{\n    \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log \\left( \n            \\frac{p_\\theta (x, z)}{q_\\phi(z | x)}\n        \\right) \n    \\right]\n    }_{\\mathcal L_{\\theta, \\phi}(x) \\\\ (ELBO)} + \n    \\underbrace{\n    \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log \\left( \n            \\frac{q_\\phi(z | x)}{p_\\theta(z | x)}\n        \\right) \n    \\right]\n    }_{D_{KL}(q_{\\phi}(z | x) \\parallel p_\\theta (z | x))}\n$$\n\nВторое слагаемое в последнем равенстве — [$KL$-дивергенция](http://www.machinelearning.ru/wiki/images/d/d0/BMMO11_6.pdf) между $q_\\phi(z \\| x)$ и $p_\\theta(z \\| x)$, которая, как известно, неотрицательна:\n\n$$\n    D_{KL}(q_{\\phi}(z | x) \\parallel p_\\theta (z | x)) \\ge 0\n$$\n\nА первое слагаемое — это величина, именуемая в английской литературе **evidence lower bound (ELBO)**:\n\n$$\n\\mathcal L_{\\theta, \\phi} (x) =\n\\mathbb E_{q_\\phi(z | x)} \\left[ \n    \\log p_\\theta (x, z) - \\log q_\\phi(z | x)\n\\right] = \\\\\n$$\n\n$$\n= \\underbrace{ \\mathbb E_{q_\\phi(z | x)} \\left[ \n    \\log p_\\theta (x | z)\n\\right]}_{\\text{reconstruction loss}} - \\underbrace{D_{KL} (q_\\phi(z | x) \\parallel p_\\theta (z))}_{\\text{regularization term}}\n$$\n\nПервое слагаемое в последнем переходе обычно называют **reconstruction loss**, так как оно оценивает качество восстановления декодером объекта $x$ из его латентного представления $z$. А второе играет роль регуляризационного члена и подталкивает распределение, генерируемое энкодером, быть ближе к априорному распределению.\n\nТак как $KL$-дивергенция неотрицательна, ELBO является нижней границей для логарифма правдоподобия данных:\n\n$$\n\\mathcal L_{\\theta, \\phi} (x) =  \\log p_\\theta (x) - D_{KL}(q_\\phi (z | x) \\parallel p_\\theta(z | x)) \\le \\log p_\\theta (x)\n$$\n\nПосмотрим повнимательнее на равенства, которые мы выписали.\n- Функцию $\\mathcal L_{\\theta, \\phi}$ можно оптимизировать градиентным спуском (SGD), предварительно выбрав удобный вид для $p_\\theta (x \\| z)$, $q_\\phi(z \\| x)$ и $ p_\\theta (z)$. Максимизируя $\\mathcal L_{\\theta, \\phi}$, мы растим $\\log p_\\theta (x)$, тем самым улучшая нашу генеративную модель. Оптимизацию ELBO с помощью SGD мы будем подробно обсуждать в следующем разделе.\n- Максимизируя $\\mathcal L_{\\theta, \\phi}$, мы одновременно минимизируем $D_{KL}(q_\\phi(z \\| x) \\parallel p_\\theta (z \\| x))$. Распределение $p_\\theta (z \\| x)$ оценивает, из каких $z$ мог бы быть сгенерирован объект $x$, и заранее оно нам не известно. Но если мы выберем достаточно большую модель для $q_\\phi(z \\| x)$, то $q_\\phi(z \\| x)$ в процессе оптимизации может очень сильно приблизиться к $p_\\theta (z \\| x)$, и тогда мы будем напрямую оптимизировать $\\log p_\\theta(x)$. Заодно мы получаем приятный бонус: для оценки распределения прообразов $x$ мы сможем использовать $q_\\phi(z \\| x)$ вместо невычислимого $p_\\theta (z \\| x)$. То есть $q_\\phi$, которое мы при выводе формулы ввели в рассмотрение как произвольное распределение, действительно будет играть роль энкодера для модели.\n\n{% cut \"Альтернативный вывод выражения для ELBO\" %}\n\nВ рассуждениях выше введение $q_{\\phi}(z \\| x)$ в рассмотрение могло показаться довольно формальным. Поэтому мы приведём здесь ещё один подход к выводу выражения для ELBO, который может показаться более естественным. Он состоит в последовательном применении приёма, называемого [importance sampling](https://statweb.stanford.edu/~owen/mc/Ch-var-is.pdf), и неравенства Йенсена.\n\n![2](https://yastatic.net/s3/education-portal/media/importance_sampling_b8e2228d10_09295299ff.webp)\n\nВо многих практических задачах возникает ситуация, в которой мы хотим вычислить $\\mu = \\mathbb E[ f(X) ]$, но при этом $f(x)$ близка к нулю вне некоторой области $A$, а вероятность попасть в эту важную область очень мала: $P(X \\in A) \\approx 0$.\n\nМножество $A$ может либо иметь слишком маленькую мощность, либо быть в хвосте распределения случайной величины $X$. Обычное семплирование по методу Монте-Карло может почти не сгенерировать примеров, которые бы попадали в множество $A$. Проблемы такого типа довольно часто встречаются в физике высоких энергий, байесовском выводе, прогнозировании опасных природных явлений и во многих других областях.\n\nДостаточно интуитивным выглядит решение, состоящие в том, чтобы попробовать как-то искусственно увеличить долю важных примеров среди всех остальных. Это можно сделать, используя распределение, дающее больше веса примерам из важной области. Отсюда и название метода — **importance sampling** (выборка по значимости).\n\nИтак, пусть наша задача — вычислить математическое ожидание $\\mu = \\mathbb E_p\\left[ f(x) \\right] = \\int_{\\mathcal D} f(x) p(x) dx$, где \n- $p$ — плотность распределения на множестве $\\mathcal D \\in \\mathbb R^d$, \n- $f$ — некоторая интегрируемая функция. \n\nПусть $q$ — функция плотности вероятности, определённая и положительная на $\\mathcal D$, позволяющая осуществлять семплирование примеров из некоторого интересующего нас узкого подмножества. Наша задача — перейти от семплирования из $p$ к семплированию из $q$ для оценки $\\mu$. Поскольку среднее $\\mathbb E_q\\left[ f(x) \\right]$, вообще говоря, не равно $\\mu$, запишем следующее:\n\n$$\n\\mu = \\mathbb E_p\\left[ f(x) \\right] = \\int_{\\mathcal D} f(x) p(x) dx = \\int_{\\mathcal D} \\frac{f(x) p(x)}{q(x)} q(x) dx = \\mathbb E_q\\left[ \\frac{f(x) p(x)}{q(x)} \\right]\n$$\n\nИсходная плотность $p$ называется номинальной (nominal distribution), а плотность $q$ — смещённой (importance distribution). Отношение правдоподобия $\\frac{p(x)}{q(x)}$ компенсирует смещение, возникающее при переходе от $p$ к $q$.\n\nНапомним также формулировку неравенства Йенсена для случайных величин.\n\nНапомним также формулировку неравенства Йенсена для случайных величин: если $\\xi$ — случайная величина с конечным математическим ожиданием и $g(x)$ — выпуклая функция, то:\n\n$$\n\\mathbb E[g (\\xi)] \\ge g(\\mathbb E [\\xi])\n$$\n\nТеперь вернёмся к исходной задаче. Снова, для любого $q_\\phi(z \\| x)$, отличного от нуля для всех $z \\in Z^M$, мы можем записать:\n\n$$\n    \\log p_\\theta (x) = \\log \\int_{Z^M} p_\\theta(x | z) p_{\\theta}(z) dz = \\\\\n$$\n\n$$\n    = \\log \\mathbb{E}_{p_\\theta(z)} [p_\\theta(x | z)] = \\\\\n$$\n\n$$\n    = \\log \\mathbb{E}_{q_\\phi(z | x)} \\left[ \\frac{p_\\theta(x | z) p_\\theta(z)}{q_\\phi(z | x)} \\right] \\ge \\\\\n$$\n\n$$\n    \\ge \\mathbb E_{q_\\phi(z | x)} \\log \\left[ \\frac{p_\\theta(x | z) p_\\theta(z)}{q_\\phi(z | x)} \\right] = \\\\\n$$\n\n$$\n   = \\mathbb E_{q_\\phi(z | x)} \\log \\left[p_\\theta(x | z) \\right] - \\mathbb E_{q_\\phi(z | x)} \\log \\left[\\frac{q_\\phi(z | x)}{p_\\theta(z)} \\right] = \\\\\n$$\n\n$$\n   = \\mathbb E_{q_\\phi(z | x)} \\log \\left[p_\\theta(x | z) \\right] - D_{KL} (q_\\phi(z | x) \\parallel p_\\theta (z))\n$$\n\nВ результате проведённых выкладок мы, как можно заметить, снова получили выражение для ELBO. На третьем переходе мы применили importance sampling, а на четвёртом — неравенство Йенсена для $g(x) = \\log (x)$.\n\nМинус данного подхода состоит в том, что он, в отличие от предыдущего способа, не позволяет выписать в явном виде формулу для разности между $\\log p_\\theta (x)$ и ELBO:\n\n$$\n    \\log p_\\theta (x) - ELBO = D_{KL}(q_{\\phi}(z | x) \\parallel p_\\theta (z | x))\n$$\n\nНо зато данный вывод естественным образом следует из более общих методов, не требуя применения искусственных трюков.\n\n{% endcut %}\n\n### Обучение VAE с помощью градиентного спуска\n\nВажное свойство ELBO в том, что его можно оптимизировать градиентным спуском относительно параметров $\\phi$ и $\\theta$. Если объекты датасета $D$ независимы и одинаково распределены, то $\\mathcal L_{\\theta, \\phi} (D)$ запишется как сумма (или среднее) значений $\\mathcal L_{\\theta, \\phi} (x)$ на объектах $x \\in D$:\n\n$$\n    \\mathcal L_{\\theta, \\phi} (D) = \\sum_{x \\in D} \\mathcal L_{\\theta, \\phi} (x)\n$$\n\nЗначения $\\mathcal L_{\\theta, \\phi} (x)$ и их градиенты $\\nabla \\mathcal L_{\\theta, \\phi} (x)$ в общем случае вычислить невозможно, однако можно получить их несмещённые оценки, что позволит нам использовать стохастический градиентный спуск.\n\nОценку для градиента по параметрам $\\theta$ получить несложно:\n\n$$\n    \\nabla_\\theta \\mathcal L_{\\theta, \\phi}(x)\n    = \\nabla_\\theta \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log p_\\theta(x, z) - \\log q_\\phi(z | x)\n    \\right] = \\\\\n$$\n\n$$\n    = \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\nabla_\\theta(\\log p_\\theta(x, z) - \\log q_\\phi(z | x))\n    \\right] = \\\\\n$$\n\n$$\n    = \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\nabla_\\theta \\log p_\\theta(x, z)\n    \\right] \\approx \\\\\n$$\n\n$$\n    \\approx \\frac{1}{K} \\sum_k \\nabla_\\theta \\log p_\\theta(x, z_k),\n$$\n\nгде в последней строчке $z_k \\sim q_\\phi(z \\| x)$. Однако оценку на градиент по параметрам $\\phi$ получить сложнее, ведь они также участвуют и в семплировании:\n\n$$\n     \\nabla_\\phi \\mathcal L_{\\theta, \\phi}(x)\n    = \\nabla_\\phi \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log p_\\theta(x, z) - \\log q_\\phi(z | x)\n    \\right] \\ne \\\\\n$$\n\n$$\n    \\ne \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\nabla_\\phi(\\log p_\\theta(x, z) - \\log q_\\phi(z | x))\n    \\right]\n$$\n\nВ общем случае эта проблема не разрешима. Однако некоторые распределения позволяют применить **репараметризацию (reparameterization trick)**: представить переменную $z$ как обратимую дифференцируемую функцию от случайного шума, параметров $\\phi$ и переменнной $x \\in D$:\n\n$$\n    z = g(\\varepsilon, \\phi, x)\n$$\n\nЗдесь распределение $\\varepsilon \\sim p_\\varepsilon$ не зависит от $\\phi$ и $x$. Например, пусть $\\varepsilon \\sim \\mathcal N (0, I)$. Тогда $g$ может иметь следующий вид:\n\n$$\n    z = g(\\varepsilon, \\phi, x) = \\mu_\\phi(x) + \\varepsilon \\cdot \\sigma_\\phi(x) \\sim \\mathcal N (\\mu_\\phi(x), \\sigma^2_\\phi(x))\n$$\n\nПосле такой замены мы сможем получить оценку на градиент по $\\phi$:\n\n$$\n     \\nabla_\\phi \\mathcal L_{\\theta, \\phi}(x)\n    = \\nabla_\\phi \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log p_\\theta(x, z) - \\log q_\\phi(z | x)\n    \\right] = \\\\\n$$\n$$\n    = \\nabla_\\phi \\mathbb E_{p_\\varepsilon} \\left[ \n        \\log p_\\theta(x, g(\\varepsilon, \\phi, x)) - \\log q_\\phi(g(\\varepsilon, \\phi, x) | x)\n    \\right] = \\\\\n$$\n$$\n    = \\mathbb E_{p_\\varepsilon} \\left[ \n        \\nabla_\\phi \\big( \n            \\log p_\\theta(x, g(\\varepsilon, \\phi, x)) - \\log q_\\phi(g(\\varepsilon, \\phi, x) | x) \n        \\big)\n    \\right] \\approx \\\\\n$$\n$$\n    \\approx \\frac{1}{K} \\sum_{k} \\nabla_\\phi \\big( \n        \\log p_\\theta(x, g(\\varepsilon_k, \\phi, x)) - \\log q_\\phi(g(\\varepsilon_k, \\phi, x) | x)\n    \\big),\n$$\n\nгде в последней строчке $\\varepsilon_k \\sim p_\\varepsilon$. Репараметризация хорошо иллюстрируется следующей картинкой:\n\n![2](https://yastatic.net/s3/education-portal/media/reparametrization_92f25ad7f1_6321ae51f3.webp)\n\nЗдесь $f$ — функция потерь. Значения $f$ на обеих схемах одинаковы, но на левой картинке градиенты по $\\phi$ рассчитать не получится, так как мы не можем дифференцировать по случайной переменной $z$.\n\nОднако на правой картинке источник случайности перемещается во входные данные благодаря репараметризации, а градиенты вычисляются по детерминированным переменным. Таким образом, мы получили сетап, типичный для оптимизации с помощью SGD: там мы приближаем градиент функции потерь по случайным батчам входных данных, а здесь роль случайных батчей играют одновременно батчи из переменных $x$ и случайных переменных $\\varepsilon$.\n\nКроме нормального распределения, есть довольного много примеров распределений, допускающих репараметризацию. Их можно найти [по ссылке](https://arxiv.org/pdf/1312.6114.pdf) в разделе \"The reparameterization trick\". Однако большая часть реализаций VAE используют именно нормальное распределение.\n\nВ итоге примерный алгоритм обучения VAE такой:\n\n``` python\ndataset = np.array(...)\nepsilon = RandomDistribution(...)\n\n# Энкодер q_phi(z|x) — нейронная сеть с параметрами phi\nencoder = Encoder()\n\n# Декодер p_theta(x|z) — нейронная сеть с параметрами theta\ndecoder = Decoder()\n\nfor step in range(max_steps):\n     # Семплируем батч исходных данных и случайного шума\n     batch_x = sample_batch(dataset)\n     batch_noise = sample_batch(epsilon)\n    \n     # Считаем параметры распределения q(z | x) с помощью энкодера\n     latent_distribution_parameters = encoder(batch_x)\n     \n     # Делаем репараметризацию (семплируем из q(z | x))\n     z = reparameterize(latent_distribution_parameters, batch_noise)\n\n     # Декодер отдаёт параметры выходного распределения\n     output_distribution_parameters = decoder(z)\n\n     # Вычисляем ELBO и обновляем параметры моделей\n     L = -ELBO(\n        latent_distribution_parameters, \n        output_distribution_parameters, \n        batch_x\n     )\n     L.backward()\n```\n\nСтоит подчеркнуть, что декодер выдаёт именно параметры выходного распределения, а не конкретный семпл из этого распределения. Например, если вы моделируете выходные изображения с помощью нормального распределения $\\mathcal{N}(\\mu(z), \\sigma^2(z))$, то декодер на выходе предскажет некоторые $\\hat \\mu(z)$ и $\\hat \\sigma(z)$, которые вместе с параметрами латентного распределения (выход энкодера) будут поданы в ELBO.\n\nДля генерации конкретной картинки на этапе инференса нужно будет либо честно провести семплирование из $\\mathcal{N}(\\hat \\mu(z), \\hat \\sigma^2(z))$, либо, как часто делают, просто взять среднее $\\hat \\mu(z)$ в качестве выходного изображения. В общем случае конкретный способ проведения инференса зависит от вида используемого выходного распределения.\n\n### Выбор вида используемых распределений\n\nПришло время привести примеры конкретных $p_\\theta(x \\| z)$, $q_\\phi(z \\| x)$ и $p_\\theta(z)$, с которыми можно построить VAE. Для начала предположим, что $p_\\theta(z)$ можно положить равным стандартному нормальному распределению:\n\n$$\n    p_\\theta(z) = \\mathcal N(0, I)\n$$\n\nЗаметим, что в этом случае у априорного распределения $z$ отсутствует зависимость от параметров $\\theta$. \n\nРаспределение $p_\\theta(x \\| z)$ зависит от того, к какому распределению принадлежат ваши данные. Если ваши данные имеют непрерывное распределение, то $p_\\theta(x \\| z)$ можно задать, например, как гауссовское распределение:\n\n$$\n    p_\\theta(x | z) = \\mathcal N(f_\\theta(z), \\sigma^2)\n$$\n\nВектор средних в этом примере определяется функцией $f$ с переменными $\\theta$ и $z$, а матрица ковариаций определяется постоянной диагональной матрицей. Функцию $f$ можно задать с помощью нейронной сети с параметрами $\\theta$. При желании, матрицу ковариаций тоже можно задавать некоторой функцией и не ограничивать её вид только постоянными матрицами. Если же ваши данные дискретны, то может подойти категориальное распределение:\n\n$$\n    p_\\theta(x | z) = \\operatorname{Categorical}(f_\\theta(z)),\n$$\n\nв котором вектор вероятностей $f_\\theta(z) = (p_1, \\ldots, p_n)$ — выход нейросети после применения $\\text{softmax}$. Если у вас бинарные данные, вы можете использовать бернуллиевское распределение:\n\n$$\n    p_\\theta(x | z) = \\operatorname{Bernoulli}(f_\\theta(z)),\n$$\n \nгде $f_\\theta(z) = p$ — выход нейронной сети после применения сигмоиды.\n\nРаспределение $q_\\phi(z \\| x)$ может, в принципе, быть любым, но в самом простом случае оно имеет вид гауссовского распределения c диагональной матрицей ковариаций:\n\n$$\n    q_\\phi(z | x) = \\mathcal N(\\mu_\\phi(x), \\sigma_\\phi^2(x))\n$$\n\nТакое распределение позволяет, в частности, применить репараметризацию, обсуждавшуюся выше. Если выбрать $z$ двумерным, то распределения, определямые $q$, хорошо визуализируются:\n\n![2](https://yastatic.net/s3/education-portal/media/encoder_vae_diagram_dad0562e49_1e0f9bbb40.svg)\nА теперь вспомним, как определяется ELBO:\n\n$$\n    \\mathcal L_{\\theta, \\phi} (x) \n    = \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log p_\\theta (x | z)\n    \\right] - D_{KL} (q_\\phi(z | x) \\parallel p_\\theta (z))\n$$\n\nВычислим его для приведённых выше распределений. \n\nНачнём с $D_{KL} (q_\\phi(z \\| x) \\parallel p_\\theta (z))$. $KL$-дивергенция между распределениями $\\mathcal N(\\mu, \\Sigma)$ и $\\mathcal N(0, I)$ равна:\n\n$$\n     D_{KL} ( N(\\mu, \\Sigma) \\parallel \\mathcal N(0, I)) = \\frac{1}{2} \\left(\n        \\mu^T \\mu + tr \\Sigma - M - \\log (\\det \\Sigma)\n     \\right),\n$$\n\nгде $M$ — размерность этих распределений. Вывод этого соотношения можно найти [здесь](https://mr-easy.github.io/2020-04-16-kl-divergence-between-2-gaussian-distributions/). В нашем случае $\\mu_\\phi(x) = (\\mu_1, \\ldots, \\mu_M)$, $\\sigma^2_\\phi(x) = \\operatorname{diag}(\\sigma^2_1, \\ldots, \\sigma^2_M)$ и\n\n$$\n    D_{KL} (q_\\phi(z \\| x) \\parallel p_\\theta (z)) = D_{KL} (\\mathcal N(\\mu_\\phi(x), \\sigma_\\phi^2(x)) \\parallel \\mathcal{N}(0, I)) = \\\\\n$$\n\n$$\n    = \\frac{1}{2} \\sum_{j = 1}^M (\\sigma_j^2 + \\mu_j^2 - 1 - \\ln \\sigma_j^2)\n$$\n\nТогда ELBO будет вычисляться как:\n\n$$\n    \\mathcal L_{\\theta, \\phi} (x) = \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log p_\\theta (x | z)\n    \\right] - D_{KL} (q_\\phi(z | x) \\parallel p_\\theta (z)) = \\\\\n$$\n$$\n    = \\mathbb E_{\\mathcal N(\\mu_\\phi(x), \\sigma_\\phi^2(x))} \\left[ \n        \\log p_\\theta (x | z)\n    \\right] - \\frac{1}{2} \\sum_{j = 1}^M (\\sigma_j^2 + \\mu_j^2 - 1 - \\ln \\sigma_j^2) \\approx \\\\\n$$\n$$\n    \\approx \\frac{1}{K} \\sum_{k = 1}^K \\log p_\\theta (x | z_k) + \\frac{1}{2} \\sum_{j = 1}^M (1 + \\ln \\sigma_j^2 - \\mu_j^2 -\\sigma_j^2),\n$$\n\nгде $z_k \\sim \\mathcal N(\\mu_\\phi(x), \\sigma_\\phi^2(x))$. Как было упомянуто в [этой статье](https://arxiv.org/pdf/1312.6114.pdf) от авторов VAE в разделе 2.3, число семплирований $K$ можно положить равным единице при достаточно большом размере батча (например, 100). \n\nЕсли вы выберете биномиальное $p_\\theta (x \\| z)$, то \n\n$$\n    \\log p_\\theta (x | z) = \\sum_{j = 1}^D \\log p_\\theta(x_j | z) = \\sum_{j = 1}^D \\log \\operatorname{Bernoulli}(x_j, p_j) = \\\\\n$$\n$$\n    = \\sum_{j = 1}^D x_j \\log p_j + (1 - x_j) \\log(1 - p_j)\n$$\n\nЕсли гауссовское $\\mathcal N(f_\\theta(z), \\sigma^2)$, то\n\n$$\n    \\log p_\\theta (x | z) = \\sum_{j = 1}^D \\log p_\\theta(x_j | z) = \\sum_{j = 1}^D \\log \\left( \n        \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( \n            -\\frac{(x_j - f_{\\theta, j}(z))^2}{2 \\sigma^2}\n        \\right)\n    \\right) = \\\\\n$$\n$$\n    = - \\frac{D}{2} \\log 2 \\pi - D \\log \\sigma - \\frac{1}{2 \\sigma^2} \\sum_{j = 1}^D (x_j - f_{\\theta, j}(z))^2\n$$\n\nПример реализации обучения и применения VAE на датасете MNIST на Keras можно найти [здесь](https://blog.keras.io/building-autoencoders-in-keras.html), а на PyTorch — [здесь](https://github.com/pytorch/examples/blob/master/vae/main.py).\n\n### Инференс обученной модели\n\nКогда мы обучили VAE, мы сможем генерировать новые семплы, просто подавая $z \\sim \\mathcal{N}(0, I)$ на вход декодеру:\n\n![2](https://yastatic.net/s3/education-portal/media/vae_decoder_diagram_385be2e566_6c396a28e8.svg\"></a>\n\nЭнкодер для генерации новых семплов не нужен. Однако нам может понадобиться оценить $p(x) = \\int p(x \\| z) p(z) dz$ для $x$ из тестового множества, чтобы понять, с какой вероятностью модель сможет сгенерировать $x$. Для оценки интеграла нам нужно насемплировать некоторое количество $z$, и если брать семплы из $z \\sim \\mathcal{N}(0, I)$, то оценка может плохо сойтись. Но можно снова использовать ELBO как нижнюю границу для $\\log p(x)$ и оценивать уже её, семплируя из распределения $q_\\phi(z \\| x)$. Такая оценка сойдётся быстрее и даст примерное представление о том, насколько хорошо модель справляется с конкретным примером $x$.\n\nТакже интересно бывает взглянуть на то, как распределены коды обучающих примеров в латентном пространстве. Так, например, может выглядеть распределение латентных кодов цифр MNIST для обученного VAE в двумерном латентном пространстве:\n\n![2](https://yastatic.net/s3/education-portal/media/vae_classes_plane_0fa7689113_4e6b5e1037.webp)\n\nРазные типы цифр обозначены разными цветами (соответствие цифр и цветов показано на шкале сбоку). Здесь видно, что лучше всего модель различает нули и единицы, а восьмёрки и тройки — хуже всего. Стоит, конечно, отметить, что латентное пространство выбрано двумерным в целях визуализации, и при большей его размерности модель могла бы научиться различать цифры более качественно.\n\nДля двумерного латентного пространства есть ещё один интересный способ визуализировать структуру многообразия, выученного VAE. Можно взять равномерную сетку на единичном квадрате и отобразить её в латентное пространство, применив к ней функцию, обратную к CDF нормального распределения. \n\n{% cut \"Почему это сработает\" %}\n\nУзлы равномерной сетки $u_{ij}$ можно в некотором приближении считать семплами из равномерного распределения: $u_{ij} \\sim \\text{Uniform}([0, 1])$. Поэтому семплы $\\Phi^{-1}(u_{ij})$ приближённо подчиняются нормальному распределению:\n\n$$\n    \\mathbb P(\\Phi^{-1}(u_{ij}) \\le t) = \\mathbb P(u_{ij} \\le \\Phi(t)) = \\Phi(t)\n$$\n\n{% endcut %}\n\nПолученные семплы можно подать в декодер и посмотреть, какие картинки будут соответствовать узлам сетки:\n\n![2](https://yastatic.net/s3/education-portal/media/manifolds_6b5b85515c_c695dfba8d.webp)\n\nЗдесь изображены примеры, сгенерированные для датасетов Frey Face и MNIST (оба доступны по [ссылке](https://cs.nyu.edu/~roweis/data.html)). Такая визуализация позволяет увидеть плавный переход латентных кодов одних объектов в коды других, а также взаимное расположение латентных кодов.\n\nДля MNIST снова видно, в частности, что коды нулей и единиц модель разнесла далеко друг от друга, а коды троек и восьмёрок очень близки. А ещё интересно наблюдать плавный переход от шестёрок к нулям и от семёрок к единицам. Для Frey Face видно, что весёлые лица расположены далеко от грустных, а по главной диагонали квадрата можно проследить плавный переход от серьёзного лица к улыбающемуся.\n\nЕщё интересно посмотреть на то, как меняется качество генерируемых цифр в зависимости от размерности латентного пространства (на картинках просто случайные семплы из модели):\n\n![2](https://yastatic.net/s3/education-portal/media/latent_spaces_129c8124ab_024fd5632c.webp)\n\nЗаметный переход виден между размерностями 2 и 5, дальнейший рост размерности почти не оказывает значимого эффекта.\n\n### Conditional VAE (CVAE)\n\nИногда мы можем захотеть сгенерировать не просто какой-то произвольный объект из датасета, а относящийся к конкретной группе или классу. Ранее мы выписывали уравнение для $\\log p_\\theta(x)$:\n\n$$\n    \\log p_\\theta(x) = \\mathbb E_{q_\\phi(z | x)} \\left[ \n        \\log p_\\theta (x | z)\n    \\right] - D_{KL} (q_\\phi(z | x) \\parallel p_\\theta (z)) + D_{KL}(q_{\\phi}(z | x) \\parallel p_\\theta (z | x))\n$$\n\nВсе распределения, участвующие в этом уравнении, мы можем сделать обусловленными по переменной $y$:\n\n$$\n    \\log p_\\theta(x | y) = \\mathbb E_{q_\\phi(z | x, y)} \\left[ \n        \\log p_\\theta (x | z, y)\n    \\right] - D_{KL} (q_\\phi(z | x, y) \\parallel p_\\theta (z | y)) + D_{KL}(q_{\\phi}(z | x, y) \\parallel p_\\theta (z | x, y))\n$$\n\nПеременная $y$ может быть лейблом объекта $x$ или вообще произвольным тензором, как-то характеризующим $x$. Вместо $p_\\theta(z)$, единого для всех $x$ из обучающей выборки, для каждого значения $y$ теперь будет отдельное априорное распределение $p_\\theta(z \\| y)$.\n\nПеременная $y$ может принимать и дискретные, и непрерывные значения. Она может даже, например, быть половиной изображения, которую модели предлагается дополнить. На всякий случай подчеркнём, что обучение CVAE — это не то же самое, что обучение нескольких независимых VAE, так как веса CVAE общие для всех классов.\n\nНа уровне имплементации это реализуется довольно просто: нужно всего лишь сконкатенировать входы энкодера и декодера с тензором, соответствующим $y$. Если $y$ имеет категориальные значения, то бывает полезно предварительно закодировать их one-hot векторами. Алгоритм будет примерно таким:\n\n``` python\ndataset, labels = np.array(...), np.array(...)\nepsilon = RandomDistribution(...)\n\n# Энкодер q_phi(z|x) — нейронная сеть с параметрами phi\nencoder = Encoder()\n\n# Декодер p_theta(x|z) — нейронная сеть с параметрами theta\ndecoder = Decoder()\n\nfor step in range(max_steps):\n     # Семплируем батч исходных данных, лейблов и случайного шума\n     batch_x = sample_batch(dataset)\n     batch_y = sample_batch(labels)\n     batch_noise = sample_batch(epsilon)\n\n     # Подаём в энкодер конкатенацию входных данных и лейблов\n     encoder_input = concatenate([batch_x, batch_y])\n    \n     # Считаем параметры распределения z с помощью энкодера\n     latent_distribution_parameters = encoder(encoder_input)\n     # Делаем репараметризацию\n     z = reparameterize(latent_distribution_parameters, batch_noise)\n\n     # Конкатенируем полученный случайный вектор и лейблы\n     decoder_input = concatenate([z, batch_y])\n\n     # Декодер отдаёт нам выходное изображение\n     output_distribution_parameters = decoder(decoder_input)\n\n     # Вычисляем ELBO и обновляем параметры\n     L = -ELBO(\n        latent_distribution_parameters, \n        output_distribution_parameters, \n        batch_x\n     )\n     L.backward()\n```\n\nРеализацию CVAE на PyTorch и Tensorflow можно найти, например, [здесь](https://github.com/wiseodd/generative-models/tree/master/VAE/conditional_vae).\n\nЕсли визуализировать распределение латентных кодов для цифр MNIST, полученных после обуславливания модели на класс цифры, то можно увидеть что-то такое:\n\n![2](https://yastatic.net/s3/education-portal/media/z_dist_cvae_b651c517c3_b275364e3a.webp)\n\nМы видим непонятную смесь из точек вместо явных кластеров, которые выделяла обычная модель VAE. Однако дело тут в том, что, вместо того, чтобы пытаться размещать все цифры в одном пространстве $p(z) \\sim \\mathcal N (0, I)$, модель использует отдельное латентное пространство $p(z \\| y) \\sim \\mathcal N (0, I)$ для каждой цифры:\n\n![2](https://yastatic.net/s3/education-portal/media/cvae_manifold_6_becdec52d5_1e4e21995e.webp)\n![2](https://yastatic.net/s3/education-portal/media/cvae_manifold_7_b98915c786_33c732547a.webp)\n\nНа картинке справа — априорные распределения для цифр 6 и 7, а слева — визуализация структуры выученных многообразий для этих цифр, построенная так же, как аналогичная визуализация для VAE. Качество изображений каждой отдельной цифры заметно повышается:\n\n![2](https://yastatic.net/s3/education-portal/media/samples_from_cvae_60f0f65726_44246fd857.webp)\n\nВидно, что вариабельность генерации цифр теперь тоже заметно выросла, и модель может имитировать написание цифр разными почерками.\n\n## Обзор статей\n\nКроме стандратного описания работы VAE, приведём результаты нескольких недавних интересных работ, базирующихся на идее VAE.\n\n### VQ-VAE и VQ-VAE-2\n\nМодели [VQ-VAE](https://arxiv.org/pdf/1711.00937v2.pdf) и [VQ-VAE-2](https://arxiv.org/pdf/1906.00446.pdf) интересны тем, что в них в качестве априорных распределений были задействованы дискретные распределения. В каких ситуациях дискретные распределения могут быть более применимы, чем непрерывные? Например, если мы имеем дело с токенам в задачах NLP или фонемами в обработке речи. Картинки также можно было бы кодировать некоторым набором из целых чисел: например, одно число могло бы кодировать тип объекта, другое — его цвет, третье — цвет фона и так далее:\n\n![2](https://yastatic.net/s3/education-portal/media/discrete_enc_dec_2dba0b17a0_6f46c2a61b.webp)\n\nКроме того, существуют довольно мощные алгоритмы (например, [Трансформер](https://arxiv.org/abs/1706.03762)), предназначенные для работы с дискретными данными. Выучивание хороших дискретных представлений даёт возможность эффективно использовать такие алгоритмы для, например, задачи генерации картинок.\n\n#### VQ-VAE\n\nАвторы VQ-VAE вводят дискретное латентное пространство в виде $K$ вещественных векторов $e_1, \\ldots, e_K$ размерности $D$. Векторы из этого пространства называются **кодовыми векторами** или **кодами**. На рисунке ниже приведена примерная схема обучения предлагаемой модели.\n\n![2](https://yastatic.net/s3/education-portal/media/vq_vae_40e8acafa9_1e58753f42.webp)\n\nЭнкодер принимает на вход картинку $x$ и выдаёт на выходе тензор $z_e(x)$. На рисунке этот тензор имеет размерность $M \\times M \\times D$: последняя размерность совпадает с длиной кодовых векторов, а $M \\times M$ — это пространственная размерность выхода CNN (для простоты мы здесь не пишем явно размерность батчей).\n\nКаждый из $M \\times M$ векторов из $z_e(x)$ отображается в ближайший к нему по $L_2$-расстоянию кодовый вектор. После такой процедуры тензор $z_e(x)$ переходит в тензор $z_q(x)$, состоящий из $M \\times M$ кодовых векторов. Декодер получает на вход тензор $z_q(x)$ и отображает его в исходную картинку. Для работы с речью и текстами авторы использовали двумерный тензор $z_e(x)$ вместо трёхмерного.\n\nВыходное распределение энкодера $q(z \\| x)$ определено здесь следующим образом:\n\n$$\nq(z=k|x)=\\begin{cases}1,&k=\\arg\\min_j\\|z_e(x)-e_j\\|_2,\\\\0,&\\text{иначе}\\end{cases}\n$$\n\nВо время обучения в качестве априорного распределения в латентном пространстве используется равномерное распределение $p(z) = \\frac{1}{K}$, поэтому слагаемое $D_{KL} (q(z \\| x) \\parallel p (z))$ оказывается постоянным и равным $\\log K$:\n\n$$\n    D_{KL} (q(z | x) \\parallel p (z)) = - \\sum_{k = 1}^K q(z = k | x) \\log \\left( \\frac{p(z)}{q(z = k | x)} \\right) = \\log K\n$$\n\nВ точках, где $q(z = k \\| x) = 0$, предпоследнее выражение продолжается нулём по непрерывности. Таким образом, ELBO для таких распределений примет вид\n\n$$\n    ELBO(x) = \\mathbb{E}_{q(z | x)} [\\log p_\\theta (x | z_e(x))] - D_{KL} (q(z | x) \\parallel p (z)) = \\log p_\\theta (x | z_q(x)) - \\log K,\n$$\n\nгде $\\theta$ — параметры декодера. При оптимизации $\\log K$ можно не учитывать. Отображение выхода энкодера в кодовые векторы не дифференцируемо, поэтому при обучении применяется следующий трюк: при обратном проходе градиент копируется напрямую из декодера в энкодер, пропуская при этом слой, отображающий выходы энкодера в кодовые векторы.\n\nЭтот трюк очень близок к приёму, известному как **straight-through estimator**, впервые предложенному в этой [статье](https://arxiv.org/pdf/1308.3432.pdf) (а его простое описание можно найти [тут](https://www.hassanaskary.com/python/pytorch/deep%20learning/2020/09/19/intuitive-explanation-of-straight-through-estimators.html)). Использование straight-through estimator, однако, не позволяет обучать сами кодовые векторы, так как по ним не будут вычисляться градиенты. Поэтому лосс для обучения модели складывается из трёх компонент:\n\n$$\n    \\mathcal{L} = \\log p(x | z_q(x)) + \\| sg[z_e(x)] - z_q(x) \\|_2^2 + \\beta \\| z_e(x) - sg[z_q(x)] \\|_2^2\n$$\n\nЗдесь $sg[\\cdot]$ обозначает оператор остановки дифференцирования: через его аргумент не текут градиенты.\n{% cut \"Замечание по поводу обозначений\" %}\n\nВ статье лосс записан несколько иначе:\n\n$$\n\\mathcal{L} = \\log p(x | z_q(x)) + \\| sg[z_e(x)] - e \\|_2^2 + \\beta \\| z_e(x) - sg[e] \\|_2^2\n$$\n\nЭти обозначения кажутся несколько путающими по двум причинам:\n1. Буква $e$ в нижнем индексе $z_e(x)$ призвана обозначить только то, что это выход энкодера, а не наличие связи между кодовыми векторами $e$ и параметрами энкодера. Но второе довольно легко для себя предположить. \n2. Вычитание $e$ обозначает вычитание не всех элементов словаря из соответствующей позиции тензора $z_e(x)$, а только лишь ближайшего соседа к элементу $z_e(x)$ на этой позиции. То есть по факту вычитание $e$ в этой записи равносильно вычитанию $z_q(x)$. Это не уточняется в статье, но можно [увидеть](https://github.com/deepmind/sonnet/blob/v2/sonnet/src/nets/vqvae.py#L113) в официальной реализации.\n\n{% endcut %}\n\nПервое слагаемое — это ELBO с точностью до константы. Второе слагаемое отвечает за сдвиг кодовых векторов в сторону выходов энкодера. Чтобы не получилось так, что выходы энкодера всё время меняют кодовые векторы за счёт второй компоненты лосса, а сами на каждой итерации выдают векторы, далёкие от текущих кодовых векторов, добавляется третье слагаемое. Оно отвечает за то, чтобы энкодер стремился выдавать векторы, близкие к кодовым векторам, а его значимость регулируется с помощью коэффициента $\\beta$.\n\nОднако при обучении мы потеряли регуляризационное слагаемое $D_{KL} (q(z \\| x) \\parallel p (z))$, из-за чего распределение энкодера не было обязано приближать собой априорное распределение и осталось его узким подмножеством. Из-за этого с наибольшей вероятностью при семплировании из равномерного категориального распределения мы будем получать просто шумы вместо хороших картинок:\n\n![2](https://yastatic.net/s3/education-portal/media/bad_samples_75f081105c_8c86b457d5.webp)\n\n{% cut \"Чуть подробнее\" %}\n\nПри обучении обычного VAE мы минимизируем расстояние между априорным распределением и распределением, которое выдаёт энкодер, с помощью регуляризационного слагаемого $D_{KL} (q(z \\| x) \\parallel p (z))$.\n\nБлагодаря нему, например, двумерные латентные коды цифр MNIST приближённо распределяются по шарику — априорному нормальному распределению. А если каждой цифре выделить собственное латентное пространство (провести обуславливание на класс цифры), то априорное условное распределение для каждой цифры очень близко к нормальному.\n\nА в случае VQ-VAE мы не можем заставить распределение, предсказываемое энкодером, быть равномерным категориальным, и получаем просто какое-то категориальное распределение с неизвестной параметризацией. Это напоминает ситуацию с обычным автоэнкодером: он тоже переводит входные картинки в латентное пространство, но семплировать из такого пространства мы не можем. \n\n{% endcut %}\n\nЧтобы исправить эту проблему, авторы предлагают с помощью дополнительной модели выучить априорное распределение $p(z)$ тех латентных переменных, которые модель научилась генерировать в процессе обучения. Поскольку любое кодовое представление можно вытянуть в последовательность, а самих кодов — конечное наперёд заданное число, то эта задача близка к задаче обучения языковой модели.\n\nДействительно, ведь там мы должны по последовательности предыдущих слов предложения предсказать следующее слово из доступного словаря, а в нашем случае — по входной последовательности дискретных латентных кодов предсказать следующий латентный код.\n\nДля картинок авторы предложили моделировать априорное распределение латентных кодов с помощью PixelCNN. Детали архитектуры и обучения этой модели можно найти в оригинальной [статье](https://arxiv.org/pdf/1606.05328v2.pdf), здесь мы опишем только общую идею.\n\nPixelCNN последовательно генерирует пиксели картинки, двигаясь из верхнего левого угла в правый нижний. Она проходит все ряды последовательно от верхнего до нижнего, а внутри каждого ряда движется слева направо:\n\n![2](https://yastatic.net/s3/education-portal/media/pixelcnn_a09ba4e935_35e466109f.webp)\n\nДля цветных картинок каналы (R, G, B) также моделируются последовательно: канал B при генерации зависит от R и G, а G — только от R. При предсказании значения каждого следующего пикселя модель использует значения уже сгенерированных соседей из некоторого окружающего квадрата. Чтобы модель не могла читать пиксели, идущие после текущего предсказываемого пикселя, используется специальная маска, пример которой изображён на правой части рисунка.\n\nВ случае VQ-VAE обучение PixelCNN происходит не на пикселях, а на латентных кодах. Семплирование из выученного априорного распределения выглядит гораздо лучше, чем попытки семплировать из равномерного:\n\n![2](https://yastatic.net/s3/education-portal/media/pixel_cnn_prior_7b056530b7_943d1fafc4.webp)\n\nДля аудио вместо PixelCNN авторами используется [WaveNet](https://deepmind.com/blog/article/wavenet-generative-model-raw-audio). При обучении моделей априорных распределений есть возможность подавать метки классов, чтобы потом можно было семплировать из этих классов (принцип тот же, что и для CVAE).\n\nРезультаты реконструкции картинок из ImageNet с помощью VQ-VAE выглядят довольно неплохо (под реконструкцией понимается выход полной модели, состоящей из энкодера и декодера):\n\n![2](https://yastatic.net/s3/education-portal/media/vq_vae_reconstruction_9edc867133_30318b6a2d.webp)\n\nА так выглядят результаты семплирования из VQ-VAE с априорным распределением, выученным PixelCNN:\n\n![2](https://yastatic.net/s3/education-portal/media/vq_vae_samples_7ee45b4e87_c5c9d1b905.webp)\n\n#### VQ-VAE-2\n\nМодель VQ-VAE-2 — это расширение VQ-VAE. Она показывает значительный скачок по качеству генерируемых изображений:\n\n![2](https://yastatic.net/s3/education-portal/media/vq_vae_2_samples_5afee645f4_bc4a494bcb.webp)\n\nВпечатляет то, что на картинке именно результат семплирования из выученного моделью распределения, а не результат реконструкции. Первое основное отличие модели VQ-VAE от VQ-VAE-2 — использование иерархических латентных переменных:\n\n![2](https://yastatic.net/s3/education-portal/media/hierarchical_latents_1d8c41404a_b87a6935e4.webp)\n\nПрежде чем перейти к описанию архитектуры, хочется сделать небольшой дисклеймер: когда в тексте далее будет говориться «тензор размера $M \\times M$», то будет иметься в виду, что тензор имеет шейп $(B, M, M, C)$, где первая размерность соответствует батчам, а последняя — каналам.\n\nНа картинке показан пример двухуровневой архитектуры (хотя уровней может быть и больше). Каждому уровню соответствуют свои энкодер, декодер и набор кодовых векторов (общей размерности $D$ для всех уровней). Обозначим нижний и верхний энкодеры как $Enc_{\\text{bottom}}$ и $Enc_{\\text{top}}$, а декодеры — как $Dec_{\\text{bottom}}$ и $Dec_{\\text{top}}$.\n\n- $Enc_{\\text{bottom}}$ принимает на вход трёхканальную картинку размера $256 \\times 256$ пикселей, отображает её в тензор размера $64 \\times 64$ и передаёт на вход $Enc_{\\text{top}}$. $Enc_{\\text{top}}$ выдаёт тензор размера $32 \\times 32$, который затем отображается в тензор из кодовых векторов $z_{\\text{top}}$ (квантизуется)\n- $z_{\\text{top}}$ передаётся на вход $Dec_{\\text{top}}$, затем выходы $Enc_{\\text{bottom}}$ и $Dec_{\\text{top}}$ конкатенируются и квантизуются в $z_{\\text{bottom}}$ \n- $z_{\\text{top}}$ и $z_{\\text{bottom}}$ конкатенируются и передаются на вход $Dec_{\\text{bottom}}$, который отображает их в исходную картинку\n\nДля обучения модели используется почти такой же лосс, как для VQ-VAE. Для VQ-VAE он имел вид:\n\n$$\n    \\mathcal{L} = \\log p(x | z_q(x)) + \\| sg[z_e(x)] - z_q(x) \\|_2^2 + \\beta \\| z_e(x) - sg[z_q(x)] \\|_2^2\n$$\n\nДля VQ-VAE-2 первое и третье слагаемые сохраняют свой вид, а второе слагаемое заменяется на обновление кодовых векторов $e_i$ с помощью экспоненциального скользящего среднего. Пусть $E(x)^{(t)}$ — выход энкодера на шаге $t$, выпрямленный в двумерный тензор, последняя размерность которого равна размерности $D$ кодовых векторов.\n\nПусть $\\{ E^{(t)}_{i, 1}, \\ldots, E^{(t)}_{i, n_i^{(t)}} \\}$ — множество из $n_i^{(t)}$ векторов, для которых на шаге $t$ ближайшим оказался кодовый вектор $e_i^{(t - 1)}$. Тогда обновление $e_i$ на шаге $t$ происходит по следующим формулам:\n\n$$\n    e_i^{(t)} = \\frac{m_i^{(t)}}{N_i^{(t)}}\n$$\n\n$$\n    m_i^{(t)} = m_i^{(t - 1)} \\cdot \\gamma + \\sum_j^{n_i^{(t)}} E(x)_{i, j}^{(t)} (1 - \\gamma)\n$$\n\n$$\n    N_i^{(t)} =  N_i^{(t - 1)} \\cdot \\gamma + n_i^{(t)} (1 - \\gamma)\n$$\n\nЗдесь $\\gamma$ — некоторый вещественный параметр.\n\nТак же, как и для VQ-VAE, априорное распределение для VQ-VAE-2 выучивается отдельно уже после обучения основной модели, но в случае VQ-VAE-2 оно имеет иерархическую структуру. На картинке изображён пример такого распределения для двухуровневой архитектуры:\n\n![2](https://yastatic.net/s3/education-portal/media/hierarchical_prior_55f4d6aa56_21a33b2263.webp)\n\nДля каждого уровня обучается отдельная модель PixelCNN: одна — на кодовых векторах первого уровня, вторая — на кодовых векторах первого и второго уровней. Обе модели также принимают на вход метку класса, изображение из которого нужно насемплировать. \n\nСемплирование из финальной модели происходит так: \n- семплируются векторы $e_{\\text{top}}$ из верхнего распределения\n- из нижнего распределения семплируются векторы $e_{\\text{bottom}}$ при условии векторов $e_{\\text{top}}$\n- декодер принимает на вход векторы $e_{\\text{top}}$ и $e_{\\text{bottom}}$ и выдаёт финальную картинку\n\nРезультаты семплирования из двухуровневой модели VQ-VAE-2, обученной на ImageNet:\n\n![2](https://yastatic.net/s3/education-portal/media/vq_vae_2_image_net_11e8448202_72cfc6fb5a.webp)\n\nА это — результаты семплирования из трёхуровневой модели VQ-VAE-2, обучавшейся на [FFHQ](https://paperswithcode.com/dataset/ffhq):\n\n![2](https://yastatic.net/s3/education-portal/media/vq_vae_2_ffhq_4c83b1aab6_4367922715.webp)\n\n### DALL-E\n\nОдна из недавних работ, связанных с VAE, — это [DALL-E](https://arxiv.org/pdf/2102.12092.pdf) от OpenAI. Они обучили модель с 12 миллиардами параметров, генерирующую картинки по их текстовому описанию. Для обучения авторами был собран датасет, состоящий из 250 миллионов пар картинок и их описаний. Вот примеры работы этой модели:\n\n![2](https://yastatic.net/s3/education-portal/media/avocado_329095ee68_9f7a46934f.webp)\n\n![2](https://yastatic.net/s3/education-portal/media/open_ai_store_0110955e3f_3a7446d885.webp)\n\nВ [блог-посте](https://openai.com/blog/dall-e/) OpenAI, посвящённом DALL-E, есть возможность самостоятельно составлять текстовые описания из некоторого ограниченного словаря и смотреть на результаты. Осторожно, это затягивает :)\n\n![2](https://yastatic.net/s3/education-portal/media/capybara_1d7ed6f4c8_e3e460924c.webp)\n\nDALL-E идейно основывается на результатах VQ-VAE: сначала выучиваются кодовые векторы для картинок, а затем обучается Трансформер, моделирующий совместное априорное распределение текстов и кодовых векторов. Подробнее о трансформерах мы [рассказывали](https://education.yandex.ru/handbook/ml/article/transformery) в главе 6.3 этого хендбука.\n\nВ DALL-E задействована архитектура, основанная на декодер-части исходной архитектуры Трансформера, поэтому стоит также [почитать](https://jalammar.github.io/illustrated-gpt2/) про модель GPT-2, работающую аналогичным образом.\n\nОбучение проходит в две стадии:\n\n- Сначала обучается дискретизованный VAE (**dVAE**) c энкодером для сжатия RGB-картинок размера $256 \\times 256$ в тензор из $32 \\times 32 = 1024$ кодовых векторов. Эта стадия обучения очень напоминает VQ-VAE, но вместо добавления в лосс дополнительных слагаемых для кодовых векторов авторы DALL-E используют *релаксацию Гумбеля* — трюк, позволяющий проводить честное дифференцирование по параметрам энкодера. Об обучении dVAE мы будем говорить подробнее далее.\n- Затем обучается Трансформер (точнее, только декодер-часть исходной архитектуры Трансформера), задача которого — выучить совместное распределение картинок и их текстовых описаний. Он принимает на вход конкатенацию из эмбеддингов текстовых токенов и кодовых векторов картинок и учится для каждой входной последовательности предсказывать её продолжение. О некоторых деталях обучения Трансформера также будет рассказано далее.\n\nИнференс обученной модели происходит так: эмбеддинги текстового описания картинки подаются на вход Трансформеру, и он авторегрессионно предсказывает кодовые векторы картинки, соответствующей этому описанию, а затем полученные кодовые векторы пропускаются через декодер dVAE. \n\n#### dVAE\n\nОбучение dVAE происходит путём максимизации ELBO для картинок $x$ и их дискретных латентных представлений $z$:\n\n$$\n\\ln p_{\\theta}(x) \\ge \\mathbb E_{q_\\phi(z | x)} \\left[ \n    \\log p_\\theta (x | z) \n\\right] - \\beta \\, D_{KL} (q_\\phi(z | x) \\parallel p(z)),\n$$\n\nгде $\\phi$ и $\\theta$ — параметры энкодера и декодера дискретизованного VAE, a $p(z)$ — равномерное категориальное распределение над кодовыми векторами. Здесь можно заметить дополнительный коэффициент $\\beta$, который в стандартном VAE всегда равен 1. Однако авторы DALL-E ввели дополнительный параметр $\\beta$, опираясь на результаты [статьи](https://arxiv.org/pdf/1904.10509.pdf) о $\\beta$-VAE. Но, в отличие от исходной статьи, в их экспериментах значение $beta$ постепенно понижается в ходе обучения.\n\nЭнкодер dVAE отображает картинки размера $256 \\times 256$ в тензор $z_e(x)$ с шейпом $32 \\times 32 \\times 8192$, где $8192$ — число кодовых векторов. То есть каждой из $32 \\times 32$ позиций энкодер сопоставляет категориальное распределение над $8192$ кодовыми векторами, параметризованное выходными логитами.\n\nДля получения тензора $z_q(x)$ из кодовых векторов можно было бы сначала применить $\\text{softmax}$ к распределениям на каждой из $32 \\times 32$ позиций, а затем сопоставить каждой позиции кодовый вектор, номеру которого соответствует максимальная вероятность (взять $\\text{argmax}$ для этой позиции).\n\nОднако операция $\\text{argmax}$ не дифференцируема, и, к тому же, в концепции VAE на вход декодеру должен пойти семпл из распределения, предсказываемого энкодером, а взятие $\\text{argmax}$ на каждой позиции не является семплированием из предсказанного распределения.\n\nПоэтому нам потребуется применение некоторых трюков, которые позволят нам одновременно:\n\n- аппроксимировать семплирование из $\\text{softmax}$\n- сделать семплирование дифференцируемым\n\n##### Gumbel-Max Trick и Gumbel-Softmax\n\nПервый трюк известен в англоязычной литературе как Gumbel-Max Trick. Представим, что у нас есть логиты-выходы сетки $x_1, \\ldots, x_k$, и мы хотим с их помощью получить семпл из категориального распределения, то есть стохастически предсказать класс. Для этого мы обычно применяем к логитам $\\text{softmax}$, чтобы получить вероятности $\\pi_i$:\n\n$$\n    \\pi_i = \\frac{\\exp{x_i}}{\\sum_j \\exp{x_j}},\n$$\n\nа затем из получившегося категориального распределения $\\left\\{ \\pi_1, \\ldots, \\pi_k \\right\\}$ семплируем класс. Оказывается, этим двум шагам будет эквивалентна следующая процедура:\n\n- насемплировать числа $g_1, ..., g_k$ из стандартного распределения [Гумбеля](https://en.wikipedia.org/wiki/Gumbel_distribution),\n- прибавить к каждому из логитов $x_i$ семпл $g_i$,\n- выбрать класс $j$, такой что $j = \\text{argmax}_i(x_i + g_i)$.\n\nО том, почему это действительно так, можно почитать [здесь](https://lips.cs.princeton.edu/the-gumbel-max-trick-for-discrete-distributions/). Однако сам по себе Gumbel-Max Trick нам не поможет — ведь операция так и не стала дифференцируемой. Поэтому придётся использовать ещё один трюк, предложенный практически одновременно в двух статьях ([первая](https://arxiv.org/pdf/1611.01144.pdf) и [вторая](https://arxiv.org/pdf/1611.00712v3.pdf)) и названный Gumbel-Softmax в одной из них.\n\nЧтобы описать этот трюк, отметим, что результат операции $\\text{argmax}$ — это индекс некоторого класса $j$. Такой индекс можно описать one-hot кодированием, то есть вектором длиной $k$, в котором все элементы равны нулю, кроме $j$-го, который равен единице.\n\nGumbel-Softmax состоит в том, чтобы вместо взятия $\\text{argmax}$ на последнем этапе Gumbel-Max Trick делать следующее:\n\n- вычислить $y_i = \\frac{\\exp\\left( (x_i + g_i) / \\tau \\right)}{\\sum_{j = 1}^k \\exp \\left( (x_j + g_j) / \\tau \\right)}$, $i = 1, \\ldots, k$, — аппроксимацию one-hot при помощи $\\text{softmax}$ с температурой\n- сложить кодовые векторы $e_i$ с весами $y_i$: $z = \\sum_i y_i e_i$\n- выдать вектор $z$ в качестве латентного вектора для данной позиции\n\nНа самом деле авторы DALL-E не уточняли, как выходной вектор $z$ агрегируется из кодовых векторов и $y_i$, но такой подход применён в [реализации](https://github.com/lucidrains/DALLE-pytorch/tree/main/dalle_pytorch) DALL-E на PyTorch.\n\nПри $\\tau \\to 0$ семплирование из распределения $\\frac{\\exp\\left( (x_i + g_i) / \\tau \\right)}{\\sum_{j = 1}^k \\exp \\left( (x_j + g_j) / \\tau \\right)}$ стремится к $\\text{argmax}$, и в процессе обучения dVAE авторы постепенно уменьшали значение $\\tau$. На следующей картинке слева — просто Gumbel-Max Trick, а справа — дифференцируемый вариант Gumbel-Max Trick:\n\n![2](https://yastatic.net/s3/education-portal/media/gumbel_reparametrization_426251e2a8_6336997622.webp)\n\nТаким образом, для обучения кодовых векторов для dVAE не требуется дополнительных слагаемых в лоссе относительно ELBO, а также копирования градиентов из декодера в энкодер (как было в VQ-VAE).\n\nКроме того, стоит отметить, что $D_{KL} (q_\\phi(z | x) \\parallel p(z))$ в данном случае не вырождается в константу, а действительно действует как регурялизатор, заставляя категориальное распределение, параметризованное логитами энкодера, быть ближе к равномерному распределению над кодовыми векторами.\n\n##### Распределение Logit-Laplace\n\nЕщё один трюк в обучении dVAE касается выходного распределения $p_\\theta (x \\| z)$. Авторы DALL-E подметили проблему, возникающую при часто встречающемся выборе лапласовского и гауссовского распределений в качестве $p_\\theta (x \\| z)$: оба они определены на всей вещественной прямой, в то время как пиксели принимают значения из ограниченного интервала. Таким образом, часть плотности при моделировании «теряется», оказываясь вне возможных границ значений пикселей.\n\nЧтобы исправить эту проблему, авторы предлагают использовать распределение, которое они назвали “Logit-Laplace”. Его плотность определена на интервале $(0, 1)$ и выражается следующей формулой:\n\n$$\n    f(x | \\mu, b) = \\frac{1}{2 b x (1 - x)} \\exp \\left( -\\frac{|\\text{logit}(x) - \\mu|}{b} \\right),\n$$\n\n$$\n    \\text{logit}(x) = \\frac{x}{1 - x}\n$$\n\nЭта плотность соответствует случайной переменной, полученной применением сигмоиды к распределённой по Лапласу случайной переменной. Выражение для распределения Logit-Laplace можно получить по стандартной формуле для плотности случайной величины, полученной применением монотонной дифференцируемой функции к другой случайной величине (см. формулу, например, [тут](https://en.wikipedia.org/wiki/Probability_density_function)). Логарифм этой плотности подставляется в ELBO вместо $\\ln p_\\theta(x \\| z)$.\n\nДекодер на выходе выдаёт 6 тензоров: первые три соответствуют $\\mu$ для RGB-каналов, оставшиеся три соответствуют $\\ln b$, и эти 6 тензоров используются для подсчёта лосса. При подаче в энкодер значения картинок нормируются функцией $\\phi: [0, 255] \\to (\\varepsilon, 1 - \\varepsilon)$:\n\n$$\n    \\phi: x \\mapsto \\frac{1 - 2 \\varepsilon}{255} x + \\varepsilon\n$$\n\nЭтим авторы добиваются того, чтобы декодер моделировал значения из $(\\varepsilon, 1 - \\varepsilon)$, что позволяет нивелировать вычислительные проблемы, связанные с делением на $x(1 - x)$ в формуле плотности. Во время инференса реконструкция $\\hat x$ картинки $x$ вычисляется по формуле: \n\n$$\n    \\hat x = \\phi^{-1}(\\text{sigmoid}(\\mu)),\n$$\n\nгде $\\mu$ — первые три тензора из выхода декодера. Выходы, соответствующие $\\ln b$, при этом не используются.\n \n#### Априорное распределение на текстах и картинках\n\nНа втором этапе авторы фиксируют параметры $\\phi$ и $\\theta$ и моделируют совместное распределение картинок и их текстовых описаний с помощью [Sparse Transformer](https://openai.com/blog/sparse-transformer/) с 12 миллиардами параметров. На вход он получает конкатенацию из текстового описания картинки и её кодовых векторов. Картинка представляется 1024 кодовыми векторами, получаемыми из энкодера $q_\\phi$, причём при семплировании кодовых последовательностей используется обычный $\\text{argmax}$ без добавления шума из распределения Гумбеля.\n\nТекстовое описание токенизируется с помощью процедуры BPE (см. раздел про BPE [здесь](https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html)), и каждому токену ставится в соответствие представляющий его вектор из вещественных чисел (эмбеддинг). Для представления текста используется не более 256 токенов, а размер используемого словаря — 16 384 токена.\n\nЗадача Трансформера во время обучения — для каждого начального отрезка входной последовательности предсказать следующий за ним токен. Это может быть как текстовый токен, так и кодовый вектор картинки. Поскольку кодовые векторы картинок всегда идут за текстовыми токенами, при генерации кодовых векторов attention-механизм учитывает также и все предыдущие текстовые токены.\n\nКроме того, маска attention для кодовых векторов учитывает, что исходно они расположены не линейно друг за другом, а на прямоугольной сетке. В статье приводится несколько вариантов геометрических паттернов, которые использовались для attention-маски на кодовых векторах.\n\nВ качестве лосса используется взвешенная сумма кросс-энтропии для текстовых токенов и кросс-энтропии для кодовых векторов картинок c весами $\\frac{1}{8}$ и $\\frac{7}{8}$ соответственно (больший приоритет отдаётся генерации картнок, отсюда и больший вес для лосса).\n\nКонечно, огромный Трансформер обучить крайне непросто, и очень существенная часть статьи посвящена трюкам, которые авторы применили для обучения такой большой модели.\n\n![2](https://yastatic.net/s3/education-portal/media/duck_meme_2752e650d6_a025afbc70.webp)\n\n#### Инференс\n\nНа этапе инференса в модель подаются токены текстового описания картинки, и на их основании модель авторегрессионно предсказывает кодовые векторы:\n\n![2](https://yastatic.net/s3/education-portal/media/dalle_transformer_bcdbc306bb_5be86e20e3.webp)\n\nКодовые векторы картинки подаются в декодер dVAE, который отображает их в финальную картинку:\n\n![2](https://yastatic.net/s3/education-portal/media/dalle_inference_pic_4ae38121df_950e745022.webp)\n\nДля повышения качества предсказания авторы сначала генерируют 512 картинок для каждого текстового описания, а затем выбирают лучшую картинку из предсказанных. Разные наборы кодовых векторов для одного и того же текста можно получить, например, случайно выбирая на каждом шаге генерации какой-то кодовый вектор согласно предсказанному Трансформером распределению. Ранжирование полученных 512 картинок осуществляется с помощью [CLIP](https://openai.com/blog/clip/) — большой нейросети, обучавшейся в режиме без учителя на большом количестве данных моделировать совместное распределение картинок и текстов.\n\n## Заключение\n\nИтак, в этом параграфе мы поговорили о том, как устроен VAE в классическом смысле, — с непрерывным распределением латентных переменных, а также поговорили о работах, основанных на идеях использования дискретных распределений для VAE. \n\nКонечно, различные модификации VAE не исчерпываются только лишь отказом от непрерывных латентных переменных в пользу дискретных. Есть множество других возможных направлений для улучшения модели: использование иерархических латентных распределений (которые мы, кстати, видели в контексте VQ-VAE-2), использование функций потерь, отличающихся от ELBO, выбор различных форм латентных пространств, применение adversarial-обучения и многое другое. \n\nХороший список различных статей, посвящённых модификациям VAE, можно найти [здесь](https://jmtomczak.github.io/blog/4/4_VAE.html#There-are-many,-many-more!). Из недавних работ, связанных с применением иерархических распределений, интересной кажется [NVAE](https://arxiv.org/pdf/2007.03898.pdf) — семплы из модели выглядят весьма впечатляюще. Про неё есть хороший [видеообзор](https://www.youtube.com/watch?v=x6T1zMSE4Ts) от Yannic Kilcher. \n\nНа этом мы завершаем рассказ о VAE. Будем надеяться, что он дал вам общее представление и об исходных идеях, из которых выросла модель VAE, и о наиболее интересных последних результатах, связанных с ней.\n\nА в следующем параграфе мы поговорим о генеративно-состязательных сетях.",
        "handbook": "Учебник по машинному обучению",
        "title": "Variational Autoencoder (VAE)",
        "description": "Variational Autoencoder (VAE)"
    },
    {
        "path": "/handbook/ml/article/generativno-sostyazatelnye-seti-(gan)",
        "content": "## Введение\n\nГенеративно-состязательные сети (Generative Adversarial Networks, GAN) – это большой класс генеративных моделей, общая черта которых заключается в том, что они обучаются одновременно с другой сетью, которая старается отличить сгенерированные объекты от настоящих. В этом параграфе мы рассмотрим основы основ GAN-ов, интуитивное объясним принципы их работы, а также детально погрузимся в многочисленные приёмы и модификации оригинального подхода, которые применяются в наиболее успешных моделях. Мы также приведём примеры нескольких типов практических задач, в которых применяются генеративно-состязательные сети.\n\n![mnist_digits_73edc82188.webp](https://yastatic.net/s3/education-portal/media/mnist_digits_73edc82188_86cd92299c.webp)  \n\nГенеративно-состязательные сети — это неявная генеративная модель. То есть она не восстанавливает плотность данных в явном виде, но умеет сэмплировать из распределения данных. Самый простой и эффективный дизайн генеративных моделей, которые умеют только сэмплировать, но не умеют оценивать плотность, – это отображение одних случайных величин в другие. \n\nПодобного вида модель после обучения работает следующим образом: пусть $x$ – случайная величина, обозначающая сэмпл из распределения нужных нам данных (например, картинок с нарисованными цифрами), а $z$ – сэмпл из какого-то распределения, который нам легко получить (например, каждая его компонента берётся из стандартного нормального). Тогда, если у нас есть обученная функция $G$, которая переводит сэмплы из $p(z)$ в сэмплы из $p(x)$, то процесс генерации происходит в два этапа: сначала мы случайным образом получаем вектор $z \\sim p(z)$, а затем отображаем его в $\\hat{x} = G(z)$:\n\n$$\nz \\sim p(z),\\quad \\hat{x} = G(z):\\quad \\hat{x} \\sim p(x)\n$$\n\nКлючевым вопросом в таких моделях является соотношение размерностей $z$ и $x$. Есть генеративные модели, где $\\text{dim}(z) \\approx \\text{dim}(x)$. Примером таких подходов являются, например, нормализующие потоки. В случае генеративных состязательных сетей (как и другого класса популярных генеративных моделей, вариационных автоэнкодеров), $\\text{dim}(z) \\ll \\text{dim}(x)$. Поэтому работу этих моделей можно рассматривать как поиск многообразия размерности $\\text{dim}(z)$ среди всех случайных примеров из домена, на котором определяется $p(x)$. Например, в случае генерации цифр это соответствует поиску в домене $[0, 1]^{H \\times W}$, где $H$ – это ширина картинки, а $W$ – её высота, подмножества, в котором каждый элемент изображает какую-либо цифру. Таким образом, задача обучения генеративных состязательных сетей может рассматриваться как задача компрессии данных в низкоразмерное представление.\n\n## Основы обучения GAN-ов\n\n![counterfeiter_analogy_8df968ecec_a40b7b9c4a.svg](https://yastatic.net/s3/education-portal/media/counterfeiter_analogy_8df968ecec_a40b7b9c4a_0cc3c5a1fe.svg)\n\nКлассическая аналогия того, как учатся GANы — это фальшивомонетчик и полицейский. Задача фальшивомонетчика — научиться создавать купюры, которые полицейский не сможет отличить от реальных. Задача полицейского — научиться отличать купюры фальшивомонетчика от настоящих.\n\nЧтобы понять, как обучаются GANы, надо представить себе следующий мысленный эксперимент. Допустим, фальшивомонетчик и полицейский — друзья, которые решили поучиться друг у друга. Фальшивомонетчик создаёт несколько фальшивых купюр и показывает полицейскому. Полицейский говорит фальшивомонетчику, какие из его купюр, по его мнению, поддельные, а какие — настоящие. Фальшивомонетчик запоминает отзыв полицейского и в следующий раз улучшит свои купюры на основе отзыва от полицейского. Сам полицейский при этом тоже учится: он запоминает, что купюры, которые он видел — поддельные.\n\nВ нашем мысленном эксперименте представим, что фальшивомонетчик взаимодействует с полицейским много раз. Что получается в результате? С каждым разом купюры фальшивомонетчика всё труднее отличить от настоящих. И с каждым разом умение выявлять поддельные купюры у полицейского выше.\n\nВажный вопрос для понимания работы GANов: в какой момент мы можем утверждать, что фальшивомонетчик хорошо подделывает купюры?\n\nОтвет:\nКогда фальшивомонетчик сможет обманывать сильного полицейского. В начале нашего эксперимента полицейский плохо отличает подделку от оригинала. Поэтому обмануть его можно купюрами плохого качества. Нам же интересно получить фальшивомонетчика, который будет выдавать купюры, неотличимые от оригинала даже профессионалом.\n\nРассмотрим задачу обучения более формально. Пусть у нас есть генератор $G_\\theta$ (фальшивомонетчик) с параметрами $\\theta$, и дискриминатор $D_\\phi$ (полицейский) с параметрами $\\phi$. Генератор отображает векторы $z \\sim \\mathcal{N}(0, I)$ в $\\hat{x} \\sim q(x)$, распределение которых приближает реальное распределение данных $p(x)$. Дискриминатор каждому реальному сэмплу $x$ и фейковому $\\hat{x}$ ставит в соответствие вероятность $D(x)$, которая оценивает степень принадлежности $x$ к реальным данным, т.е. он решает задачу бинарной классификации. Самый простой способ это сделать – при помощи минимизации бинарной кросс-энтропии:\n\n$$\n    \\min_\\phi\\ \\mathbb{E}_{x \\sim p(x)} - \\log D_\\phi(x) + \\mathbb{E}_{\\hat{x} \\sim q(x)} - \\log \\big[ 1 - D_\\phi(\\hat{x}) \\big].\n$$\n\nУчитывая обозначение $\\hat{x} = G_\\theta(z)$, и то, что мы пытаемся максимизировать вероятность принадлежности к реальным данным, как её оценивает дискриминатор, задачу, которую решает генератор, можно расписать следующим образом (используя свойство выпуклости логарифма):\n\n$$\n\\begin{aligned}\n    \\theta^* =\\ & \\arg \\max_\\theta\\ \\mathbb{E}_{z\\sim p(z)} D_\\theta \\big( G_\\theta(z) \\big) \\\\\n             =\\ & \\arg \\min_\\theta\\ \\mathbb{E}_{z\\sim p(z)} - D_\\theta \\big( G_\\theta(z) \\big) \\\\\n             =\\ & \\arg \\min_\\theta\\ \\mathbb{E}_{z\\sim p(z)} \\big[ 1 - D_\\theta \\big( G_\\theta(z) \\big) \\big] \\\\\n             =\\ & \\arg \\min_\\theta\\ \\mathbb{E}_{z\\sim p(z)} \\log \\big[ 1 - D_\\theta \\big( G_\\theta(z) \\big) \\big] \\\\\n             =\\ & \\arg \\max_\\theta\\ \\mathbb{E}_{z\\sim p(z)} -\\log \\big[ 1 - D_\\theta \\big( G_\\theta(z) \\big) \\big].\n\\end{aligned}\n$$\n\nЭто равенство позволяет записать задачи, которые решают генератор и дискриминатор, вместе. (Мы также избавимся от лишних минусов, сделав так, чтобы дискриминатор решал задачу максимизации.)\n\n$$\n   \\min_\\theta \\max_\\phi\\ \\mathbb{E}_{x \\sim p(x)} \\log D_\\phi(x) + \\mathbb{E}_{z \\sim p(z)} \\log \\big[ 1 - D_\\phi\\big(G_\\theta(z)\\big) \\big].\n$$\n\nПолучается, что на самом деле генератор и дискриминатор пытаются оптимизировать одну функцию: генератор её минимизирует, а дискриминатор максимизирует. Обозначим эту функцию (минус бинарную кросс-энтропию) как $\\mathcal{L}_{\\ \\theta, \\phi}$. Тогда эту задачу оптимизации можно записать в сокращённом виде:\n\n$$\n    \\min_\\theta \\max_\\phi\\ \\mathcal{L}_{\\ \\theta, \\phi}.\n$$\n\nПо параметрам дискриминатора минимум бинарной кросс-энтропии (или минимум $\\mathcal{L}_{\\ \\theta, \\phi}$ по $\\phi$) достигается на следующей функции – оптимальном дискриминаторе для фиксированного генератора:\n\n$$\n    D_{\\phi^*}(x) = \\frac{p(x)}{p(x) + q(x)}.\n$$\n\nЕё оптимальность нетрудно проверить, используя выпуклость логарифма. Учитывая это, и формулу для $\\mathcal{L}$, интуицию работы метода обучения GANов со стороны генератора можно сформулировать следующим образом:\n\n1. Мы замеряем, насколько реалистичными являются сгенерированные сэмплы $\\\\{\\hat{x}_1, \\dots, \\hat{x}_2\\\\}$, используя для этого оптимальный дискриминатор $D\\_{\\phi^*}(x)$.\n2. Мы хотим увеличить отклик дискриминатора на каждом сэмпле, т.е. пытаемся модифицировать каждый предсказанный элемент $\\hat{x}_i$ так, чтобы на нём стало выше значение $D\\_{\\phi^*}(\\hat{x}_i)$.\n\nЕщё более простую интуицию для этой задачу можно сформулировать следующим образом. Как нужно модифицировать плотность $q(x)$, чтобы она стала ближе к $p(x)$, если к плотности распределения мы имеем доступ только через сэмплы из него? Визуализацию желаемых градиентов по случайным сэмплам для задачи сопоставления двух гауссиан можно видеть на графике ниже, где $f(x) = D\\_{\\phi^*}(x)$.\n\n![Artboard_33_f123d6e9af.svg](https://yastatic.net/s3/education-portal/media/Artboard_33_f123d6e9af_bb7a95aff1.svg) \n\nНаправленные вниз стрелки показывают, насколько нужно уменьшить координаты точек из распределения $q(x)$, чтобы получилось нечто максимально похожее на $p(x)$. То есть на самом деле точки будут сдвигаться на то же самое расстояние влево.\n\nФормализуем эту интуицию, и заодно поймём, почему вообще такой метод должен работать. Подставив выражение для оптимального дискриминатора в $\\mathcal{L}$, мы можем избавиться от внутренней максимизации в исходной задаче и оставить только внешнюю минимизацию по параметрам генератора. Тем самым, мы получим в явном виде функцию потерь, которую минимизирует генератор (обозначим её за $\\mathcal{D}_\\theta$). Для неё мы распишем математическое ожидание через интеграл и упростим дроби:\n\n$$\n\\begin{aligned}\n    \\mathcal{D}_\\theta \n    =\\ & \\! \\max_\\phi \\mathcal{L}_{\\theta, \\phi} \\\\\n    =\\ & \\mathbb{E}_{x \\sim p(x)} \\log D_{\\phi^*}(x) + \\mathbb{E}_{x \\sim q(x)} \\log \\big[ 1 - D_{\\phi^*}(x) \\big] \\\\\n    =\\ & \\mathbb{E}_{x \\sim p(x)} \\log \\frac{p(x)}{p(x) + q(x)} + \\mathbb{E}_{x \\sim q(x)} \\log \\bigg[ 1 - \\frac{p(x)}{p(x) + q(x)} \\bigg] \\\\\n    =\\ & \\int p(x) \\log \\frac{p(x)}{p(x) + q(x)} dx + \\int q(x) \\log \\frac{q(x)}{p(x) + q(x)} dx \\\\\n\\end{aligned}\n$$\n\nУпростим выражение для $\\mathcal{D}(x)$ ещё раз, прибавив и отняв константу $\\log4$, а также учитывая, что $\\int p(x)\\ dx = 1$ и $\\int q(x)\\ dx = 1$:\n\n$$\n\\begin{aligned}\n    \\mathcal{D}_\\theta\n    =\\ & - \\log 4 + \\int p(x) \\log \\frac{2p(x)}{p(x) + q(x)} dx + \\int q(x) \\log \\frac{2q(x)}{p(x) + q(x)} dx \\\\\n    =\\ & - \\log 4 + \\text{KL} \\bigg( p \\;\\Big\\|\\; \\frac{p + q}{2} \\bigg) + \\text{KL} \\bigg( q \\;\\Big\\|\\; \\frac{p + q}{2} \\bigg) \\\\\n    =\\ & - \\log 4 + 2 \\cdot JSD(p\\;\\|\\; q).\n\\end{aligned}\n$$\n\nЗдесь $\\text{KL}(P \\;\\|\\; Q)$ означает, как обычно, KL-дивергенцию\n\n$$\n\\begin{equation}\n    \\text{KL}(P \\;\\|\\; Q) = \\int P(x) \\log \\frac{P(x)}{Q(x)} dx,\n\\end{equation}\n$$\n\nкоторая показывает, насколько два распределения отличаются друг от друга. Через $JSD(p \\;\\|\\; q)$ обозначает ещё один вид дивергенции (её называют дивергенцией Йенсена-Шеннона). Получается, что при оптимальном дискриминаторе генератор, решая внешнюю задачу оптимизации, уменьшает расстояние между распределениями реальных и фейковых данных, действительно приближая их друг к другу!\n\nИсходя из этого, и в предположении достаточной capacity генератора и дискриминатора (т.е. предполагая, что их параметризация позволяет достичь оптимума), мы можем сформулировать первый, наивный алгоритм обучения генеративно-состязательных сетей.\n\n1. Решить внутреннюю задачу максимизации по $\\phi$, повторяя шаги ниже до сходимости по параметрам дискриминатора $\\phi$ к оптимальному значению $\\phi^*$:  \n  \n    — Составить мини-батч сэмплов шума $\\\\{z_1, \\dots, z_n\\\\}$ из $p(z)$.  \n    — Составить мини-батч сэмплов данных $\\\\{x_1, \\dots, x_n\\\\}$ из $p(x)$.  \n    — Обновить дикриминатор, сделав шаг вверх по его градиенту:  \n    $$\n        \\nabla_\\phi \\frac{1}{n} \\sum_{i=1}^n \\Big[ \\log D_\\phi(x_i) + \\log \\Big( 1 - D_\\phi\\big(G_\\theta(z_i)\\big) \\Big) \\Big] \\\\\n    $$\n\n2. Сделать шаг SGD для внешней задачи минимизации по $\\theta$:  \n  \n    — Составить мини-батч сэмплов шума $\\{z_1, \\dots, z_n\\}$ из $p(z)$.  \n    — Обновить генератор, сделав шаг вниз по его градиенту:  \n    $$\n        \\nabla_\\theta \\frac{1}{n} \\sum_{i=1}^n \\log \\Big( 1 - D_{\\phi^*}\\big(G_\\theta(z_i)\\big) \\Big) = \\frac{1}{n} \\sum_{i=1}^n - \\frac{\\nabla_\\theta f\\big(G_\\theta(z_i)\\big) }{1 - f\\big(G_\\theta(z_i)\\big)},\n    $$\n\n    где через $f$ мы для краткости обозначили $D_{\\phi^*}(x)$.\n\nКакие у этого наивного подхода могут быть недостатки? Во-первых, он очень медленный, потому что необходимо обучать дискриминатор до сходимости, чтобы сделать всего один шаг по градиенту генератора. Но вторая проблема намного серьёзнее: функция потерь генератора может насыщаться и выдавать близкие к нулю градиенты. Проиллюстрируем это на примере обучения простой модели, которая будет сэмплировать из одномерной гауссианы с заданными параметрами.\n\n![Artboard_35_00b6473069.svg](https://yastatic.net/s3/education-portal/media/Artboard_35_00b6473069_48b468655d.svg)\n\nРаспределение $p(x)$ в этом случае известно, а распределение $q(x)$ мы можем получить с помощью методов оценки плотности по сэмплам. Визуализируем эти плотности, а также градиент по сэмплам из генератора (a). Видно, что в случае, когда пики распределений плохо пересекаются друг с другом, градиент будет равен нулю на большинстве сэмплов, которые выдаёт генератор, т.е. они никак не будут использоваться для обучения. Чтобы понять причину происходящего, давайте посмотрим на градиент функции потерь генератора. На точках, далёких от основной «массы» $p(x)$, дискриминатор выдаёт что-то близкое к нулю, то есть знаменатель градиента практически не будет ни на что влиять, а в числителе тоже будет практически ноль: ведь если мы немного поменяем параметры генератора, то «плохие» точки по-прежнему будут далеки от $p(x)$, так что изменение лосса будет пренебрежимо малым, и градиент тоже.\n\nЭто приводит к тому, что обучение происходит недостаточно эффективно: мы тратим время на вычисление сэмплов, которые не делают никакой вклад в обновление параметров генератора. Но более существенная проблема возникает в вырожденном случае: если изначально два распределения практически не пересекаются своими плотностями (b): в этом случае процесс обучения практически не идёт. Часто ли встречается такая вырожденная ситуация на практике? Довольно часто! Достаточно представить себе ситуацию, когда мы хотим генерировать реалистичные изображения лиц, а генератор в начале обучения вместо этого выдаёт случайный шум.  Из-за наличия такой проблемы описанная выше функция потерь генератора называется «сатурирующей».\n\nВ оригинальном подходе по обучению генеративно-состязательных сетей было предложено два решения этой проблемы. Во-первых, мы можем обучать дискриминатор на каждой итерации не до сходимости, а с небольшим фиксированным числом шагов $N$ (на практике чаще всего используется $N \\le 2$). Это позволяет существенно улучшить исходную ситуацию с переобучением дискриминатора. Также мы могли бы улучшить функцию потерь для генератора, сделав так, чтобы она сглаживала выходы дискриминатора около нуля. В качестве такой функции изначально был предложен логарифм. Нетрудно видеть, что оптимум улучшенной функции потерь («несатурирующий лосс») совпадает с исходной, что позволяет сохранить все описанные выше теоретические гарантии:\n\n$$\n\\begin{aligned}\n    \\theta^* =\\ & \\arg \\min_\\theta \\mathcal{L}_{\\ \\theta,\\phi} \\\\\n    =\\ & \\arg \\min_\\theta \\mathbb{E}_{z \\sim p(z)} \\log \\big[ 1 - D_\\phi \\big( G_\\theta(z) \\big) \\big] \\\\\n    =\\ & \\arg \\min_\\theta \\mathbb{E}_{z \\sim p(z)} - \\log D_\\phi \\big( G_\\theta(z) \\big).\n\\end{aligned}\n$$\n\nТочка минимума у новой функции потерь та же, что у исходной, а градиенты оказываются ненулевыми на всех сгенерированных сэмплах.\n\n![Artboard_34_1831bed686.svg](https://yastatic.net/s3/education-portal/media/Artboard_34_1831bed686_107e48ea9e.svg)\n\nПомимо этого, на практике вместо обычного метода стохастического градиентного спуска используются его модификации, которые учитывают и первые, и вторые моменты градиентов например, Adam. Вообще, GAN-ы – довольно капризные модели, и настоятельно рекомендуется использовать готовые реализации с GitHub, оставляя большую часть гиперпараметров без изменений. Наиболее критичными среди них являются learning rate и расписание (то есть количество обновлений дискриминатора на одно обновление генератора).\n\n## Метрики качества\n\nПосле успешного обучения генератора хотелось бы также понять, насколько хорошо он работает. Для этого рассмотрим на примере задачи генерации изображений типовые ошибки, которые может совершать GAN. Наиболее частая проблема – плохое качество или наличие артефактов – вызвана ограничениями, связанными с capacity генератора и несовершенством самих методов обучения. Здесь всё просто: наша генеративная модель плохо работает, и мы это видим на сгенерированных сэмплах. Более скрытым видом ошибок является так называемый **mode collapse**: обученный генератор выдаёт реалистично выглядящие картинки, но они не покрывают всё разнообразие распределения $p(x)$. Например, если наша модель учится генерировать изображения с животными, то она может проигнорировать более редкие виды, а научиться генерировать только наиболее часто встречающиеся. Более экстремальная форма подобного поведения – это когда модель вообще выдаёт вариацию одной картинки. Иногда в литературе общее качество результатов работы нейросети, по аналогии с задачей классификации, измеряется точностью метода (precision), а отсутствие mode collapse измеряется полнотой (recall).\n\nСамый простой и действенный способ измерить как precision, так и recall – сгенерировать данные и посмотреть на них, дав экспертную оценку уровня их реализма. Не стоит им пренебрегать! Формализовать этот подход в метрику можно в виде эксперимента, который в литературе называется user study. Например, мы можем сделать опрос экспертов, которым будем показывать два примера, настоящий и сгенерированный, и попросить их угадать, где фейк. Тогда процент неправильных ответов будет являться метрикой качества для нашего метода. Такой опрос в основном показывает степень реализма полученных результатов: есть ли в них какие-то заметные артефакты, соответствуют ли они реальным примерам по своей структуре, и так далее. Отчасти он также замеряет разнообразие примеров: то, насколько они хорошо покрывают носитель распределения $p(x)$. Если обученная модель генерирует очень похожие друг на друга примеры (то есть имеет место существенный mode collapse), то эксперт через несколько примеров научится определять ненастоящие. С другой стороны, если сэмплы в целом разнообразные, но всё равно не полностью покрывают основу целевого распределения, то user study не позволит обнаружить эту проблему.\n\n### Frechet Inception Distance\n\nЕсть метрики, с помощью которых можно автоматически проводить тестирование, похожее на user study. Для изображений наиболее используемой является Frechet Inception Distance (FID). Чтобы её посчитать, нам в идеале понадобится нейросеть, предобученная на датасете, который мы генерируем, но на практике во всех случаях используется модель Inception v3, предобученная на датасете ImageNet (отсюда слово Inception в названии метрики).\n\nДля того, чтобы понять идею этой метрики, рассмотрим следующий пример: если выходом нейросети является класс (число), то его вероятность можно смоделировать мультиномиальным распределением. Гипотетически, чтобы сравнить два распределения картинок $p$ и $q$, нам достаточно измерить расстояние между двумя мультиномиальными распределениями, построенными на выходах предобученного классификатора после прогона датасетов реальных и сгенерированных данных. Если в распределении $q$ примеров из каких-то классов будет меньше или больше, чем в $p$, то такая метрика будет отличная от нуля.\n\nПонятно, что это слишком грубое приближение расстояния между двумя распределениями, т.к. оно практически никак не учитывает реализм получаемых картинок. Поэтому вместо выходов нейросети в FID было предложено использовать признаки с её глубоких слоёв. Они кодируют высокоуровневую семантику изображений, потому что по этим признакам модель предсказывает вероятность принадлежности картинки к тому или иному классу. При этом в них остаётся довольно много информации об исходном изображении и свойств локальных признаков (текстур), которые могут помочь распознать артефакты. Метрика FID работает таким образом, что сравнивает два распределения высокоуровневых признаков для реальных и сгенерированных картинок, используя в качестве их приближения многомерные гауссианы (каждая размерность соответствует одному каналу). Для измерения расстояния между этими двумя распределениями используется метрика Вассерштейна:\n\n$$\n\\begin{equation}\n    \\text{FID} = \\| \\mu - \\hat\\mu \\|^2 + \\text{Tr}\\big( \\Sigma + \\hat\\Sigma - 2(\\Sigma\\hat\\Sigma)^{1/2} \\big),\n\\end{equation}\n$$\n\nгде $\\mu \\in \\mathbb{R}^C$ и $\\Sigma \\in \\mathbb{R}^{C \\times C}$ – это среднее и матрица ковариаций глубоких признаков $\\\\{F_i \\in \\mathbb{R}^{C\\times H\\times W}\\\\}_{i=1}^N$, которые считаются по выборке из $N$ реальных картинок. При этом как средние, так и матрицы ковариаций считаются по объединению всех признаков со всех картинок без учёта пространственной размерности, т.е. по второй размерности матрицы $F \\in \\mathbb{R}^{C \\times NHW}$. То же самое делается для сгенерированных картинок, для них средние и ковариации обозначены как $\\hat\\mu$ и $\\hat\\Sigma$. Минимум этой метрики равен нулю, и достигается в случае, когда статистики, посчитанные по двум распределениям, совпадают. На практике эта метрика используется как для измерения реализма изображений, так и для детектирования mode collapse.\n\n### Интерполяции в скрытом пространстве\n\nЕщё один способ измерения качества, который мы рассмотрим, напрямую связан с тем, что генеративно-состязательные модели эффективно занимаются кодированием потенциально высокоразмерных данных в низкоразмерное представление. Но как для нейросети с большим числом параметров проверить, занимается ли она реальным кодированием или простым запоминанием выборки? \n\nРассмотрим следующий пример. Пусть наша генеративная модель к случайным векторам $z$ применяет их функцию распределения и отображает векторы в равномерно распределённые на отрезке $[0, 1]$ числа $u$. Упорядочим наш датасет. В качестве случайного сэмпла пусть наша модель выдаёт ту картинку, чей индекс, поделённый на размер датасета, ближе всего к $u$. Другими словами, наша генеративная модель будет выдавать случайные картинки из датасета вместо генерации новых картинок. Методы оценки качества, которые мы описали выше, пропустят эту проблему: ведь «сгенерированные» картинки будут в точности совпадать с настоящими.  Поэтому для полной проверки качества работы генеративной модели важно понимать, действительно ли она производит сжатие выборки в низкоразмерное представление или просто запоминает обучающие примеры.\n\nОдним из тестов на подобное поведение является интерполяция между сгенерированными примерами. Возьмём два случайных вектора $z_1$ и $z_2$ из $p(z)$. Рассмотрим все векторы, которые лежат между ними $z = \\alpha z_1 + (1 - \\alpha) z_2,\\ \\alpha \\in [0, 1]\\$. К каждому такому вектору $z$ применим наш генератор и получим $\\hat{x}$ для промежуточных векторов и $\\hat{x}_1, \\hat{x}_2$ для $z_1$ и $z_2$. Для правильно обученного GANа мы должны увидеть следующую картинку: при изменении коэффициента $\\alpha$ изображение $\\hat{x}$ должно плавно меняться и перетекать из $\\hat{x}_1$ в $\\hat{x}_2$. При этом каждая промежуточная картинка должна быть так же реалистичным сэмплом.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/interpolation_example_f6ce073e6a_dcaef51a6c.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1707.05776\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n\nКачество такой интерполяции сложно измерить численно, но если мы видим, что промежуточные результаты меняются случайно без какой-либо связи с семантикой интерполируемых примеров, то это говорит о плохом качестве генератора. Стоит упомянуть, что для сэмплов из нормального распределения, которое обычно имеют векторы $z$, намного лучше работает [интерполяция по сфере (Slerp)](https://en.wikipedia.org/wiki/Slerp), потому что в многомерном пространстве векторы $z$ практически всегда будут лежать в объёме вокруг сферы диаметра $\\sqrt{d}$, где $d$ – размерность вектора $z$.\n\nИнтерполяция в скрытом пространстве с недавних пор стала использоваться для генерации анимаций и видео. Ведь анимация — это последовательность кадров, плавно переходящих друг в друга. И если у нас есть обученный GAN для генерации картинок, то нам нужно лишь найти путь в скрытом пространстве таким образом, чтобы набор сгенерированных картинок складывался в анимацию. Более того, в скрытом пространстве можно находить различные интерпретируемые пути. Например, путь, при движении по которому размывается задний фон или меняется причёска. Почитать подробнее про это можно [тут](http://proceedings.mlr.press/v119/voynov20a/voynov20a.pdf).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/latent_directions_d708e8af59_56a407218b.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://proceedings.mlr.press/v119/voynov20a/voynov20a.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n\n### Ближайшие соседи\n\nЕщё одним способом проверить, не запомнил ли генератор датасет, является поиск ближайших соседей по датасету. Для этого следует сгенерировать несколько изображений. Для каждого изображения нужно найти несколько ближайших соседей из датасета. В качестве признаков для картинок можно взять признаки с последних слоёв сети Inception. На соседей стоит посмотреть глазами. Если мы увидим, что ближайшие соседи из датасета визуально совпадают со сгенерированными сэмплами, то это значит, что генератор запомнил сэмплы из датасета.\n\n## Базовые модели\n\nЧтобы лучше понимать современные модели, давайте сначала рассмотрим более базовые модели. Хотя они редко используются напрямую, многие идеи из них легли в основу современных моделей.\n\n### DCGAN\n\nНаиболее простая версия генеративной модели для изображений — это DCGAN ([Deep Convolutional GAN](https://arxiv.org/pdf/1511.06434.pdf), 2015 год). Её до сих пор можно иногда встретить как в литературе, так и на практике.\n\nВ основе DCGAN лежит простая идея: нейросети, основанные на свёртках, отлично подходят для распознавания изображений, а значит вполне могут подойти и для их генерации. Единственное отличие, которое требуется – это постепенно увеличивать внутри нейросети пространственный размер признаков, а не уменьшать. Для этого в современных нейросетях делается операция **nearest upsampling**, очень похожая на max pooling. В nearest upsampling пространственное разрешение карты признаков увеличивается за счёт того, что каждый вектор повторяется $K$ раз по горизонтали и по вертикали. К примеру, после увеличения таким образом карты признаков, состоящей из одной единицы, мы получим квадрат размера $K \\times K$ из единиц. На практике увеличение размерности происходит по аналогии с размерами пулинга в свёрточных дискриминативных сетях и почти всегда равно $K=2$.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/dcgan_d8eaa0ce24_237f87ff39.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Модель DCGAN. <a href=\"https://arxiv.org/pdf/1511.06434.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nТаким образом, генератор в случае DCGAN является последовательностью свёрток, слоёв батч нормализации, нелинейностей и слоёв upsampling, а дискриминатор – обычной классификационной нейросетью. При этом первым слоем в генераторе является линейный слой, который отображает вектор шума $z$ в карту признаков с начальным разрешением (как правило, размера $4 \\times 4$).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/dcgan_samples_6b57300506_43b4abf043.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Результат работы DCGAN. <a href=\"https://arxiv.org/pdf/1511.06434.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nХотя результаты работы DCGAN довольно смазанные, эта модель показала большие перспективы генеративных нейросетей для изображений.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/dcgan_interpolation_879fe2b998_0971bf6eda.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Так выглядит интерполяция в скрытом пространстве для модели DCGAN. <a href=\"https://arxiv.org/pdf/1511.06434.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\n### Условная генерация\nДопустим, что в нашем датасете есть изображения, относящиеся к разным классам, и мы хотели бы уметь генерировать изображение заданного класса. В этом случае речь идёт об **условной генерации**. В качестве условия может выступать не только метка класса, но и объект любой природы. Например, когда вы можете захотеть сгенерировать изображение по текстовому описанию.  \n\nДалее будем обозначать условие как $y$. Наша задача — построить генератор, который бы моделировал $ p(x \\mid y) $. \n\n#### Conditional GAN\n\nСамый основной метод условной генерации — конкатенация условия с вектором шума, который генератор принимает на вход. В [статье Conditional GAN](https://arxiv.org/pdf/1411.1784.pdf) 2014 года, где предложили этот метод, рекомендовалось подавать условие не только в генератор, но и в дискриминатор. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/cgan_1b1ac03e48_4cf45b5693.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Модель Conditional GAN. <a href=\"https://arxiv.org/pdf/1411.1784.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nЕсли мы генерируем векторные данные, то вектор на вход дискриминатора подаётся конкатенированным с $y$. При этом если если $ y $ — это метка класса, то стоит её закодировать с помощью one-hot encoding. Если же мы работаем с изображениями, то нам из вектора условия следует сделать изображение. Например, если картинки из датасета имеют размер $H \\times W$, то следует размножить вектор $y$, создав из него тензор размера $H \\times W \\times d_y$, где $d_y$ — размерность вектора $y$. Далее полученное «изображение» конкатенируется с входным изображением.\n\n## Современные модели\n\nТеперь на примере наиболее успешных моделей мы расскажем об улучшениях, которые во многом отходят от оригинального подхода к обучению GAN-ов и при этом значительно улучшают практические результаты, а значит расширяют практическую применимость.\n\nВ этом разделе мы рассмотрим state-of-the-art систему генерации изображений StyleGAN, методы её *обращения* (т.е., поиска векторов шума, соответствующих произвольной картинке), а также методы манипуляции семантикой изображений. После этого мы рассмотрим несколько примеров условных генеративных моделей, которые вместо шума принимают на вход изображения. Такие модели используются как для задачи повышения разрешения (super resolution), так и стилизации (например, превращение пейзажей в картины Моне). Мы сфокусируемся на изображениях, так как в этой области сконцентрирован как основной прогресс, так и наиболее впечатляющие применения генеративных моделей.\n\n### StyleGAN\n\nСамой известной генеративно-состязательной моделью, работающей с изображениями, по праву считается StyleGAN, который до сих пор активно развивается и имеет большое количество расширений (например, существуют разнообразные методы его обращения).\n\n#### Progressive Growing\n\nАрхитектура StyleGAN переняла progressive growing из модели [Progressive Growing of GANs](https://arxiv.org/abs/1710.10196). Суть данной техники заключается в том, чтобы не сразу генерировать изображение высокого разрешения, а постепенно. Давайте рассмотрим это подробнее. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/pggan_1_9d2b69beca_515c4fedba.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Иллюстрация работы генератора и дискриминатора в модели Progressive Growing GANs. <a href=\"https://arxiv.org/pdf/1710.10196.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nМы хотим получить генератор, который генерирует изображения размера 1024x1024. Обучить такой генератор очень сложно. Поэтому мы начинаем с разрешения 4x4. У генератора мы оставляем только первый блок слоёв, который позволяет из шума получить изображение размера 4x4. У дискриминатора мы оставим, наоборот, только последний, который принимает на вход изображение размером 4x4. Такой GAN мы обучаем на изображениях из датасета (предварительно уменьшив их в размере). \n\nСпустя сколько-то итераций мы понимаем, что сеть уже умеет генерировать маленькие изображения. В этот момент мы добавляем к генератору один блок, чтобы на выходе у неё получалось изображение размера 8x8. Так же мы добавляем один блок в начало дискриминатора, чтобы он на вход принимал изображения размера 8x8. Теперь генератор и дискриминатор состоят из двух блоков, которые мы и обучаем.\n\nТакой процесс мы повторяем несколько раз, пока в итоге не дойдём до нужного нам разрешения 1024x1024. Эта схема в итоге показала себя действенным способом генерации реалистичных изображений высокого разрешения.\n\n#### Подача шума в нейросеть\n\nКлючевой частью StyleGAN является используемый в нём способ подачи шума $z$ в нейросеть, и именно из-за него метод и получил своё название. Для того чтобы понять, что конкретно в нём особенного, давайте подробнее посмотрим на архитектуру сети (рисунок из предыдущего раздела, модель StyleGAN справа).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan_1_e8931c250a_1a842b0e64.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Слева: традиционный генератор. Справа: генератор модели StyleGAN. <a href=\"https://arxiv.org/pdf/1812.04948.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nВо-первых, вместо того, чтобы подавать вектор шума $z$ только в самом начале генератора, нейросеть обуславливают на него много раз на разных разрешениях признаков. Исторически, впервые похожим методом решалась задача переноса стиля одной картинки на другую, отсюда и название: a style-based generator. \n\nВ качестве метода обуславливания используются так называемые адаптивные слои. Это модификация обычных слоёв нейросетей, в которых часть параметров предсказывается другой нейросетью. Вообще говоря, адаптивным можно сделать любой вид нормализации, включая батч нормализацию, но наиболее известным примером такого слоя является *адаптивная инстанс нормализация* (*adaptive instance normalization*), и именно она использовалась в первой версии StyleGAN. \n\nВспомним, как именно работает неадаптивная версия этого слоя. Пусть у нас есть батч $F^\\text{in} \\in \\mathbb{R}^{B \\times C \\times H \\times W}$, элементы которого будем обозначать как $f_{bchw}^\\text{in} \\in \\mathbb{R}$. Здесь $B$ обозначает размер мини-батча, $C$ – количество признаков, а $H$ и $W$ – высоту и ширину. Тогда внутри слоя инстанс нормализации выполняется следующая операция:\n\n$$\n    F^\\text{out} = \\frac{F^\\text{in} - \\mu}{\\sigma} \\cdot \\gamma + \\beta.\\quad \\mu, \\sigma \\in \\mathbb{R}^{B \\times C},\\quad \\gamma, \\beta \\in \\mathbb{R}^C.\n$$\n\nЗдесь $\\mu$ и $\\sigma$ обозначают матрицы средних и стандартных отклонений, которые считаются отдельно для каждого элемента мини-батча и для каждого признака:\n\n$$\n    \\mu_{bc} = \\frac{1}{HW} \\sum_{h=1}^H \\sum_{w=1}^W f_{bchw},\\quad \\sigma_{bc} = \\sqrt{\\frac{1}{HW} \\sum_{h=1}^H \\sum_{w=1}^W (f_{bchw} - \\mu_{bc})^2}.\n$$\n\nПри этом $\\gamma$ и $\\beta$ являются параметрами слоя, которые настраиваются в процессе обучения. Особенностью этого слоя является то, что, в отличие от батч нормализации, он применяется одинаковым образом как при обучении, так и во время инференса. То есть вместо того, что приближать средние и стандартные отклонения по батчу при помощи скользящих средних, как это делается в батч нормализации, мы честно каждый раз считаем эти статистики для каждой новой картинки отдельно от всех остальных. Это делает инстанс нормализацию очень популярной в области обработки и генерации изображений, где зачастую бывает невозможным обучение с большим размером мини-батча, а значит и использование батч нормализации.\n\nАдаптивной инстанс нормализацией (AdaIN) называется слой, где $\\gamma$ и $\\beta$ являются не обучаемыми параметрами, а нейросетями, которые предсказывают эти векторы из какого-то общего для всех слоёв адаптивной инстанс нормализации входа (обозначим его через $w$):\n\n$$\n    F^\\text{out} = \\frac{F^\\text{in} - \\mu}{\\sigma} \\cdot \\gamma(w) + \\beta(w).\n$$\n\nЭто означает, что вместо оптимизации по векторам $\\gamma$ и $\\beta$ будет происходить оптимизация по параметрам этих двух нейросетей. Также это означает, что у адаптивной инстанс нормализации добавляется ещё один вход помимо набора признаков $F^\\text{in}$, который определяет её поведение: некоторый вектор $w$, который также называют вектором стиля.\n\nКак правило, в качестве $\\gamma(w)$ и $\\beta(w)$ используется нейросеть с одним линейным слоем или неглубокий персептрон.\n\nНетрудно видеть, что если в качестве вектора $w$ подавать сгенерированный шум $z$, то это будет хорошим способом многократного обуславливания нашего генератора на вектор шума. Это позволило бы глубоким слоям нейросети выучивать лишь часть той информации о выходном изображении, которая содержится в векторе $w$, например, глобальные признаки картинки. А информация о локальных признаках выходного изображения (текстурах) может появляться уже ближе к последним слоям на более высоком разрешении промежуточных признаков. Таким образом, у генератора нет необходимости хранить во всех своих картах признаков всю информацию о сгенерированной картинке, как это происходит в случае DCGAN: он может декодировать её напрямую из вектора шума по мере необходимости, что существенно облегчает обучение таких моделей и улучшает качество результатов.\n\nАвторы StyleGAN пошли даже дальше: в качестве дополнительной регуляризации они специально заставляли нейросеть использовать информацию из вектора шума частями. А именно, во время обучения все слои адаптивной нормализации случайным образом делятся на две последовательно идущие группы: первая группа обуславливается при помощи одной части вектора шума $z_1$, а вторая – при помощи другой части $z_2$. На практике это приводит к следующему эффекту: нейросеть учиться декодировать часть признаков изображения, используя вектор $z_1$, а часть – используя $z_2$. Это позволяет после обучения напрямую манипулировать выходами нейросети, смешивая разные векторы стилей $z$. \n\n#### Обучение нового латентного пространства\n\nВторое ключевое открытие авторов StyleGAN связано с задачей поиска семантически значимого редактирования векторов из выученного низкоразмерного многообразия $p(z)$. Зачем это нужно на практике мы уже упоминали ранее: на этом низкоразмером многообразии значительно проще семантически редактировать изображения, чем на уровне пикселей. Например, для задачи генерации лиц на многообразии $z$ за изменение возраста или гендера может отвечать простой аддитивный сдвиг вектора $z$ на $\\Delta z$. Если же мы попытаемся приблизить такую операцию в пространстве пикселей, то для этого уже понадобится большая нейросеть с сотнями тысяч или даже миллионами параметров.\n\nПри этом, как правило, мы хотим использовать наиболее простые операции редактирования. В идеале, мы бы хотели ограничить класс преобразований редактирования (а) сдвигами на какой-то вектор и (б) линейной (или сферически-линейной) интерполяцией двух векторов. С одной стороны, кажется, что так задача редактирования векторов существенно усложняется: этот класс преобразований даже менее выразителен, чем линейные операции. Но, с другой стороны, для таких простых преобразований легче гарантировать, что они не выведут нас за пределы многообразия, в котором у распределения $p(z)$ большая «масса», т.е. того множества векторов $z$, которые генератор чаще всего видел во время обучения. Для нормального распределения, как было сказано ранее, это многообразие можно приблизить сферой радиуса $\\sqrt{d}$.\n\nНо будет ли легко найти хорошо работающие преобразования на многообразии случайных векторов $z$, взятых из нормального распределения? Авторы StyleGAN обнаружили, что если сначала пропустить векторы $z$ через многослойный персептрон $f$, и подавать на вход свёрточного генератора его выходы $w = f(z)$, то редактировать латентные векторы на выученном многообразии $w \\in \\mathcal{W}$ станет намного проще. Это объясняется тем, что функция $f$ имеет возможность выучить достаточно сложное распределение для переменной $w$, которое упростило бы задачу генерации картинки для свёрточной части генератора. И на практике оказывается, что такое выученное представление $\\mathcal{W}$ улучшает не только качество генерируемых картинок, но и качество результатов для семантического редактирования векторов.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan_examples_f18ca2f78e_4336874805.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Примеры генерации StyleGAN. <a href=\"https://arxiv.org/pdf/1812.04948.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\n#### Truncation trick\n\nПоследняя важная деталь, которая тем не менее очень сильно помогла авторам StyleGAN получить настолько хорошие результаты – это так называемый truncation trick. Он был впервые предложен в более ранних работах и продолжает оказывает огромное влияние на качество результатов. Его суть состоит в том, чтобы после обучения сэмплировать те примеры из латентного пространства, которые чаще всего видел генератор во время обучения. Например, если мы во время обучения брали вектор $z$ из нормального распределения, то при использовании truncation trick после обучения мы бы его сэмплировали из нормального распределения с обрезанными хвостами. Тем самым, интуитивно, мы убираем из сгенерированной выборки те примеры входных векторов, которые генератор реже видел во время обучения. Однако, нетрудно заметить что такая процедура приводит к потере разнообразия в выходных картинках. Например, если мы обрежем нормальное распределение вплоть до его среднего значения, то тогда нейросеть сможет выдавать лишь один пример. При всём при этом потеря разнообразия выходов – не такая большая проблема, т.к. обученный генератор всё ещё может часто ошибаться и выдавать маргинальные примеры. Фильтрация таких плохих примеров по какому-то выставленному порогу – в этом и есть суть применения truncation trick.\n\nВ случае StyleGAN, авторам хотелось бы применять этот трюк непосредственно на распределении в выученном латентном пространстве $\\mathcal{W}$. Для этого они применяют простой трюк: сначала считают центр масс $\\mathcal{W}$, усредняя векторы $w$ для большой выборки сэмплов $z$:\n\n$$\n    \\bar{w} = \\mathbb{E}_{z \\sim p(z)} [ f(z) ],\n$$\n\nа затем сдвигают каждый сгенерированный вектор $w$ по направлению к этому центру:\n\n$$\n    w' = \\bar{w} + \\psi (w - \\bar{w}),\n$$\n\nгде $\\psi < 1$ – это параметр, который задаёт trade-off между качеством результатов и их разнообразием.\n\n### StyleGAN-2\n\nХотя работа StyleGAN показала довольно хорошие результаты, авторы статьи про StyleGAN-2 [Analyzing and Improving the Image Quality of StyleGAN](https://arxiv.org/abs/1912.04958) заметили, что в некоторых случаях она может выдавать некачественные изображения. В частности, StyleGAN в некоторых случая может выдавать изображения с артефактами. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan_artifacts_e8c61c9be6_92dbafc75f.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Примеры артефактов StyleGAN. <a href=\"https://arxiv.org/pdf/1912.04958.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nОсновной причиной этих артефактов оказалась адаптивная нормализация. Изначально, адаптивная нормализация состояла из двух частей: нормализация (на рисунке обозначена как Norm) и модуляция (на рисунке обозначена как Mod). В нормализации мы вычитали среднее и делили на стандартное отклонение. В модуляции мы умножали на новое выученное стандартное отклонение и прибавляли новое выученное среднее. \n\nАвторы StyleGAN2 предложили несколько модификаций для этапа нормализации. Каждое изменение в статье добавляли последовательно, следя за изменением общего качества генерации. \n\n1. Как из нормализации, так и из модуляции убрали вычитание/прибавление среднего. Нормализация и модуляция теперь выполняются независимо друг от друга и были перемещены в начало/конец стилевых блоков (см рисунок ниже, (c) Revised architecture).\n2. Нормализацию из предыдущего пункта заменили на демодуляцию весов. По сути это та же нормализация, только теперь нормализуются веса свёрток, а не входные данные (см рисунок ниже, (d) Weight demodulation. Обратите внимание на $w_1, w_2, w_3$). \n    <figure>\n    <img src=\"https://yastatic.net/s3/education-portal/media/stylegan2_605de023ae_b010b216d2.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n    <figcaption>\n    <p>Изменения, которые добавили в StyleGAN. <a href=\"https://arxiv.org/pdf/1912.04958.pdf\">Ссылка на источник картинки.</a></p>\n    </figcaption>\n    </figure>\n\n3. В StyleGAN используется техника [progressive growing](https://arxiv.org/pdf/1710.10196.pdf) (см раздел про StyleGAN). Из-за этого StyleGAN появляются артефакты, возникающие при исследовании латентного пространства с помощью интерполяций. Некоторые объекты лиц (глаза, зубы), которые должны вращаться при вращении головы, оставались на месте. Чтобы побороть эти артефакты, вместо progressive growing в StyleGAN2 стали использовать residual connections.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan2_progressive_d01545db47_9ec9aa0376.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Артефакты из-за прогрессивной генерации в StyleGAN. <a href=\"https://arxiv.org/pdf/1912.04958.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nЭти изменения позволили улучшить качество генерируемых изображений и избавиться от артефактов StyleGAN. Вот, например, некоторые примеры сгенерированных изображений модели StyleGAN2:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan2_results_cb58a8cc0b_f15cc11383.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Примеры изображений, сгенерированных с помощью StyleGAN2. <a href=\"https://arxiv.org/pdf/1912.04958.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\n### StyleGAN-ADA\n\nСледующий шаг в развитии архитектуры StyleGAN — это статья [StyleGAN-ADA](https://arxiv.org/abs/2006.06676). ADA расшифровывается как **A**daptive **D**iscriminator **A**ugmentation. В данной статье авторы предложили механизм аугментации данных, который позволяет стабилизировать обучение и избежать переобучения дискриминатора.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan_ada_augmentations_019b3516fe_9a8260a37a.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>На левом рисунке (b) изображено, куда добавляется аугментация (синие блоки). На правом рисунке (c) изображена степень аугментации в зависимости от контролирующего её параметра p. <a href=\"https://arxiv.org/pdf/2006.06676.pdf\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nВсего в статье использовали 18 разных аугментаций. В статье также предложили некоторую эвристику того, как понимать, насколько переобучился дискриминатор. Эвристика нужна для того, чтобы адаптивно контролировать параметр аугментации $p$ в зависимости от степени переобучения.\n\nОсновная идея алгоритма контроля $p$ в процессе обучения следующая. Изначально этот параметр равен нулю. Его значение изменяется на фиксированную величину каждые четыре мини-батча (авторы пишут, что частота обновлений не влияет на результат). Если наблюдается, что дискриминатор слишком переобучился, то параметр $p$ увеличивается. И наоборот, при низкой степени переобучении дискриминатора значение $p$ уменьшается.\n\nАугментация, как показали авторы, действительно помогает стабилизировать обучение при маленьком количестве данных. Однако, большой набор реальных данных всегда будет выигрывать у аугментации. \n\n### StyleGAN-T\n\nБольшинство современных моделей, которые показали впечатляющие результаты для генерации изображений, работают по схеме text to image. То есть текст является входом для нейросети, изображение — выходом. Обычно текст на входе называют prompt. По такой схеме работают модели Stable Diffusion, DALLE 2, Midjourney. Все эти модели являются диффузионными. Однако, пока что списывать GANы со счетов не стоит. Хотя качество у GANов не такое высокое, как у диффузионных моделей, а обучать их сложнее, у них есть неоспоримое преимущество — быстрая генерация изображений.\n\nНа момент написания этого параграфа самая свежая статья про генерацию изображений с помощью GANов — [StyleGAN-T](https://arxiv.org/abs/2301.09515). Её авторы решили на основе StyleGAN сделать модель для генерации изображений из текста.\n\nАрхитектура модели StyleGAN-T очень похожа на архитектуру модели StyleGAN (за основу авторы взяли [StyleGAN-XL](https://arxiv.org/abs/2202.00273) — версию StyleGAN для больших обучающих выборок). В качестве кодировщика текста была использована предобученная модель [CLIP](https://arxiv.org/abs/2103.00020). \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan_t_architecture_c881b0cf15_989f0c2419.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Архитектура модели StyleGAN-T. <a href=\"https://arxiv.org/abs/2301.09515\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\nНа что стоит обратить внимание в данной архитектуре:\n- Текст, закодированный CLIP text encoder, подаётся на вход как генератору, так и дискриминатору. Дискриминатор в данном случае классифицирует не отдельное изображение, а пару текст/изображение.\n- Сгенерированное изображение пропускается через фиксированный кодировщик изображений, также взятый из модели CLIP (CLIP image encoder на рисунке архитектуры). Полученное представление изображения должно быть близко с представлением текста, полученным с помощью CLIP text encoder. Это достигается за счёт добавление CLIP guidance loss в общую функцию потерь. Для разрешения выше 64x64 авторы берут случайные кропы размера 64x64 на изображении, чтобы посчитать CLIP guidance loss.\n\nОсновное новшество модели StyleGAN-T — это лучшая GAN-модель для генерации изображений из текста. До этого большинство хорошо работающих моделей позволяли генерировать изображения для заданного класса или вообще без условий. Связать текст с изображением — гораздо более сложная задача. \n\n#### Результаты генерации\n\nПоскольку на вход модель принимает не только шум, но и закодированный текст, она позволяет делать интерполяции по пространству текста. Примеры сгенерированных изображений и интерполяций по текстовому пространству вы можете видеть на рисунке ниже. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/stylegan_t_results_f7fd7e01d0_8cade2358c.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Результаты генерации моделью StyleGAN-T. <a href=\"https://arxiv.org/abs/2301.09515\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nКачество изображений StyleGAN-T отстаёт от диффузионных моделей, таких как Stable Diffusion или DALLE 2, о чём пишут сами авторы. Однако данная модель сильно выигрывает по скорости: на одной и той же видеокарте Stable Diffusion генерирует изображение за 3.7 секунды, в то время как StyleGAN-T за 0.02 секунды.\n\n#### Disclaimer\n\nВыше были перечислены лишь основные особенности данного класса генеративных моделей, на которые стоит обратить внимание. Эти соображения нашли применение в других задачах помимо генерации картинок из шума. На самом деле, список трюков и нюансов, необходимых для успешного обучения такой модели, намного обширнее. На практике для генеративных моделей настоятельно рекомендуется отталкиваться от готовых кодовых баз, внося минимальные и контролируемые изменения в процесс обучения. Особенно чувствительны генеративные модели бывают к архитектуре генератора и дискриминатора, к параметрам оптимизации (learning rate, количество обновлений весов дискриминатора на одно обновление генератора, и т.д.), а также к значениям весов лоссов (например, к весу R1 регуляризации, которую мы тут не обсуждали).\n\n## Применения генеративных состязательных нейросетей\n\nДо этого мы рассмотрели основные особенности генеративных состязательных нейросетей, а также их применение в задаче генерации изображений. В этом разделе мы рассмотрим, какие ещё задачи можно решать с помощью таких моделей.\n\nОтметим, что задачи, которые мы рассмотрим ниже, можно решать и другими способами без ГАНов. Зачастую диффузионные модели (MidJourney, Stable Diffusion) показывают лучшие результаты в этих задачах. Тем не менее в данном же разделе мы рассмотрим именно методы на основе генеративных состязательных нейросетей.\n\n### Inpainting\n\nПредставьте, что вы хотите удалить с фотографии людей на заднем плане. Встаёт вопрос, чем их заменить? Для этого существует задача инпеинтинга (inpainting). Она заключается в том, чтобы восстановить часть изображения, которая была выделена маской. Если выделить людей или объекты на фотографии маской, то нейросеть для инпеинтинга будет способна зарисовать эти участки чем-то подходящим для конкретной фотографии. \n \n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/inpainting_example_bd2b238b82_ee4a87ad29.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Пример работы модели инпеинтинга. <a href=\"https://arxiv.org/abs/2109.07161\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nОбычно генератор модели GANs для инпеинтинга представляют собой image-to-image модели. То есть изображение подаётся как на вход, так и на выход. То, что происходит внутри генератора, зависит от архитектуры модели. Как правило, используются U-Net-подобные архитектуры с какими-то дополнениями.  Так, например, в одной из последних работ по инпеинтигу на основе GANs [Resolution-robust Large Mask Inpainting with Fourier Convolutions](https://arxiv.org/abs/2109.07161) используются Fast Fourier Convolutions.\n\nЧтобы обучить модель инпеинтинга, нужно подготовить данные в формате пар <изображение с маской, изображение без маски>. Сделать это не сложно. Достаточно на существующем наборе изображений случайным образом выделить участки для удаления, после чего обучать нейросеть их восстанавливать.\n\n\n#### Outpainting\n\nЗадачу inpainting можно так же превратить в задачу outpainting, то есть дорисовки изображения по краям. Для этого нужно в качестве маски подать пиксели, которые находятся за рамками изображения. При этом само исходное изображение можно уменьшить, если того требуют размерности нейросети. \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/outpainting_example_5ca5da2a68_d418dcd028.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Пример outpainting, сделанный моделью In&Out. <a href=\"https://arxiv.org/abs/2104.00675\">Ссылка на источник картинки.</a></p>\n  </figcaption>\n</figure>\n\n\nЗадача outpainting может быть полезна, когда хочется расширить изображение, например, чтобы увеличить его разрешение.\n\n#### Редактирование изображений\n\nДо этого мы рассматривали, как можно редактировать латентное пространство обученной состязательной модели, чтобы это отражалось на сгенерированных изображениях. В 2023 году вышла работа [Drag Your GAN](https://vcai.mpi-inf.mpg.de/projects/DragGAN/), которая основана на этом принципе, и позволяет редактировать изображения перетаскиванием одной точки в другую.\n\n<iframe width=\"100%\" height=\"500\" src=\"https://frontend.vh.yandex.ru/player/48072e442ea77083824bc3af91595450?from=partner&mute=1&autoplay=1&tv=0&loop=true&play_on_visible=false\" allow=\"autoplay; fullscreen; accelerometer; gyroscope; picture-in-picture; encrypted-media\" frameborder=\"0\" scrolling=\"no\" allowfullscreen></iframe>\n\n<p style=\"color:darkslategrey;font-size:14px\">Пример работы Drag Your GAN.<a href=\"https://vcai.mpi-inf.mpg.de/projects/DragGAN/\">cсылка на источник изображения</a></p>\n\nМетод Drag Your GAN основан на модели StyleGAN2. Ему на вход подаётся набор изначальных точек и набор конечных точек. Внутри метода поочерёдно выполняются следующие два шага:\n1. Обновление латентного пространства и обновления изображения с помощью оптимизации;\n2. Обновление координат точек (трекинг точек).\n\nИзначально метод работает только со сгенерированным изображениями. Однако, нет проблем в том, чтобы добавить кодировщик, который бы переводил реальные изображения в латентное пространство модели. В таком случае можно будет редактировать и реальные изображения.\n\nДемо Drag Your GAN доступно по [ссылке](https://huggingface.co/spaces/DragGan/DragGan).",
        "handbook": "Учебник по машинному обучению",
        "title": "Генеративно-состязательные сети (GAN)",
        "description": "Генеративно-состязательные сети (GAN)"
    },
    {
        "path": "/handbook/ml/article/normalizuyushie-potoki",
        "content": "## Введение\n\nВ главе [Генеративный подход к классификации](https://education.yandex.ru/handbook/ml/article/generativnyj-podhod-k-klassifikacii) мы уже познакомились с типом моделей, которые оценивают совместное распределение $p(X,Y)$. Такие модели называют **генеративными**. Для простоты предположим, что мы имеем всего один класс, тогда задача моделирования $P(X,Y)$ сводится к задаче моделирования $p(X)$. Научившись моделировать это распределение, мы сможем:\n\n- генерировать объекты $x \\sim p_\\theta^\\mathcal{data}$, где $\\theta$ – параметры модели;\n- оценивать вероятность встретить данный объект $\\mathbf{x}$ среди набора наблюдаемых данных $\\mathcal{D}$;\n- выучивать скрытые представления для объекта $\\mathbf{x}$.\n\nИзвестными примерами генеративных моделей являются:\n\n- Авторегрессионные модели:\n\n$$p_\\theta(\\mathbf{x}) = \\prod_{i=1}^n p_\\theta(x_i \\vert \\mathbf{x}_{<i}),\n$$\n\n$$x \\in \\mathbb{R}^n,\n$$\n\n- Вариационные автокодировщики:\n\n$$p_\\theta(\\mathbf{x}) = \\int p_\\theta(\\mathbf{x}, \\mathbf{z}) d\\mathbf{z},\n$$\n\n$$\\mathbf{z} \\in \\mathbb{R}^m.\n$$\n\nНо оба эти метода не позволяют одновременно:\n\n- получать скрытые представления для объектов\n- точно вычислять функцию правдоподобия\n\n**Нормализующие потоки** способны решить обе эти задачи.\n\n## Мотивация\n\n![flow](https://yastatic.net/s3/education-portal/media/flow_2ce610b050_f34b9b2f31.webp)\n\nПусть $\\mathbb{x} \\sim p_x(\\mathbb{x})$, где $p_x(\\mathbb{x})$ неизвестно, а $\\mathbb{z} \\sim p_z(\\mathbb{z}) = \\mathcal{N}(0, I)$. Мы хотим найти отображение $f_{\\theta} : \\mathbb{R}^n \\rightarrow \\mathbb{R}^n$, для которого $\\mathbb{x} = f_{\\theta}(\\mathbb{z})$ и $\\mathbb{z} = f_{\\theta}^{-1}(\\mathbb{x})$.\n\nОтображение $f$ преобразует базовую функцию плотности $p_z$ к более сложной $p_x$. С его помощью мы можем генерировать сложный объект путем сэмплинга простого объекта $\\mathbb{z}$ (скрытой переменной) из распределения $p_z$ и применения «генератора» $f(\\mathbb{z}) = \\mathbb{x}$. Обратное отображение $f^{-1}$ «нормализует» сложное распределение $p_x$, приводя его к простому $p_z$.\n\nНайдя такое отображение $f$, мы сможем генерировать новые объекты $\\mathbb{x}$, а оценить плотность $p_x(\\mathbb{x})$ поможет формула преобразования плотности случайной величины. Давайте её вспомним.\n\n### Формула замены переменной\n\nПусть $\\mathbb{x} \\sim p_x(\\mathbb{x})$, $\\mathbb{z} \\sim p_z(\\mathbb{z})$, при этом отображение $f : \\mathbb{R}^n \\rightarrow \\mathbb{R}^n$ дифференцируемо, обратимо и $\\mathbb{x} = f(\\mathbb{z})$. Тогда:\n\n$$p_x(\\mathbb{x}) = p_z(f^{-1}(\\mathbb{x})) \\cdot \\bigg| \\text{det} \\left( J_{f^{-1}} \\right) \\bigg|,\n$$\n\nгде $\\text{det} \\left( J_{f^{-1}} \\right)$ – якобиан отображения $f^{-1}$.\n\n## Определение\n\nИтак, **нормализующий поток** – это обратимое дифференцируемое отображение $f_{\\theta} : \\mathbb{R}^n \\rightarrow \\mathbb{R}^n$, которое переводит исходные представления объектов в скрытые: $\\mathbb{x} = f_{\\theta}(\\mathbb{z})$ и $\\mathbb{z} = f_{\\theta}^{-1}(\\mathbb{x})$.\n\nПри этом функция правдоподобия $p_x(\\mathbb{x})$ вычисляется по формуле:\n\n$$p_x(\\mathbb{x}) = p_z(f^{-1}(\\mathbb{x})) \\cdot \\bigg| \\text{det} \\left( J_{f^{-1}} \\right) \\bigg|\n$$\n\nУмея вычислять функцию правдоподобия, мы можем обучать нашу модель $f_\\theta$ методом максимума правдоподобия (ММП):\n\n$$\\log \\space p_x(\\mathcal{D}; \\theta) = \\sum_{i=1}^M \\text{log} \\space p_z(f^{-1}_\\theta(\\mathbb{x})) + \\log \\space \\bigg| \\text{det} \\left( J_{f^{-1}} \\right) \\bigg|.\n$$\n\nгде $\\mathcal{D} = \\{ x^{(i)}\\}_{i=1}^M$ – выборка наблюдаемых данных из распределения $p_x$.\n\nОбычно модель нормализующего потока составляет композицию из $K$ не очень сложных отображений, чтобы она была, с одной стороны, достаточно контролируемой, а с другой – достаточно выразительной:\n\n$$f = f_1 \\circ f_2 \\circ \\dots \\circ f_K\n$$\n\nТогда якобиан вычисляется по формуле:\n\n$$\\det \\left( J_{f^{-1}} \\right) = \\prod_{i=1}^{K} \\det \\left( J_{f^{-1}_i} \\right)\n$$\n\nНо вычисление якобиана является очень затратной операцией. Для того, чтобы мы могли обучать модели эффективно на высокоразмерных данных (аудио, изображения), необходимо использовать такое отображение $f$, подсчет якобиана которого был бы эффективен!\n\n<p-important>\n\nВ отличе от VAE и GANов, нормализующие потоки требуют вычисления функции правдоподобия, воэтому важно уметь **эффективно** вычислять функцию правдоподобия. Метод максимального правдоподобия позволяет обучать нормализующие потоки стабильнее в сравнении с GAN-ами, а возможность быстро и точно вычислять значение функции правдоподобия выделяет нормализующие потоки на фоне VAE и диффузионных моделей.\n</p-important>\n\nПримером такого отображения является **планарный поток** (**Planar Flow**), где отображение $f$ принадлежит следующему семейству функций:\n\n$$\\mathbb{x} = f_\\theta(\\mathbb{z}) = \\mathbb{z} + \\mathbb{u}_\\theta h (\\mathbb{w}_\\theta ^ \\top \\mathbb{z} + b_\\theta),\n$$\n\nгде $\\mathbb{u}_\\theta, \\mathbb{w}_\\theta, b_\\theta$ – обучаемые параметры, а $h$ – гладкая нелинейная функция, например, $\\text{tanh}$.\n\nЯкобиан такого отображения можно будет посчитать за $O(n)$. Обозначим\n\n$$\\psi(\\mathbb{z}) = h'(\\mathbb{w}_\\theta^\\top \\mathbb{z} + b_\\theta) \\mathbb{w}_\\theta.\n$$\n\nТогда\n\n$$\\bigg| \\det \\left( J_{f} \\right) \\bigg| = \\big| \\det( \\mathbb{I} + \\mathbb{u}_\\theta \\psi(\\mathbb{z})^\\top) \\big| = \\big| (1 + \\mathbb{u}_\\theta^\\top \\psi(\\mathbb{z})) \\big|.\n$$\n\n![planar](https://yastatic.net/s3/education-portal/media/planar_d4c78adc79_bc33898cce.webp)\nДействие планарного нормализующего потока на нормальное и равномерное распределение ([ссылка на статью](https://arxiv.org/abs/1505.05770)).\n\n## Развитие идеи\n\nВ планарных потоках нам удалось быстро посчитать якобиан, потому что матрица имела специальный вид (сумма единичной и низкоранговой). Но мы знаем и другие случаи, когда определитель можно посчитать быстрее – треугольные матрицы. Их определитель равен произведению элементов на диагонали.\n\nСледующие модели активно использовали этот трюк.\n\n### NICE: Non-linear Independent Component Estimation и RealNVP\n\nАвторы модели [NICE](https://arxiv.org/abs/1410.8516) предложили использовать в качестве $f_\\theta$ следующее семейство преобразований:\n\n$$\\mathbb{x} = f_\\theta(\\mathbb{z}) =\n\\begin{cases}\n    \\mathbb{x}_{1:d} = \\mathbb{z}_{1:d} \\\\\n    \\mathbb{x}_{d+1:n} = \\mathbb{z}_{d+1:n} + m_\\theta(\\mathbb{z}_{1:d})\n\\end{cases},\n$$\n\nгде $1<d<n$, а $m_\\theta$ – произвольная нейросеть с $d$ входами и $n - d$ выходами. Такое преобразование называют **аддитивным связыванием** (**additive coupling**).\n\nОбратное преобразование вычисляется с такой же легкостью, а якобиан равен $1$. То есть, $p_x(\\mathbb{x}) = p_z(f^{-1}(\\mathbb{x}))$, что является довольно сильным ограничением модели.\n\nДалее, из-за того, что\n\n$$\\mathbb{x}_{1:d} = \\mathbb{z}_{1:d},\n$$\n\nпервые $d$ каналов вектора $x$ совпадают с координатами нормального шума $z$, то есть моделирования этих каналов $x$ не происходит. Из-за этого выразительная способность модели NICE была относительно невысокой.\n\nПозже авторы NICE позже предложили использовать между слоями нормализующих потоков зафиксированные перестановки признаков/каналов $\\mathbb{x}$, что стало основой работы [RealNVP](https://arxiv.org/abs/1605.08803). Использование перестановок позволяет добиться того того, чтобы все выходные каналы оказались затронуты преобразованием $f_\\theta(z)$; при этом градиент перестановки вычисляется легко.\n\n$$\\mathbb{x} = f_\\theta(\\mathbb{z}) =\n\\begin{cases}\n    \\mathbb{x}_{1:d} = \\mathbb{z}_{1:d} \\\\\n    \\mathbb{x}_{d+1:n} = \\exp(s_\\theta(\\mathbb{z}_{1:d})) \\odot \\mathbb{z}_{d+1:n} + m_\\theta(\\mathbb{z}_{1:d})\n\\end{cases},\n$$\n\nгде $\\odot$ – поэлементное умножение, а $s_\\theta$ – нейросеть, которая может быть произвольной, но, как правило, выбирается такой же архитектуры, как и $m_\\theta$. Такое преобразование называют **аффинным связыванием** (**affine coupling**).\n\nПолучившееся отображение тоже легко обращается, а его якобиан равен:\n\n$$\\det \\left( J_{f^{-1}} \\right) = \\exp \\sum_{i=d+1}^n ( s_\\theta(\\mathbb{z}_{1:d}) )_i\n$$\n\nЗаметим, что, как и в случае аддитивного связывания, значительная часть каналов остается неизменной при использовании аффинного связывания. Для того, чтобы преобразование $f_\\theta(x)$ моделировало распределение $x$ во всех каналах, на разных слоях неизменными оставляют разные подмножества из $d$ каналов.\n\nЧтобы улучшить сходимость глубоких ($K > 1$) нормализующих потоков, авторы предложили использовать Batch Normalization. Данное преобразование тоже является обратимым, а его якобиан вычисляется крайне просто.\n\nВ результате, выразительная способность модели сильно повысилась, и она стала способна выучивать сложные распределения:\n\n![realnvp](https://yastatic.net/s3/education-portal/media/realnvp_992fd9db24_90691e3b3e.webp)\n\n### Masked Autoregressive Flows\n\n[Ссылка на статью](https://arxiv.org/abs/1705.07057)\n\nДанный вид нормализующих потоков также обладает нижнетреугольным якобианом, но он использует другое семейство функций:\n\n$$x_i = z_i \\exp( f_{\\alpha_i} (\\mathbb{x}_{1:i-1}) ) + f_{\\mu_i} (\\mathbb{x}_{1:i-1}),\n$$\n\nгде $\\mu_i(x_{1:i-1})$ и $\\alpha_i(x_{1:i-1})$ – нейросети произвольной архитектуры.\n\nКак видно из формулы, $x_i$ напрямую зависит от $x_{1:i-1}$. Таким образом, элементы генерируются **авторегрессивно**, что и дало название архитектуре.\n\nЯкобиан такого преобразования вычисляется по следующей формуле:\n\n$$\\det \\left( J_{f^{-1}} \\right) = \\exp\\bigg( -\\sum_{i=1}^n f_{\\alpha_i} (\\mathbb{x}_{1:i-1}) \\bigg)\n$$\n\nТаким образом, шаг генерации выглядит следующим образом:\n\n1. $z \\sim  \\mathcal{N}(0, I)$\n2. $x_1 = z_1  \\exp(\\alpha_1) + \\mu_1$$\n3. $x_2 = z_2  \\exp(f_{\\alpha_2}(x_1)) + f_{\\mu_2}(x_1)$\n   ...\n\nОднако вычисление скрытых переменных $z$ не является авторегрессивным:\n\n$$z_i = (x_i - f_{\\mu_i}(x_{1:i-1})) \\exp(-f_{\\alpha_i} (x_{1:i-1}))\n$$\n\nНесмотря на то, что данная разновидность нормализующих потоков кажется более мощной моделью, её трудно применить на практике к данным высокой размерности. Это происходит из-за того, что генерация нового объекта осуществляется авторегрессивно по координатам, что становится слишком затратным при обучении на высокоразмерных данных, например, на изображениях.\n\n### Inverse Autoregressive Flows\n\n[Ссылка на статью](https://arxiv.org/abs/1606.04934)\n\nЧтобы быстро генерировать объекты из сложного распределения, мы можем избавиться от авторегрессивности на шаге генерации, поставив в авторегрессивную зависимость не наблюдаемые, а латентные переменные:\n\n$$z_i = (x_i - f_{\\mu_i}(z_{1:i-1})) \\exp(-f_{\\alpha_i} ({z}_{1:i-1}))\n$$\n\nМожем заметить, что проблема долгого вычисления авторегрессивных выражений никуда не уходит. Мы лишь изменяем построение модели таким образом, чтобы генерировать объекты $\\mathbb{x}$ быстрее:\n\n$$x_i = z_i \\cdot \\exp(f_{\\alpha_i}(z_{1:i-1})) + f_{\\mu_i}(z_{1:i-1})\n$$\n\nНо вычисление $\\mathbb{z}$, а значит и правдоподобия, становится долгим, и обучение занимает больше времени.\n\n### Звук\n\nНормализующие потоки стали наиболее актуальны в задаче генерации звука, поскольку они обладают достаточно высокой выразительностью и эффективностью, чтобы быстро генерировать аудиозаписи высокого качества. В этом контексте, модель нормализующего потока должна генерировать аудио, получая на вход описание того, что ей необходимо сгенерировать. То есть модель обуславливается на дополнительные признаки.\n\nНормализующие потоки могут быть обусловлены на входные данные путем использования дополнительных входных данных в качестве переменной, от которой зависят преобразования, применяемые к данным. Обусловливающей переменной может быть любая дополнительная информация, имеющая отношение к задаче генерации, такая как текстовые описания, изображения или другие характеристики данных.\n\nВ контексте генерации аудио обуславливающей переменной обычно служит [mel-спектрограмма](https://medium.com/analytics-vidhya/understanding-the-mel-spectrogram-fca2afa2ce53), которая позволяет отобразить интенсивность различных частот аудио-сигнала в разные моменты времени.\n\n![melspec](https://yastatic.net/s3/education-portal/media/melspec_1dcc106402_25c40b6bfc.webp)\n\nНормализующий поток учится генерировать сигнал в виде waveform-а на основе спектрограммы путем обратного преобразования.\n\n![waveform](https://yastatic.net/s3/education-portal/media/waveform_656aaac1a9_b981993d89.webp)\n\nЧтобы генерировать более длинные фрагменты звука, модель генерирует короткие звуковые кадры (фреймы) за раз, которые затем объединяются для формирования полного waveform-а.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_38_e7555b15c8_6d648a81ee.svg)\n\nТеперь мы готовы узнать про применение нормализующих потоков в генерации аудио!\n\n### Probability Density Distillation и Parallel WaveNet\n\n[Ссылка на статью](https://arxiv.org/abs/1711.10433)\n\nАрхитектура Inverse Autoregressive Flow (IAF) была изначально предложена для задачи генерации аудио. Она позволяет генерировать объекты крайне эффективно, но обучение методом максимального правдоподобия занимает много времени из-за авторегрессивности вычислений. Метод Probability Density Estimation позволяет решить эту проблему с помощью использования второй предобученной авторегрессивной модели в качестве учителя. IAF обучается в качестве модели-студента, минимизируя KL дивергенцию $\\text{KL}(p_S \\vert\\vert p_T),$ где $p_S$ и $p_T$ – распределения студента и учителя соответственно. Ключевым достижением данного подхода является то, что вычисление функции потерь требует вычисления кросс-энтропии между учителем и студентом, а не правдоподобия, что позволяет максимально распараллелить все вычисления ввиду отсутствия авторегрессивности в вычислениях.\n\nВместе с тем в данной работе в качестве учителя выбирается не случайная модель, а оригинальная авторегрессивная модель [WaveNet](https://www.deepmind.com/blog/wavenet-a-generative-model-for-raw-audio), которая в 2016 году позволила достичь state-of-the-art качества генерации аудио. Эта модель является не нормализующим потоком, а обыкновенной авторегрессивной моделью, которая обучается предсказывать следующий кусочек аудио (фрейм) длиной в несколько миллисекунд.\n\n![wavenet](https://yastatic.net/s3/education-portal/media/wavenet_4a32f3d218_5baa882564.gif)\n\nТаким образом, с помощью IAF и Probability Density Distillation авторам удалось ускорить генерацию более чем в 1000 раз без потери качества!\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_3_96419b9795_00e114ab5b.svg)\n\nНа картинке выше мы видим, что модель использует лингвистические признаки для генерации аудио. Эта задача является примером **задачи условной генерации**, где на вход модели подается [спектрограмма](https://en.wikipedia.org/wiki/Mel_scale), сгенерированная отдельной моделью по тексту, а на выход ожидается речь в аудио-формате (waveform). О том, как модель использует дополнительную информацию для обуславливания, поговорим в главе про [Waveglow](#waveglow)\n\n### Glow\n\nИсследователи из OpenAI в 2018 году опубликовали работу [Glow: Generative Flow with Invertible 1×1 Convolutions](https://arxiv.org/pdf/1807.03039.pdf), которая значительно улучшает результаты модели RealNVP. Опишем два главых улучшения.\n\nВо-первых, для перемешивания каналов Glow использует **обратимые свертки с ядром 1x1** вместо фиксированной матрицы перестановок каналов в RealNVP;\n\nЭто нововведение является по-настоящему красивым, так как в нем предлагается способ вычисления якобиана 2D-свертки за $O(n)$. А именно, логарифм якобиана такой 1x1-свертки с числом каналов $n$ для тензора размера $h \\times w \\times n$ равен $hw \\cdot \\log \\vert \\det(W) \\vert$, где $W$ – матрица свёртки 1х1.\n\nАвторы предлагают использовать следующий вариант LU-разложения для матрицы $W$:\n\n$$W = PL(U + \\text{diag}(s)),\n$$\n\nгде $P$ – фиксированная матрица перестановок, $L$ – нижнетреугольная матрица с единицами на диагонали, $U$ – верхнетреугольная матрица с нулями на диагонали, а $s$ – обучаемый вектор.\n\nНетрудно показать, что\n\n$$\\log | \\det(W) | = \\text{sum}(\\log(s))\n$$\n\nБлагодаря этому авторам удалось снизить сложность вычислений якобиана с $O(n^3)$ до $O(n)$\n\nКроме того, для улучшения сходимости использовали собственно разработанный **actnorm-слой** (**activation normalization**). Поскольку нормализующие потоки требуют много вычислительных ресурсов, для обучения используются мини-батчи маленького размера, из-за чего батч-нормализация работает не очень хорошо. Авторы предлагают использовать следующий тип нормализации – actnorm:\n\n$$x'_{i,j} = s \\odot x_{i,j} + b\n$$\n\n* Нормализуем входной тензор (промежуточное изображение) по размерности каналов;\n* Инициализируем параметры смещения $b$ и разброса $s$ статистиками с **первого батча**;\n* Далее обучаем их в качестве обычных параметров.\n\nТаким образом, один блок нормализующего потока выглядит так:\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_4_130a9ea4b3_0424b0240e.svg)\n\n### WaveGlow\n\n[Ссылка на статью](https://arxiv.org/pdf/1811.00002.pdf)\n\nВторым важным с практической точки зрения применением нормализующих потоков стала модель **WaveGlow**. Она представляет собой версию модели Glow, адаптированную для генерации речи по тексту.\n\nКак мы помним, эта задача также является примером **задачи условной генерации**:\n\n$$\\log \\space p_{x|c}(\\mathcal{D}; \\theta) = \\sum_{i=1}^M \\text{log} \\space p_{z|c}(f^{-1}_\\theta(\\mathbb{x}, \\mathbb{c}) | \\mathbb{c}) + \\log \\space \\bigg| \\text{det} \\left( J_{f^{-1}} \\right) \\bigg|.\n$$\n\nНа практике это приводит к тому, что все распределения в нашей формуле становятся **условными**. Таким образом, при генерации мы также сэмплируем из условного распределения $z \\sim p_{z|c}(z|c)$, а в слоях нормализующих потоков используем преобразования $x_i = f_i(x_{i-1}, c)$.\n\nВ качестве обуславливающего фактора $c$ для WaveGlow мы имеем сгенерированную по тексту [mel-спектрограмму](https://en.wikipedia.org/wiki/Mel_scale), а на выходе ожидаем получить соответствующую тексту и спектрограмме аудио-запись. Как мы видим на изображении и в формулах ниже, mel-спектрограмма используется как дополнительный признак для нейросети, генерирующей параметры афинного преобразования. В качестве модели, которая производит параметры афинного преобразования, используется похожая на WaveNet архитектура с dilated-свертками.\n\nПравая часть схемы ниже более подробно показывает строение слоя affine coupling:\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_32_5cf5f0ee4c_4fd72398b5.svg)\n\n$$(x_a, x_b) = \\text{split}(x) \\\\\n(\\log s, t) = WN(x_a, \\text{mel-spectrogram}) \\\\\nx_b' = s \\odot x_a + t \\\\\nf_{coupling}^{-1} (x)w = \\text{concat}(x_a, x_b')\n$$\n\nОперация $split$ разделяет тензор $x$ пополам на два тензора меньшей размерности $x_a$ и $x_b$ для их последующего участия в слое **аффинного связывания** (affine coupling).\n\nПример генерации:\n[Источник](https://nv-adlr.github.io/WaveGlow)\n\n<table><thead>\n<tr><th>Ground truth</th><th>WaveNet</th><th>WaveGlow</th></tr>\n</thead><tbody><tr>\n<td><audio controls=\"\"><source src=\"audio/real.wav\" type=\"audio/wav\"></audio></td>\n<td><audio controls=\"\"><source src=\"audio/wavenet.wav\" type=\"audio/wav\"></audio></td>\n<td><audio controls=\"\"><source src=\"audio/waveglow.wav\" type=\"audio/wav\"></audio></td>\n</tr></tbody></table>\n\n## Out-of-distribution detection\n\nМожет показаться, что способность точно и эффективно вычислять функцию правдоподобия может позволить без труда обнаруживать аномалии в данных, что может пригодиться во многих приложениях. Однако в работе [Kirichenko et al.](https://arxiv.org/abs/2006.08545) на примере задачи генерации изображений было показано, что нормализующие потоки выучивают отображение картинок в латентное пространство, основываясь на локальных корреляциях пикселей и графических деталях, а не на семантическом контенте. Из-за этого правдоподобие OOD-объектов может быть выше, чем правдоподобие in-distribution сэмплов.\n\n![flows](https://yastatic.net/s3/education-portal/media/flows_ood_8620c90463_5420c22f23.webp)\n\nОднако позже было предложено использовать ряд эвристик для того, чтобы улучшить способность к детекции аномалий за счет подсчета значения функции правдоподобия:\n\n1. Использовать значение правдоподобия второй модели потока, обученного на отличном от исходного датасете (например, ImageNet при исходном CelebA). А затем вычислять отношенение этих двух значений для вынесения вердикта об аномальности объекта. [Schirrmeister et al.](https://arxiv.org/abs/2006.10848)\n2. В работе [Serrà et al.](https://arxiv.org/abs/1909.11480) показали, что проблема качества нормализующих потоков в задаче детекции аномалий связана с чрезмерным влиянием сложности входных данных на значение функции правдоподобия. Поэтому авторы предложили использовать в качестве поправки размер сжатого изображения с помощью одного из алгоритмов компрессии (JPEG2000/PNG).\n\n![flows](https://yastatic.net/s3/education-portal/media/flows_ood_compression_f6c5a5e125_623f4182c0.webp)\n\n## Сравнение с другими типами генеративных моделей\n\nОбратимся к статье [Bond-Taylor et al.](https://arxiv.org/abs/2103.04922), в которой приводится количественный анализ всех существующих семейств генеративных моделей в задаче генерации изображений из датасета CIFAR-10.\n\n![nf](https://yastatic.net/s3/education-portal/media/nf_comparison_8444b65d4c_71a5389edf.webp)\n\nВ таблице выше указано, насколько представители каждого из популярных семейств генеративных моделей эффективны в следующих аспектах решения задачи:\n\n1. скорость обучения;\n2. скорость генерации;\n3. число обучаемых параметров;\n4. разрешение генерируемого изображения;\n5. ограничение на форму якобиана;\n6. возможность вычислять правдоподобие объекта;\n7. FID ([Fréchet Inception Distance](https://arxiv.org/abs/1706.08500)) тестовой выборки;\n8. Отрицательный логарифм правдоподобия тестовой выборки.\n\nЗа расшифровкой обратимся к таблице ниже:\n\n![nf](https://yastatic.net/s3/education-portal/media/nf_comparison_criteria_8ea27b2e47_ee256aab04.webp)\n\nПодведя итог, можно сказать, что нормализующие потоки:\n\n* требуют очень много времени на обучение, так как при обучении проводятся нетривиальные неоптимизированные вычисления;\n* имеют скорость генерации, сравнимую с GAN-ами;\n* менее эффективны по соотношению качество/число параметров, чем GAN-ы и диффузионные модели;\n* позволяют **быстро** вычислять точное значение функции правдоподобия объекта;\n* обладают сравнительно неплохим качеством генерации, проигрывающим GAN-ам и диффузионным моделям.\n\nИтак, нормализующие потоки явно выделяются среди других семейств генеративных моделей своими свойствами – обратимостью и способностью вычислять правдоподобие объекта. Но если для решения задачи они не требуются, то имеет смысл попробовать другие модели – в первую очередь, GAN-ы и диффузионные модели.",
        "handbook": "Учебник по машинному обучению",
        "title": "Нормализующие потоки",
        "description": null
    },
    {
        "path": "/handbook/ml/article/diffuzionnye-modeli",
        "content": "## Введение\n\nВ этом параграфе мы снова попробуем решить задачу генерации, когда нам дана выборка объектов из распределения $x_0 \\sim q(x)$, и хотим научиться генерировать новые объекты из распределения , которых нет в нашей выборке.\n\nВероятно, вы уже знакомы с другими генеративными моделями, например VAE или GAN-ы. Здесь же мы познакомим вас с еще одним видом генеративных моделей: **диффузионные модели**, которые стали крайне популярны в последнее время благодаря своему высокому качеству генерации объектов из заданного распределения. В общий чертах, они работают следующим образом: берем шум из $\\mathcal{N}(0, I)$ и шаг за шагом удаляем компоненты шума до тех пор, пока не получим объект $x_0$ из распределения, см. иллюстрацию ниже.\n\n![Screenshot_2022_08_10_at_7_40_50_PM_4f35128d6e.webp](https://yastatic.net/s3/education-portal/media/Screenshot_2022_08_10_at_7_40_50_PM_4f35128d6e_5e997fb3b8.webp)\n\n## Более детально\n\nДля детального понимания стоит объяснить, что такое **прямой и обратный диффузионные процессы**. **Прямой** процесс заключается в постепенном зашумлении картинки с помощью распределения $q$, а **обратный**, наоборот, в расшумлении с помощью распределения $p$. Их можно схематично изобразить следующим образом:\n\n![Artboard_37_5c7b09c386.svg](https://yastatic.net/s3/education-portal/media/Artboard_37_5c7b09c386_d0cccfa898.svg)\n\n**Прямой** диффузионный процесс определяется как апостериорное распределение $q(x_{1:T}|x_0)$. Это распределение также является Марковской цепочкой, которая постепенно добавляет гауссовский шум к объекту $x_0$. На каждом шаге шум добавляется с различной магнитудой, которая определяется расписанием дисперсий $\\{\\beta_1, ... , \\beta_T\\}$. При правильном выборе расписания в пределе по числу шагов $T$ мы должны сойтись к шуму из $\\mathcal{N}(0, I)$. В качестве распределений $q$ берут нормальные распределения:\n\n$$\nq(x_t | x_{t - 1}) := \\mathcal{N}(x_t; \\sqrt{1 - \\beta_t}x_{t - 1}, \\beta_tI), \\ \\ \\ \\ \\ \\ \\ q(x_{1:T}|x_0) = \\prod_{t = 1}^T q(x_t | x_{t - 1})\n$$\n\nТеперь перейдем к **обратному** процессу и к самой **диффузионной модели**.\n\n**Диффузионная модель** - это вероятностная модель с латентными переменными вида $p_\\theta(x_0) := \\int p_\\theta(x_{0:T}) dx_{1:T}$, где промежуточные состояния $x_1, ..., x_T$ соответствуют зашумленным объектам, a $x_0$ - объект из распределения. Совместное распределение $p_\\theta(x_{0:T})$ называет **обратным диффузионным процессом**, который представляет собой Марковскую цепочку из гауссовских распределений $p_\\theta(x_{i-1}|x_{i})$: \n\n$$\np(x_{0:T}) = p(x_0) \\prod_{t = 1}^Tp_{\\theta}(x_{t-1}|x_t) \\ \\ \\ \\ \\ \\ \\ \\ \\ p_\\theta(x_{T})=\\mathcal{N}(x_T | 0, I)\n$$\n\n$$\n  p_{\\theta}(x_{t - 1}|x_t):= \\mathcal{N}(x_{t - 1}; \\mu_{\\theta}(x_t, t), \\Sigma_{\\theta}(x_t, t))\n$$\n\nТаким образом, обратный процесс параметризуется моделью $\\theta$, которая по зашумленному объекту $x_t$ и шагу $t$ предсказывает среднее $\\mu_{\\theta}(x_t, t)$ и дисперсию $\\Sigma_{\\theta}(x_t, t)$.\n\n## Обучение диффузионной модели\n\nДиффузионный модели обучаются, максимизируя вариационную нижнюю оценку (ELBO) логарифма правдоподобия  $\\log p_{\\theta}(x_0)$. По тому же принципу обучаются VAE, с тем лишь отличием, что у диффузионных моделей другая форма модели с латентными переменными.  Итак, давайте выведем ELBO для диффузии:\n\n$$\n\\begin{aligned}\n- \\log p_\\theta(\\mathbf{x}_0) \n&\\leq - \\log p_\\theta(\\mathbf{x}_0) + D_\\text{KL}(q(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0) \\| p_\\theta(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0) ) \\\\\n&= -\\log p_\\theta(\\mathbf{x}_0) + \\mathbb{E}_{\\mathbf{x}_{1:T}\\sim q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_0)} \\Big[ \\log\\frac{q(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0) p_\\theta(\\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{0:T})} \\Big] \\\\\n&= -\\log p_\\theta(\\mathbf{x}_0) + \\mathbb{E}_q \\Big[ \\log\\frac{q(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{0:T})} + \\log p_\\theta(\\mathbf{x}_0) \\Big] \\\\\n&= \\mathbb{E}_q \\Big[ \\log \\frac{q(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{0:T})} \\Big] \\\\\n\\text{Let }L_\\text{VLB} \n&= \\mathbb{E}_{q(\\mathbf{x}_{0:T})} \\Big[ \\log \\frac{q(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{0:T})} \\Big] \\geq - \\mathbb{E}_{q(\\mathbf{x}_0)} \\log p_\\theta(\\mathbf{x}_0)\n\\end{aligned}\n$$\n\n- Комментарий\n    \nЕсли вы знакомы с VAE, то вывод $L_{VLB}$ должен быть вам понятен, однако ниже приведен вывод с помощью неравенства Йенсена\n\n$$\n\\begin{aligned}\nL_\\text{CE}\n&= - \\mathbb{E}_{q(\\mathbf{x}_0)} \\log p_\\theta(\\mathbf{x}_0) \\\\\n&= - \\mathbb{E}_{q(\\mathbf{x}_0)} \\log \\Big( \\int p_\\theta(\\mathbf{x}_{0:T}) d\\mathbf{x}_{1:T} \\Big) \\\\\n&= - \\mathbb{E}_{q(\\mathbf{x}_0)} \\log \\Big( \\int q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_0) \\frac{p_\\theta(\\mathbf{x}_{0:T})}{q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_{0})} d\\mathbf{x}_{1:T} \\Big) \\\\\n&= - \\mathbb{E}_{q(\\mathbf{x}_0)} \\log \\Big( \\mathbb{E}_{q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_0)} \\frac{p_\\theta(\\mathbf{x}_{0:T})}{q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_{0})} \\Big) \\\\\n&\\leq - \\mathbb{E}_{q(\\mathbf{x}_{0:T})} \\log \\frac{p_\\theta(\\mathbf{x}_{0:T})}{q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_{0})} \\\\\n&= \\mathbb{E}_{q(\\mathbf{x}_{0:T})}\\Big[\\log \\frac{q(\\mathbf{x}_{1:T} \\vert \\mathbf{x}_{0})}{p_\\theta(\\mathbf{x}_{0:T})} \\Big] = L_\\text{VLB}\n\\end{aligned}\n$$\n\nТеперь вернемся к распределению $q(x_t | x_{t - 1})$.  Для того чтобы получить $x_t$, придется итеративно получать $x_1, ..., x_{t - 1}$. Однако это можно сделать более эффективно благодаря нормальным распределениям. Для этого обозначим $\\alpha_t := 1- \\beta_t$ и $\\bar{\\alpha}_t:= \\prod_{i = 1}^t\\alpha_i$, тогда</p> \n\n$$\nq(x_t | x_0) = \\mathcal{N}(x_t;\\sqrt{\\bar{\\alpha}_t} x_0, (1-\\bar{\\alpha}_t)I)\n$$\n\n- Формальный вывод этого факта\n\n$$\n\\begin{aligned}\n\\mathbf{x}_t \n&= \\sqrt{\\alpha_t}\\mathbf{x}_{t-1} + \\sqrt{1 - \\alpha_t}\\mathbf{z}_{t-1}; \\text{ где } \\mathbf{z}_{t-1}, \\mathbf{z}_{t-2}, \\dots \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}) \\\\\n&= \\sqrt{\\alpha_t}(\\sqrt{\\alpha}_{t - 1}x_{t - 2} + \\sqrt{1 - \\alpha_{t - 1}}\\mathbf{z}_{t - 2})  + \\sqrt{1 - \\alpha_t} \\mathbf{z}_{t-1} \\\\\n&= \\sqrt{\\alpha_t \\alpha_{t-1}} \\mathbf{x}_{t-2} + \\sqrt{1 - \\alpha_t \\alpha_{t-1}} \\bar{\\mathbf{z}}_{t-2}; \\text{ где } \\bar{\\mathbf{z}}_{t-2} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}) \\ \\ {(*)} \\\\\n&= \\dots \\\\\n&= \\sqrt{\\bar{\\alpha}_t}\\mathbf{x}_0 + \\sqrt{1 - \\bar{\\alpha}_t}\\mathbf{z} \\\\\nq(\\mathbf{x}_t \\vert \\mathbf{x}_0) &= \\mathcal{N}(\\mathbf{x}_t; \\sqrt{\\bar{\\alpha}_t} \\mathbf{x}_0, (1 - \\bar{\\alpha}_t)\\mathbf{I})\n\\end{aligned}\n$$\n    \n(*) Пояснение ко второму переходу. У нас выходит\n\n$$\n\\sqrt{\\alpha_t(1 - \\alpha_{t - 1})}z_{t - 2} + \\sqrt{1 - \\alpha_t}z_{t - 1} \\\\ = \\sqrt{\\alpha_t(1 - \\alpha_{t - 1}) + (1 - \\alpha_t)}\\bar{z}_{t- 2} \\\\ = \\sqrt{1 - \\alpha_t\\alpha_{t - 1}}\\bar{z}_{t - 2}; \\text{ где } z_{t - 1},z_{t - 2},\\bar{z}_{t - 2} \\sim \\mathcal{N}(0, I)\n$$\n\nТогда $L_{VLB}$ может быть переписано как\n\n$$\nL_{VLB} = \\mathbb{E}_q [\\underbrace{D_\\text{KL}(q(\\mathbf{x}_T \\vert \n\\mathbf{x}_0) \\parallel p_\\theta(\\mathbf{x}_T))}_{L_T} + + \\sum_{t=2}^T \n\\underbrace{D_\\text{KL}(q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \n\\mathbf{x}_0) \\parallel p_\\theta(\\mathbf{x}_{t-1} \n\\vert\\mathbf{x}_t))}_{L_{t-1}} \\underbrace{- \\log p_\\theta(\\mathbf{x}_0 \n\\vert \\mathbf{x}_1)}_{L_0}\n$$\n\n- Долгий вывод\n    \nСерым в скобках комментарий к последующему переходу.\n\n$$\n\\begin{aligned}L_\\text{VLB} &= \\mathbb{E}_{q(\\mathbf{x}_{0:T})} \\Big[ \\log\\frac{q(\\mathbf{x}_{1:T}\\vert\\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{0:T})} \\Big] \\quad \\textit{\\color{gray}{(расписываем совместное распределение)}}\\\\&= \\mathbb{E}_q \\Big[ \\log\\frac{\\prod_{t=1}^T q(\\mathbf{x}_t\\vert\\mathbf{x}_{t-1})}{ p_\\theta(\\mathbf{x}_T) \\prod_{t=1}^T p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t) } \\Big] \\ \\ \\ \\textit{\\color{gray}{(берем логарифм)}} \\\\&= \\mathbb{E}_q \\Big[ -\\log p_\\theta(\\mathbf{x}_T) + \\sum_{t=1}^T \\log \\frac{q(\\mathbf{x}_t\\vert\\mathbf{x}_{t-1})}{p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t)} \\Big] \\textit{\\color{gray}{(отщепляем члены суммы)}} \\\\&= \\mathbb{E}_q \\Big[ -\\log p_\\theta(\\mathbf{x}_T) + \\sum_{t=2}^T \\log \\frac{q(\\mathbf{x}_t\\vert\\mathbf{x}_{t-1})}{p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t)} + \\log\\frac{q(\\mathbf{x}_1 \\vert \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_0 \\vert \\mathbf{x}_1)} \\Big] \\textit{\\color{gray}{(*)}}\\\\&= \\mathbb{E}_q \\Big[ -\\log p_\\theta(\\mathbf{x}_T) + \\sum_{t=2}^T \\log \\Big( \\frac{q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t)}\\cdot \\frac{q(\\mathbf{x}_t \\vert \\mathbf{x}_0)}{q(\\mathbf{x}_{t-1}\\vert\\mathbf{x}_0)} \\Big) + \\log \\frac{q(\\mathbf{x}_1 \\vert \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_0 \\vert \\mathbf{x}_1)} \\Big] \\textit{\\color{gray}{(лог произведения раскрываем)}}\\\\&= \\mathbb{E}_q \\Big[ -\\log p_\\theta(\\mathbf{x}_T) + \\sum_{t=2}^T \\log \\frac{q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t)} + \\sum_{t=2}^T \\log \\frac{q(\\mathbf{x}_t \\vert \\mathbf{x}_0)}{q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_0)} + \\log\\frac{q(\\mathbf{x}_1 \\vert \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_0 \\vert \\mathbf{x}_1)} \\Big] \\textit{\\color{gray}{(от второй суммы останется только 1ый и последний член)}} \\\\&= \\mathbb{E}_q \\Big[ -\\log p_\\theta(\\mathbf{x}_T) + \\sum_{t=2}^T \\log \\frac{q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t)} + \\log\\frac{q(\\mathbf{x}_T \\vert \\mathbf{x}_0)}{q(\\mathbf{x}_1 \\vert \\mathbf{x}_0)} + \\log \\frac{q(\\mathbf{x}_1 \\vert \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_0 \\vert \\mathbf{x}_1)} \\Big] \\textit{\\color{gray}{(комбинируем 1 и 3 член, 3 и 4 член)}}\\\\&= \\mathbb{E}_q \\Big[ \\log\\frac{q(\\mathbf{x}_T \\vert \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_T)} + \\sum_{t=2}^T \\log \\frac{q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0)}{p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t)} - \\log p_\\theta(\\mathbf{x}_0 \\vert \\mathbf{x}_1) \\Big] \\\\&= \\mathbb{E}_q [\\underbrace{D_\\text{KL}(q(\\mathbf{x}_T \\vert \\mathbf{x}_0) \\parallel p_\\theta(\\mathbf{x}_T))}_{L_T} + \\sum_{t=2}^T \\underbrace{D_\\text{KL}(q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0) \\parallel p_\\theta(\\mathbf{x}_{t-1} \\vert\\mathbf{x}_t))}_{L_{t-1}} \\underbrace{- \\log p_\\theta(\\mathbf{x}_0 \\vert \\mathbf{x}_1)}_{L_0} ]\\end{aligned}\n$$\n\nПояснение (*). Пользуемся тем, что у нас Марковский процесс, и теоремой Байеса: \n\n$$\nq(x_t | x_{t - 1}) = q(x_t|x_{t - 1}, x_0) = \\frac{q(x_{t - 1}| x_t, x_0)q(x_t | x_0)}{q(x_{t - 1}|x_0)}\n$$\n\nТаким образом во время обучения, на каждой итерации параллельно оптимизируются случайные член $L_t$ с помощью градиентного спуск (сэмлируем $t \\sim U\\{1,...,T\\}$). Поскольку все распределения нормальные, то KL между ними можно выписать в явной форме (см. ниже).\n\n- Формула KL между двумя нормальными\n    \n$$\n\\begin{split}        KL(\\mathcal{N}_1 \\ || \\ \\mathcal{N}_2) = \\frac{1}{2}\\bigg(Tr(\\Sigma^{-1}_2 \\Sigma_1) + (\\mu_2 - \\mu_1)^T \\Sigma^{-1}_2 (\\mu_2 - \\mu_1) + \\\\[1.5ex]        + \\ln \\frac{det(\\Sigma_2)}{det(\\Sigma_1)} - d \\bigg)    \\end{split}\n$$\n\nЕсли $\\Sigma_1 = \\sigma_1I, \\ \\Sigma_2 = \\sigma_2I$\n\n$$\n\\begin{split}        KL(\\mathcal{N}_1 \\ || \\ \\mathcal{N}_2) = \\frac{1}{2}\\bigg(\\frac{d\\sigma_1}{\\sigma_2} + \\frac{1}{\\sigma_2}\\|\\mu_2 - \\mu_1\\|^2 + \\\\[1.5ex]        + \\ln \\frac{\\sigma_2}{\\sigma_1}\\bigg)    \\end{split}\n$$\n\nОсталось только выписать $q(x_{t - 1}| x_t, x_0)$ . Мы знаем, поскольку у нас все распределения нормальные, то и $q(x_{t - 1}| x_t, x_0)$  будет нормальным.\n\nОбозначим\n\n$$\nq(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0) = \\mathcal{N}(\\mathbf{x}_{t-1}; \\color{blue}{\\tilde{\\boldsymbol{\\mu}}}(\\mathbf{x}_t, \\mathbf{x}_0), \\color{red}{\\tilde{\\beta}_t} \\mathbf{I}) \n$$\n\n- Вывод $q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0)$\n    \nПрименим формулу Байеса и распишем. Тут мы просто пытаемся понять, как будут выглядеть среднее и дисперсия, выделяя квадратичную форму в показателе экспоненты\n\n$$\nq(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0) = q(\\mathbf{x}_t \\vert \\mathbf{x}_{t-1}, \\mathbf{x}_0) \\frac{ q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_0) }{ q(\\mathbf{x}_t \\vert \\mathbf{x}_0) } \\propto \n$$\n\n$$\n  \\propto \\exp \\Big(-\\frac{1}{2} \\big(\\frac{(\\mathbf{x}_t - \\sqrt{\\alpha_t} \\mathbf{x}_{t-1})^2}{\\beta_t} + \\frac{(\\mathbf{x}_{t-1} - \\sqrt{\\bar{\\alpha}_{t-1}} \\mathbf{x}_0)^2}{1-\\bar{\\alpha}_{t-1}} - \\frac{(\\mathbf{x}_t - \\sqrt{\\bar{\\alpha}_t} \\mathbf{x}_0)^2}{1-\\bar{\\alpha}_t} \\big) \\Big) \n$$\n\n$$\n  = \\exp \\Big(-\\frac{1}{2} \\big(\\frac{\\mathbf{x}_t^2 - 2\\sqrt{\\alpha_t} \\mathbf{x}_t \\color{blue}{\\mathbf{x}_{t-1}} \\color{black}{+ \\alpha_t} \\color{red}{\\mathbf{x}_{t-1}^2} }{\\beta_t} + \\frac{ \\color{red}{\\mathbf{x}_{t-1}^2} \\color{black}{- 2 \\sqrt{\\bar{\\alpha}_{t-1}} \\mathbf{x}_0} \\color{blue}{\\mathbf{x}_{t-1}} \\color{black}{+ \\bar{\\alpha}_{t-1} \\mathbf{x}_0^2} }{1-\\bar{\\alpha}_{t-1}} - \\frac{(\\mathbf{x}_t - \\sqrt{\\bar{\\alpha}_t} \\mathbf{x}_0)^2}{1-\\bar{\\alpha}_t} \\big) \\Big)=  \n$$\n\n$$\n  = \\exp\\Big( -\\frac{1}{2} \\big( \\color{red}{(\\frac{\\alpha_t}{\\beta_t} + \\frac{1}{1 - \\bar{\\alpha}_{t-1}})} \\mathbf{x}_{t-1}^2 - \\color{blue}{(\\frac{2\\sqrt{\\alpha_t}}{\\beta_t} \\mathbf{x}_t+\\frac{2\\sqrt{\\bar{\\alpha}_{t-1}}}{1 - \\bar{\\alpha}_{t-1}} \\mathbf{x}_0)} \\mathbf{x}_{t-1} \\color{black}{ + C(\\mathbf{x}_t, \\mathbf{x}_0) \\big) \\Big)}\n$$\n    \nДалее перепишем красные и синие выражения в более красивой форме\n\n$$\n\\color{red}{\\tilde{\\beta}_t} = 1/(\\frac{\\alpha_t}{\\beta_t} + \\frac{1}{1 - \\bar{\\alpha}_{t-1}}) = 1/(\\frac{\\alpha_t - \\bar{\\alpha}_t + \\beta_t}{\\beta_t(1 - \\bar{\\alpha}_{t-1})}) = \\boxed{\\frac{1 - \\bar{\\alpha}_{t-1}}{1 - \\bar{\\alpha}_t} \\cdot \\beta_t} \n$$\n\n$$\n\\color{blue}{\\tilde{\\boldsymbol{\\mu}}_t (\\mathbf{x}_t, \\mathbf{x}_0)} = (\\frac{\\sqrt{\\alpha_t}}{\\beta_t} \\mathbf{x}_t + \\frac{\\sqrt{\\bar{\\alpha}_{t-1} }}{1 - \\bar{\\alpha}_{t-1}} \\mathbf{x}_0)/(\\frac{\\alpha_t}{\\beta_t} + \\frac{1}{1 - \\bar{\\alpha}_{t-1}}) \n$$\n\n$$\n  = (\\frac{\\sqrt{\\alpha_t}}{\\beta_t} \\mathbf{x}_t + \\frac{\\sqrt{\\bar{\\alpha}_{t-1} }}{1 - \\bar{\\alpha}_{t-1}} \\mathbf{x}_0)\\frac{1 - \\bar{\\alpha}_{t-1}}{1 - \\bar{\\alpha}_t} \\cdot \\beta_t \n$$\n\n$$\n  = \\boxed{\\frac{\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_{t-1})}{1 - \\bar{\\alpha}_t} \\mathbf{x}_t + \\frac{\\sqrt{\\bar{\\alpha}_{t-1}}\\beta_t}{1 - \\bar{\\alpha}_t} \\mathbf{x}_0}\n$$\n\n### Другой лосс. Предсказываем шум\n\nВ прошлой подсекции наша модель предсказывала среднее и дисперсию нормального распределения. Давайте зафиксируем $\\Sigma_{\\theta}(x_t, t) = \\sigma^2_tI$. Обычно берут $\\sigma^2_t = \\beta_t$ или $\\sigma^2_t = \\tilde{\\beta}_t = \\frac{1 - \\bar{\\alpha}_{t - 1}}{1 - \\bar{\\alpha}_t}\\beta_t.$  Тогда $L_{t - 1}$ из предыдущей секции можно переписать как\n\n$$\nL_{t} = \\mathbb{E}_q\\bigg[\\frac{1}{2\\sigma^2_t}\\|\\mu_{\\theta}(x_t, x_0) - \\tilde{\\mu}_t(x_t, x_0)\\|^2\\bigg] + const(\\theta)\n$$\n\nЭто первый момент, как меняется функционал, если мы не хотим предсказывать $\\Sigma_{\\theta}(x_t, t)$, а фиксируем её.\n\nТеперь вспомним, что  $q(x_t | x_0) = \\mathcal{N}(x_t;\\sqrt{\\bar{\\alpha}_t} x_0, (1-\\bar{\\alpha}_t)I)$, но благодаря тому, что у нас гауссовское распределение, это можно переписать в виде\n\n$$\nx_t(x_0, \\epsilon) = \\sqrt{\\bar{\\alpha}_t} x_0 +  \\sqrt{1-\\bar{\\alpha}_t}\\epsilon, \\ \\ \\ \\epsilon \\sim \\mathcal{N}(0, I)\n$$\n\nВыразим отсюда $x_0$ и получим, что $x_0 = \\frac{1}{\\sqrt{\\bar{\\alpha}_t}}(x_t - \\sqrt{1 - \\bar{\\alpha}_t}\\epsilon)$, тогда подставим это выражение в  формулу для $\\tilde{\\boldsymbol{\\mu}}(\\mathbf{x}_t, \\mathbf{x}_0)$ (из подсекции «Вывод $q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \\mathbf{x}_0)$») и получим\n\n$$\n\\tilde{\\boldsymbol{\\mu}}(\\mathbf{x}_t, \\mathbf{x}_0) = \\frac{1}{\\sqrt{\\alpha_t}}(x_t - \\frac{\\beta_t}{\\sqrt{1 - \\bar{\\alpha}_t}}\\epsilon) \n$$\n\nТеперь скажем, что наша модель будет предсказывать $\\epsilon$. И просто будем «подставлять» его в выражение для $\\tilde{\\mu}$ выше. Обозначим предсказание модели как $\\epsilon_{\\theta}(x_t, t)$ — предсказанный шум $\\epsilon$. Тогда лосс $L_t$ превратиться в\n\n$$\nL_t = \\mathbb{E}_{x_0, z}\\bigg[ \\frac{\\beta^2_t}{2\\alpha_t(1 - \\bar{\\alpha}_t )\\sigma^2_t}\\|\\epsilon - \\epsilon_{\\theta}(\\sqrt{\\bar{\\alpha}_t} x_0 +  (1-\\bar{\\alpha}_t)\\epsilon, t)\\|^2\\bigg]\n$$\n\nТем не менее лосс можно еще больше упростить и просто обучать с помощью MSE на $\\epsilon$.\n\n$$\nL^{simple}_t = \\mathbb{E}_{x_0, \\epsilon, t}\\bigg[ \\|\\epsilon - \\epsilon_{\\theta}(\\sqrt{\\bar{\\alpha}_t} x_0 +  (1-\\bar{\\alpha}_t)\\epsilon, t)\\|^2\\bigg]\n$$\n\nИтак, алгоритмы обучения и сэмплирования выглядят вот так (на картинке  $z:= \\epsilon$).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_cf1a3672e9_43c6fd4279.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Алгоритм обучения и сэмплирования диффузионной модели (Изображение взято из: <a href=\"https://arxiv.org/abs/2006.11239\">Ho et al. 2020)</a></p>\n  </figcaption>\n</figure>\n\nСтоит отметить, что важным недостатком диффузионных моделей является низкая скорость сэмплирования. Согласно [Song et al. 2020](https://arxiv.org/abs/2010.02502): «Требуется 20 часов на генерацию 50 тысяч картинок размера 32х32, используя DDPM, и меньше минуты, используя GAN» (Nvidia 2080 Ti GPU). Тем не менее, в данном направлении был достигнут значительный прогресс и в целом проблема медленного сэмплирования была частично решена: [Jiaming Song et al. (2021)](https://arxiv.org/abs/2010.02502), [Kong & Ping (2021)](https://openreview.net/pdf?id=agj4cdOfrAP), [Bond-Taylor et al. (2021)](https://arxiv.org/abs/2111.12701)\n\nДавайте зафиксируем, какие функции потерь можно использовать. Для всех них справедлив тот факт, что мы сэмплируем шаг равномерно во время обучение $t \\sim U\\{1,...,T\\})$ и оптимизируем соответствующий $L_{t}$.\n\n- Оптимизируя член из суммы $L_{VLB}$. Это KL дивергенция между двумя нормальными распределениями\n\n$$\nL_{VLB} = \\mathbb{E}_q \\underbrace{D_\\text{KL}(q(\\mathbf{x}_T \\vert \n\\mathbf{x}_0) \\parallel p_\\theta(\\mathbf{x}_T))}_{L_T} + + \\sum_{t=2}^T \n\\underbrace{D_\\text{KL}(q(\\mathbf{x}_{t-1} \\vert \\mathbf{x}_t, \n\\mathbf{x}_0) \\parallel p_\\theta(\\mathbf{x}_{t-1} \n\\vert\\mathbf{x}_t))}_{L_{t-1}} \\underbrace{- \\log p_\\theta(\\mathbf{x}_0 \n\\vert \\mathbf{x}_1)}_{L_0}\n$$\n\n- При фиксированной дисперсии $\\Sigma_{\\theta}$ можно оптимизировать взвешенную MSE между средними нормальных распределений\n\n$$\nL_{t} = \\mathbb{E}_q\\bigg[\\frac{1}{2\\sigma^2_t}\\|\\mu_{\\theta}(x_t, x_0) - \\tilde{\\mu}_t(x_t, x_0)\\|^2\\bigg] + const(\\theta)\n$$\n\n- При фиксированной дисперсии и при предсказании шума с помощью взвешенной MSE. Или просто MSE. $L^{simple}_t$ является **самым популярным** вариантом, который на практике дает лучшие результаты.\n\n$$\nL_t = \\mathbb{E}_{x_0, z}\\bigg[ \\frac{\\beta^2_t}{2\\alpha_t(1 - \\bar{\\alpha}_t )\\sigma^2_t}\\|\\epsilon - \\epsilon_{\\theta}(\\sqrt{\\bar{\\alpha}_t} x_0 +  (1-\\bar{\\alpha}_t)\\epsilon, t)\\|^2\\bigg] \\\\\nL^{simple}_t = \\mathbb{E}_{x_0, z}\\bigg[ \\|\\epsilon - \\epsilon_{\\theta}(\\sqrt{\\bar{\\alpha}_t} x_0 +  (1-\\bar{\\alpha}_t)\\epsilon, t)\\|^2\\bigg]\n$$\n\n### Выбор расписания $\\beta_t$\n\nРасписание является гиперпараметром, основными требованиями на который являются невозрастание $(\\beta_1 \\leq ... \\leq \\beta_T)$ и чтобы прямой процесс сходился к $\\mathcal{N}(0, I)$ в пределе по $T$. Второе может гарантироваться тем, что $\\bar{\\alpha}_t \\to 0$. Вспомним,\n\n$$\nq(x_t | x_0) = \\mathcal{N}(x_t;\\sqrt{\\bar{\\alpha}_t} x_0, (1-\\bar{\\alpha}_t)I)\n$$\n\nОднако на практике [оно](https://arxiv.org/abs/2006.11239) также проверяется, чтобы $D_{KL}(q(x_T | x_0) || \\mathcal{N}(0, I))$ было близко к 0.\n\nТакже стоит упомянуть, что обычно берут $T = 1000$. Но также важно помнить про требования выше, ведь расписание шума непосредственно зависит от $T$.\n\nЧаще всего используют линейное расписание, где $\\beta_1 = 10^{-4}, \\ \\beta_T = 0.02$.  У данных констант нет никакой мотивации, кроме той, которая описана выше. Они были предложены в [Ho et al. (2020)](https://arxiv.org/abs/2006.11239).\n\nВ [Nichol & Dhariwal (2021)](https://arxiv.org/abs/2102.09672) было предложено косинусное расписание, которое помогло диффузионным моделям достичь лучшего NLL (negative loglikelihood): \n\n$$\n\\beta_t = \\text{clip}(1-\\frac{\\bar{\\alpha}_t}{\\bar{\\alpha}_{t-1}}, 0.999) \\quad\\bar{\\alpha}_t = \\frac{f(t)}{f(0)}\\quad\\text{where }f(t)=\\cos\\Big(\\frac{t/T+s}{1+s}\\cdot\\frac{\\pi}{2}\\Big)\n$$\n\nАвторы обнаружили, что линейное расписание плохо работает на картинках 64х64 и меньше. А именно, последнии шаги прямого прохода были шумными и малоинформатиыными (просто зашумляем шум еще больше):\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_1_ef776c9292_19c00be1f3.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Пример зашумления картинки для линейного (сверху) и косинусного (снизу) расписания.\n  </figcaption>\n</figure>\n\nТакже они обнаружили, что если обучать модель с линейным расписанием только на 80% первых шагов, то модель не становится сильно хуже, что подтверждает неиформативность последних шагов. Далее, они подобрали расписание так, чтобы $\\sqrt{\\bar{\\alpha}_t}$ убывало линейно на большей части отрезка (от 0 до $T$) и почти не менялось рядом с 0 и $T$. Разницу в $\\sqrt{\\bar{\\alpha}}_t$ для разных расписаний можно увидеть на картинке ниже:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_21_b212322bde_2961396e17.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Изображение взято из <a href='https://arxiv.org/abs/2102.09672'>Nichol & Dhariwal, 2021</a></p>\n  </figcaption>\n</figure>\n\n- Детали\n    \nТакже они  ограничивают $\\beta_t$ числом 0.999, чтобы в конце процесса не было проблем с численной устойчивостью. Коэффициент $s$ используется, чтобы $\\beta_t$ не были слишком малы рядом с нулем. Он равен 0.008. Такое число было выбрано так, чтобы «$\\sqrt{\\beta_0}$ была немного меньше, чем размер бина одного пикселя, то есть $1/127.5$»\n\n### Classifier guidance\n\nВ [Nichol & Dhariwal (2021)](https://arxiv.org/pdf/2105.05233.pdf) был предложен метод условной генерации, который повышает качество генерируемых картинок, при этом уменьшая их разнообразие. Для этого предобучается «шумный» классификатор на зашумленных картинках, то есть $p_{\\phi}(y |x_t)$. Затем он используется во время сэмплирования, корректируя предсказанное среднее на $\\nabla_x \\log p_{\\phi}(y|x_t)$. В [Nichol & Dhariwal (2021)](https://arxiv.org/pdf/2105.05233.pdf) (Секция 4.1) показывают, что данная добавка позволяет превратить распределение $p_\\theta(x_{i-1}|x_{i})$ в $p_\\theta(x_{i-1}|x_{i}, y)$. Важно, что исходная диффузионная модель никак не меняется, что делает трюк еще более привлекательным.  Алгоритм сэмплирования можно видеть на картинке ниже. Коэффициент $s$ отвечает за силу guidance.\n\n- Мотивация\nУ генеративной модели GAN есть способ, который позволяет «балансировать» между разнообразием картинок и их качеством — *truncation trick.* Он заключается в сэмплировании латентного вектора [truncated normal distibution](https://en.wikipedia.org/wiki/Truncated_normal_distribution). Данный трюк был хорошо описан и исследован в статье про [BigGAN](https://arxiv.org/abs/1809.11096).  Поэтому в диффузионных моделях тоже хотелось бы иметь метод, который позволяет балансировать между качеством и разнообразием. Авторы предложили classifier guidance, сравнили его с *truncation trick* и показали, что их метод строго лучше.\n    \n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_3_217b177b1b_1a4dd17e55.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Изображение взято из <a href='https://arxiv.org/pdf/2105.05233.pdf'>Nichol & Dhariwal, 2021</a></p>\n  </figcaption>\n</figure>\n\n### Classifier-free guidance\n\n[Ho & Salimans (2021)](https://openreview.net/pdf?id=qw8AKxfYbI) предложили метод, в котором guidance достигается без использования дополнительной модели, поскольку это достаточно затратно. Для этого они обучали условную модель $\\epsilon_{\\theta}(x_t | y)$, у которой во время обучения реальная метка $y$ заменялась с какой-то фиксированной вероятностью (10%) на пустую метку ($y=\\emptyset$). Это по сути позволяет нам обучать безусловную модель $\\epsilon_{\\theta}(x_t)$ одновременно с условной $\\epsilon_{\\theta}(x_t | y)$Тогда во время сэмплирования делаем так, чтобы предсказание немного менялось в сторону $\\epsilon_{\\theta}(x_t | y)$, а именно:\n\n$$\n\\hat{\\epsilon}_{\\theta}(x_t | y) = \\epsilon_{\\theta}(x_t | \\emptyset) + s\\cdot(\\epsilon_{\\theta}(x_t | y) - \\epsilon_{\\theta}(x_t | \\emptyset))\n$$\n\nМотивация этой формулы следовала из формулы Байеса:\n\n$$\np(y | x_t) \\propto \\frac{p(x_t | y) }{p(x_t)} \\\\\n\\implies \\log p(y | x_t) \\propto \\log p(x_t | y) - \\log p(x_t) \\\\\n\\implies \\nabla_{x_t} \\log p(y | x_t) \\propto \\nabla_{x_t} \\log p(x_t | y) - \\nabla_{x_t} \\log p(x_t) \\\\\n\\implies \\nabla_{x_t} \\log p(y | x_t) \\propto \\epsilon(x_t | y) - \\epsilon(x_t)\n$$\n\nТогда мы можем просто подставить $\\nabla_{x_t} \\log p(y | x_t)$ в формулу для classifier guidance из предыдущей подсекции и получить желаемое равенство с точностью до коэффициента $s$.\n\n## Овервью ключевых работ на сегодняшний день\n\n- Jonathan Ho et al. [«Denoising diffusion probabilistic models.»](https://arxiv.org/abs/2006.11239) arxiv Preprint arxiv:2006.11239 (2020)\n\nОсновная работа, в которой диффузионные модели (Denoising Diffusion Probabilistic Models, DDPMs) были применены для генерации картинок. Параграф в основном построен на ней. \n\n- Jiaming Song et al. [«Denoising diffusion implicit models.»](https://arxiv.org/abs/2010.02502) arxiv Preprint arxiv:2010.02502 (2020)\n\nОдна из первых попыток ускорить генерацию объектов. Идея следущая: давайте изменим прямой диффузионный процесс так, чтобы используя предобученную DDPM, приближать новый обратный процесс за меньшее число шагов. \n\nЧтобы не обучать новую модель, нам нужен прямой диффузионный процесс, у которого будет такая же (суррогатная) функция потерь, а обратный процесс все еще останется Марковским. Оказалось, что существует целое семейство не-Марковских прямых процессов, удовлетворяющих этим требования. Это семейство имеет следующий вид: \n\n$$\nq_\\sigma (x_{1:T}|x_0):= q_\\sigma (x_{T}|x_0)\\prod_{t=2}^{T} q_\\sigma (x_{t-1}|x_t,x_0), \n$$\n\nгде $q_\\sigma (x_{T}|x_0)= \\mathcal{N}(\\sqrt{\\alpha_t}x_0, (1 - \\alpha_t)I)$ и для всех $t>1,$\n\n$$\nq_\\sigma (x_{t-1}|x_t,x_0)= \\mathcal{N}(\\sqrt{\\alpha_{t-1}}x_0+\\sqrt{1-\\alpha_{t-1}-\\sigma_t^2 }\\cdot\\frac{x_t-\\sqrt{\\alpha_{t}}x_0}{\\sqrt{1-\\alpha_t}},\\sigma_t^2 I)\n$$\n\nСреднее было выбрано так, чтобы $q_{\\sigma}(x_t | x_0) = \\mathcal{N}(\\sqrt{\\alpha_t}x_0, (1 - \\alpha_t)I)$ для всех $t$. (см. Лемму 1 в Приложении B к статье). То есть важно лишь то, чтобы маргинальное распределение $q_{\\sigma}(x_t | x_0)$ не менялось по сравнению с обычным Марковским случаем. Прямой процесс может быть получен с помощью теоремы Байеса:\n\n$$\nq_\\sigma (x_t|x_{t-1},x_0)=\\frac{q_\\sigma (x_{t-1}|x_t,x_0)q_\\sigma (x_t|x_0)}{q_\\sigma (x_{t-1}|x_0)}\n$$\n\nТут $\\sigma$ контролирует степень стохастичности прямого процесса. Можно заметить, что в отличии от исходного диффузионного процесса, предложенный прямой процесс больше не является Марковским, так как каждый $x_t$ теперь зависит и от $x_{t-1}$ и от $x_0$. Схематично, это можно изобразить как на картинке справа. (Слева исходный диффузионный процесс для сравнения)\n\n![Screen_Shot_2022_08_22_at_00_38_27_b822865ad2.webp](https://yastatic.net/s3/education-portal/media/Screen_Shot_2022_08_22_at_00_38_27_b822865ad2_d2336fed77.webp)\n\n- Заметка  \nАвторы обращают внимание, что функция потерь в DDPM зависит от $q(x_t|x_0)$, а не от $q(x_1{:}x_T | x_0)$ напрямую. Это означает, что нам нужно выбрать любой другой прямой диффузионный процесс, у которого $q(x_t|x_0)$ остались те же. \n\nДалее, мы можем переписать обратный процесс в данном виде:\n\n$$\nx_{t-1}=\\sqrt{\\alpha_{t-1}}\\;\\underbrace{\\frac{x_t-\\sqrt{1-\\alpha_{t}}\\epsilon_\\theta^{(t)}(x_t)}{\\sqrt{\\alpha_t}}}_{\"predicted\\:x_0\"}+\\underbrace{\\sqrt{1-\\alpha_{t-1}-\\sigma_t^2 }\\cdot \\epsilon_\\theta^{(t)}(x_t)}_{\"direction\\;pointing\\;to\\;x_t\"}+\\underbrace{\\sigma_t\\epsilon_t}_{random\\:noise}\n$$\n\nЗаметим, что при $\\sigma_t = \\sqrt{(1 - \\alpha_{t - 1})(1 - \\alpha_t)}\\sqrt{1 - \\alpha_t / \\alpha_{t - 1}}$ прямой процесс становится марковским, а обратный как у DDPM (обычное сэмплирование, описанное в основной секции). При $\\sigma_t = 0$ процесс сэмплирования становится детерминистичным (данный способ и называется DDIM). Ускорение сэмплирования достигается засчет использования лишь какого-то подмножества шагов ($0 \\leq \\tau_1 \\leq ... \\leq \\tau_S \\leq T, \\ \\ \\ S < T$). Также одним из плюсов детерминистичного сэмплирования является возможность делать семантическую интерполяцию в латентном пространстве (как у GANов). \n\n- Alex Nichol & Prafulla Dhariwal. [«Improved denoising diffusion probabilistic models»](https://arxiv.org/abs/2102.09672) arxiv Preprint arxiv:2102.09672 (2021)\n\nУлучшение DDPM, в котором был предложен новое расписание шума, что улучшило NLL. Также был изучен вариант, в котором дисперсия $\\Sigma_{\\theta}(x_t, t)$ предсказывается моделью.\n\n- Prafula Dhariwal & Alex Nichol. [«Diffusion Models Beat GANs on Image Synthesis.»](https://arxiv.org/abs/2105.05233) arxiv Preprint arxiv:2105.05233 (2021).\n\nСтатья, в которой показывается, что DDPM могут генерировать более качественные картинки по сравнению с GANами. Также был предложен метод conditional сэмплирования. Для этого предобучается классификатор на зашумленных сэмплах, а во время сэмплирования среднее нормального распределения «корректируется» на градиент классификатора.\n\n- Jacob Austin et al. [«Structured Denoising Diffusion Models in Discrete State-Spaces»](https://arxiv.org/abs/2107.03006).arXiv:2107.03006 (2021)\n\nДиффузионные модели на дискретных данных (например, текст). Вместо нормальных распределений используются категориальные. Также была обобщена [мультиномиальная диффузия](https://arxiv.org/abs/2102.05379) с помощью «матриц перехода», которые задают способ зашумления дискретных данных. \n\nБолее подробно: у нас есть $x_t \\in \\{1, ..., K\\}$ — дискретная величина на всех шагах диффузии, тогда для каждого шага $t$ определена **матрица прямого перехода $Q_t$** такая, что $[Q_t]_{ij} = q(x_t = j| x_{t - 1} = i)$. То есть строки матрицы суммируются в единицу. Тогда если обозначить через $\\mathbf{x}_t \\in \\mathbb{R}^K$ one-hot-закодированную версию $x_t$, то прямой процесс можно описать через категориальные распределения:\n\n$$\nq(\\mathbf{x}_t | \\mathbf{x}_{t -1}) = Cat(\\mathbf{x}_t; \\mathbf{p} = \\mathbf{x}_{t - 1}Q_t)\n$$\n\nКак и в нормальных распределениях, можем выписать \n\n$$\nq(\\mathbf{x}_t | \\mathbf{x}_{0}) = Cat(\\mathbf{x}_t; \\mathbf{p} = \\mathbf{x}_{0}\\bar{Q}_t), \\ \\ \\ где \\ \\ \\ \\bar{Q}_t=Q_1Q_2...Q_t  \n$$\n\n$$\nq(\\mathbf{x}_{t - 1}| \\mathbf{x}_t, \\mathbf{x}_0) = Cat(\\mathbf{x}_{t - 1}; \\mathbf{p} = \\frac{\\mathbf{x}_{t}{Q}^T_t \\odot \\mathbf{x}_0\\bar{Q}_{t-1}}{\\mathbf{x}_0\\bar{Q}_t\\mathbf{x}^T_t})\n$$\n\nПоскольку тут нет такой хорошей параметризации через $\\epsilon$, как у нормальных распределений, то единственный способ обучать — с помощью KL дивергенции  (членами$L_{VLB}$). \n\nОстается только понять, как выбирать $Q_t$. Помимо того, чтобы сумма в каждой строчке была один, требуется, чтобы $\\bar{Q}_t$ сходилось (при $t \\to \\infty$) к равномерному распределению в каждой строчке (аналог нормального шума). За конкретными примерами стоит обратиться к статье. \n\n- Серия работ про text-conditional diffusions: [GLIDE](https://arxiv.org/pdf/2112.10741.pdf), [ImaGen](https://arxiv.org/pdf/2205.11487.pdf), [DALLE-2](https://cdn.openai.com/papers/dall-e-2.pdf)\n\nОпишем работу метода GLIDE. Стоит задача генерировать картинки по заданному текстовому описанию. Для этого используется classifier-free guided diffusion model или [CLIP](https://openai.com/blog/clip/). Это два разных варианта модели, которые авторы сравнивают. В первом случае модель обуславливается на эмбеддинги текста, которые были получены из обучаемого трансформера. Во втором случае guidance осуществляется за счет $\\nabla_{x_t} \\langle f(x_t), g(c) \\rangle$ (это по сути градиент лосса метода CLIP) . Тут $f$ — это картиночный энкодер (на зашумленных картинках), а $g$ — это  энкодер текстового входа. В целом, авторы получили, что classifier-free guidance генерирует более качественные картинки.\n\n- Song et al. [«Score-Based Generative Modeling through Stochastic Differential Equations»](https://openreview.net/forum?id=PxTIG12RRHS)\n\nСпособ описать диффузионные модели через стохастические дифференциальные уравнения.\n\n- [What are Diffusion Models?](https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#reverse-diffusion-process). Прекрасный блог от Lilian Weng (OpenAI).",
        "handbook": "Учебник по машинному обучению",
        "title": "Диффузионные модели",
        "description": null
    },
    {
        "path": "/handbook/ml/article/yazykovye-modeli",
        "content": "В 2023 году ChatGPT стал самой узнаваемой языковой моделью машинного обучения во всём мире — причём как среди специалистов, так и среди обычных людей.\n\nСпособность вести осмысленный диалог, отвечать на практически любые вопросы и быть применимыми без дообучения в большом спектре задач с высоким качеством — вот залог их  популярности.\n\nВ этом параграфе мы расскажем, что такое языковые модели, как они устроены, как развивались, а также как изменились за последнее время.\n\n## Что такое языковые модели?\n\nГоворя простым языком, языковые модели — это алгоритмы, способные продолжать тексты. Если чуть усложнить, то это [вероятностные алгоритмы](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D1%80%D0%BE%D1%8F%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC), и к ним сразу можно задать эмпирический критерий качества: хорошая модель даёт разумные продолжения данных ей текстов.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_28_f05133b534_16ab8022ff.svg)\n\nДавайте разберём пример выше.\n\nМодель высчитывает вероятность возможных продолжений текста и предлагает их нам. Слово «фрукт» — наименее разумное продолжение нашей фразы, в то время как слово «наука» — наиболее разумное. И действительно, это часть определения машинного обучения, которое мы давали в начале этого учебника.\n\nТаким образом, нам осталось лишь научить алгоритм моделировать эти вероятности и максимизировать их для разумных предложений. Но как это сделать? По ходу развития языковых моделей подходы менялись, мы расскажем о каждом из них в хронологическом порядке.\n\nНачнём с краткого экскурса в историю — поговорим о статистических моделях, рекуррентных нейронных сетях и трансформерах. А затем перейдём к современным — GPT-1, GPT-2, GPT-3, InstructGPT, ChatGPT и LLaMa.\n\n## Развитие языковых моделей\n\n### Статистические модели\n\nИдея модели лежит на поверхности, много где применяется в самых разных вариациях даже в ХХ веке, поэтому сложно назвать авторов или точную дату создания. Однако этот метод популярен до сих пор — используется в клавиатурах смартфонов для исправления опечаток и быстрого набора текстов через Т9.\n\nТеперь подробнее о методе.\n\nНапомним вероятностную формулировку цепей Маркова в общем виде:\n\n$$P(w_1,w_2, ..., w_N) = P(w_N | w_1,w_2, ..., w_{N - 1}) \\times P(w_1,w_2, ..., w_{N - 1}) = P(w_N | w_1,w_2, ..., w_{N - 1}) \\times P(w_{N-1} | w_1,w_2, ..., w_{N - 2}) \\times ... \\times P(w_2| w_1) \\times P(w_1)\n$$\n\nЕсли представить, что $w_i$  — это слово, а набор этих омега — это предложение, то по формуле становится возможным посчитать вероятность предложения $w_1, w_2, ..., w_N$ С практической точки зрения всё чуть сложнее, ведь распределение слов в реальном языке (какое, с какими и как часто встречается), вообще говоря, неизвестно.\n\nЕго принято аппроксимировать на основе **корпуса текстов** (например, всего интернета) — в этом случае считаются совстречаемости слов друг с другом, и по ним считаются вероятности.\n\nВ условной вероятности число переменных, от которых зависит распределение следующего слова, называется контекстом. Например, в выражении $P(w_N | w_1,w_2, ..., w_{N - 1})$ длина контекста равна $N - 1$. На практике же редко считают вероятности с контекстом больше трёх, на это есть несколько причин:\n\n1. Сложность в подсчёте и хранении каждого возможного уникального контекста длины $K$. Если корпус текстов состоит из $N$  различных слов, то стоимость хранения счётчиков встречаемости для выбранной длины контекста равна $N^K$, что очень много при больших $K$.\n2. Большой контекст реже встречается. То есть слова «яблоку», «негде» и «упасть» поодиночке встречаются чаще, чем их комбинация «яблоку негде упасть». Отсюда достаточность статистик падает с ростом длины контекста.\n\nВ учебном примере предлагается ограничиться шириной контекста размера 1:\n\n$$P(w_1,w_2, ..., w_N) = P(w_N | w_{N - 1}) \\times P(w_{N-1} | w_{N - 2}) \\times ... \\times P(w_2| w_1) \\times P(w_1)\n$$\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_26_ee99363b0b_e7ae9384f8.svg)\n\nИнтересно, что такой подход достаточно популярен до сих пор. Например, он используется в умных клавиатурах, чтобы подсказать следующее слово.\n\n**Достоинства статистических моделей:**\n\n- Простота имплементации.\n- Высокая скорость работы алгоритма.\n- Низкая вычислительная стоимость обучения и инференса.\n\n**Недостатки статистических моделей:**\n\n- Не сможет сгенерировать слова, которые не шли подряд в обучающем корпусе.\n- Очень маленький контекст.\n- Длинные последовательности равновероятны ≈ нулю (в цепях Маркова для длинных последовательностей много множителей меньше нуля, поэтому их произведение уже практически равно нулю для любых множителей). Отсюда алгоритм не может выдавать разумные продолжения большой длины.\n\n### Токенизация\n\nЯзыковые модели, да и вообще все модели, которые оперируют текстом, используют понятие токена. Токен — это единица текста, которую понимают алгоритмы. В примере выше токен&nbsp;— это отдельное слово $w_i$ (этот подход называется [мешком слов](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%88%D0%BE%D0%BA_%D1%81%D0%BB%D0%BE%D0%B2)), однако текст можно разбивать на токены и иначе.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_29_6f0ec76380_52cf81559a.svg)\n\nРаньше предложение разбивалось на слова по пробелам, знакам препинания, исключались стоп-слова и так далее (назовем это [CountVectorizer](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html)). Но у этого подхода возникали две проблемы с разными словоформами. Они:\n\n- Либо обозначались разными токенами,&nbsp;что не совсем верно, ведь слово-то одно и то же. И получалось, что похожим смыслом обладало сразу несколько токенов.\n- Либо приводились к начальной форме — и в итоге терялся падеж, время, число.\n\nСовременные токенизаторы построены на алгоритме BPE (Byte Pair Encoding; об устройстве BPE более подробно можно прочитать в&nbsp;[учебнике Лены Войта](https://lena-voita.github.io/nlp_course/seq2seq_and_attention.html#bpe)). Решение требует фиксации определённого числа токенов. Как только это сделано, в словарь добавляются все символы из текста, ищутся самые частые их сочетания и снова добавляются. Этот процесс продолжается до тех пор, пока число токенов не станет равно заданному значению.\n\nТокенизатор SentencePiece в определённом смысле совершеннее, чем BPE, — он наследует логику Unigram- и BPE-токенизаторов, иначе работает с пробелами (добавляет `_`  перед соответствующим токеном) и не построен на логике разбиения слов по разделителям.\n\nПоэтому, в отличие от BPE, он способен работать с такими языками, как японский или китайский. Подробнее о его устройстве можно прочитать [здесь](https://arxiv.org/pdf/1808.06226.pdf).\n\n<aside>\n💡 Токенизаторы не разделяют входной поток по значимости. Например, число 12345 BPE могут разбить на два токена — 1 и 2345, что явно не соответствует логике написанного выражения. Также они будут неправильно выделять всё число в отдельный токен, так как чисел бесконечное количество. Сейчас используется идея о разбиении всех чисел на цифры, чтобы множеством из десяти токенов представить всё многообразие чисел.\n\n</aside>\n\n### Рекуррентные нейронные сети (RNN)\n\nПоявились после статистических моделей, подробнее о хронологии [здесь](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%B0%D1%8F_%D0%BD%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C). Рекуррентные нейронные сети концептуально можно описать формулой, где:\n\n$А$ — некоторая модель;\n\n$h_t$  — внутреннее состояние модели на момент времени $t$;\n\n$x_t$ — токен, который сейчас обрабатывается.\n\nТогда следующий токен $x_{t+1}$ получается так:\n\n$$x_{t+1} = g(h_{t}); \\space h_{t} = A(h_{t-1}, x_t)\n$$\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_8_5b50b2cae3_8b1196ece9.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://colah.github.io/posts/2015-08-Understanding-LSTMs/\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nПодробно об устройстве RNN мы рассказываем в параграфе [Нейросети для работы с последовательностями](https://academy.yandex.ru/handbook/ml/article/nejroseti-dlya-raboty-s-posledovatelnostyami). Здесь же коротко отметим, что существуют различные модификации рекуррентных сетей, которые усложняют структуру алгоритма $А$, даже добавляют механизм внимания Attention. Если коротко, то он позволяет лучше оценивать взаимосвязи токенов в тексте. Все они в разной степени помогают модели усваивать более длинные и сложные последовательности токенов.\n\n**Достоинства RNN:**\n\n- Высокая скорость инференса и сравнительно низкая стоимость.\n- Более качественный текст, чем у моделей на статистиках.\n- Теоретически понимает контекст в сотни слов (а с Attention ещё больше).\n- Точно учитывает весь контекст документа.\n\n**Недостатки RNN:**\n\n- Невозможность параллельного обучения на многих устройствах, отсюда не получится просто так обучить большую RNN.\n- Модель «хорошо помнит» лишь несколько последних токенов контекста (без Attention).\n- Проблемы с обучением (exploading/vanishing gradients).\n\n## Трансформеры\n\nБолее подробно трансформеры и их устройство описаны в параграфе [Трансформеры](https://academy.yandex.ru/handbook/ml/article/transformery). Последней и наиболее успешной с точки зрения качества оказалась архитектура трансформеров. Она состоит из двух частей: encoder (на изображении слева) и decoder (на изображении справа).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_4_7ec4e62ad5_01f8318233.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/1706.03762\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nИзначально был популярен подход обучать части отдельно. Так на базе encoder-блоков были построены [BERT-модели](https://en.wikipedia.org/wiki/BERT_\\(language_model\\)). Идея обучения звучит несложно: давайте из входного текста замаскируем токеном [MASK](https://academy.yandex.ru/handbook/ml/article/transformery) 15% имеющихся токенов и обучим модель угадывать, какие именно токены были скрыты. Тогда, если модель обучится это делать, она сможет очень хорошо понимать текст.\n\nТаким образом, энкодеры обладают следующими особенностями:\n\n- Анализируют входной текст и связи между токенами.\n- Выделяют важные токены для определённой задачи.\n- Ничего не генерируют.\n\nНа базе декодеров сделаны GPT-модели. Они обучаются предсказывать следующий токен на основе предыдущих. На инференсе, когда очередной токен сгенерирован, он добавляется в контекст, и уже на основе него выбирается новый токен. Таким образом модель:\n\n- генерирует токен за токеном.\n- смотрит на весь контекст, архитектурно, нет забывания токенов.\n- имеет возможность (как и BERT-модели) обучаться параллельно.\n- обладает достаточно высокой вычислительной стоимостью инференса.\n\n<aside>\n💡 Контекст в случае трансформеров определяется числом токенов, которые они могут обработать за раз. Архитектурно за понимание контекста отвечает блок Attention, и размеры матриц в нём как раз определяют размер контекста. \n\nРазмер матриц конечен: чем они больше, тем сложнее вычислять блок внимания, поэтому контекст существенно ограничен. На момент написания параграфа разработаны различные модификации Attention, позволяющие растить понимаемый контекст, однако они имеют ряд проблем, с которыми предлагаем ознакомиться читателю [самостоятельно](https://arxiv.org/abs/2303.09752).\n\n</aside>\n\n## Современные подходы\n\n### GPT-1 & GPT-2\n\nНачнём немного издалека, с моделей GPT-1 и GPT-2.\n\nПервая была обучена в 2018 году на 7000 книг и имела размер контекста в 512 токенов. И она сразу получилась довольно сильной: после дообучения на специализированные задачи (бенчмарки) показывала на них лучшее на то время качество.\n\nТак, в задачах CoLA (бенчмарк классификационный, в нём надо определить грамматическую корректность предложения) результат вырос до 45,4 против прежнего результата в 35,0 у RNN. А в [GLUE](https://gluebenchmark.com) — с 72,8 до 68,9.\n\nВторая модель была обучена в 2019 году. Она состояла из рекордных для того времени 1,5 млрд параметров (то есть была в \\~10 раз больше первой), имела контекст в 1024 токена и была обучена на 40 ГБ текстовых данных. GPT-2 снова побеждала предыдущие подходы, включая GPT-1, на многих [бенчмарках](https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf).\n\nПо сравнению с первой версией модели у второй произошел качественный рост: теперь она могла генерировать разумные тексты — а не только предложения. Правда, не всегда и не с первой попытки.\n\n### GPT-3\n\nGPT-3 стала революцией с точки зрения качества и размеров. В 2020 году была получена модель размером в 175 млрд параметров, она обучалась на 570 ГБ текстовых данных с контекстом в 2048 токенов. Модель [могла](https://arxiv.org/abs/2005.14165) решать целый спектр задач, включая перевод, суммаризацию и ответы на вопросы, с качеством, близким к человеческому уровню, а также отличалась высокой способностью генерировать креативный контент. Демонстрацию работы модели лучше посмотреть в [этой статье](https://arxiv.org/pdf/2005.14165.pdf) на 28 странице и далее.\n\n#|\n||\n\nМодель\n\n|\n\nЧисло обучающих данных\n\n|\n\nКонтекст\n\n|\n\nЧисло параметров\n\n|\n\nDecoder-слои\n\n|\n\nHidden-size (размерность тензоров внутри модели)\n\n|\n\nTrain batchsize (размер батча при обучении)\n\n||\n||\n\nGPT\n\n|\n\n7000 книг\n\n|\n\n512\n\n|\n\n117 млн\n\n|\n\n12\n\n|\n\n768\n\n|\n\n64\n\n||\n||\n\nGPT-2\n\n|\n\n40 ГБ текстовых данных\n\n|\n\n1024\n\n|\n\n1,5 млрд\n\n|\n\n48\n\n|\n\n1600\n\n|\n\n512\n\n||\n||\n\nGPT-3\n\n|\n\n570 ГБ текстовых данных\n\n|\n\n2048\n\n|\n\n175 млрд\n\n|\n\n96\n\n|\n\n12 288\n\n|\n\n3 200 000\n\n||\n|#\n\nМодель демонстрировала действительно впечатляющие результаты: собрав обучающие данные, можно было с высоким качеством решить практически любую текстовую задачу.\n\nОднако для применения таких решений остаётся проблема со стоимостью их обучения. Для обучения GPT-2 авторы использовали 16 GPU (иначе говоря —&nbsp;графических процессоров, видеокарт), а для GPT-3 уже 3200. Для дообучения модели под определенную задачу, конечно, понадобится меньше ресурсов, но всё равно достаточно много.\n\nЧто с этим делать? Использовать подводки.\n\n## Подводки\n\n### Few-shot обучение\n\nОказывается, что обучать большие языковые модели решать определённые задачи не всегда нужно (как мы говорили ранее, это ресурсоёмко): можно составить `few-shot` подводку. Подводка — словесное описание поставленной задачи, составленное определенным образом.\n\nПредставим, что мы хотим осуществить перевод с английского на французский. Для обучения нам необходимо было бы составить пары $(X,y)$, где $X$ — слово на английском, а $y$ — на французском. Сделаем иначе — опишем задание на естественном языке:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_5_5954076cc1_9266fdd720.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2005.14165.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nЗдесь на английском языке сформулировано задание и предлагается слово «cheese» перевести на французский. Назовем такую конструкцию `zero-shot`-примером. Такой запрос GPT-3, возможно, поймёт, но работать будет плохо.\n\nДавайте увеличим количество примеров в подводке и назовем эту конструкцию `one-shot`:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_6_c4d7ff5bbe_7d9177e227.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2005.14165.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nИли больше, и это будет `few-shot`:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_7_f46df68173_5889d09b18.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2005.14165.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nПри этом приёме не тратятся ресурсы на обучение модели, она лишь смотрит на контекст и генерирует продолжение. Оказывается, этого достаточно, чтобы сравняться с downstream-обучением. Продемонстрируем преимущество такого подхода на двух бенчмарках.\n\n- TriviaQA — вопросно-ответный бенчмарк, составленный на основе Википедии. Он помогает оценивать знания модели и ее ответы на вопросы.\n- Lambada — оценивает меморизацию длинного контекста модели. Чем выше скор, тем лучше модель на обоих бенчмарках.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_15_d87b0ec3d3_709e99da30.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://yastatic.net/s3/education-portal/media/Artboard_16_5f093e4e0e_89accafbce.svg\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_9_775c9a32b8_86cc9fc37b.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2005.14165.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nГрафики выше демонстрируют несколько особенностей:\n\n- `Few-shot` позволяет получать качество, сравнимое с дообучением на определённом датасете, и стремится к человеческому качеству.\n- С ростом числа обучаемых параметров модели растет её качество.\n- На правом графике `few-shot`-примеры начинают работать лучше `zero-shot`-примеров лишь с некоторого размера модели. Это говорит о том, что модель начинает демонстрировать «умные» свойства лишь начиная с некоторого размера.\n\n<aside>\n💡 На самом деле последний пункт достаточно часто встречается в языковых моделях. Случается так, что определённые приёмы не работают с маленькими моделями, но показывают себя лишь на больших. \n\nЭто можно назвать фазовым переходом, когда языковая модель вместе с увеличением размера и числа пройденных текстов на обучении обретает б**о**льшую обобщающую способность.\n\n</aside>\n\n### Формулировка имеет значение\n\n`Few-shot` действительно полезен и помогает получать от модели нужный результат без обучения, но всё же недостаточно хорошо.\n\nПредположим, мы хотим узнать у модели, как приготовить любимое блюдо. Пусть это будет лазанья:\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_25_e3e34eb28f_affbc5f625.svg)\n\nМожно заметить, что запрос к модели можно задать по-разному, но ответ ожидается обычно какой-то конкретный. Авторы [этой статьи](https://arxiv.org/pdf/2102.09690.pdf) заметили, что сама по себе конструкция `few-shot`-примера не приводит к стабильному результату. Качество решения задачи очень зависит от:\n\n1. Текстового описания задачи.\n2. Числа примеров в подводке.\n3. Порядка, в котором примеры следуют друг за другом в подводке.\n4. Формате составления `few-shot`.\n\nЧтобы улучшить качество решения задачи, авторы предлагают осуществлять калибровку подводок. В статье они заметили, что модели смещены относительно подводок, то есть переформулировка запроса ведёт к смещению в ответе модели, а также к росту разброса ответов.\n\nНапример, модели задают вопрос и её задача — ответить «да» или «нет». Если `few-shot` состоит из четырёх примеров и они идут в порядке «да», «да», «нет»,  «нет», то, вероятнее всего, дальше модель ответит «нет» на любой вход, просто потому что слово «нет» встречалось последним.\n\nКалибровать модель предлагается с помощью выученного линейного преобразования:\n\n$$\\hat{q} = softmax(W\\hat{p} + b)\n$$\n\nВ этом преобразовании:\n\n$W$ и $b$ — обучаемые;\n\n$\\hat{p}$ — вероятности на выходе модели;\n\n$\\hat{q}$ — откалиброванные вероятности;\n\nОбучающие данные собираются так:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_11_baded546e5_7f0910407f.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2102.09690.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nДля различных задач собираем подводки и добавляем нейтральное слово N/A. В этом примере несмещённая модель должна давать с вероятностью 50% ответ «positive» или «negative».\n\nЧтобы добиться такого распределения ответов у смещённой модели, представим:\n\n$$W = diag(\\hat{p})^{-1}, \\space b = 0\n$$\n\nТакже все `few-shot`-примеры стандартизуются в специальный формат вопрос — ответ, как на картинке выше.\n\nЭтот метод (синий график) по сравнению со стандартными `few-shot`-примерами (красный график) помог повысить качество и уменьшить разброс результата. Таким образом, оптимизировав всего 4 параметра, авторы существенно улучшили итоговый результат.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_17_9383aa3031_8186a854cf.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2102.09690.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n### Promt-tuning\n\nКачество работы модели зависит от подводки, и `few-shot` просто один из способов её построения. Эксперименты показывают, что грамотный подбор промта позволяет экономить на обучении и решать задачи с высоким качеством. Проблема в обучении больших моделей — нехватка оперативной памяти на GPU, поэтому не будем оптимизировать все параметры модели.\n\nПусть необходимо решить задачу $А$, к ней имеется обучающее множество вида $(X,y)$. Введём дополнительные токены, которых не было в словаре: $<P_1>, <P_2>, … , <P_k>$ — и будем добавлять в каждый текст из X согласно какому-то правилу.\n\nПравило может быть таким: имеем 20 спецтокенов, добавим токены 1–10 в начало строки, а 11–20 в конец.\n\nТогда, можно «заморозить» все параметры в модели, кроме этих токенов, и сэкономить на обучении. Если токенов 100 и каждый из них имеет размерность в 1024, то необходимо [оптимизировать](https://aclanthology.org/2021.emnlp-main.243.pdf) лишь 100 тысяч параметров вместо 175 млрд в случае обучения всей модели.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_20_510dffa69e_dc695b3dc6.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://habr.com/ru/companies/sberdevices/articles/596103/\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n<aside>\n💡 Эффект от такого трюка достаточно многогранен:\n\n1. Меньше обучаемых параметров — меньше памяти занимает модель.\n2. Меньше обучаемых параметров — быстрее происходит обучение.\n3. Обычно нужно сильно меньше обучающих данных, чем при традиционном обучении всей модели для достижения высокого качества.\n4. Высокое качество результата.\n\n</aside>\n\nПолучается, что можно оптимизировать подводку, или, другими словами, находить наиболее оптимальный промт, который лучше прочих решает поставленную задачу.\n\n### Как повысить качество решения задач из разных категорий\n\nЯзыковые модели призваны решать самый широкий спектр текстовых задач — вопросно-ответные, суммаризацию, диалоговость, перевод и многие другие.\n\nПолучается, что модель должна после некого обучения (подбора подводки или оптимизации вообще всех параметров под каждую задачу) решать каждую из них на высоком уровне. Однако модель обычно учится на текстах из интернета, книгах и других доступных ресурcах. И формат задачи, который обычно требуется от модели, не соответсвует тому, что алгоритм привык видеть на обучении. К этому стоит добавить, что среди веб-документов просьба что-то сократить или определить тональность документа встречается не очень часто.\n\nИсправить этот недостаток призваны подходы по генерализации языковых моделей: [FLAN](https://arxiv.org/abs/2109.01652) и [T0](https://arxiv.org/pdf/2110.08207.pdf). Инструкции даются на естественном языке и для подготовки качественного обучающего множества предлагается произвести следующие действия:\n\n- Каждой отдельной задаче (будь то перевод, написание отзывов или суммаризация) пишется по несколько различных подводок, отражающих смысл задания.\n- Итоговый датасет составляется из отдельных задач, все строчки датасета перемешиваются случайным образом.\n- Авторы стараются собрать как можно более разнообразные задачи в обучающее множество.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/image_c59be1810f_9c218e10c8.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2109.01652.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_15_cf6d62ddc7_86774d99a6.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2110.08207.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_14_a891eaf1bb_7e62044341.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2109.01652.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nДве картинки сверху демонстрируют FLAN- и T0- подходы по созданию датасета, а картинка снизу — рост усреднённого качества модели после обучения на смеси. Таким образом с некоторого размера модели наблюдается повышение метрик качества при дальнейших дообучениях генерализованной модели на отложенных задачах.\n\n### Chain-of-Thought\n\nПредыдущий подход со смесью датасетов помогает решать многие задачи в среднем заметно лучше. Однако есть задачи, где качество результатов модели всё ещё низкое. Например, предложить эффективный код, решающий некую алгоритмическую задачу, найти минимум некоторой аналитической функции потерь, посчитать производную фукнции в точке и так далее.\n\nТакие вопросы требуют рассуждения, которое модель не может просто так провести из-за своей архитектуры. Выход — составить подводки в стиле `Chain-of-Thought (CoT)`**:**\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_17_6d70a2cc66_1d6ba81a5b.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2201.11903.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n`CoT`-подводка состоит из трёх обязательных элементов:\n\n- Формулировки задачи на естественном языке.\n- Подробного пошагового решения.\n- Ответа на задачу.\n\nФормирование такого промта, особенно на `few-shot`, заставляет модель рассуждать, как можно правильно решить задачу. Авторы [этой статьи](https://arxiv.org/pdf/2201.11903.pdf) сравнили на двух математических бенчмарках способность модели решать сложные задачи.\n\n- MultiArith — проверяет умение решать простые арифметически задачки.\n- GSM8K — более сложные.\n\nРезультаты демонстрируют, что наличие `CoT` в подводке увеличивает способность решать математические задачки у больших языковых моделей.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_27_cc8f312f50_1540104611.svg)\n\n## InstructGPT\n\nНаконец, обсудив, как готовить обучающие данные, перейдем к прародителю ChatGPT. Инструкционная модель — это та, которая обучена отвечать на пользовательские запросы в режиме `zero-shot` (а вообще, и `few-shot`, и любой человекочитаемый формат) с высоким качеством.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Untitled_19_a92859782e_e98ea7dd76.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/abs/2203.02155\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\nInstructGPT — это модель, и она интересна с точки зрения выработки концепции обучения всех инструкционных моделей (InstructGPT, ChatGPT, GPT-4 и других). С некоторыми нюансами обучение состоит из четырех этапов:\n\n1. Подготовка качественного претрейна. Языковая модель должна содержать в себе как можно больше знаний о мире, чтобы иметь возможность в последующем решать произвольные задачи с высоким качеством. На этом этапе необходимо озаботиться наибольшим разнообразием, чистотой и полнотой обучающих данных. Подробнее об этом мы поговорим в последнем разделе этого параграфа.\n2. SFT (supervised finetuning) — обучение модели следовать инструкциям. Этот пункт мы подробно обсудили в предыдущей части параграфа (T0, FLAN, CoT). На этом этапе важно составить грамотный инструкционный датасет, где инструкция содержит произвольные запросы к модели, а ответ на неё — подробный текст, которым будущий пользователь будет доволен. Грамотный сбор таких данных довольно дорогостоящий процесс, но от него напрямую зависит, каким образом модель будет взаимодействовать с пользователем.\n3. Обучение reward-модели. Каждый ответ алгоритма можно оценить с точки зрения вежливости, подробности или персонажности. Персонажность позволяет модели считать себя, например, капитаном Джеком Воробьем и общаться на пиратском говоре. Также есть менее формализуемые критерии качества ответов, их даже сложно описать словами. Например, что в основном людям ответ 1 нравится больше чем ответ 2.\n   Reward-модель агрегирует эти кртитерии в число — меру качества. Чем оно выше, тем качественнее ответ модели. Для выравнивания поведения модели обычно важно уметь оценивать тысячи текстов, а вручную это делать дорого и долго, поэтому обучается специальная модель-оценщик. Про то, как обучать reward-модель, будет рассказано далее.\n4. Этап Reinforcement Learning (RL). На нём языковая модель обучается генерировать такие ответы, которые имели бы наивысшую оценку относительно reward-модели. Про то, как делать RL, будет рассказано далее.\n\n## ChatGPT\n\nОдна из самых нашумевших языковых моделей в мире наследует логику обучения Instruct GPT. Основные отличия от последней заключаются в:\n\n- Диалоговости. Модель обучена работать с диалогами, держать их в контексте и помнить историю того, что требовал пользователь. Обучение производится посредством сбора/написания диалоговых данных.\n- Размере и качестве инструкционного датасета.\n- Том, что больше внимания уделено разметке и обучению reward-модели и этапу с RL.\n\nК сожалению, OpenAI не предоставили детали обучения ChatGPT, а предложили лишь общий ход действий. Также неизвестны архитектурные параметры модели.\n\n## Как обучить свою LLM?\n\nОбсудим детально на примере доступных в open-source моделей семейства LLaMA.\n\n### LLaMa\n\nВ качестве примера возьмём самую свежую архитектуру трансформеров на первую половину 2023 года — [LLaMa](https://arxiv.org/pdf/2302.13971.pdf), а также способы превращать её в чатовую модель, проводить Alignment на примере [LLaMa-2](https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/). Вторая модель архитектурно не отличается от первой (кроме увеличенного контекста до 4096 токенов), поэтому содержание статей можно объединить в один рассказ.\n\n### Претрейн\n\nДля обучения с нуля качественной языковой модели необходимы:\n\n1. мощный кластер на сотни видеокарт, на котором можно производить параллельное обучение модели. Больше GPU — больше модель можно обучить и быстрее по времени обучения;\n2. терабайты текстовых данных для тренировки на них;\n3. архитектура, которая лучшим образом может моделировать язык.\n\nПоговорим подробнее о двух последних пунктах.\n\n**Текстовые данные**\n\nТекстовые данные можно брать из открытых источников, таких как CommonCrawl, C4, Taiga и прочее. Важно обеспечить:\n\n- чистоту данных — например, убрать html-тэги, устранить дублирование текстов;\n- полноту — чтобы модель одинаково хорошо решала математические задачи, писала код или сочиняла стихотворения, текстов соответствующих доменов должно быть в достатке в обучающем корпусе;\n- разнообразие данных.\n\nСуществуют эмпирические законы обученности модели, но здесь остановимся на числе пройденных за обучение токенов. В LLaMa-моделях это значение варьируется от 1T до 2Т. Ниже приведены основные параметры по числу размерности внутренних эмбедингов, числу голов Attention, слоёв и параметров обучения разных моделей:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_24_50eed180aa_353d8fabf6.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://arxiv.org/pdf/2302.13971.pdf\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n**Архитектура**\n\nУ LLaMa-моделей предлагается целый ряд архитектурных изменений. Так как в учебнике рассматривался лишь базовая архитектура трансформеров, то опишем, что в ней необходимо изменить, чтобы получить LLaMa-модель.\n\n1. **Pre-нормализация**.\n\n    <figure>\n <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_7_c57422a1c6_83b3d48f85.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n <figcaption>\n <p>Обычно используется <a href=\"https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html\">LayerNorm</a>, а в LLaMa — RMSNorm.</p>\n </figcaption>\n </figure>\n\n   Пусть $x \\in \\R^m, y \\in \\R^n.$  Тогда нелинейное преобразование в общем виде выглядит так:\n\n   $$a_i = \\sum_{j=1}^{m} w_{ij}x_{j}, y_i = f(a_i + b_i)\n   $$\n   \n   И LayerNorm можно описать следующими формулами:\n\n   $$\\mu = \\frac{1}{n}\\sum_{i=1}^n a_i, \\space \\sigma = \\sqrt{\\frac{1}{n}\\sum_{i=1}^n (a_i - \\mu) ^ 2}\n   \\\\\n   y_i = f(\\frac{a_i - \\mu}{\\sigma}g_i + b_i)\n   $$\n   \n   В свою очередь экспериментально RMSNorm демонстрирует лучшие результаты в сравнении с  LayerNorm и высчитывается так:\n\n   $$y_i = f(\\frac{a_i}{\\sqrt{\\frac{1}{n}\\sum^{n}_{i=1} a_i^2}}g_i + b_i)\n   $$\n   \n   \n\n2. SwiGLU-активация используется вместо ReLU. $⊗$ — значок поэлементного умножения матриц.\n\n   $$ReLU(x) = max(0, x)\n   \\\\\n   SwiGLU(x, W, V, b, c, β) = Swish_β(xW + b) ⊗ (xV + c)\n   \\\\\n   Swish_β(x) = x \\sigma(βx)\n   $$\n   \n   \n\n3. Роторные эмбединги. Информацию о том, в каком порядке следуют токены внутри модели, хранят в себе позиционные эмбединги. Они могут быть абсолютными (кодирование синусами и косинусами, как описано в параграфе о [трансформерах](https://academy.yandex.ru/handbook/ml/article/transformery)) или относительными (кодируется расстояние между каждой парой токенов).\n\n   Роторные эмбединги позволяют вычислять относительную связь между парой токенов на этапе вычисления Attention, также они выигрывают по сравнению с относительными в совместимости kernel-ов. То есть, одно из понятных не технических отличий их от других — вычисление позиционной информации на каждом слое модели при подсчёте Attention, а не только перед первым слоем. Это позволяет на каждом слое явно обрабатывать информацию об относительном расположении токенов. Роторные эмбединги показывают лучшее качество на многих задачах и являются стандартом для обучения языковых моделей. Подробнее о них можно почитать в [этой статье](https://arxiv.org/pdf/2104.09864v4.pdf).\n\nСуществуют также техники ускорения обучения моделей и оптимизации использования памяти, но с этим предлагаем читателям ознакомиться самостоятельно.\n\n### SFT (supervised finetuning)\n\nВторой этап обучения инструкционных языковых моделей требует множество инструкций. Рецепт как их готовить был подробно описан в [середине этого параграфа](https://academy.yandex.ru/handbook/ml/article/yazykovye-modeli#podvodki). Снова проговорим, что для написания инструкций или сбора датасета необходимо, чтобы инструкции были:\n\n- разнообразными;\n- качественными;\n- имели одинаковый формат, чтобы чатовая модель могла обучиться диалоговости (где вопрос пользователя, где ее ответ);\n- информативными;\n- подробными;\n- `Chain-of-Thought (CoT)`, `few-shot` и так далее.\n\n### Reward-модель\n\nТретий этап в создании инструкционных моделей. Есть несколько способов собрать датасет для обучения reward-модели. Он должен содержать тексты и метки к ним. Если меток много (например, в случае балльной оценки), можно использовать разновидности [ранжирующих лоссов.](https://gombru.github.io/2019/04/03/ranking_loss/) Разберем способ обучения модели на бинарную оценку.\n\nПусть модели подается на вход инструкция $x$. Поменяв температуру, способ сэмплирования или использовав разные чек-пойнты модели, возможно получить два разнообразных ответа $y_1$ и $y_2$. Не ограничивая общность, предположим, что, согласно некоторым предпочтениям, асессоры или пользователи установили, что первый ответ лучше второго.\n\nПроделаем эту операцию много раз и получим обучающее множество, состоящее из $\\{x^i, y_1^i, y_2^i\\}_{i = 1} ^ N$. Тогда reward-модель можно обучать минимизацией следующей функции потерь:\n\n$$\\mathcal{L}_{ranking} = -log(\\sigma(r_{\\theta}(x, y_1) - r_{\\theta}(x, y_2) - m(r)))\n$$\n\nГде:\n\n$r_{\\theta}$  — reward-модель с обучаемыми параметрами тета;\n\n$m(r)$ — некий margin, который определяет, насколько сильно модель должна отделять хороший и плохой ответы друг от друга.\n\n### **RL (Reinforcement Learning**)\n\nНа четвёртом этапе, этапе выравнивания модели, можно воспользоваться разными алгоритмами. LLaMa-2 Chat была обучена последовательно сначала на Rejection Sampling fine-tuning (RL «для бедных») и Proximal Policy Optimization (PPO).\n\n**Rejection Sampling fine-tuning**. Этот подход основан на довольно простой стратегии. Пусть имеется инструкция $x$. Сгенерируем для неё $N$ ответов и выберем тот, который получает наивысшую оценку у reward-модели. График ниже демонстрирует, что чем больше $N$, тем больше reward-score у лучшего ответа. Собрав пары `инструкция — лучший ответ`, можно обучить на них языковую модель и провести таким образом выравнивание поведения модели.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Artboard_18_4698578595_cac97c6825.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/\">ссылка на источник картинки</a>\n  </figcaption>\n</figure>\n\n**Proximal Policy Optimization**. Для лучшего понимания происходящего советуем прочесть параграф, посвященный [RL](https://academy.yandex.ru/handbook/ml/article/obuchenie-s-podkrepleniem).\n\nОсновная задача, как обычно, следовать некой политике, которая лучшим образом отражает human feedback. Политика — наша итоговая модель, value-функция оценивает средний reward в текущем состоянии (обычно это та же самая модель с линейным слоем поверх).\n\nФормализуем термины из RL для задачи выравнивания языковой модели:\n\n- Политика $\\pi$ — обучаемая языковая модель.\n- Value-функция $V_{\\pi}(s_t)$ — обычно та же самая модель с линейным слоем поверх, оценивает средний reward, если действовать из состояния $s_t$ согласно политике $\\pi$.\n- $s_t$ — состояние в момент времени $t$. Это весь контекст $t$-токенов, которые модель успела сгенерировать к текущему моменту.\n- $a_t$ — действие из текущего состояния в момент времени $t$. Обозначает следующий токен, который будет сгенерирован.\n- $\\tau$ — траектория, т. е. тройки $\\{s_i, a_i, r_i\\}_{i = 0}^{\\infty}$, — это состояния генерируемого токена и награды за него\n\nСразу можно сделать вывод, что в языковых моделях $s_{t+1} = concat([s_t, a_t])$, $Q(s_t, a_t) = V(s_{t+1}).$\n\nТакже, в RL символом $\\infty$ обозначается вся последовательность токенов, то есть на практике сюда можно подставлять количество сгенерированных токенов.\n\nИнициализируем $\\theta_0, \\psi_0$ — начальные веса политики и value-функции\n\nДля $n = 0, 1, 2, …, N:$\n\n1. Соберем коллекцию траекторий $D_n = \\{\\tau_i\\}$ , следуя политике $\\pi(\\theta_n)$.\n\n2. Посчитаем $A(s_t, a_t) = Q(s_t, a_t) - V(s_t)$. Эта формула отражает разницу между финальной наградой за выбранное действие $a_t$ в текущем состоянии $s_t$ и средней финальной наградой, которую можно было бы получить в этом состоянии. Вообще говоря, с помощью метода Generalized Advantage Estimation ([GAE](https://arxiv.org/abs/1907.00456)) её можно аппроксимировать следующим выражением:\n\n   $$\\hat{A_t} = r_t + \\gamma V_{\\theta_n}(s_{t+1}) - V_{\\theta_n}(s_{t}) \n   $$\n   \n   \n\n3. Обновляем веса политики согласно одному из лоссов PPO. Например, используем такой:\n\n   $$\\theta_{n+1} = \\underset{\\theta}{argmax} \\space \\mathbb{\\hat{E}}_t \\left[ \\frac{\\pi_{\\theta_n}(a_t | s_t)}{\\pi_{\\theta_{n-1}}(a_t | s_t)} \\hat{A}_t \\right] - \\beta KL(\\pi_{\\theta_{n-1}}(\\cdot | s_t), \\pi_{\\theta_{n}}(\\cdot | s_t))\n   $$\n   \n   \n\n4. С помощью MSE лосса оптимизируем значение value-функции:\n\n   $$\\mathcal{L}(\\psi) = \\hat{\\mathbb{E_t}} \\left[ || V_{\\psi_n}(s_t) - \\hat{R_t}|| ^ 2 \\right]\n   \\\\\n   \\hat{R_t} = \\sum_{l=0}^{\\infty} \\gamma^l r_{t+l}\n   $$\n   \n   \n\n## Итог\n\nМы с вами обсудили, как развивались языковые модели, какие приёмы и техники необходимы для успешного обучения инструкционных моделей. Также на примере архитектуры LLaMa разобрали, как самостоятельно обучить языковые модели с нуля.",
        "handbook": "Учебник по машинному обучению",
        "title": "Языковые модели",
        "description": null
    },
    {
        "path": "/handbook/ml/article/intro-recsys",
        "content": "\n## Где можно встретить рекомендательные системы?\n\nС рекомендательными системами можно столкнуться там, где есть большое множество товаров и пользователей, которые хотят найти нужные для себя товары. Рекомендательные системы помогают отобрать наиболее релевантные для пользователя объекты, тем самым экономя его время. Приведём несколько примеров:\n\n- YouTube рекомендует пользователям видео;\n- На сайтах интернет-магазинов можно встретить блоки с рекомендациями товаров;\n- Музыкальные сервисы наподобие Spotify или Яндекс.Музыки рекомендуют музыкальные треки.\n\n![recsys_example_c3d1b1a019.webp](https://yastatic.net/s3/education-portal/media/recsys_example_c3d1b1a019_7aee860313.webp)\n\nЧто такое «релевантные для пользователя товары» – это нетривиальный вопрос, который решается отдельно для каждой задачи исходя из бизнес-логики.\n\n#### Поиск vs рекомендации\n\nОтметим, что, хотя задачи поиска и рекомендаций кажутся похожими и, как мы увидим, могут использовать схожие методы, у них есть одно важное отличие: в задаче поиска есть сформулированный запрос от пользователя, а в задаче рекомендаций явного запроса нет, есть только история взаимодействий пользователя с объектами и наша надежда на то, что мы верно распознали его скрытые желания. Это различие объясняет некоторые особенности дизайна рекомендательных систем, которые мы подробнее обсудим в конце этого параграфа, при разборе классического пайплайна рекомендательной системы.\n\n## Формализация задачи\n\n### Explicit и Implicit feedback\n\nВведём ряд обозначений. Пусть у нас есть множество пользователей $U$ и множество объектов $I$. Для каждого пользователя $u \\in U$ есть множество объектов $I_u \\subset I$, с которыми он взаимодействовал и которым поставил рейтинги $R_u = \\left(r_{ui}\\right)_{i \\in I_u}$. Рейтинг (его также называют фидбеком) – это некоторая характеристика взаимодействия пользователя с объектом; про него можно думать, как про некоторый таргет, который мы выбрали для оптимизации рекомендательной системы.\n\nТаким образом, задачу рекомендательных систем можно переформулировать в следующем виде: для каждого пользователя $u \\in U$ необходимо оценить значение $r_{ui}$ для $i \\in I \\setminus I_{u}$ и выбрать несколько товаров с наибольшим $\\hat{r}_{ui}$. Иными словами, надо научиться среди непоказанных пользователю товаров находить те, которые заинтересовали бы его больше всего.\n\nПриведем несколько примеров фидбека:\n- Для товара – факт добавления в корзину;\n- Для музыки – дослушали ли трек до конца;\n- Для статьи – лайк/дизлайк;\n- Для видео – время его просмотра или факт просмотра, например, наполовину.\n\nКак правило, фидбек разделяют на два типа – explicit и implicit. Из-за различия для каждого фидбека есть разные техники обработки и использования, которые будут обсуждаться в параграфе про [матричные факторизации](https://academy.yandex.ru/handbook/ml/article/matrichnaya-faktorizaciya).\n\n**Explicit, или явный фидбек** – это такие действия пользователя, по которым точно можно понять, понравился ли ему объект. Это может быть оценка, поставленная, фильму, лайк/дизлайк к видео или рецензия на купленный товар. Такого фидбека очень мало, но он наиболее точно характеризует отношение пользователя к товару.\n\n**Implicit, или неявный фидбек** – это любая другая информация о действиях пользователя на сайте. Он выступает в качестве прокси к явному фидбеку. Например, факт того, что пользователь досмотрел видео до конца, не говорит о том, понравилось ли оно ему, однако можно сделать предположение, что большинству досмотревших видео до конца оно понравилось. Приведем основные примеры неявного фидбека: клик на статью, время просмотра видео, покупка товара. Обычно такого сигнала в разы больше, чем явного, однако он более шумный, и не стоит доверять ему так же, как явному. Например, при оптимизации кликов на статью может получиться так, что рекомендательная система научится находить кликбейт, а не интересные пользователю статьи – это может плохо отразиться на сервисе в долгосрочной перспективе.\n\n### Ранжирующая модель\n\nЗадачу построения рекомендательной системы можно формулировать в качестве задачи классификации (клик/не клик) или регрессию (сколько звёзд пользователь поставит объекту), но это не самые распространённые стратегии.\n\nОбратим внимание, что нам на самом деле не обязательно уметь точно оценивать рейтинги $r_{ui}$. Достаточно уметь для пользователя и набора объектов генерировать перестановку этих объектов в порядке убывания рейтинга. Модель, решающую данную задачу, называют **ранжирующей**. \n\nОпишем классический пайплайн применения ранжирующей модели для одного пользователя. На вход подаются признаки пользователя и объекта, и для пары пользователь-объект на основе этих признаков выдается некоторое число, ответ модели. Далее мы сортируем объекты в порядке его убывания. Из полученной перестановки обычно берут несколько первых объектов для показа пользователю.\n\nБолее подробно о том, как решается задача ранжирования, вы можете прочитать в соответствующем параграфе.\n\n## Коллаборативная фильтрация\n\n![Artboard_22_590bae5dfb.svg](https://yastatic.net/s3/education-portal/media/Artboard_22_590bae5dfb_483ab4a53a.svg)\n\nРассмотрим матрицу взамодействий пользователя, приведённую выше. Что можно порекомендовать Кате, исходя из исторических данных? Можно заметить, что взаимодействия Кати похожи на взамодействия Пети (так как они оба лайкали объекты 1 и 8). Иными словами, их интересы в чём-то похожи, поэтому Кате можно порекомендовать, например, объект 3 (так как он понравился Пете). Можно проделать аналогичное упражнение с Петей и сделать вывод, что ему не стоит рекомендовать объект 10.\n\nМожно решать и транспонированную задачу: для лайкнутого пользователем объекта искать похожие, то есть те, которые пользователи достаточно часто лайкали вместе с ним. Например, объекты 1 и 8 похожи друг на друга, так как их лайкали одни и те же пользователи, и точно так же похожи 1 и 3.\n\nПроиллюстрированный выше подход называют **коллаборативной фильтрацией**. Он объединяет семейство методов рекомендаций, использующих сходство по истории взаимодействия между пользователем и товаром. Рассмотрим конкретные простые методы коллаборативной фильтрации.\n\n### User2User рекомендации\n\nВведём меру похожести двух пользователей $s(u, v)$, которая тем больше, чем выше сходство между $u$ и $v$. Для пользователя $u$ рассмотрим множество похожих на него пользователей $N(u) = \\{ v \\in U \\setminus \\{u\\} \\vert  s(u, v) > \\alpha  \\},$ где $\\alpha$ – настраиваемый гиперпараметр, в чём-то аналогичный порогу бинарного классификатора.\n\nДопустим, мы хотим теперь оценить рейтинг $r_{ui}$, который пользователь $u$ поставил бы объекту $i$. Сделаем это, опираясь на рейтинги, которые ставили похожие на $u$ пользователи. Например, можно взять взвешенное среднее:\n\n$$\n\\hat{r}_{ui} = \\frac{\\sum_{v \\in N(u)} s(u, v) r_{vi}}{\\sum_{v \\in N(u)} \\lvert s(u, v) \\rvert}\n$$\n\nМодуль добавляется для того, чтобы корректно обработать непохожих пользователей, то есть с пары с отрицательной похожестью, которая может возникнуть, если при построении $N(u)$ взять достаточно маленькое $\\alpha$.\n\nМожно пойти дальше и усовершенствовать метод оценивания. У пользователей могут быть разные диапазоны оценок: кто-то ставит почти всегда в диапазоне 1-3, а кто-то предпочитает ставить 4-5. Иными словами, для разных пользователей оценка «нормально» (и соответственно, оценки «хорошо» и «плохо») могут соответствовать разным значениям рейтинга. Для устранения этой проблемы, можно брать не сырой рейтинг пользователя $r_{vi}$, а его отклонение от среднего всех оценок пользователя: $r_{vi} - \\overline{r}_{v}$. Таким образом, мы учитываем только разброс вокруг среднего и итоговая оценка будет выглядеть так:\n\n$$\n\\hat{r}_{ui} = \\overline{r}_u + \\frac{\\sum_{v \\in N(u)} s(u, v) \\left(r_{vi} - \\overline{r}_v\\right)}{\\sum_{v \\in N(u)} \\lvert s(u, v) \\rvert}\n$$\n\nМожно пойти еще дальше и учесть дисперсию оценок пользователей:\n\n$$\n\\hat{r}_{ui} = \\overline{r}_u + \\sigma_{u} \\frac{\\sum_{v \\in N(u)} s(u, v) \\left(r_{vi} - \\overline{r}_v\\right) / \\sigma_v}{\\sum_{v \\in N(u)} \\lvert s(u, v) \\rvert}, \\, \\text{где} \\, \\sigma_{u} = \\sqrt{ \\frac{1}{I_u} \\sum_{i \\in I_{u} } \\left(r_{ui} - \\overline{r}_u\\right) ^ 2},\n$$\n\nгде $I_{u}$ – множество объектов, с которыми взаимодействовал пользователь $u$.\n\nВ заключение приведём несколько вариантов оценки схожести пользователей:\n\n- Мера Жаккара: $s(u, v) = \\frac{\\lvert P_u \\cap P_v \\rvert}{\\lvert P_u \\cup P_v \\rvert},$ где $P_u$ – множество понравившихся $u$ айтемов;\n- Скалярное произведение общих рейтингов: $s(u, v) = \\sum_{i \\in I_u \\cap I_v} r_{ui} r_{vi}$;\n- Корреляция Пирсона:\n\n$$\ns(u, v) = \\frac{\\sum_{i \\in I_u \\cap I_v} (r_{ui} - \\overline{r}_u)(r_{vi} - \\overline{r}_v)}{\\sqrt{\\sum_{i \\in I_u \\cap I_v} (r_{ui} - \\overline{r}_u)^2} \\sqrt{\\sum_{i \\in I_u \\cap I_v} (r_{vi} - \\overline{r}_v)^2}}\n$$\n\n- Дисконтированная корреляция Пирсона. Так как айтемов в пересечении $I_u \\cap I_v$ в действительности не всегда может быть достаточно много, можно дисконтировать похожести, посчитанные по небольшому множеству айтемов, домножая корреляцию на $\\min(\\frac{\\lvert I_u \\cap I_v \\rvert}{50}, 1)$.\n\n### Item2Item рекомендации\n\nТеперь попробуем решать транспонированную задачу. Введем меру похожести объектов $s(i, j)$. Если нам нужно оценить рейтинг, который пользователь $u$ поставил бы ещё не виденному им объекту $i$, то мы можем рассмотреть множество $N(i)$ близких к $i$ объектов и оценить $\\hat{r}_{ui}$ аналогично user2user подходу:\n\n$$\n\\hat{r}_{ui} = \\frac{\\sum_{j \\in N(i)} s(i, j) r_{uj}}{\\sum_{j \\in N(i)} \\lvert s(i, j) \\rvert}\n$$\n\nМеру схожести объектов можно задать как adjusted cosine:\n\n$$\ns(i, j) = \\frac{\\sum_{u \\in U_i \\cap U_j} (r_{ui} - \\overline{r}_u)(r_{uj} - \\overline{r}_u)}{\\sqrt{\\sum_{u \\in U_i \\cap U_j} (r_{ui} - \\overline{r}_u)^2} \\sqrt{\\sum_{u \\in U_i \\cap U_j} (r_{uj} - \\overline{r}_u)^2}}\n$$\n\n\nгде $U_i$ – множество пользователей, оценивших товар $i$. Обратите внимание, что $\\hat{r}_u$ – это средняя оценка пользователя, а не объекта, то есть это не корреляция Пирсона – на практике данный подход обычно работает лучше.\n\n### Особенности коллаборативной фильтрации\n\nВыделим ключевые особенности методов, основанных на коллаборативной фильтрации, о которых следует помнить при разработке рекомендательных систем:\n- Они не опираются ни на какую дополнительную информацию кроме матрицы оценок $R_{ui}$, предполагая, что этого должно быть достаточно для улавливания качественного сигнала о схожести пользователей и товаров;\n- Предложенные методы не применимы для новых объектов и пользователей – для них просто нет истории или она недостаточно информативна для того, чтобы методы могли давать более-менее точные оценки;\n- Так как методы коллаборативной фильтрации основаны только на истории прошлых взаимодействий, рекомендательная система, построенная исключительно на их основе будет постепенно вгонять пользователя в информационный пузырь: эти методы не предполагают открытия новых интересов у пользователя, они способны только эксплуатировать уже имеющиеся.\n\n## Content-based рекомендации\n\nТакже помимо коллаборативной фильтрации существует content-based подход для построения рекомендаций: измерение похожести между объектами на основе их содержания. Например, две статьи про то, как заменить колесо на велосипеде можно считать похожими с точки зрения содержания. Иными словами, входом для content-based модели являются разные контентные признаки и характеристики товара (например, текст статьи, время публикации, картинки), а выходом является некоторое числовое представление объекта (эмбеддинг). Отметим, что никакую коллаборативную информацию такие модели не используют, они ничего не знают про других пользователей и про их взаимодействие с объектами. Например, Bert является чисто контентной моделью – он переводит текст в эмбеддинг.\n\nПусть у нас есть некоторый контентные эмбеддинги $e_i \\in \\mathbb{R}^n$ для каждого товара – например, мы применили обученный Bert для получения векторных представлений статей. Тогда мы можем посчитать скалярное произведение (или косинусное расстояние) до оценённых пользователем объектов и оценить рейтинги, как:\n\n$$\n\\hat{r}_{ui} = \\max_{j \\in I_{u}, r_{uj} > \\alpha} \\rho(e_i, e_j) r_{uj},\n$$\n\nгде $\\rho$ – скалярное произведение или косинусное расстояние между двумя векторами, $I_{u}$ – множество оценённых пользователем объектов, а $\\alpha$ – гиперпараметр. Таким образом, высокие рейтинги получат объекты, похожие на те, что понравились пользователю – мы получили простую ранжирующую модель.\n\nПлюс контентного подхода в том, что, в отличие от чисто коллаборативного подхода, он одинаково хорошо работает на новых и старых айтемах, так как контентные модели основаны только на статичной контентной информации, которая всегда доступна. Из минусов можно отметить, что похожесть по контенту может ещё больше загонять пользователя в информационный пузырь: например, контентная модель вряд ли сможет к кофемашине порекомендовать кофейные зерна, в то время как коллаборативный подход получит сигнал о том, что товары являются дополняющими напрямую из действий других пользователей.\n\nОтметим, что существуют гибридные модели, совмещающие в себе коллаборативный и контентный сигналы. Например, такой моделью является DSSM.\n\nПодробнее о контентных моделях вы узнаете в соответствующем параграфе.\n\n## Классический пайплайн рекомендательной системы\n\n![Artboard_22_copy_b853d2a0c5.svg](https://yastatic.net/s3/education-portal/media/Artboard_22_copy_b853d2a0c5_18adbac397.svg)\n\nМы разобрали несколько классических подходов к построению рекомендаций, теперь нужно обсудить, как это скомпоновать в единую рекомендательную систему.\n\nДля начала сформулируем ряд свойств, которыми должна обладать хорошая рекомендательная система:\n1. При ранжировании товаров в порядке убывания $\\hat{r}_{ui}$ нам хотелось бы учитывать как можно больше сигналов/фичей (как пользователя, так и объекта);\n2. Рекомендательная система должна работать достаточно быстро;\n3. Должен быть несложный механизм, позволяющий понятно учитывать «бизнес-логику» (например, если при прочих равных мы больше хотим показывать свежие статьи).\n\nДля соблюдения первого пункта, очевидно, нужна ранжирующая модель. В качестве самой модели часто применяют бустинг – на табличных данных он, как правило, cправляется лучше, плюс он быстрее нейронных сетей с точки зрения времени применения. \n\nЗдесь не будет лишним упомянуть про feedback loop. Для обучения ранжирующей модели мы обычно берем прошлую историю взаимодействия пользователей с показанными ему объектами, считаем $r_{ui}$ и составляем на основе этих оценок обучающий датасет. Таким образом, обучая новую модель, мы с некоторыми оговорками будем учиться предсказывать старую модель. Поэтому есть риск, что она застрянет в локальном оптимуме, из которого сложно выбраться. В качестве решения этой проблемы можно, например, подмешивать в выдачу случайные объекты и давать им больший вес в функции потерь. Таким образом, у нас появляется некоторое подмножество объектов, которые не были смоделированы нашей моделью. В качестве дополнительного плюса такого подхода мы в какой-то степени будем выбивать пользователя из его информационного пузыря, показывая объекты из категорий, которыми он еще не интересовался.\n\nВ реальной рекомендательной системе обычно от нескольких миллионов товаров и хотя бы несколько сотен тысяч пользователей в день (а чаще несколько миллионов). Обученная CatBoost модель на 5000 объектов отрабатывает где-то за 100-125ms на CPU. Фичи пользователей и объектов постоянно меняются, поэтому на каждый запрос пользователя мы должны заново скорить все объекты. Но тогда только на скоринг мы будем тратить порядка 25 секунд, а если это не CatBoost, а, например, нейронная сеть, то, скорее всего, ещё больше. Это очень существенные и необоснованные затраты.\n\nВ действительности, пользователю наверняка интересна лишь небольшая часть имеющихся у нас товаров. Можно попытаться сузить множество до потенциально интересных пользователю объектов и уже для них применить «тяжёлую» ранжирующую модель, которая определит финальную выдачу. Этот подход называется **отбором кандидатов**. К отбору кандидатов предъявляют два требования:\n\n- он должен быть быстрым;\n- он должен иметь хорошую полноту поиска подходящих пользователю объектов, то есть в полученной после отбора кандидатов подмножестве должны в избытке находиться интересные пользователю статьи/фильмы/продукты;\n\nПриведем несколько подходов к отбору кандидатов:\n\n- Эвристики: самые популярные товары, популярные за $X$ последних дней, популярные среди жителей этого города, недавно опубликованные;\n- Коллаборативные: item2item или user2user рекомендации. Мы можем в оффлайне предподсчитывать все необходимые статистики и строить таблички из пользователя в множество подходящих айтемов или из айтема в айтемы. Также есть более сложные подходы на основе матричных разложений, о которых будет рассказано в соответствующем параграфе;\n- Контентные методы: берём content-based эмбеддинги объектов и строим быстрый индекс для поиска ближайших объектов (например, HNSW). Подробнее о быстром поиске ближайших соседей вы можете почитать в параграфе про метрические методы. Далее, можем взять понравившиеся пользователю товары и найти похожие на них.\n\nОбычно отбор кандидатов состоит из набора разных источников кандидатов, где каждый источник по смыслу пытается покрыть какой-то пользовательский аспект.\n\nДвухступенчатая рекомендательная система уже обладает двумя хорошими свойствами, осталось предложить механизм, который позволит учитывать бизнес-логику. Под бизнес-логикой здесь понимается некоторое качество рекомендательной системы, которое хотелось бы иметь, но которое достаточно нетривиально, чтобы мы не стали зашивать его в саму ранжирующую модель. Приведем примеры возможных пожеланий:\n\n- Реже показывать старые видео в ленте;\n- Реже показывать слишком длинные видео или видео, снятые в плохом качестве;\n- Обеспечить разнообразную для пользователя выдачу. Например, если пользователь интересуется кошками и машинами, А ранжирующая модель всем видео про кошек дала большую оценку, чем любому видео про машины, то получится, что лента пользователя будет состоять только из кошек, хотя ему также интересны и машины.\n\nВсе эти свойства подразумевают под собой небольшое переупорядочивание объектов после применения ранжирующей формулы. Этот механизм называется **переранжированием** (**реранкингом**).",
        "handbook": "Учебник по машинному обучению",
        "title": "Введение в рекомендательные системы",
        "description": null
    },
    {
        "path": "/handbook/ml/article/rekomendacii-na-osnove-matrichnyh-razlozhenij",
        "content": "## Введение\n\nДопустим, мы работаем в сервисе рекомендаций фильмов и перед нами стоит задача подобрать для каждого пользователя набор наиболее релевантных фильмов. Пользователь может разными способами провзаимодействовать с фильмом: посмотреть его, оставить отзыв, поставить оценку (например, от 1 до 5).\n\nВ этом параграфе мы будем строить рекомендации на основе матрицы оценок user-item. Её строки соответствуют объектам, а столбцы – пользователям. На $(i, j)$-й позиции матрицы мы ставим либо пропуск, либо оценку, выставленную $i$-м объекту $j$-му пользователем. Разумеется, не все оценки нам известны: вряд ли каждый пользователь имел возможность ознакомиться с каждым объектом. В процессе решения задачи мы будем пытаться восстановить оценки на местах пропусков. Сделав это, мы сможем, например, порекомендовать пользователю те объекты, которые он ещё не смотрел, но предсказанная оценка которых для этого пользователя максимальна.\n\n![user_item_matrix_b796b9180a_31e9322dd5.svg](https://yastatic.net/s3/education-portal/media/user_item_matrix_b796b9180a_31e9322dd5_f968f1cb28.svg)\n\nВсе типы взаимодействия пользователей с объектами мы можем рассматривать как пользовательский фидбек. Обычно различают **явный** (**explicit**) и **неявный** (**implicit**) виды фидбека. Фидбек называется явным, если он отражает степень интереса пользователя к объекту. Например, к этому типу относят рейтинги, лайки и дизлайки. Такого фидбека обычно мало, он поступает только от тех пользователей, которые соглашаются нам его дать.\n\nОбычно гораздо больше информации имеется о неявных предпочтениях – просмотры, клики, добавление в закладки. Но если пользователь, например, посмотрел фильм, мы ещё не можем сделать вывод, что он ему понравился. Мы можем лишь утверждать, что до просмотра этот фильм казался ему достаточно интересным. Поэтому обычно неявная обратная связь более шумная, чем явная.\n\nДля начала научимся работать с явным фидбеком.\n\n## Связь с задачей матричной факторизации\n\nВернёмся к задаче восстановления матрицы оценок и предположим, что каждый пользователь и объект можно закодировать набором из $S$ скрытых признаков, а оценка $i$-го объекта $u$-м пользователем равна скалярному произведению соответствующих векторов скрытых представлений $x_u$ и $y_i$. Тогда если бы наша матрица оценок была заполнена полностью, её можно было бы представить в виде произведений двух матриц $X$ и $Y$, составленных по столбцам из скрытых представлений пользователей и объектов:\n\n$$\nU = X^T \\cdot Y\n$$\n\n![Decomp31_30b64943e4.webp](https://yastatic.net/s3/education-portal/media/Decomp31_30b64943e4_4c8c18a7b4.webp)\n\nПравда, в таком случае нам бы и не требовалось ничего решать: мы могли бы просто рекомендовать пользователю объекты с самыми высокими оценками в соответствующей строке. Но суровая реальность такова, что зачастую матрица оценок сильно разрежена. Мы можем поступить следующим образом: восстановить латентные векторы для пользователей и объектов по имеющемуся набору оценок, после чего предсказать оценки для всех отсутствующих позиций. В параграфе, посвящённом [матричной факторизации](https://academy.yandex.ru/handbook/ml/article/matrichnaya-faktorizaciya#ispolzovanie-svd-razdelyonnye-predstavleniya-i-rekomendatelnaya-sistema-dlya-bednyh), мы уже обсуждали способы решения данной задачи с помощью SVD и стохастического градиентного спуска. У SVD есть существенные недостатки: из-за большого количества пропусков в матрице полученное решение будет слишком шумным, а кроме того, его придется каждый раз рассчитывать заново при добавлении новых пользователей или объектов. Градиентный спуск не имеет данных проблем, но тоже не очень практичен. В этом параграфе мы рассмотрим более эффективный алгоритм, называемый **Alternating Least Squares** (**ALS**).\n\n## Постановка задачи\n\nПусть, как и раньше, $x_u, y_i$ – скрытые представления пользователей и объектов соответственно размерности $T$. Запишем эти векторы по строкам в матрицы $X$ и $Y$ размера $S\\times N$ и $S\\times D$ соответственно, где $N$ – количество пользователей, а $D$ – количество объектов.\n\nОбозначим через $R$ множество таких пар $(u, i)$ пользователей и объектов, для которых имеются явно проставленные оценки.\n\nПредсказывать рейтинги мы будем как скалярное произведение скрытых представлений:\n\n$$\\hat{r}_{ui} = x_u^Ty_i$$\n\nВ результате мы приходим к следующей задаче оптимизации. Мы хотим научиться как можно лучше приближать известные рейтинги:\n\n$$\\min_{x_u, y_i} \\sum\\limits_{(u,i) \\in R} (r_{ui} - x_u^Ty_i)^2  $$\n\nДобавив регуляризацию получаем следующую функцию потерь:\n\n$$\\min_{x_u, y_i} \\sum\\limits_{(u,i) \\in R}(r_{ui}-x_{u}^{T}y_i)^2+\\lambda\\sum\\limits_{\\forall u}||x_u||^2C_u+\\lambda\\sum\\limits_{\\forall i}||y_i||^2C_i$$\n\n## Alternating Least Squares (ALS)\n\nОптимальные параметры можно найти с помощью хорошо знакомого нам градиентного спуска, но есть более быстрые и надёжные способы. Если мысленно заморозить параметры, соответствующие латентным факторам пользователей, задача оптимизации латентных представлений объектов сведётся к задаче наименьших квадратов, для которой мы знаем точное решение.\n\nИтоговый процесс оптимизации функции потерь будет иметь следующий вид. \n\nВ цикле до сходимости:\n\n- Фиксируем матрицу $X$ (скрытые представления пользователей);\n- Решаем задачу L2-регуляризованной регрессии для каждого товара и находим оптимальную матрицу $Y$;\n- Фиксируем матрицу $Y$ (скрытые представления объектов);\n- Решаем задачу L2-регуляризованной регрессии для каждого пользователя и находим оптимальную матрицу $X$;\n\nРешение, получаемое путём попеременного вычисления точных аналитических решений, обычно точнее тех, что получаются с помощью наивного градиентного спуска. Более того, данное решение имеет эффективную реализацию, позволяющую использовать преимущества параллельных вычислений.\n\nДля лучшего понимания распишем каждый шаг данного алгоритма оптимизации:\n\n### ALS - шаг по (одному) $x_u$:\n\n$$\n\\underset{x_u}{\\mathrm{argmin}} \\sum\\limits_{(u,i) \\in R}^{}(r_{ui}-x_{u}^{T}y_i)^2+\\lambda\\sum\\limits_{\\forall u}||x_u||^2C_u + \\lambda\\sum\\limits_{\\forall i}||y_i||^2C_i\n$$\n\nРаскроем квадратичный член:\n\n$$\n\\underset{x_u}{\\mathrm{argmin}} \\sum\\limits_{(u, i) \\in R}^{} r_{ui}^2 - 2 \\sum\\limits_{(u,i) \\in R}^{} r_{ui}x_{u}^{T}y_i + \\sum\\limits_{(u,i) \\in R}^{} (x_{u}^{T}y_i)^2\n+\\lambda\\sum\\limits_{\\forall u}||x_u||^2C_u + \\lambda\\sum\\limits_{\\forall i}||y_i||^2C_i\n$$\n\nВ первой сумме константы, они уходят. Из второй и третьей возьмём только те слагаемые, в которых участвует $x_u$. Из четвёртой остается только член с $x_u$, так как все $x_v$ независимы. Последняя сумма пропадает, так как $x_v$ и $y_j$ независимы:\n\n$$\n\\underset{x_u}{\\mathrm{argmin}}  - 2 \\sum\\limits_{i:\\,(u,i) \\in R}^{} r_{ui}x_{u}^{T}y_i + \\sum\\limits_{i:\\,(u,i) \\in R}^{} (x_{u}^{T}y_i)^2 + \\lambda C_u x_u^T x_u = \n$$\n\nВ первой сумме индекс $u$ фиксирован, поэтому $x_u$ можно вынести за знак суммы:\n\n$$\n\\underset{x_u}{\\mathrm{argmin}} -2x_{u}^{T} \\sum\\limits_{(u, i) \\in R}^{} r_{ui}y_i + \\sum\\limits_{(u, i) \\in R}^{} x_{u}^{T}y_i \\cdot x_{u}^{T}y_i + \\lambda C_u (x_u, x_u)  = \n$$\n\nОбъединим второй и третий члены формулы, вынесем умножение на $x_u$ за скобки:\n\n$$\n\\underset{x_u}{\\mathrm{argmin}} -2x_{u}^{T} \\Bigl( \\sum\\limits_{(u,i) \\in R}^{} r_{ui}y_i \\Bigr) + x_u^{T} \\Bigl( \\sum\\limits_{(u,i) \\in R}^{} y_i y_i^T + \\lambda C_u \\Bigr) x_u = \n$$\n\nТеперь воспользуемся тем, что\n\n$$\n\\underset{x_u}{\\mathrm{argmin}} -2x_u^TB_u + x_u^TA_ux_u = A_u^{-1}B_u\n$$\n\nи выпишем ответ:\n\n$$\nx_u^* = \n\\Bigl( \\sum\\limits_{i: (u, i) \\in R}^{} y_jy_j^T + \\lambda C_i I \\Bigr)^{-1} \\Bigl( \\sum\\limits_{j: (i,j) \\in R}^{} r_{ij}y_j \\Bigr)\n$$\n\nТаким образом, мы получили аналитическое выражение для вычисления каждого $x_u$ на шаге алгоритма. Отметим, что каждый вектор $x_u$ мы можем вычислить независимо от других $x_v$. Данное наблюдение позволяет нам использовать всю мощь параллельных вычислений для эффективного решения оптимизационной задачи. Распределив данные так, что на каждой вычислительной машине хранятся все $y_i$ для некоторого подмножества $x_u$, на одной итерации алгоритма мы можем параллельно вычислить все $x_u$. На следующей итерации аналогичным образом вычисляем все $y_i$.\n\n## IALS (Implicit ALS)\n\n[Оригинальная статья](http://yifanhu.net/PUB/cf.pdf)\n\nРаньше мы работали с матрицей $R$ как с матрицей рейтингов, явно проставленных пользователем. Как мы говорили выше, такого фидбека обычно довольно мало, а куда больше неявного фидбека. При этом количество данных может быть критичным при работе с такими разреженными структурами, как матрицы рейтингов, поэтому хочется научиться работать и с неявным фидбеком тоже.\n\nНеявным фидбеком является в том числе и факт взаимодействия, поэтому мы можем заполнить всю матрицу user-item целиком: на тех позициях, где пользователь положительно взаимодействовал с объектом, поставим $1$, а на тех, где взаимодействие было негативным или его вообще не произошло, поставим $0$. Эта компонента фидбека называется предпочтением (preference):\n\n$$\n\\begin{equation}\n    p_{ui} = \n    \\begin{cases}\n        1, & r_{ui} > 0 \\\\\n        0, & r_{ui} \\le 0 \\text{ или } r_{ui} \\text{ не определено}\n    \\end{cases}\n\\end{equation}\n$$\n\nТем самым мы избавились от пропусков в матрице, но использовали не всю информацию. Согласитесь, если один пользователь посмотрел часовое видео польностью, а другой выключил после 5 минут, несправедливо считать, что это видео им понравилось в одинаковой степени. Введём ещё степень уверенности (confidence), отражающую уверенность в оценке пользователя:\n\n$$\nc_{ui} = 1 + \\alpha |r_{ui}|\\ (\\text{ степень уверенности в } p_{ui}),\n$$\n\nгде $\\alpha$ – некоторая константа.\n\nНа местах пропусков мы явно проставляем $p_{ij} = 0$. На остальных позициях мы можем сами регулировать степень уверенности в зависимости от фидбека пользователя. \n\nРассмотрим следующую функцию потерь:\n\n$$\n\\sum\\limits_{\\forall u,i}^{} c_{ui} (p_{ui} - x_{u}^{T}y_i) ^ 2 + \\lambda \\sum\\limits_{\\forall u}^{} ||x_u||^2C_u + \\lambda \\sum\\limits_{\\forall i}^{} ||y_i||^2C_i, \\\\\n$$\n\nОна позволяет:\n\n- Учитывать неявный фидбек, которого обычно на порядок больше, чем явного,\n- Регулировать степень уверенности в действиях пользователей.\n\n### IALS: оптимизация\n\nРаспишем нашу функцию потерь по аналогии с ALS и приведем к форме $-2x_u^TB_u + x_u^TA_ux_u$:\n\n$$\n\\underset{x_u}{\\mathrm{argmin}} \\sum\\limits_{u,i}^{} c_{ui}(p_{ui} - x_u^{T}y_i)^2 + \\lambda \\sum\\limits_{u}^{} ||x_u||^2C_u + \\lambda \\sum\\limits_{i}^{} ||y_i||^2C_i = \\\\\n\\underset{x_u}{\\mathrm{argmin}} \\sum\\limits_{i}^{} c_{ui} p_{ui}^2 - \n2 \\sum\\limits_{i}^{} c_{ui} p_{ui} x_u^{T} y_i +\n\\sum\\limits_{i}^{} c_{ui} (x_u^{T}y_i)^2 + \\lambda C_u x_u^Tx_u = \\\\\n\\underset{x_u}{\\mathrm{argmin}} - \n2 x_u^{T} \\sum\\limits_{\\forall i}^{} c_{ui} p_{ui} y_i +\n\\sum\\limits_{\\forall i}^{} c_{ui} x_u^{T}y_i \\cdot x_u^{T}y_i + \\lambda C_u x_u^{T}x_u = \\\\\n\\underset{x_i}{\\mathrm{argmin}} - \n2 x_u^{T} \n    \\Bigl(\n        \\sum\\limits_{\\forall i}^{} c_{ui} p_{ui} y_i\n    \\Bigr)  +\nx_u^{T} \n    \\Bigl(\n        \\sum\\limits_{\\forall i}^{} c_{ui} y_i y_i ^{T} + \\lambda C_u\n    \\Bigr) \nx_u = \\\\\n\\Bigl( \n    \\sum\\limits_{\\forall i}^{} c_{ui}y_{i}y_{i}^{T} + \\lambda C_u I \n\\Bigr)^{-1}\n\\Bigl(\n    \\sum\\limits_{\\forall i}^{} c_{ui}p_{ui}y_{i}\n\\Bigr) = \n$$\n\nРазобьём сумму на 2 части. В первой будет сумма по тем элементам, с которыми у пользователя не было положительного взаимодействия. Во второй – сумма по всем остальным элементам. Также заметим, что во втором множителе суммирование имеет смысл только по ненулевым элементам:\n\n$$\n\\Bigl(\n    \\sum\\limits_{\\forall i: p_{ui}=0}^{}c_{ui}y_i \\cdot y_{i}^{T} + \\sum\\limits_{\\forall i: p_{ui}\\neq 0}^{} c_{ui}y_i \\cdot y_{i}^{T} + \\lambda C_u I\n\\Bigr)^{-1} \n\\Bigl(\n    \\sum\\limits_{\\forall i: p_{ui}\\neq 0}^{} c_{ui}p_{ui}y_i\n\\Bigr) = \n$$\n\nЗаметим, что в первой сумме все $c_{ui}$ будут равны 1 (так как везде $p_{ui} = 0$). Прибавим и вычтем единицу к $c_{ui}$ во второй сумме и разобьем её на две компоненты. Вторый из них будет сумма по всем $y_iy_i^T$, где $p_{ui} \\neq 0$. Объединив её с первой суммой, получим<br>просто $Y^{T}Y$:\n\n$$\n\\Bigl(\n    Y^{T}Y + \\lambda C_u I + \\sum\\limits_{\\forall i: p_{ui}\\neq 0}^{} (c_{ui} - 1)y_{i}y_{i}^{T}\n\\Bigr)^{-1}\n\\Bigl(\n    \\sum\\limits_{\\forall i: p_{ui}\\neq 0}^{} c_{ui}p_{ui}y_{i}\n\\Bigr)\n$$\n\nЗаметим, что произведение $Y^{T}Y$ никак не зависит от $u$. Мы можем посчитать его один раз для всех $x_u$ перед очередной итерацией. В остальном же мы точно так же, как и в случае с обычным ALS, можем распределить данные так, чтобы на одной машине содержались все $y_j$, необходимые для обновления $x_v$, хранящихся на этой машине, и сделать следующий шаг оптимизации нашей функции потерь.\n\n## Обобщения ALS и IALS\n\n- Обе модели: и ALS, и Imlicit ALS – можно несколько усложнить, вместо $r_{ui} \\approx x_{u}y_{i}$ рассмотрев $r_{ui} \\approx x_{u}y_{i} + b_{u} + b_{i} + \\mu$. В таком случае $b_i$ и $b_j$ играют роль некоторых априорных усреднённых оценок пользователя и объекта соответственно, а $\\mu$ является глобальной априорной константой.\n- В модели IALS мы обычно полагаем элементы $p_{ui}$ равными $1$ во всех случаях, когда имело место взаимодействие, но можем использовать и другие значения, в том числе зависящие от того, что ещё нам известно о пользователях и объектах.\n- Для уверенности $c_{uv} = 1 + \\alpha \\|r_{ui}\\|$ для IALS необязательно использовать $1$ в качестве значения по умолчанию. Например, события «пользователь не посмотрел популярный фильм» и «пользователь не посмотрел редкий фильм» могут иметь для нас разный вес.\n\n\n## FunkSVD\n\nЭтот подход получил широкую известность после конкурса Netflix Prize в 2006 году. [Пост Саймона Фанка про участие в Netflize Prize](https://sifter.org/simon/journal/20061211.html)\n\nФанк предложил моделировать рейтинг как $\\hat{r}_{ui} = \\mu + b_u + b_i + x_{u}y_{i}$. Однако, в отличие от ALS, оптимизация производилась с помощью стохастического градиентного спуска. Правила обновления весов выглядели следующим образом:\n\n$$\n\\begin{cases}\n    e_{ui} = \\hat{r}_{ui} - r_{ui} \\\\ \n    x_u \\xleftarrow{} x_u + \\eta (e_{ui}y_{i} - \\lambda x_{u}) \\\\\n    y_i \\xleftarrow{} y_i + \\eta (e_{ui}x_{u} - \\lambda y_{i}) \\\\\n    b_u \\xleftarrow{} b_u + \\eta (e_{ui} - \\lambda b_{u}) \\\\\n    b_i \\xleftarrow{} b_i + \\eta (e_{ui} - \\lambda b_{i}) \\\\\n\\end{cases}\n$$\n\nЭтот подход не получил большой популярности, так как градиентный спуск, в отличие от ALS, намного сложнее распараллелить.\n\n## Singular Value Decomposition with implicit feedback (SVD++)\n\n[Оригинальная статья](https://people.engr.tamu.edu/huangrh/Spring16/papers_course/matrix_factorization.pdf)\n\nРанее мы отдельно рассматривали факторизации для явного и неявного фидбека. Но, ограничиваясь только одним типом фидбека, мы теряем много информации. Если мы работаем над стриминговым сервисом, то в качестве неявного фидбека мы можем взять, например, историю фильмов, взятых в прокат. Такие данные не предоставляют нам явных оценок пользователей, но позволяют выявить неявные предпочтения. Учесть неявный фидбек в модели можно следующим образом:\n\n$$\nr_{ui} \\approx \n\\Bigl(\n    x_{u} + \\frac{1}{\\sqrt{|\\{j|p_{uj} \\neq 0\\}|}} \n    \\sum\\limits_{\\forall j: p_{uj}\\neq 0}^{} \\widehat{y}_j\n\\Bigr)^T\ny_{i} + b_{u} + b_{i} + \\mu\n$$\n\nВ данной модели пользователь представлен скрытым представлением $x_u$, а также слагаемым, отражающим историю неявных взаимодей с айтемами: $\\frac{1}{\\sqrt{|\\{j|p_{uj} \\neq 0\\}|}} \\sum\\limits_{\\forall j: p_{uj}\\neq 0}^{} \\widehat{y}_j$.  \n\nВажно отметить, что вектора $\\widehat{y}_j$ не совпадают с векторами $y_{i}$. Это своего рода «неявные» вектора айтемов.\n\n## Collaborative Filtering with Temporal Dynamics (timeSVD++)\n\n[Оригинальная статья](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.379.1951&rep=rep1&type=pdf)\n\nОсобенностью всех рассмотренных на данный момент разложений является отсутствие учёта порядка просмотра объектов.\n\nОднако, как показывает практика, со временем пользователь может менять своё мнение о тех или иных айтемах. Тогда, отсортировав взаимодействия по времени, мы можем разбить события на бакеты и модифицировать приведённую выше функцию потерь, в которой таргет выражается следующим образом:\n\n$$\nr_{ui}(t) \\approx \n\\Bigl(\n    x_{u}(t) + \\frac{1}{\\sqrt{|\\{j|p_{uj} \\neq 0\\}|}} \n    \\sum\\limits_{\\forall j: p_{uj}\\neq 0}^{} \\widehat{y}_j\n\\Bigr)\ny_{i} + b_{u}(t) + b_{i}(t) + \\mu\n$$\n\n## SLIM (Sparse Linear Methods)\n\n[Оригинальная статья](http://glaros.dtc.umn.edu/gkhome/node/774)\n\nОписанные выше методы демонстрируют хорошее качество, однако требуют больших усилий для эффективной работы в онлайн сервисах. Возникает потребность в лёгких моделях, эффективность которых значительно выше, но качество которых не сильно хуже. Для этого была предложена линейная разреженная модель.\n\nИтак, пусть $A$ – бинарная матрица $N \\times D$ user-item взаимодействий, например, матрица кликов/показов. Будем определять ответ алгоритма $a_{ui}$ как взвешивание событий из истории пользователя:\n\n$$\\hat{a}_{ui} = \\sum\\limits_j w_{ij}a_{uj}$$\n\nПри этом наложим ограничение $w_{ij} \\ge 0$. В такой постановке мы будем учить модель находить «похожие» объекты. Добавим ещё условие $w_{ii} = 0$, которое позволит нам избежать элементарного решения – единичной матрицы $W = I$.В результате вес $w_{ij}$ выступает в качестве некоторой меры схожести $i$-го и $j$-го объектов. Осталось определиться с методом оптимизации данных параметров.\n\nДля оптимизации используется функция потерь MSE с $L_{1}$- и $L_{2}$-регуляризаторами:\n\n$$\n\\frac{1}{2}\\sum\\limits_{u, i}^{}(a_{ui} - \\sum\\limits_{j}^{}w_{ij}a_{uj})^{2} + \n\\lambda \\sum\\limits_{i,j}^{}|w_{ij}| +\n\\frac{\\beta}{2}\\sum\\limits_{i, j}^{}(w_{ij})^2 \\xrightarrow{} \\min_{W}\n$$\n\nМожно заметить, что задачу можно разбить на $D$ независимых по строкам матрицы $W$:\n\n$$\n\\frac{1}{2}\\sum\\limits_{u}^{}(a_{ui} - \\sum\\limits_{j}^{}w_{ij}a_{uj})^{2} + \n\\lambda \\sum\\limits_{j}^{}|w_{ij}| +\n\\frac{\\beta}{2}\\sum\\limits_{j}^{}(w_{ij})^2 \\xrightarrow{} \\min_{w_{i1}, ..., w_{iD}} (\\forall i)\n$$\n\nДанную задачу можно решать покоординатным спуском:\n1. Фиксируем все строки $W$, кроме одной координаты $w_{ij}$;\n2. переходим в оптимум по $w_{ij}$;\n3. переходим к следующей координате;\n4. повторять до сходимости.\n\nПрименение данной модели выглядит следующим образом:\n1. Рассчитываем вектор взаимодействий пользователя $(u_{ui})_{i=1}^D$;\n2. Считаем $at{a}_{ui}$ для всех непросмотренных объектов;\n3. Отбираем топ $k$ непросмотренных объектов по $\\hat{a}_{ui}$.\n\nТак как в задаче оптимизации мы пользуемся $L_{1}$-регуляризацией, матрица $W$ получается разреженной. Матрица просмотров $A$ тоже разреженная (по определению). Эти обстоятельства позволяют заметно улучшить эффективность применения модели.\n\n## Итоги\n\nВ этом параграфе мы рассмотрели некоторые рекомендательные модели на основе матричных факторизаций. Такие модели редко используется в чистом виде для формирования рекомендательной выдачи. Обычно результаты матричной факторизации используются для генерации кандидатов в рекомендации, когда из сотен тысяч и миллионов объектов необходимо отобрать небольшое количество (например, сотни) самых релевантных. Для генерации кандидатов требуется перемножить вектор пользователя с вектором каждого из сотен тысяч объектов и отобрать топ самых релевантных. \n\nВ онлайн-сервисах, когда время формирования рекомендаций составляет несколько сотен миллисекунд, нет возможности при каждом запросе рассчитывать релевантность каждого объекта для данного пользователя. Оптимизировать поиск можно с помощью инструментов для поиска ближайших соседей. Для любой функции близости, в том числе и для скалярного произведения, можно построить индекс – структуру данных, с помощью которой для любого пользователя мы сможем быстро приближённо, но зато быстро искать «ближайшие» объекты. В результате, принцип работы выглядит следующим образом: \n\n- обучаются эмбеддинги объектов и пользователей;\n- для представлений эмбеддингов строится индекс; \n- в рантайме по вектору пользователя происходит приближённый поиск $n$ самых релевантных объектов; таким образом генерируется список кандидатов в рекомендации;\n- дальше список кандидатов обрабатывается с помощью более хитрых методов машинного обучения.\n\nПодробнее о том, как быстро искать ближайших соседей, вы можете узнать в параграфе посвященном [метрическим методам](https://education.yandex.ru/handbook/ml/article/metricheskiye-metody)\n\nПомимо генерации кандидатов, полученные представления можно использовать в качестве признаков в более сложных моделях.\n\nОсновной недостаток методов, основанных на матричной факторизации, состоит в том, что они используют лишь информацию о взаимодействии пользователей и объектов, но не о них самих. В следующем параграфе мы рассмотрим [контентные методы](https://education.yandex.ru/handbook/ml/article/kontentnye-rekomendacii), которые используют атрибуты объектов и пользователей.\n\n## Список литературы\n\n- [Статья](http://yifanhu.net/PUB/cf.pdf) про Implicit ALS\n- [Статья](https://people.engr.tamu.edu/huangrh/Spring16/papers_course/matrix_factorization.pdf) про SVD++\n- [Статья](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.379.1951&rep=rep1&type=pdf) про TimeSVD++\n- [Статья](http://glaros.dtc.umn.edu/gkhome/node/774) про SLIM\n- [Пост](https://sifter.org/simon/journal/20061211.html) Саймона Фанка про участие в конкурсе Netflix Prize",
        "handbook": "Учебник по машинному обучению",
        "title": "Рекомендации на основе матричных разложений",
        "description": null
    },
    {
        "path": "/handbook/ml/article/kontentnye-rekomendacii",
        "content": "## Введение\n\nВсе рекомендательные системы можно поделить на три типа в зависимости от того, какую информацию они используют для построения рекомендаций:\n\n- Контентные;\n- Коллаборативые;\n- Гибридные.\n\nВ данном разделе мы подробнее рассмотрим основные алгоритмы построения контентных рекомендаций.\n\nОсновная идея контентных рекомендаций состоит в том, что для их построения будут использоваться атрибуты объектов и пользователей. На основе данных атрибутов мы можем найти релевантные данному пользователю объекты и рекомендовать их.\n\nПредставим, например, что мы работаем в музыкальном онлайн-сервисе и хотим подбирать наиболее релевантную музыку нашим пользователям. Допустим у нас есть пользователь Иван, который интересуется русским роком. Тогда наша система может рекомендовать Ивану музыку этого или подобных жанров. \n\nМожно придумать много различных атрибутов трека: жанр, автор, год выхода, продолжительность и так далее. Также можно использовать дополнительную информацию о пользователе: возраст, уровень дохода и тому подобные.\n\n### Какими бывают контентные признаки\n\nДопустим, мы работаем в музыкальном сервисе. Тогда в качестве признаков объектов можно использовать: \n\n1. Стандартные статистики объекта: количество лайков, кликов, полных прослушиваний;\n2. Признаки автора: количество слушателей, жанр;\n3. Неструктурированные данные: названия треков, обложки альбомов или даже предобученные эмбеддинги треков целиком.\n\nВ качестве признаков пользователей можно использовать:\n\n1. Информацию про пользователя, если она нам доступна: возраст, пол, язык, насколько долго пользуется сервисом;\n2. Информацию про контекст запроса: с какого устройства был сделан, в какое время.\n3. Информацию про друзей пользователя и их взаимодействия. Например, усреднённый эмбеддинг всех треков, которые слушал каждый из друзей. Или же можно обучить RNN или Transformer на истории и результат конкатенировать к остальным признакам.\n\n## Факторизационные машины\n\nНачнём с постановки задачи. Пусть I – множество объектов (айтемов), U - множество пользователей. Для каждой пары объект-пользователь построим вектор размерности $\\vert U\\vert + \\vert I\\vert$ взаимодействия этой пары, в котором единицы стоят на месте соответствующих пользователя и объекта:\n\n![one_hot_user_item_b8c1678dc9_013706689e.svg](https://yastatic.net/s3/education-portal/media/one_hot_user_item_b8c1678dc9_013706689e_51661596dd.svg)\n\nПредсказывать будем пользовательские рейтинги объектов $a(x)$.\n\nМожно рассмотреть простейшую регрессионную модель:\n\n$$ a(x) = w_0 + \\sum_{t=1}^{\\vert U\\vert + \\vert I\\vert} w_t x_t $$\n\nЗаметим, что к этой модели легко добавить любые фичи объектов, пользователей или пар объект-пользователь:\n\n![factorization_machines_with_content_0dcffc3780_20df998b08.svg](https://yastatic.net/s3/education-portal/media/factorization_machines_with_content_0dcffc3780_20df998b08_6965e8beab.svg)\n\nДальше будем обозначать через $n$ общее число фичей. Модель можно обогатить признаками, отвечающими за взаимодействия второго порядка:\n\n$$ a(x) = w_0 + \\sum_{t=1}^n w_t x_t + \\sum_{r=1}^n \\sum_{s=r+1}^n w_{rs} x_r x_s $$\n\nМатрицу $W = (w_{rs})$ можно считать симметричной: в любом случае, мы используем только её верхний треугольник.\n\nИз-за использования попарных взаимодействий пользователей и объектов в полученной модели будет $\\frac{n(n+1)}{2} +n + 1$ параметр, и так как $n\\geqslant\\vert U\\vert + \\vert I\\vert$ может быть очень большим, работать с такой моделью может оказаться непросто.\n\nДля решения этой проблемы можно использовать следующий трюк. Сопоставим каждому признаку $x_t$ вектор $v_t \\in \\mathbb{R}^k$ для некоторого не очень большого $k$ и представим модель в виде:\n\n$$ a(x) = w_0 + \\sum_{t=1}^n w_t x_t  + \\sum_{r=1}^n\\sum_{s=r+1}^m <v_r, v_s> x_r x_s $$\n\nТаким образом, мы заменяем симметричную матрицу коэффициентов $W$ на её низкоранговое приближение $V^T V$, где $V$ – матрица $n \\times k$ с векторами $v_i$ по столбцам. Число параметров модели при этом можно снизить до $nk + n + 1$. На практике матрица $W$ разреженная, и, как правило, даже при небольшом $k$ получается её неплохо приблизить. В то же время, при небольших $k$ модель обладает лучшей обобщающей способностью.\n\nВычислить $\\sum_{r=1}^n \\sum_{s=1}^m w_{rs} x_r x_s$ по можно за $O(nk)$:\n\n$$ \\sum_{r=1}^n \\sum_{s=r+1}^n <v_r, v_s> x_r x_s = $$\n\n$$ = \\frac12 \\sum_{r=1}^n \\sum_{s=1}^n <v_r, v_s> x_r x_s - \\frac12 \\sum_{r=1}^n <v_i, v_i> x_i x_i = $$ \n\n$$ = \\frac12 \\sum_{r=1}^n \\sum_{s=1}^n \\sum_{f=1}^k v_{rf} v_{sf} x_r x_s - \\frac12 \\sum_{r=1}^n \\sum_{f=1}^k v_{rf} v_{sf} x_r x_s = $$\n\n$$ = \\frac12 \\sum_{f=1}^k \\left(\\sum_{r=1}^n v_{rf} x_r) \\cdot (\\sum_{s=1}^n v_{sf} x_s) - \\sum_{r=1}^n v_{rf}^2 x_r^2 \\right) = $$\n\n$$ = \\frac12 \\sum_{f=1}^k \\left((\\sum_{r=1}^n v_{rf} x_r)^2 - \\sum_{r=1}^n v_{rf}^2 x_r^2 \\right)$$ \n\nИтоговая модель имеет вид\n\n$$\na(x) = w_0 + \\sum_{r=1}^n w_r x_r + \\frac12 \\left|\\left| \\sum_{r=1}^n v_r x_r \\right|\\right|_2^2 - \\frac12 \\sum_{r=1}^n ||v_r||_2^2x_r^2\n$$\n\nДанная модель и называется **факторизационной машиной**.\n\nПервоначально факторизационные машины использовали только коллаборативный сигнал, но, как мы уже видели, в такую модель можно естественным образом добавить и контентную информацию.\n\nФакторизацонную машину можно обучать для решения разных задач. Например:\n\n- Предсказание рейтинга. Ответ модели $a(x)$ можно интерпретировать, как вещественный рейтинг, и решать задачу регрессии.\n- Бинарную классификацию рекомендовать/не рекомендовать. Тогда $a(x)$ имеет смысл логита, и мы можем оптимизировать оптимизировать log loss или hinge loss.\n- Ранжирование объектов. Тогда $a(x)$ – это ранжирующая функция.\n\nМодель обычно обучается градиентным спуском.\n\n### FFM – Field-aware Factorization Machines \n\n[Оригинальная статья](https://www.csie.ntu.edu.tw/~cjlin/papers/ffm.pdf)\n\n[Статья про практическое применение](https://arxiv.org/pdf/1701.04099.pdf)\n\nКак следующий этап развития факториационных машин, появилась идея иметь несколько различных латентных представлений для каждой из фичей.\n\nПример: есть три разных по своей природе признака: год выпуска, цвет и марка автомобиля. В факторизационной машине для учёта взаимодействия год-цвет и год-марка используется один и тот же вектор для года. Но так как эти признаки разные по смыслу, то и характер их взаимодействия может отличаться.\n\nИдея: использовать 2 разных вектора для признака «год выпуска» при учёте взаимодействий год-цвет и год-марка. Таким образом, модель принимает вид:\n\n$$a(x) = w_0 + \\sum_{t=1}^n w_t x_t  + \\sum_{r=1}^n\\sum_{s=r+1}^m <v_{r,s}, v_{s,r}> x_r x_s$$\n\n![FFM_659f00db4d.webp](https://yastatic.net/s3/education-portal/media/FFM_659f00db4d_8c9f5b0e2a.webp)\n\nАвторы статьи выложили [исходный код своей библиотеки libffm](https://github.com/ycjuan/libffm), с помощью которой они смогли войти в топ-3 сразу в трёх соревнованиях на kaggle (Criteo, Avazu, Outbrain). Подробнее об этом можно почитать [вот тут](https://www.csie.ntu.edu.tw/~r01922136/libffm/).\n\n## DSSM (deep sematic similiarity model)\n\nТеперь рассмотрим ещё одну популярную модель, которая использует контентную информацию для построения рекомендаций – **DSSM**.\n\n[Оригинальная статья](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/cikm2013_DSSM_fullversion.pdf)\n\nВ оригинальной статье DSSM была использована для нахождения «схожести» между поисковым запросом и документом. Для этого она использовала текст запроса и текст документа. \n\nDSSM представляет из себя «двуногую» (two-tower) нейронную сеть. В исходной постановке на первый вход подаётся текст запроса, а на второй – текст документа. Далее, независимо для текста запроса и текста документа строятся эмбеддинги. Итоговая «схожесть» вычисляется, как косинусная мера близости между ними.\n\nНа схеме ниже Q – это запрос (query), а D – документ (document).\n\n![DSSM_full_product_softmax_27645fd2c8.webp](https://yastatic.net/s3/education-portal/media/DSSM_full_product_softmax_27645fd2c8_4756f6f976.webp)\n\nНекоторые авторы пытались в качестве меры близости рассматривать вместо косинусной меры обучаемый MLP, но это оказалось гиблой идеей.\n\nЭта архитектура оказалась крайне удобной при использовании на практике, так как эмбеддинги пользователя и объекта можно предподсчитать независимо и дальше хранить сразу готовые представления для них, а при запросе к рекомендациям просто пересчитывать меру близости, что ускоряет применение модели.\n\nДанная идея хорошо обобщается на построение рекомендаций. Поиск релевантных объектов можно представить, как задачу ранжирования, где вместо текстов запроса и документа мы будем иметь некоторую контентную информацию о пользователе и объекте.\n\n### Обучение DSSM\n\nДавайте считать, что мы для каждого запроса $q$ предсказываем один релевантный документ.\n\nОбозначим через $y_q$ и $y_d$ построенные моделью эмбеддинги запроса $q$ и документа $d$ соответственно. Будем вычислять условную вероятность клика по документу $d$ при условии запроса $q$ следующим образом:\n\n$$P(d\\vert q)  = \\frac{\\exp(b_0 R(q, d))}{\\sum_{i=1}^D \\exp(b_0 R(q, d_i))}$$\n\nгде \n\n$$ R(q, d) = \\cos(y_q, y_d) = \\frac{y_q^T y_d}{||y_q|| \\cdot ||y_d||}$$\n\nЗдесь $b_0$ – коэффициент сглаживания, который подбирается эмпирически, а $D$ – число всех документов.\n\nЕсли в качестве функции потерь мы выбираем кросс-энтропию, то на паре запрос-кликнутый документ $(q, d^+)$ она принимает вид\n\n$$ \\mathcal{L}(q, d^+) = -log(P(d^+\\vert q)).$$\n\nНо вычислять градиент такого функционала для каждого примера дорого, ведь для этого придётся для каждого запроса находить вероятность клика по всем документам. Что же делать? На помощь приходит **negative sampling**. Заметим, что среди документов $d$ в знаменателе $P(d\\vert q)$ есть лишь один кликнутый, а остальные тысячи и миллионы являются отрицательными примерами. Есть смысл на каждом шаге оптимизации рассматривать не все из них, а только небольшую выборку, вместо полной суммы\n\n$$\\sum_{i=1}^D \\exp(b_0 R(q, d_i))$$\n\nберя\n\n$$\\exp(b_0 R(q, d^+)) + \\sum_{i=1}^k \\exp(b_0 R(q, d^-_i)),$$\n\nгде $d^-_1,\\ldots,d^-_k$ – подобранные для запроса $q$ негативные примеры. Генерировать их можно по-разному; на практике чаще всего используют одну из следующих стратегий:\n\n1. Равновероятно выбирать подмножество документов из некликнутых. В оригинальной статье предлагают брать позитивные и негативные в соотношении $4:1$. \n2. С большей вероятностью выбирать те из некликнутых документов, популярность которых выше.\n3. На каждой эпохе обучения выбирать некликнутые документы, получившие максимальный скор для этого запроса на предыдущей эпохе.\n\n### Другие функции потерь\n\n#### Pairwise loss \n\nЗадачу построения рекомендаций можно решать, как задачу ранжирования. Например, это можно делать с помощью попарного лосса. А именно, рассмотрим пару объектов, в которой $i_1$ – релевантный, а $i_2$ не релевантный для пользователя $u$. Тогда мы можем использовать один из двух вариантов функции потерь:\n\n- $\\mathcal{L}(R(u, i_1), R(u, i_2)) = \\text{CrossEntropy}(1.0, \\sigma(R(u, i_1) - R(u, i_2)))$. Тем самым модель будет учиться ранжировать положительные примеры выше отрицательных.\n\n- $\\mathcal{L}(R(u, i_1), R(u, i_2)) = \\max(0, \\alpha - R(u, i_1) + R(u, i_2))$ (triplet loss). При этом модель обучается так, чтобы положительный и отрицательный примеры как можно больше отличались. Эта функция потерь довольно популярна не только в DSSM сетках, но и в целом в задачах, где нужно обучить парные представления $(y_q, y_d)$ объектов $(q, d)$ из разных доменов так, чтобы для релевантных друг другу $q$ и $d$ эмбеддинги оказывались близкими, а для не релевантных далёкими.\n\n#### Full Product Softmax loss\n\nРассмотрим батч $(u_1, i_1, r_1),\\ldots, (u_M, i_M, r_M)$ размера $M$, где $u_t$ – пользователь, $i_t$ – пользователю, а $r_t$ – таргет, степень релевантности объекта пользователю. Построим по ним:\n\n- матрицу эмбеддингов пользователей $U \\in \\mathbb{R}^{M \\times D}$;\n- матрицу эмбеддингов объектов $W \\in \\mathbb{R}^{M \\times D}$;\n- вектор таргетов $r \\in \\mathbb{R}^M$.\n\nРассмотрим матрицу \n\n$$\\text{softmax}(\\alpha U W^T + \\beta), U W^T \\in \\mathbb{R}^{M \\times M},$$\n\nгде softmax берётся по строкам\n\n![DSSM_full_product_softmax_27645fd2c8.webp](https://yastatic.net/s3/education-portal/media/DSSM_full_product_softmax_27645fd2c8_5e53be04fe.webp)\n\nРассмотрим функцию потерь вид\n\n$$ L = -\\mathbb{I}\\{r > 0\\}^T \\cdot \\log(\\text{diag}(\\text{softmax}(\\alpha U W^T + \\beta)))$$\n\nЭта функция потерь старается сделать так, чтобы для релевантных друг другу (с $r > 0$) пар $(u, i)$ скалярное произведение эмбеддингов $\\langle w_u, w_i\\rangle$ было максимальным.\n\n## Трансформеры для рекомендаций\n\nВ 2018 году появилась архитектура трансформеров на основе механизма внимания. Модели на основе трансформеров показали state-of-the-art результаты на большом числе NLP задач, а впоследствии оказалось, что они отлично подходят и для задач компьютерного зрения. С их помощью можно решать и задачи рекомендаций. Аналогия заключается в следующем: если в NLP трансформеры работают с последовательностями токенов, то в рекомендациях в качестве последовательности можно взять историю событий пользователя. Каждый элемент последовательности – это взаимодействие пользователя с объектом, например, клик на объект.\n\nКлассические модели рекомендаций часто игнорируют тот факт, что история пользователя – это направленная последовательность, в которой порядок событий имеет значение. Трансформеры позволяют учитывать как порядок событий, так и сложные паттерны в поведении и интересах пользователя. Например, исследователи из Alibaba представили модель, которую назвали Behaviour Sequence Transformer. Авторы заявляют, что модель используется в продакшене. Модель решает задачу Click Through Rate (CTR) prediction – предсказание вероятности клика по объекту. \n\n![transformer_ea88a1cd77.webp](https://yastatic.net/s3/education-portal/media/transformer_ea88a1cd77_b6f60a80db.webp)\n\nНа вход модели подается история кликов пользователя, на основе которой нужно предсказать вероятность клика по заданному объекту. Роль архитектуры трансформера здесь в том, чтобы качественно закодировать представление пользователя, после чего применяется обычный multi layer perceptron (MLP) для предсказания вероятности.\n\nПомимо архитектур, которые специально разрабатываются под задачи рекомендаций, трансформеры можно использовать и как обособленные предобученные модели для построения векторых представлений текстов или изображений, которые затем подаются как признаки для решения downstream задач в домене рекомендаций. Несмотря на очевидные преимущества трансформеров с точки зрения качества, их использование в продакшене часто ограничивается имеющимися вычислительными ресурсами. Это особенно актуально для рекомендаций, где модели важно применять непосредственно в момент запроса пользователя.",
        "handbook": "Учебник по машинному обучению",
        "title": "Контентные рекомендации",
        "description": null
    },
    {
        "path": "/handbook/ml/article/horoshie-svojstva-rekomendatelnyh-sistem",
        "content": "## Введение\n\nПредположим, выдача нашей рекомендательной системы имеет высокие значения метрик ранжирования. Значит ли это, что система действительно хорошая? Не всегда просто ответить на этот вопрос. Оптимизируя определенные метрики, можно выкрутить кликбейт, и пользователи будут охотно кликать в моменте, но больше не станут пользоваться таким сервисом. Соответственно, нужно как-то измерять «счастье пользователей», попытаться формализовать свойства, которыми должна обладать хорошая рекомендательная система. Однозначного ответа на этот вопрос нет, всё зависит от контекста применения рекомендательной системы. В этом разделе мы поговорим о наиболее распространённых критерях, которые довольно часто оказываются важными.\n\n## Полнота (Coverage)\n\nПод полнотой в данном контексте понимается доля рекомендованных объектов $I_{recommended}$ среди всех объектов $I$. \n\n$$\nCoverage = \\frac{|I_{recommended}|}{|I|}\n$$\n\nЭта метрика была предложенна в статье Ge, M., Delgado-Battenfeld, C., Jannach, D. (2010, September). Beyond accuracy: evaluating recommender systems by coverage and serendipity. In Proceedings of the fourth ACM conference on Recommender systems (pp. 257-260).\n\nДанную метрику имеет смысл оценивать в разных временных интервалах, при этом принимая во внимание возможные ограничения, связанные с объемом данных. Например, нас может интересовать значение полноты за первый день работы рекомендательной системы, а может – за неделю. Целевое поведение полноты будет различаться в зависимости от доменных областей и бизнес деталей конкретного случая. Например, в рекомендациях музыки может быть полезно периодически повторно рекомендовать треки, которые пользователю в наибольшей степени нравятся, так как пользователь может захотеть послушать их еще раз. В то же время в рекомендациях фильмов это реже оказывается осмысленным: обычно проходит много времени, прежде чем пользователь захочет пересмотреть фильм. Таким образом, во втором случае полнота будет расти быстрее за счет отсутствия повторов. \n\nЕще одним фактором, влияющим на полноту, является алгоритм холодного старта, который может использоваться для того чтобы найти подходящие объекты для нового пользователя или подходящих пользователей для нового объекта. Часто пользователям на этапе холодного старта показывают самые популярные объекты. Из-за этого свежедобавленные объекты (например, музыкальные треки) могут неявно пессмимизироваться алгоритмом. Один из способов решения проблемы – бустить свежие объекты в течение определённого времени, чтобы они показывались чаще. Настроки логики холодного старта могут сильно повлиять на метрику полноты.\n\nСреди других актуальных вопросов, которыми стоит задаваться: \n\n- Cколько нужно дней, чтобы полнота достигала заданного значения $p$? \n- Возможно ли достичь такого значения в принципе, используя текущий алгоритм? \n\nЧтобы ответить на эти вопросы, нужно принимать во внимание ряд факторов: \n\n- Какой объём трафика у системы рекомендаций? \n- Есть ли у бизнеса ограничения, влияющие на конечный список рекомендаций? \n- Имеет ли алгоритм рекомендаций достаточную степень персонализации? \n- Можно ли регулировать режимы exploration и exploitation во время работы рекомендательной системы?\n\nКаждый из этих факторов может по-разному влиять на динамику полноты. Бизнес ограничения и слабая степень персонализации могут сдерживать рост полноты. Напротив, если модель высокоперсонализированная и учитывает много пользовательских факторов, то она способна рекомендовать больше уникальных объектов из хвоста распределения, которые тоже могут ему понравиться, тем самым обеспечивая рост полноты.\n\n## Новизна (Novelty)\n\nОдин из способов оценить новизну рекомендательной системы – использовать статистическую меру собственной информации объекта (self information), которая используется в теории информации и тесно связана с понятием энтропии. Значение собственной информации для события $X$ равняется логарифму вероятности наступления данного события. Согласно теории, чем меньше вероятность наступления события, тем больше потенциальной информации принесет это событие при его наступлении. Единицей информации при использовании логарифма по основании $2$ является бит.\n\nТеперь если переносить идею собственной информации в парадигму рекомендательных систем, то получается, что чем менее популярен объект, тем более вероятно, что он будет новым для пользователя. А значит мера информации у такого объекта будет выше. Для каждого рекомендованного объекта $i$ считаем вероятность, с которой его порекомендуют случайному пользователю: $ P_{i} = \\frac{m_{i}}{N} $, где $ m_{i} $ – количество пользователей, которым был показан $i$-й объект, а $N$ – общее число пользователей. Для заданного пользователя усредняем значение собственной информации по списку его рекомендаций $R$ и получаем итоговое значение метрики:\n\n$$\nNovelty_{user} = \\frac{1}{|R|}\\sum_{i\\in R}^{}-log(P(i))\n$$\n\n## Разнообразие (Diversity) \n\nРазнообразие – это способность модели рекомендовать разные по содержанию объекты. Такое свойство очень важно для долгосрочного успеха сервисов, основанных на рекомендательных системах. Действительно, если модель постоянно рекомендует похожие друг на друга объекты, то рано или поздно пользователю наскучат такие рекомендации. \n\n![diversity_4b72cbf150.webp](https://yastatic.net/s3/education-portal/media/diversity_4b72cbf150_c6708d3208.webp)\n\nРазнообразие можно рассчитывать на основе комбинаций метрик полноты и новизны. Также мерой разнообразия может быть дисперсия рекомендаций за заданный промежуток времени. Помимо этого популярны подходы, использующие эмбединги объектов для оценки попарной похожести объектов и расчёта на основе неё значения разнообразия. Одна из таких метрик – Intra List Similarity (ILS). Чтобы ее посчитать, нужно иметь эмбединги объектов рекомендаций, находящиеся в едином векторном пространстве. Для расчёта разнообразия для одного пользователя нужно усреднить попарную схожесть $\\text{sim}$ между рекомендованными объектами:\n\n$$\nILS_{user} = \\frac{1}{R}\\sum_{i\\epsilon R}^{}\\sum_{j\\epsilon R}^{}\\text{sim}(i,j),\n$$\n\nгде $R$ – это набор рекомендованных пользователю объектов.\n\nДля того чтобы добиться большего разнообразия, метрику нужно минимизировать. Мера схожести должна быть *больше* для более похожих объектов. Чаще всего используется косинусная близость (cosine similarity).\n\n## Serendipity\n\nОдно из самых желанных свойств для любой рекомендательной системы. У слова serendipity нет четкого перевода, в 2008 году оно даже [попало в список самых неподдающихся переводу слов в мире](http://www.todaytranslations.com/blog/most-untranslatable-word/). На русский иногда оно переводится как «интуитивная прозорливость». \n\nSerendipity – это способность рекомендовать такие объекты, которые не только релевантны для пользователя, но ещё и существенно отличаются от того, с какими объектами пользователь взаимодействовал в прошлом.\n\n![serendipity_52a0a5da8c_8e0517ac0b.svg](https://yastatic.net/s3/education-portal/media/serendipity_52a0a5da8c_8e0517ac0b_633c54ae13.svg)\n\nSerendipity – довольно субъективное свойство и его сложно формализовать. Более того рекомендации, удовлетворяющие этому свойству, встречаются редко, что усложняет интерпретацию и измерение serendipity. Нет консенсуса о том, какой метрикой можно оценить его. Мы расскажем о способе, предложенном в статье T. Murakami, K. Mori, R. Orihara, Metrics for evaluating the serendipity of recommendation lists, in: New Frontiers in Artificial Intelligence, Vol. 4914, Springer Berlin Heidelberg, Berlin, Heidelberg, 2008, pp. 40–46.\n\nПусть $R_{u}$ – список рекомендаций для пользователя, $\\text{Pr}_{u}(i)$ – предсказание модели, для каждого объекта из списка, а $\\text{Prim}_{u}(i)$ – предсказание примитивной модели (в качестве примитивной можно брать модель на основе эвристик без машинного обучения или простую неперсональную модель), а $\\text{rel}$ – известная релевантность объекта для пользователя. Тогда Serendipity рассчитывается следующим образом:\n\n$$\nSerendipity_{user} = \\sum_{i\\epsilon R}^{}max(\\text{Pr}_{u}(i)-\\text{Prim}_{u}(i), 0) \\cdot {\\text{rel}_{u}(i)}\n$$\n\nЗначение метрики можно усреднить по всем пользователям тестовой выборки. Чем больше значение, тем больше модель удовлетворяет свойству Serendipity.\n\nКлючевая идея формулы такова: если уверенность персонализированной модели в том, что пользователю понравится $i$-ый айтем, больше, чем уверенность неперсональной модели (примитивной), это значит, что данному пользователю может особенно понравиться $i$-й айтем.\n\nОтдельный вопрос – как оптимизировать Serendipity. Нужно улучшать способность модели к персонализации: \n\n- добавлять больше фичей для пар (пользователь, объект); \n- взвешивать таргеты, чтобы более тонко учитывать необычные клики/просмотры;\n- писать кастомные функции потерь, которые будут поощрять модель за буст неожиданныйх объектов (которые в большей степени удовлетворяют свойству serendipity).\n\nКроме того, имеет смысл оптимизировать модель по метрике serendipity на офлайн тестовой выборке.\n\n## Заключение\n\nВ этом разделе мы рассмотрели ключевые свойства рекомендательных систем и метрики для их оценки. Рекомендательные системы – сложная область, где нет готовых рецептов оценки качества. Ключевые метрики всегда идут от продуктовых деталей применения рекомендательной системы. Полезно смотреть на несколько метрик одновременно, чтобы оценить разные свойства моделей.\n\nВ какой момент нужно начинать следить за метриками из данного раздела? Несмотря на их ценность, на начальном этапе стоит концентрироваться на более простых и интуитивно понятных с точки зрения бизнеса метриках: конверсии, среднем времени визита и так далее. А вот как только базовые метрики будут на удовлетворительном уровне, стоит начинать мониторить и оптимизировать метрики, разобранные в этом разделе.",
        "handbook": "Учебник по машинному обучению",
        "title": "Хорошие свойства рекомендательных систем",
        "description": null
    },
    {
        "path": "/handbook/ml/article/klasterizaciya",
        "content": "## Задача кластеризации\n\nВ задаче классификации мы имели дело с восстановлением отображения из множества объектов в конечный набор меток классов. При этом классы были зафиксированы заранее, то есть мы с самого начала примерно понимали, какого рода объекты должны относиться к каждому из них, и мы располагали обучающей выборкой с примерами объектов и классов, к которым они относятся. В задаче кластеризации мы тоже разбиваем объекты на конечное множество классов, но у нас нет ни обучающей выборки, ни понимания, какой будет природа этих классов. То, что модель кластеризации какие-то объекты сочла «похожими», отнеся к одному классу, будет новой информацией, «открытием», сделанным этой моделью. Обучающей выборки у нас также не будет: ведь мы не знаем заранее, что за классы получатся (а иногда и сколько их будет). Таким образом, **кластеризация** — это задача обучения без учителя. Из-за общего сходства постановок задач в литературе кластеризацию иногда называют **unsupervised classification**. \n\nМетоды кластеризации часто применяют, когда фактически нужно решить задачу классификации, но обучающую выборку собрать затруднительно (дорого или долго). При этом валидационную выборку для оценки результатов кластеризации собрать значительно проще, так как для неё требуется меньше примеров. При этом стоит помнить, что точность работы supervised-методов значительно выше. Поэтому, если обучающую выборку всё-таки можно собрать, лучше решать задачу классификации, чем задачу кластеризации.\n\n## Примеры задач кластеризации\n\nХороший пример применения методов кластеризации — анализ геоданных. В мобильных приложениях, собирающих геоданные пользователей, часто требуется понять, где именно пользователь находился. GPS-координаты известны с некоторой погрешностью, пользователь тоже обычно двигается, поэтому вместо точного положения часто приходится иметь дело с роем точек. Положение усугубляется, когда мы пытаемся анализировать поведение сразу тысяч людей в какой-то локации — например, определить, в каких точках люди чаще всего садятся в такси у аэропорта. Может показаться, что достаточно посмотреть на данные — и мы увидим в точности нужные нам кластеры. Изображение ниже показывает, как может выглядеть ситуация всего для нескольких пользователей: согласно данным GPS, такси подбирают пассажиров и внутри здания аэропорта, и на взлётной полосе, и там, где это происходит на самом деле:\n\n![19_1_54408bffaa.webp](https://yastatic.net/s3/education-portal/media/19_1_54408bffaa_7f0ab021e1.webp)\n\nПодобная задача решалась в Яндекс.Такси при разработке пикап-пойнтов (наиболее удобных точек вызова такси, подсвечиваемых в приложении). Координаты точек заказа кластеризовались таким образом, чтобы кластер соответствовал какому-то одному, удобному для пользователя месту, и центры кластеров использовались как кандидаты в пикап-пойнты. Те кандидаты, которые удовлетворяли простым фильтрам (например, не попадали в здание или в воду), использовались в приложении. При этом не обходилось и без вручную проставленных пикап-пойнтов: например, такое решение использовалось в окрестностях аэропортов.\n\nДругой пример кластеризации геоданных, который всегда рядом с нами, — это интерфейсы для просмотра фотографий в вашем смартфоне. Почти наверняка вы можете просмотреть их в привязке к местам, где они были сделаны, и по мере масштабирования карты вы будете видеть разное количество кластеров фотографий. Кстати, если говорить об интерфейсах, то есть и другой интересный пример: если нужно подстроить цветовую схему вашего интерфейса под выбираемое пользователем изображение (например, фоновую картинку), достаточно кластеризовать цвета из пользовательского изображения, используя RGB-представление (или любое другое) как признаки цвета, и воспользоваться для оформления цветами, соответствующими центрам кластеров.\n\n## Простейшие методы кластеризации с помощью графов\n\nМожно приводить примеры не только про геоаналитику, однако тема геоданных поможет нам придумать пару наиболее простых и наглядных методов кластеризации. Представим, что перед нами рой геокоординат и нам нужно предложить по этим данным пикап-пойнты для такси. Разберём пару очевидных методов.\n\n### Выделение компонент связности\n\nЛогично попробовать объединить точки, которые находятся друг от друга на расстоянии двух-трёх метров, а потом просто выбрать наиболее популярные места. Для этого давайте построим на известных нам точках граф: точки, расстояние между которыми в пределах трёх метров, мы соединим рёбрами. Выделим в этом графе компоненты связности, они и будут нашими кластерами.\n\nУ этого способа есть пара очевидных недостатков. Во-первых, может найтись сколько угодно длинная цепочка точек, в которой соседние отстоят друг от друга на пару метров, — и вся она попадёт в одну компоненту связности. В итоге наша отсечка по трём метрам имеет очень опосредованное отношение к диаметру кластеров, а сами кластеры будут получаться значительно больше, чем нам хотелось бы. Во-вторых (и с первой проблемой это тоже связано), непонятно, как мы выбираем максимальное расстояние, при котором соединяем точки ребром. В данной задаче ещё можно предъявить хоть какую-то логику, а вот если бы мы кластеризовали не геометки, а что-то многомерное, например электронные письма по их тематике, придумать отсечку было бы уже сложнее. Если наша цель — не только решить практическую задачу, но и придумать достаточно общий метод кластеризации, понятно, что нам хочется понимать, как подбирать параметры этого метода (в данном случае условие добавления рёбер в граф). Эти соображения могут привести нас к другому решению.\n\n### Минимальное остовное дерево\n\nВместо того чтобы проводить рёбра в графе, давайте их удалять. Построим [минимальное остовное дерево](https://ru.wikipedia.org/wiki/Минимальное_остовное_дерево), считая расстояния между точками весами рёбер. Тогда, удалив $N$ рёбер с наибольшим весом, мы получим $N+1$ компоненту связности, которые, как и в прошлом подходе, будем считать кластерами. Различие в том, что теперь нам нужно задавать не расстояние, при котором проводится ребро, а количество кластеров. С одной стороны, если мы решаем задачу расчёта пикап-пойнтов в какой-то конкретной локации (аэропорт, торговый центр, жилой дом), нам может быть понятно, сколько примерно пикап-пойнтов мы хотим получить. С другой стороны, даже без локального рассмотрения можно просто сделать достаточно много кластеров, чтобы было из чего выбирать, но при этом достаточно мало, чтобы в каждый кластер попадало репрезентативное количество точек. Аналогичная логика будет справедлива и во многих других задачах кластеризации: количество кластеров — достаточно общий и достаточно хорошо интерпретируемый параметр, чтобы настраивать его вручную, поэтому во многих методах кластеризации количество кластеров выступает как гиперпараметр.\n\nДалее будем рассматривать некоторую обобщённую задачу кластеризации без привязки к нашему примеру с анализом геоданных. Мы приведём три наиболее популярных метода кластеризации — k-средних, иерархическую кластеризацию и DBSCAN, а затем рассмотрим вопросы оценки качества кластеризации.\n\n## Метод K средних\n\nПожалуй, один из наиболее популярных методов кластеризации — это метод K-средних (K-means). Основная идея метода — итеративное повторение двух шагов:\n\n1) распределение объектов выборки по кластерам;\n2) пересчёт центров кластеров.\n\nВ начале работы алгоритма выбираются $K$ случайных центров в пространстве признаков. Каждый объект выборки относят к тому кластеру, к центру которого объект оказался ближе. Далее центры кластеров пересчитывают как среднее арифметическое векторов признаков всех вошедших в этот кластер объектов (то есть центр масс кластера). Как только мы обновили центры кластеров, объекты заново перераспределяются по ним, а затем можно снова уточнить положение центров. Процесс продолжается до тех пор, пока центры кластеров не перестанут меняться.\n\n![kmeans_4a27aaf200.gif](https://yastatic.net/s3/education-portal/media/kmeans_4a27aaf200_0c3fe72855.gif)\n\n### Выбор начального приближения\n\nПервый вопрос при выборе начального положения центров — как, выбирая центры из некоторого случайного распределения, не попасть в область пространства признаков, где нет точек выборки. Базовое решение — просто выбрать в качестве центров какие-то из объектов выборки.\n\nВторая потенциальная проблема — кучное размещение центров. В этом случае их начальное положение с большой вероятностью окажется далёким от итогового положения центров кластеров. Например, для таких изначальных положений центров\n\n![19_2_55eb1fbe5f.webp](https://yastatic.net/s3/education-portal/media/19_2_55eb1fbe5f_1bc4d07ce0.webp)\n\nмы получим неправильную кластеризацию.\n\n![19_3_a081b9c158.webp](https://yastatic.net/s3/education-portal/media/19_3_a081b9c158_06b66f9a43.webp)\n\nЧтобы бороться с этим явлением, выгодно брать максимально удаленные друг от друга центры. \n\nНа практике работает следующая эвристика: \n\n1) первый центр выбираем случайно из равномерного распределения на точках выборки;\n2) каждый следующий центр выбираем из случайного распределения на объектах выборки, в котором вероятность выбрать объект пропорциональна квадрату расстояния от него до ближайшего к нему центра кластера.\nМодификация K-means, использующая эту эвристику для выбора начальных приближений, называется K-means++.\n\n### Выбор метрик\n\nТак как работа метода K-средних состоит из последовательного повторения до сходимости двух шагов, обоснованность применения различных метрик (расстояний между точками, а не метрик качества :) или функций близости связана с тем, «ломают» они какой-либо из этих шагов или нет.\n\nПервый шаг с отнесением объектов к ближайшим центрам не зависит от вида метрики. Второй шаг предполагает пересчёт центров как среднего арифметического входящих в кластер точек, и вот здесь будет подвох: к оптимальности выбора центров в среднем арифметическом приводит именно евклидова метрика (подробнее в разделе «Что оптимизирует K-means»).\n\nОднако на практике никто не мешает использовать метод и без должного обоснования, поэтому можно экспериментировать с любыми расстояниями, с той лишь оговоркой, что не будет никаких теоретических гарантий, что метод сработает. Наиболее распространённая альтернатива евклидовой метрике — это косинусная мера близости векторов (она особенно популярна в задачах анализа текстов):\n\n$$CosineSimilarity(\\mu_k, x_i)=\\frac{<\\mu_k, x_i>}{\\|\\mu_k\\|_2 \\cdot \\|x_i\\|_2}$$\n\nПри её использовании стоит не забывать, что косинусная мера — это функция близости, а не расстояние, так что чем больше её значения, тем ближе друг к другу векторы.\n\n### Mini-batch K-means\n\nНесложно заметить, что, если считать $K$ и размерность пространства признаков константами, оба шага алгоритма работают за $O(n)$, где n — количество объектов обучающей выборки. Отсюда возникает идея ускорения работы алгоритма. В mini-batch K-means мы не считаем шаги сразу на всей выборке, а на каждой итерации выбираем случайную подвыборку (мини-батч) и работаем на ней. В случае когда исходная выборка очень велика, переход к пакетной обработке не приводит к большой потере качества, зато значительно ускоряет работу алгоритма.\n\n### Понижение размерности\n\nС другой стороны, вычисление расстояний и средних делается за $O(d)$, где $d$ — размерность пространства признаков, так что другая идея ускорения K-means — это предварительно понизить размерность пространства признаков (с помощью PCA или эмбеддингов). Особенно удачно эта идея работает в задачах кластеризации текстов, когда K-means применяют на эмбеддингах слов: получается выиграть не только в скорости работы, но и в интерпретируемости результатов кластеризации.\n\nКстати, сам алгоритм кластеризации тоже можно использовать как метод понижения размерности. Если вы решаете задачу обучения с учителем и пространство признаков очень разнообразно (то есть обучающая выборка не даёт вам достаточно статистики при столь большом числе признаков), можно выполнить кластеризацию объектов выборки на 500 или 1000 кластеров и оперировать попаданием объектов в какой-то кластер как признаком. Такой подход называется **квантизацией пространства признаков** (**feature space quantization**) и часто помогает на практике, когда нужно огрубить признаки, добавить им интерпретируемости или же, наоборот, обезличить.\n\nХрестоматийный пример такого использования кластеризации — метод bag of visual words, расширяющий bag of words из анализа текстов на работу с изображениями. Идея метода в том, чтобы строить признаковое описание изображений на основе входящих в него фрагментов: так, изображения с лицами будут содержать фрагменты с носом, глазами, ртом, а изображения с машинами — колёса, зеркала, двери. Но проблема здесь в том, что нарезать такие фрагменты из обучающей выборки и искать точные совпадения в новых примерах изображений, которые нужно классифицировать, — безнадёжная затея. В жизни фрагменты изображений не повторяются в других изображениях с попиксельной точностью. Решение этой проблемы оказалось возможным при помощи алгоритмов кластеризации (исторически использовался именно K-means): фрагменты изображений из обучающей выборки кластеризовали на 100–1000 кластеров («визуальных слов»), а проходясь по новым изображениям, также нарезали их на фрагменты и относили к одному из этих кластеров. В итоге как новые изображения, так и изображения из обучающей выборки можно было описать количеством вхождений в них фрагментов из различных кластеров («визуальных слов»), так же как в анализе текстов описывают текст количеством вхождений в него слов из словаря. В таком признаковом пространстве уже можно было успешно обучать модели машинного обучения. \n\nСейчас выделение «визуальных слов» в задаче классификации изображений происходит автоматически: с одной стороны, задачи компьютерного зрения теперь решаются нейросетями, но с другой стороны — если мы визуализируем отдельные слои этих нейросетей, станет понятно, что их логика работы во многом похожа на описанную выше. При этом идея квантизации признаков не утратила своей актуальности. Вот лишь несколько современных примеров её применения:\n\n1. Если вам необходимо дать возможность заказчику (например, внешней компании) анализировать используемые вами признаки — отсутствие провалов в данных и какие-то другие общие показатели, но нельзя отдавать признаки как есть (например, из-за законодательства, регулирующего передачу пользовательских данных), возможное решение — это агрегировать признаки по кластерам.\n2. Та же цель может быть отчасти достигнута, если перейти к самим кластерам как к признакам, чтобы скрыть исходные признаки.\n3. Переход к кластерам может быть сделан не с целью что-то скрыть, а наоборот, с целью повысить интерпретируемость: исходные сырые данные часто не вполне понятны бизнесу, но позволяют построить маркетинговые сегменты по различным коммерческим интересам пользователей, из-за чего становится удобно показывать принадлежность к этим сегментам как исходные признаки, не вдаваясь в детали о том, на каких данных эти сегменты построены.\n4. Для ускорения поиска похожих объектов в пространстве признаков вы также можете проводить поиск внутри того же кластера и соседних кластеров, так что за счёт «огрублённого» вида признаков какие-то процессы можно ещё и ускорить.\n\n### Что оптимизирует K-means\n\nПроговорим на интуитивном уровне, какую оптимизационную задачу решает K-means.\n\nОба шага алгоритма работают на уменьшение среднего квадрата евклидова расстояния от объектов до центров их кластеров:\n\n$$\\Phi_0 = \\frac{1}{nK} \\sum\\limits_{k=1}^{K} \\sum\\limits_{i=1}^{n} (\\mu_k - x_i)^2 \\mathbb{I}[a(x_i)=k]$$\n\nНа шаге отнесения объектов к одному из кластеров мы выбираем кластер с ближайшим центроидом, то есть минимизируем каждое слагаемое в $\\Phi_0$: все потенциально большие слагаемые мы зануляем, а оставляем ненулевыми только наименьшие из возможных (при условии фиксирования центров кластеров).\n\nНа шаге пересчёта центров кластеров мы выбираем центр таким образом, чтобы при фиксированном наборе объектов, относящихся к кластеру, для всех $k$ минимизировать выражение, стоящее под суммой по $k$:\n\n$$\\sum\\limits_{i=1}^{n}  (\\mu_k - x_i)^2 \\mathbb{I}[a(x_i)=k]$$\n\nЗдесь уже становится принципиально, что мы определяем квадрат расстояния как квадрат разности векторов, так как именно отсюда при дифференцировании по $\\mu_k$ и записи необходимого условия экстремума получается, что центры кластеров нужно пересчитывать как средние арифметические $x_i$, принадлежащих кластеру.\n\nЭтих соображений, конечно, недостаточно, чтобы утверждать, что мы найдём минимум $\\Phi_0$. Более того, гарантии того, что мы найдём глобальный минимум, вообще говоря, нет. Однако, потратив чуть больше усилий, можно доказать, что процесс сойдётся в один из локальных минимумов.\n\nТакже можно справедливо заметить, что, так как любой центр кластера — это среднее арифметическое входящих в кластер объектов $x_i$, на выборке фиксированного размера есть лишь конечное множество потенциальных центров кластеров. Если предположить, что в ходе работы K-means не зацикливается, отсюда следует, что рано или поздно центры кластеров не изменятся на следующем шаге и алгоритм сойдётся. При этом фактическая сходимость, конечно же, происходит задолго до полного перебора всех возможных центров кластеров.\n\n## Иерархическая агломеративная кластеризация\n\nДругой классический метод кластеризации — это **иерархическая кластеризация**. Иногда дополнительно уточняют: **иерархическая агломеративная кластеризация**. Название указывает сразу на два обстоятельства.\n\nВо-первых, есть деление алгоритмов кластеризации на **агломеративные** (**agglomerative**) и **дивизивные**, или **дивизионные** (**divisive**). Агломеративные алгоритмы начинают с небольших кластеров (обычно с кластеров, состоящих из одного объекта) и постепенно объединяют их в кластеры побольше. Дивизивные начинают с больших кластеров (обычно – с одного единственного кластера) и постепенно делят на кластеры поменьше.\n\n![19_4_7ed88aaa93.webp](https://yastatic.net/s3/education-portal/media/19_4_7ed88aaa93_a97e85a875.webp)\n\nВо-вторых, кластеризация бывает, по аналогии с оргструктурой в организациях, плоской (когда все кластеры равноправны и находятся на одном уровне кластеризации) и иерархической (когда кластеры бывают вложены друг в друга и образуют древовидную структуру).\n\nВ случае иерархической агломеративной кластеризации мы действительно будем начинать с кластеров из одного объекта, постепенно объединяя их, а уже последовательность этих объединений даст структуру вложенности кластеров. Даже если в итоге мы будем использовать кластеры с одного уровня, не углубляясь ни в какую вложенность, кластеризация всё равно называется иерархической, так как иерархия естественным образом возникает в процессе работы алгоритма.\n\nСам алгоритм выглядит предельно просто:\n\n1. Создаём столько кластеров, сколько у нас объектов в выборке, каждый объект — в своём отдельном кластере.\n2. Повторяем итеративно слияние двух ближайших кластеров, пока не выполнится критерий останова.\n\n### Расстояния в иерархической кластеризации\n\nКак измерить расстояние между кластерами из одного объекта? Нужно просто взять расстояние между этими объектами. Остаётся вопрос, как обобщить расстояние между объектами до расстояния между кластерами (если в них более одного объекта). Традиционные решения — брать среднее расстояние между объектами кластеров, минимальное расстояние или максимальное. Если обозначить кластеры $U$ и $V$, расстояние между ними в этом случае можем вычислять по одной из формул:\n\n$$d_{avg}(U, V) = \\frac{1}{|U| \\cdot |V|} \\sum\\limits_{u \\in U} \\sum\\limits_{v \\in V} \\rho(u,v)$$\n\n$$d_{min}(U, V) = \\min\\limits_{(u,v) \\in U \\times V} \\rho(u,v)$$\n\n$$d_{max}(U, V) = \\max\\limits_{(u,v) \\in U \\times V} \\rho(u,v)$$\n\nИспользуемая формула расстояния между кластерами — один из гиперпараметров алгоритма. Кроме приведённых стандартных вариантов бывают и более экзотичные, например расстояние Уорда (Ward distance). В наиболее общем виде способы задания расстояния между кластерами даются формулой Ланса — Уильямса (Lance — Williams; более подробно вы можете почитать в [этой статье](https://arxiv.org/pdf/1105.0121.pdf)). Сами же расстояния между объектами можно задавать любой метрикой, как евклидовой, так и манхэттенским расстоянием или, например, косинусной мерой (с той лишь поправкой, что это мера близости, а не расстояние).\n\n### Условия окончания работы алгоритма (критерии останова)\n\nВ качестве условия для завершения работы алгоритма можем выбрать либо получение нужного количества кластеров (количество кластеров может быть гиперпараметром алгоритма), либо выполнение эвристик на основе расстояния между объединяемыми кластерами (например, если расстояние сливаемых кластеров значительно выросло по сравнению с прошлой итерацией). На практике же обычно кластеризацию проводят вплоть до одного кластера, включающего в себя всю выборку, а затем анализируют получившуюся иерархическую структуру с помощью дендрограммы.\n\n### Дендрограмма\n\nПо мере объединения кластеров, каждой итерации алгоритма соответствует пара объединяемых на этой итерации кластеров, а также расстояние между кластерами в момент слияния. Расстояния с ростом итерации будут только увеличиваться, поэтому возникает возможность построить следующую схему, называемую **дендрограммой**:\n\n![19_5_64e913b1bf.webp](https://yastatic.net/s3/education-portal/media/19_5_64e913b1bf_85496f57cf.webp)\n\nЗдесь по горизонтали внизу отмечены объекты кластеризуемой выборки, под горизонтальной осью подписаны номера объектов, а их расположение вдоль оси продиктовано только эстетическими соображениями: нам удобно строить дендрограмму так, чтобы никакие дуги в ней не пересекались. По вертикали отложены расстояния между кластерами в момент слияния. Когда происходит объединение кластеров, состоящих из нескольких объектов, соответствующая этой итерации алгоритма дуга идёт не до конкретных объектов выборки, а до дуги другого кластера.\n\nТаким образом мы получаем наглядную визуализацию древовидной структуры процесса кластеризации. В частности, на дендрограмме мы можем визуально заметить, в какой момент происходит скачок расстояний между кластерами, и попытаться определить «естественное» количество кластеров в нашей задаче. На практике же это соображение, как правило, остаётся лишь красивой теорией, так как любую кластеризацию можно делать в разной степени «мелкой» и «естественного» количества кластеров в практических задачах часто не существует. В случае же если данные были получены таким образом, что в них действительно есть какое-то естественное количество кластеров, иерархическая кластеризация обычно справляется с определением числа кластеров по дендрограмме заметно хуже, чем DBSCAN. Именно алгоритму DBSCAN мы и посвятим следующий раздел.\n\n## DBSCAN\n\nАлгоритм **DBSCAN** (**Density-based spatial clustering of applications with noise**) развивает идею кластеризации с помощью выделения связных компонент. \n\nПрежде чем перейти к построению графа, введём понятие плотности объектов выборки в пространстве признаков. Плотность в DBSCAN определяется в окрестности каждого объекта выборки $x_i$ как количество других точек выборки в шаре $B(\\varepsilon, x_i)$. Кроме радиуса $\\varepsilon$ окрестности в качестве гиперпараметра алгоритма задается порог $N_0$ по количеству точек в окрестности.\n\nДалее все объекты выборки делятся на три типа: **внутренние / основные точки** (**core points**), **граничные** (**border points**) и **шумовые точки** (**noise points**). К основным относятся точки, в окрестности которых больше $N_0$ объектов выборки. К граничным — точки, в окрестности которых есть основные, но общее количество точек в окрестности меньше $N_0$. Шумовыми называют точки, в окрестности которых нет основных точек и в целом содержится менее $N_0$ объектов выборки.\n\nАлгоритм кластеризации выглядит следующим образом:\n\n1. Шумовые точки убираются из рассмотрения и не приписываются ни к какому кластеру.\n2. Основные точки, у которых есть общая окрестность, соединяются ребром. \n3. В полученном графе выделяются компоненты связности.\n4. Каждая граничная точка относится к тому кластеру, в который попала ближайшая к ней основная точка.\n\nУдобство DBSCAN заключается в том, что он сам определяет количество кластеров (по модулю задания других гиперпараметров — $\\varepsilon$ и $N_0$), а также в том, что метод успешно справляется даже с достаточно сложными формами кластеров. Кластеры могут иметь вид протяжённых лент или быть вложенными друг в друга как концентрические гиперсферы. На изображении ниже показан пример выделения кластеров достаточно сложной формы с помощью DBSCAN:\n\n![19_6_9cae9e34d3.webp](https://yastatic.net/s3/education-portal/media/19_6_9cae9e34d3_76ab832434.webp)\n\nDBSCAN — один из самых сильных алгоритмов кластеризации, но работает он, как правило, заметно дольше, чем mini-batch K-means, к тому же весьма чувствителен к размерности пространства признаков, поэтому используется на практике DBSCAN только тогда, когда успевает отрабатывать за приемлемое время. \n\n## Какой метод кластеризации выбирать?\n\nЕсли сравнивать частоту использования K-means, иерархической кластеризации и DBSCAN, то на первом месте, бесспорно, будет K-means, а второе место будут делить иерархический подход и DBSCAN. Иерархическая кластеризация — более известный и простой в понимании метод, чем DBSCAN, но довольно редко отрабатывающий качественно. Частая проблема иерархической кластеризации — раннее образование одного гигантского кластера и ряда очень небольших, что приводит к сильной несбалансированности количества объектов в итоговых кластерах. В то же время DBSCAN — менее широко известный подход, но, когда его можно применить, качество, как правило, получается выше, чем в K-means или иерархической кластеризации.\n\n## Оценка качества кластеризации\n\nДалее приведём список основных метрик качества кластеризации и обсудим некоторые особенности их применения.\n\n### Среднее внутрикластерное расстояние\n\nСмысл среднего внутрикластерного расстояния максимально соответствует названию:\n\n$$F_0 = \\frac{\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=i}^{n} \\rho(x_i, x_j) \\mathbb{I}[a(x_i)=a(x_j)]}{\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=i}^{n} \\mathbb{I}[a(x_i)=a(x_j)]}$$\n\nСумма расстояний между точками из одного и того же кластера делится на количество пар точек, принадлежащих к одному кластеру. В приведённой выше формуле пары вида $(x_i, x_i)$ включены в рассмотрение, чтобы избежать неопределённости $\\frac{0}{0}$ в случае, когда в каждом кластере ровно по одному объекту. Однако иногда записывают суммы по $i < j$, просто доопределяя $F_0$ в описанном случае нулём.\n\nРешая задачу кластеризации, мы хотим по возможности получать как можно более кучные кластеры, то есть минимизировать $F_0$.\n\nВ случае если у кластеров есть центры $\\mu_k$, часто рассматривается аналогичная метрика — средний квадрат внутрикластерного расстояния:\n\n$$\\Phi_0 = \\frac{1}{nK} \\sum\\limits_{k=1}^{K} \\sum\\limits_{i=1}^{n} \\rho(\\mu_k, x_i)^2 \\mathbb{I}[a(x_i)=k]$$\n\n### Среднее межкластерное расстояние\n\nАналогично среднему внутрикластерному расстоянию вводится среднее межкластерное:\n\n$$F_1 = \\frac{\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=i}^{n} \\rho(x_i, x_j) \\mathbb{I}[a(x_i) \\neq a(x_j)]}{\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=i}^{n} \\mathbb{I}[a(x_i) \\neq a(x_j)]}$$\n\nСреднее межкластерное расстояние, напротив, нужно максимизировать, то есть имеет смысл выделять в разные кластеры наиболее удалённые друг от друга объекты.\n\n### Гомогенность\n\nДля измерения следующих метрик (гомогенности, полноты и V-меры) нам уже потребуется разметка выборки. Будем обозначать кластеры, к которым наш алгоритм кластеризации относит каждый объект, буквами $k \\in \\lbrace 1, ..., K \\rbrace$, а классы, к которым объекты отнесены разметкой, — буквами $с \\in \\lbrace 1, ..., С \\rbrace$. Разумный вопрос при наличии разметки — зачем нам решать задачу кластеризации, если с разметкой можно поставить задачу как задачу классификации. Это и правда хороший вопрос в том случае, если размеченных данных достаточно много для обучения классификатора. На практике же часто встречаются ситуации, когда данных достаточно для оценки качества кластеризации, но всё ещё не хватает для использования методов обучения с учителем.\n\nПусть $n$ — общее количество объектов в выборке, $n_k$ — количество объектов в кластере номер $k$, $m_c$ — количество объектов в классе номер $с$, а $n_{ck}$ — количество объектов из класса $c$ в кластере $k$. Рассмотрим следующие величины:\n\n$$H_{class} = - \\sum\\limits_{c = 1}^{C} \\frac{m_c}{n} \\log {\\frac{m_c}{n}}$$\n\n$$H_{clust} = - \\sum\\limits_{k = 1}^{K} \\frac{n_k}{n} \\log {\\frac{n_k}{n}}$$\n\n$$H_{class | clust} = - \\sum\\limits_{c = 1}^{C}\\sum\\limits_{k = 1}^{K} \\frac{n_{ck}}{n} \\log {\\frac{n_{ck}}{n_k}}$$\n\nНесложно заметить, что эти величины соответствуют формуле энтропии и условной энтропии для мультиномиальных распределений $\\frac{m_c}{n}$, $\\frac{n_k}{n}$ и $\\frac{n_{ck}}{n_k}$ соответственно.\n\nГомогенность кластеризации определяется следующим выражением:\n\n$$Homogeneity = 1 - \\frac{H_{class | clust}}{H_{class}}$$\n\nОтношение $\\frac{H_{class \\vert clust}}{H_{class}}$ показывает, во сколько раз энтропия изменяется за счёт того, что мы считаем известной принадлежность объектов к выделенным нашим алгоритмом кластерам. Худший случай — когда отношение оказывается равным единице (энтропия не изменилась, условная энтропия совпала с обычной), лучший — когда каждый кластер содержит элементы только одного класса и номер кластера, таким образом, точно определяет номер класса (в этом случае $h=1$).\n\nТривиальный способ максимизировать гомогенность кластеризации — выделить каждый объект выборки в отдельный кластер.\n\n### Полнота\n\nПолнота задаётся аналогично гомогенности, с той лишь разницей, что вводится величина $H_{clust \\vert class}$, симметричная $H_{class \\vert clust}$:\n\n$$Completeness = 1 - \\frac{H_{clust | class}}{H_{clust}}$$\n\nПолнота равна единице, когда все объекты класса всегда оказываются в одном кластере.\n\nТривиальный способ максимизировать полноту кластеризации — объединить всю выборку в один кластер.\n\n\n### V-мера\n\n**Гомогенность** и **полнота** кластеризации – это в некотором смысле аналоги точности и полноты классификации. Аналог F-меры для задачи кластеризации тоже есть, он называется V-мерой и связан с гомогенностью и полнотой той же формулой, что и F-мера с точностью и полнотой:\n\n$$V_{\\beta} = \\frac{(1 + \\beta) \\cdot Homogeneity \\cdot Completeness}{\\beta \\cdot Homogeneity + Completeness}$$\n\nВ частности, $V_1$ по аналогии с $F_1$-мерой в классификации (не путать со средним межкластерным расстоянием, которое мы тоже обозначали $F_1$ выше) будет просто средним гармоническим гомогенности и полноты:\n\n$$V_{1} = \\frac{2 \\cdot Homogeneity \\cdot Completeness}{Homogeneity + Completeness} $$\n\nV-мера комбинирует в себе гомогенность и полноту таким образом, чтобы максимизация итоговой метрики не приводила к тривиальным решениям.\n\n### Коэффициент силуэта\n\nЕщё одна метрика кластеризации, на этот раз уже не требующая разметки, это **коэффициент силуэта** (**silhouette coefficient**). Изначально коэффициент определяется для каждого объекта выборки, а метрика для результатов кластеризации всей выборки вводится как средний коэффициент силуэта для всех объектов выборки.\n\nЧтобы ввести коэффициент силуэта $S(x_i)$, нам потребуются две вспомогательные величины. Первая, $A(x_i)$, — это среднее расстояние между $x_i$ и объектами того же кластера. Вторая, $B(x_i)$, — это среднее расстояние между $x_i$ и объектами следующего ближайшего кластера. Коэффициент силуэта вводится следующим образом:\n\n$$S(x_i) = \\frac{B(x_i) - A(x_i)}{\\max(B(x_i), A(x_i))}$$\n\nВ идеальном случае объекты «родного» кластера $x_i$ должны быть ближе к $x_i$, чем объекты соседнего кластера, то есть $A(x_i) < B(x_i)$. Однако это неравенство выполняется далеко не всегда. Если «родной» кластер $x_i$, например, имеет форму очень протяжённой ленты или просто большой размер, а недалеко от $x_i$ есть кластер поменьше, может оказаться, что $A(x_i) > B(x_i)$. Таким образом, если мы посмотрим на разность $B(x_i) - A(x_i)$, она может оказаться как положительной, так и отрицательной, но в идеальном сценарии всё же следует ожидать положительное значение. Сам же коэффициент $S(x_i)$ принимает значения от –1 до +1 и максимизируется, когда кластеры кучные и хорошо отделены друг от друга.\n\nКоэффициент силуэта особенно полезен (по сравнению с другими приведёнными метриками) тем, что одновременно и не требует разметки, и позволяет подбирать количество кластеров. См. подробнее [в примере из документации scikit-learn](https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html).\n\n### Различия и выбор метрик качества кластеризации\n\nПодводя итог в теме метрик качества в задаче кластеризации, отметим, что есть несколько разных сценариев использования этих метрик. Если вы уже определились с количеством кластеров, можно оптимизировать среднее внутрикластерное или среднее межкластерное расстояние. Если у вас ещё и есть разметка — гомогенность и полноту. V-мера за счёт сочетания гомогенности и полноты в целом позволяет выполнять и подбор количества кластеров.\n\nОднако разметка, с одной стороны, есть далеко не всегда, а с другой стороны, в задаче кластеризации часто очень субъективна. Сложность кластеризации в том, что на одной и той же выборке нас вполне могут устроить сразу несколько различных вариантов кластеризации, то есть задача поставлена некорректно и имеет более одного решения. Формализовать, какие решения нас устроят, на практике довольно сложно, поэтому сама по себе задача кластеризации решается не слишком хорошо.\n\nЕсли разметки нет и число кластеров не фиксировано, лучшая метрика на практике — коэффициент силуэта. Исключение — ситуация, когда результат кластеризации используется далее для решения некоторой задачи обучения с учителем (как было в примере классификации изображений с помощью visual bag of words). В этом случае можно абстрагироваться от качества кластеризации и выбирать такой алгоритм кластеризации и такие его гиперпараметры, которые позволят лучше всего решить итоговую задачу.",
        "handbook": "Учебник по машинному обучению",
        "title": "Кластеризация",
        "description": "Методы кластеризации: K-Means, агломеративная кластеризация, DBSCAN. Оценка качества кластеризации"
    },
    {
        "path": "/handbook/ml/article/vremennye-ryady",
        "content": "## Введение\n\n**Временной ряд** — значения меняющихся во времени признаков, полученные в некоторые моменты времени.\n\n![ts](https://yastatic.net/s3/education-portal/media/ts_4586b0902c_3f22fd0ec7.webp)\n\n**Задача прогнозирования**\n\nПусть $(y_t, t \\in \\mathbb{N})$ – временной ряд, для которого известны значения $y_1, \\ldots, y_T$. Требуется построить <b>прогноз</b> – функцию $f$, такую что величина $\\widehat{y}_{T+h} = f(y_1, \\ldots, y_T, h)$ как можно лучше приближает значение $y_{T+h}$, где $h \\in \\{1, \\ldots, H\\}$ – количество шагов, на которое нужно построить прогноз, а величина $H$ – горизонт прогнозирования, то есть максимальное количество шагов для построения прогноза. Иными словами, прогноз значения ряда в момент времени $T+h$ строится на основе известных значений ряда до момента времени $T$. Кроме этого имеет смысл строить <b>предсказательный интервал</b>, то есть интервал $(d_{T+h}, u_{T+h})$, т.ч. $\\mathbb{P}(d_{T+h} \\leqslant y_{T+h} \\leqslant u_{T+h}) \\geqslant \\alpha$.\n\nНапример, пусть $y_t$ – значение какого-то признака в момент времени $t$, и у нас есть значения ряда за месяц, то есть $y_1, \\ldots, y_{30}$. Пусть также требуется предсказать значения ряда на неделю вперед. Тогда прогноз на первые сутки вперед будет равен $\\widehat{y}_{31} = f(y_1, \\ldots, y_{30}, 1)$, а прогноз на пятые сутки $\\widehat{y}_{35} = f(y_1, \\ldots, y_{30}, 5)$.\n\nСпустя некоторое время прогноз можно перестроить. Например, пусть прогноз перестраивается один раз в трое суток. Тогда оценку значения $y_{35}$ мы уточним как $\\widehat{y}_{35} = f(y_1, \\ldots, y_{33}, 2)$.  При этом может оказаться, что функция $f$ умеет принимать на вход лишь фиксированное количество предыдущих значений ряда. Например, если она умеем строить прогноз по последним 30 значениям ряда, то запись будет иметь вид $\\widehat{y}_{35} = f(y_4, \\ldots, y_{33}, 2)$. Иногда для уточнения того, в какой момент построен прогноз значения $y_{35}$, указывают момент времени построения прогноза. Например, запись $\\widehat{y}_{35\\:\\vert\\:30}$ означает, что прогноз на 35-й день построен в день 30, а $\\widehat{y}_{35\\:\\vert\\:33}$ – в день 33.\n\nЕсли признаков несколько, не обязательно прогнозировать каждый признак. Часто выделяется один или несколько целевых признаков, а остальные признаки являются вспомогательными и могут улучшить прогноз.\n\nПрактические примеры:\n\n1. Прогноз погоды на 10 дней вперед.\n2. Прогноз осадков на 2 часа вперед.\n\n## Примеры временных рядов\n\n**Ежемесячные продажи антидиабетических лекарств в Австралии с июля 1991 по июнь 2008.** На этом графике мы можем видеть возрастающий тренд, возможно, даже нелинейный, и кроме этого есть сезонность (периодичность) значений по годам.\n\n![ex](https://yastatic.net/s3/education-portal/media/ex_5_2ee6327df8_7ac9055a6a.webp)\n\n**Максимальный спрос на электричество в штате Виктория (Австралия) за 30-минутные интервалы с 10 января 2000 в течении 115 дней.** Здесь мы можем наблюдать сразу две сезонности – суточную и недельную. Первая сезонность вызвана тем, что люди обычно больше потребляют электричество днем, чем ночью. Недельная сезонность вызвана более высоким потреблением электричества по будням. Если бы мы посмотрели данные за несколько лет, то увидели бы еще одну сезонность – годовую, например, вызванную тем, что в теплое время года работает больше кондиционеров.\n\n![ex](https://yastatic.net/s3/education-portal/media/ex_2_edd214b6d4_e624752725.webp)\n\nПочему бы нам не построить прогноз простыми методами, например, линейной регрессией по времени? Общий тренд так можно уловить. Но в остатках (то есть в разности между истинными значениями и прогнозом) этой модели будет достаточно много информации, которую хотелось бы как-то учесть.\n\n![ex](https://yastatic.net/s3/education-portal/media/ex_5_regr_86f4ec08db_d8869c1677.webp)\n\nМожно также добавить квадрат значения времени. Тогда можно уловить квадратичный тренд, но не более.\n\n![ex](https://yastatic.net/s3/education-portal/media/ex_5_regr_sq_abc4a91d9d_7f51695156.webp)\n\n## Прогнозирование с помощью сведения к задаче регрессии\n\nДавайте для начала поймем, что мы вообще хотим сделать. Посмотрим на этот график, на котором показаны продажи одного из товаров в магазине за разные года.\n\n![ts](https://yastatic.net/s3/education-portal/media/ts_predict_df49cf88a0_2a78d25310.webp)\n\nМы знаем значения ряда (<font color=\"green\"><b>зеленые</b></font>) до момента времени $t$, в данном случае за 4 года с 2013 по 2016 включительно. Предположим также, что в данный момент мы отмечаем Новый год 2017. В этот момент мы хотели бы предсказать (<font color=\"blue\"><b>синее</b></font>) будущие значения ряда (<font color=\"orange\"><b>оранжевое</b></font>) за весь 2017 год на основе четырехлетней истории продаж.\n\nОсновная идея – подадим известные (<font color=\"green\"><b>зеленые</b></font>) значения ряда в какую-то регрессионную функцию, получив тем самым предсказания. При этом можем брать не все известные значения ряда, а только $p$ последних значений. Иначе говоря, модель имеет вид\n\n$$y_t = f(y_{t-1}, \\ldots, y_{t-p}),\n$$\n\nгде $f$ – произвольная функция. Ее можно построить некоторым известным методом машинного обучения, например, линейной регрессией, решающими деревьями, бустингами, нейронными сетями (как сверточными, так и рекуррентными). Разберёмся, какие признаки мы подадим на вход регрессии.\n\n### Признаки\n\n#### Общий принцип\n\nНа практике при генерации идей о том, какие признаки можно создавать для построения модели, рекомендуется строить следующий график. На нем нужно отметить момент времени $t$ и мысленно поставить себя в этот момент времени. Затем нужно подумать, какие данные нам при этом доступны. В модель можно брать любые признаки, которые доступны к моменту времени $t$. Если все данные поступают сразу, то можно брать все признаки, которые зависят только от значений до момента времени $t$. В реальности часть данных может поступать с задержкой. Например, если данные загружаются в базу данных раз в сутки в полночь, то в полдень нам не доступны данные за последние 12 часов.\n\n![1](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_902d9298d4_8020007396.svg)\n\nТакже нужно помнить о том, на сколько времени вперед нужно сделать прогноз. Например, пусть у нас задача состоит в том, чтобы построить прогнозы продаж в магазине с целью планирования новых поставок. После того, как на основе прогноза мы примем решение о составе товаров в новой поставке, необходимо сначала собрать данные товары на складе, потом отправить машину в магазин, и затем еще разложить товар на полки в магазине. На эту процедуру может уходить от нескольких часов до нескольких дней. Тем самым еще до момента начала формирования новой поставки модель прогнозирования продаж должна построить прогноз спроса на товар к тому моменту, когда его выложат на полки.\n\n#### Даты\n\nПосмотрим на то, какие признаки можно извлечь\n\nПусть дана какая-то дата: **13.04.2021 09:00**.\n\nОтсюда можно получить следующие признаки:\n\n* день недели: \\[2\\];\n* месяц:       \\[4\\];\n* год: \\[2021\\];\n* сезон: \\[весна\\];\n* праздник: \\[0\\];\n* выходной: \\[0\\];\n* час: \\[9\\].\n\n#### Предыдущие значения ряда.\n\nНапример, если мы хотим построить признаки в момент времени $t$ для прогнозирования $y_t$, то можно рассмотреть в качестве признаков $p$ предыдущих значений ряда $y_{t-1}, \\ldots, y_{t-p}$.\n\n#|\n||\n\nВремя\n\n|\n\nТаргет\n\n|\n\nПризнаки\n\n||\n||\n\n$t$\n\n|\n\n$y_t$\n\n|\n\n$y_{t-1}, \\ldots, y_{t-p}$\n\n||\n||\n\n$t-1$\n\n|\n\n$y_{t-1}$\n\n|\n\n$y_{t-2}, \\ldots, y_{t-p-1}$\n\n||\n||\n\n$t-2$\n\n|\n\n$y_{t-2}$\n\n|\n\n$y_{t-3}, \\ldots, y_{t-p-2}$\n\n||\n|#\n\n\nДля реализации таких признаков можно выполнить сдвиги **вперед** временного ряда на $1, 2, \\ldots, p$ шагов. Например, в таблице для прогнозирования значений ряда мы рассматриваем два предыдущих значений ряда, выполняя тем самым два сдвига вперед. Таким образом, для прогнозирования значения 5 января, которое равно 235, мы берем признаки 230 и 215, которые являются значением ряда за 4 и 3 января соответственно.\n\n![1](https://yastatic.net/s3/education-portal/media/1_rgb_split_rooster_copy_127d9b7e45_0e438ecc93.svg)\n\n#### Скользящее окно\n\nНе всегда имеет смысл в качестве признаков в чистом виде брать все предыдущие значения ряда. Например, если данные приходят раз в секунду, то для того чтобы учесть изменения ряда за последний час, пришлось бы создавать 3600 признаков. Вместо этого по предыдущим значениям ряда $y_{t-1}, \\ldots, y_{t-p}$ можно посчитать:\n\n* среднее;\n* взвешенное среднее;\n* экспоненциальное сглаживание;\n* медиана;\n* минимум/максимум;\n* стандартное отклонение;\n* любую другую статистику.\n\nПодобное скользящее окно можно рассматривать и по другим временн*ы*м факторам, которые мы не прогнозируем.\n\nПримеры:\n\n* Средняя *температура* на прошлой неделе для предсказания температуры на завтра.\n* Средняя *влажность* на прошлой неделе для предсказания температуры на завтра.\n\nЕсли в задаче данные хорошие и удаётся использовать более-менее стандартные признаки, то можно воспользоваться готовыми инструментами. Если данные не очень приятные, стоит подумать над тем, какие признаки использовать и как реализовать их получение.\n\n#### Сезонность\n\nЕсли во временном ряду наблюдается сезонность, то стоит использовать сезонные признаки, например, следующие.\n\n* Значение переменной сутки/неделю/месяц/год назад. Такие факторы также можно усреднять.\n* Сезонность, полученная методами декомпозирования ряда (об этом расскажем ниже).\n\nПримеры:\n\n* Значение температуры год назад.\n* Среднее значение температуры 23 ноября за 5 последних лет.\n* Среднее значение температуры за 5 последних лет на неделе, в которую входит 23 ноября.\n\n#### Счётчики\n\nИдея состоит в том, чтобы группировать данные не только по временным факторам, но и по любым категориальным. Например, пусть сегодня нет ветра. Тогда в качестве признака можно рассмотреть среднюю температуру в безветренные дни по историческим данным.\n\nМожно также использовать сразу несколько факторов. Например, мы строим прогноз в апреле. Тогда можно рассматривать среднюю температуру в безветренные дни в апреле по историческим данным.\n\n#### Резюме\n\nПодведем итог о том, какие признаки можем использовать для построения нашей модели.\n\n* Используются **только** данные из прошлого, никакие данные из будущего нельзя использовать при прогнозировании. Нужно также учитывать возможные задержки в поступлении данных.\n* Большое количество признаков может привести к вычислительным затратам.\n* Можно генерировать и другие признаки с учетом знаний о предметной области.\n\n### Построение прогноза\n\nМы определились с тем, какие брать признаки. Теперь разберемся с тем, как прогнозировать. Пусть требуется построить прогноз на $H$ шагов вперед. Выделяют три основных способа построить прогнозы:\n\n* Рекурсивная стратегия;\n* Прямая стратегия;\n* Гибридная стратегия.\n\n#### Рекурсивная стратегия\n\nДля каждого момента времени $t_0\\leqslant t \\leqslant T$ создается объект обучающей выборки:\n\n* *Признаковое описание* – история ряда до момента времени $t-1$.\n* *Целевая метка* – значение $y_t$.\n\nПо этим данным мы обучаем какую-либо регрессионную модель строить прогнозы на один шаг вперед. При построении прогноза на несколько шагов вперед мы сначала построим прогноз на один шаг. Затем – на второй шаг, используя полученный прогноз на первый шаг в качестве признаков, и далее аналогично.\n\nИначе говоря, если для прогнозирования $y_t$ признаковое описание имеет вид $(y_{t-p}, \\ldots, y_{t-1})$, то для построения прогноза $y_{t+1}$ рассматривается признаковое описание $(y_{t-p+1}, \\ldots, y_{t-1}, \\widehat{y}_t)$.\n\nНа картинке считаем, что M-2, M-1 и M это названия признаков у построенной модели.\n\n![recursive](https://yastatic.net/s3/education-portal/media/recursive_8427cc778b_923a246e65.webp)\n\n#### Прямая стратегия\n\nВ прямой стратегии предполагается, что построением каждого прогноза в рамках горизонта прогнозирования должна заниматься своя модель. Тем самым создается $H$ моделей прогнозирования для каждого момента времени $t_0\\leqslant t \\leqslant t_0+H-1$.\n\n* *Признаковое описание* – история ряда до момента времени $t_0-1$, причем признаки одни и те же для каждой модели.\n* *Целевая метка* – значение $y_t$.\n\n![direct](https://yastatic.net/s3/education-portal/media/direct_7ff22dabcb_ba7c98a644.webp)\n\n#### Гибридная стратегия\n\nГибридная стратегия объединяет в себе преимущества рекурсивной и прямой стратегий. Как и в прямой стратегии, создается $H$ моделей прогнозирования, но при этом каждая следующая модель использует прогнозы предыдущей подобно тому, как это делает рекурсивная стратегия.\n\nИтак, мы должны построить\n\n* модель для прогноза на 1 шаг вперед;\n* модель для прогноза на 2 шага вперед, используя прогноз уже обученной модели на 1 шаг вперед в качестве признака;\n* модель для прогноза на 3 шага вперед, используя прогноз уже обученных моделей на 1 и 2 шага вперед в качестве признаков;\n* и так далее обучается $H$ моделей.\n\nПризнаковое описание:\n\n* история ряда до момента времени $t_0-1$;\n* предсказание предыдущих моделей для $t_0, t_0-1, \\ldots, t-1$.\n\nНа картинке показаны признаковые описания для моделей в такой стратегии.\n\n![hybrid](https://yastatic.net/s3/education-portal/media/hybrid_8f9dd2444d_70893afe15.webp)\n\nМожно задаться вопросом: что лучше брать при обучении моделей для прогноза на несколько шагов вперёд – истинные значения или же предсказания предыдущих моделей. Если брать истинные, то мы можем точнее построить модели прогнозирования, но, с другой стороны, на этапе применения вы будете использовать прогнозы, а они могут иметь другое распределение, чем истинные данные, в частности, могут иметь смещение и большую дисперсию. В таком случае мы получим плохие следующие прогнозы.\n\n#### Модели для нескольких временных рядов\n\nВ реальности очень часто нужно прогнозировать сразу огромное количество временных рядов.\n\nПримеры:\n\n* Предсказание температуры для различных регионов/городов.\n* Предсказания уровня продаж для различных типов товаров (молоко/яблоки/мясо).\n\nПроблема:\n\n* модель на каждый временной ряд – слишком много ресурсов и не масштабируемо;\n* мало моделей – плохие предсказания для каждого ряда по отдельности.\n\nИдея: создавать модели не для каждого временного ряда, а для группы временных рядов. Иначе говоря, разделить объекты на категории, и для каждой категории создавать отдельную модель.\n\n![cluster](https://yastatic.net/s3/education-portal/media/cluster_model_444955a517_8bd1eedf81.webp)\n\n### Оценка качества моделей\n\nДля оценка качества моделей прогнозирования временного ряда в основном используются метрики качества регрессии.\n\n* Средняя квадратичная ошибка\n\n$$MSE = \\frac{1}{T-R+1} \\sum_{t=R}^T \\left(\\widehat{y}_t - y_t\\right)^2.\n$$\n\n* Средняя абсолютная ошибка\n\n$$MAE = \\frac{1}{T-R+1} \\sum_{t=R}^T \\left\\vert\\widehat{y}_t - y_t\\right\\vert.\n$$\n\nЭти метрики показывают, например, на сколько рублей или на сколько единиц товара мы ошибемся.\n\nТакже могут использоваться:\n\n* Средняя абсолютная ошибка в процентах\n\n$$MAPE = \\frac{100}{T-R+1} \\sum_{t=R}^T \\left\\vert\\frac{\\widehat{y}_t - y_t}{y_t}\\right\\vert.\n$$\n\n* Взвешенная средняя ошибка в процентах.\n\n$$WAPE = 100 \\cdot \\dfrac{\\sum_{t=R}^T \\vert\\widehat{y}_t - y_t\\vert}{\\sum_{t=R}^T \\vert y_t\\vert}.\n$$\n\nЭти метрики достаточно популярны из-за того, что позволяют оценить качество в относительных величинах без зависимости от шкалы измерений.\n\n#### Кросс-валидация для временных рядов.\n\nСтандартные схемы кросс-валидации нельзя применять для временных рядов потому что значения во временных рядах нельзя перемешивать. Существует два способа построить кросс-валидацию на временных рядах.\n\n**Схема 1.**\n\n* Обучаемся на первых $t$ значениях временного ряда $y_1\\:...\\:y_{t}$, прогнозируем следующие $\\Delta t$ значений ряда $\\widehat{y}_{t+1}\\:...\\:\\widehat{y}_{t+\\Delta t}$.\n* Обучаемся на $y_1\\:...\\:y_{t+\\Delta t}$, прогнозируем $\\widehat{y}_{t+\\Delta t+1}\\:...\\:\\widehat{y}_{t+2\\Delta t}$.\n* ...\n* Обучаемся на $y_1\\:...\\:y_{t+(k-1)\\Delta t}$, прогнозируем $\\widehat{y}_{t+(k-1)\\Delta t+1}\\:...\\:\\widehat{y}_{t+k\\Delta t}$.\n* На каждой итерации считаем ошибки и усредняем.\n\n![Group](https://yastatic.net/s3/education-portal/media/Group_1_df539253d3_78a875d6a0.svg)\n\n**Схема 2.**\n\n* Обучаемся на первых $t$ значениях временного ряда $y_1\\:...\\:y_{t}$, прогнозируем следующие $\\Delta t$ значений ряда $\\widehat{y}_{t+1}\\:...\\:\\widehat{y}_{t+\\Delta t}$.\n* Обучаемся на $y_{1+\\Delta t}\\:...\\:y_{t+\\Delta t}$, прогнозируем $\\widehat{y}_{t+\\Delta t+1}\\:...\\:\\widehat{y}_{t+2\\Delta t}$.\n* ...\n* Обучаемся на $y_{1+(k-1)\\Delta t}\\:...\\:y_{t+(k-1)\\Delta t}$,~прогнозируем~$\\widehat{y}_{t+(k-1)\\Delta t+1}\\:...\\: \\widehat{y}_{t+k\\Delta t}$.\n* Считаем ошибки и усредняем.\n\n![cross](https://yastatic.net/s3/education-portal/media/cross_val2_1f5518a032_b791f27515_1e8335dd56.svg)\n\nЭти две схемы отличаются только размером обучающего множества. В первом случае он постоянно растет, во втором – не меняется, а само обучающее множество при этом сдвигается. Ту или иную схему на практике стоит использовать в зависимости от того, какая решается задача. Например, если данных достаточно много и предполагается онлайн работа модели с периодическим дообучением, то обычно при каждом дообучении размер обучающего множества фиксируют. В таком случае имеет смысл воспользоваться второй схемой, чтобы оценить качество модели, обученной именно на таким количестве данных. Если же данных немного, то для обучения желательно использовать все доступные данные. В таком случае имеет смысл использовать первую схему.\n\nОбратите внимание, что во всех случаях размер тестового интервала времени фиксирован. Это необходимое условие, потому как распределение значений метрики на разных размерах данных может отличаться. Вспомните, например, про зависимость дисперсии выборочного от размера выборки.\n\n### Резюме: стандартные модели ML для временных рядов\n\nПреимущества\n\n* Свободно используют дополнительную информацию – экзогенные факторы или признаки.\n* Много рядов – много моделей. Нейронная сеть может иметь несколько выходов, и это позволяет прогнозировать сразу несколько рядов одной моделью. Пример: прогнозирование продаж различных товаров.\n\nНедостатки\n\n* Предсказательные интервалы напрямую не строятся.\n* Иногда работают хуже стандартных моделей.\n* Обработка признаков может быть труднее, чем в других моделях, которые мы рассмотрим далее.\n* Интерпретация моделей может вызывать трудности у заказчика.\n\n## Декомпозиция временных рядов\n\nДекомпозиция  – процедура разложения временного ряда на три временных компоненты:\n\n* **Тренд** $T_t$ – плавное долгосрочное изменение временного ряда.\n* **Сезонность** $S_t$ – циклические изменения временного ряда с постоянным периодом сезонности $s$.\n* **Ошибка** $R_t$ – непрогнозируемая случайная компонента ряда.\n\nМожно рассматривать аддитивную декомпозицию, в которой ряд представляется в виде $y_t = T_t + S_t + R_t$, а также мультипликативную в виде $y_t = T_t \\cdot S_t \\cdot R_t$. Нетрудно понять, что для построения мультипликативного разложения достаточно выполнить аддитивную декомпозицию для ряда $\\log  y_t$.\n\n### Декомпозиция на основе скользящего среднего\n\nПусть $s$ – известный заранее период сезонности. Компоненты разложения вычисляются последовательно по следующим правилам.\n\n* **Тренд**\n\nВычисляется с помощью скользящего окна длины $s$: $T_t = \\dfrac{1}{s}\\sum\\limits_{i=t-s/2}^{t+s/2}y_i$.\n\n* **Сезонность**\n  Усреднение значений по сезону после удаления тренда.\n\n  * Вычитаем тренд $y_t: = y_t - T_t$;\n  * Формируются $s$ подгрупп: $G_i = \\{y_i, y_{i + s}, \\ldots, y_{i + ks}\\}$;\n  * $i$-е значение сезонности вычисляется усреднением по $i$-й группе $S_i = \\overline{G_i}$.\n\n* **Ошибка**&tab;&tab;\n  $R_t = y_t - T_t - S_{(t\\ mod\\ s)}$.\n\n![ex](https://yastatic.net/s3/education-portal/media/ex_3_stl_c09e4ba22c_fec382cf63.webp)\n\n### STL-декомпозиция\n\nНазвание метода расшифровывается как **S**easonal-**T**rend decomposition using **L**OESS. Является более продвинутой моделю для декомпозиции временного ряда. Напоминание: LOESS – взвешенная линейная регрессия, где вес объекта пропорционален расстоянию от него до точек обучающей выборки.\n\nПринцип работы:\n\n* Инициализация тренда нулем: $T^0=0$;\n* В цикле по $k$ до сходимости:\n  * Вычитаем из ряда текущее значение тренда $y_t: = y_t - T_t^k$.\n  * Формируются $s$ подгрупп: $G_i = \\{y_i, y_{i + s}, \\ldots, y_{i + ks}\\}$.\n  * С помощью LOESS в каждой группе в каждый момент времени предсказывается сезонность $S_t$.\n  * Вычитаем из ряда полученную сезонность $y_t: = y_t - S_t$.\n  * С помощью LOESS предсказывается новое значение тренда $T_t^{k + 1}$.\n\n*Замечание.* Пропущен шаг работы с выбросами.\n\n![stl](https://yastatic.net/s3/education-portal/media/stl_f3b3a92cd7_343b7feb4d.webp)\n\nПреимущества STL-декомпозиции:\n\n* Больше настраиваемых параметров, позволяющих подогнать модель под любые данные.\n* Сезонная компонента может изменяться с течением времени, и это изменение контролируется пользователем.\n* Модель может быть устойчива к выбросам.",
        "handbook": "Учебник по машинному обучению",
        "title": "Временные ряды",
        "description": "Временные ряды"
    },
    {
        "path": "/handbook/ml/article/analitika-vremennyh-ryadov",
        "content": "## Автокорреляционная функция\n\t\nВременной ряд – зависимые между собой наблюдения. Например, температура воздуха сегодня достаточно сильно зависит от вчерашнего показателя температуры. Эту зависимость хотелось бы описать численно. Для этого часто используют разные виды коэффициентов корреляции, например, корреляции Пирсона, Спирмена и Кендалла. Каждый из этих коэффициентов корреляции вычисляется по двум выборкам, корреляцию между которыми требуется посчитать. В данном случае мы имеем один временной ряд, и наша задача – оценить корреляцию между разными наблюдениями ряда, считая, что она не меняется со временем.\n\t\nВ качестве оценки корреляции значений $y_t$ и $y_{t+\\tau}$ для любых $t$ рассмотрим коэффициент корреляции Пирсона ряда с самим собой со сдвигом на $\\tau$. Тем самым мы получим численную оценку степени влияния значения $y_t$ на значение $y_{t+\\tau}$:\n\n$$r_{\\tau} = \\widehat{corr}(y_t, y_{t+\\tau})   = \\frac{\\sum\\limits_{t=1}^{T-\\tau} \\left(y_t - \\overline{y}\\right)\\left(y_{t+\\tau} - \\overline{y}\\right)}{\\sum\\limits_{t=1}^T \\left(y_t - \\overline{y}\\right)^2},$$\n\nгде $\\tau$ – лаг автокорреляции, а среднее вычисляется по всему ряду $\\overline{y} = \\frac{1}{T}\\sum\\limits_{t=1}^T y_t$.  Например, если мы хотим оценить степень влияния сегодняшней температуры на завтрашнюю, то посчитаем коэффициент корреляции исходного ряда и им же, сдвинутым на 1 день.\n\t\n*Замечание.* Формула содержит некоторые упрощения при оценке ковариации и дисперсий.\n\t\nСвойства коэффициента корреляции:\n* $\\vert r_{\\tau}\\vert \\leqslant 1$;\n* $r_{\\tau} = 0$ – отсутствие автокорреляции, при этом значения могут быть зависимыми (см. подробнее про разницу между независимостью и некоррелированностью);\n* $r_{\\tau} > 0$ – положительная корреляция, то есть чем *больше* было значение вчера, тем оно будет *больше* сегодня;\n* $r_{\\tau} < 0$ – отрицательная корреляция, то есть чем *больше* было значение вчера, тем оно будет *меньше* сегодня;\n* $\\vert r_{\\tau} \\vert = 1$ означает строгую линейную зависимость.\n\n\nПосмотреть простые примеры и потренировать свою интуицию вы можете в игре [Guess The Correlation](http://guessthecorrelation.com/).\n\t\nПусть мы посчитали значение автокорреляции. А как понять, значение 0.1 – это много или мало? На этот вопрос может ответить *статистический критерий Льюнга-Бокса* (Ljung–Box), который проверяет значимость отклонения $r_{\\tau}$ от нуля. Основное правило, которое нужно здесь понять – если значение p-value критерия не превосходит $0.05$ (или другого *заранее* фиксированного порога значимости), то автокорреляция с лагом $\\tau$ значима. Это число вычисляется с помощью стандартных статистических пакетов (например, [statsmodels](https://www.statsmodels.org/dev/generated/statsmodels.stats.diagnostic.acorr_ljungbox.html) в Питоне).\n\t\nРассмотрим временной ряд дорожно-транспортных происшествий за 14 лет с дискретностью 1 месяц, то есть с 12 измерениями в год. На графике мы видим явную сезонность. На нижнем графике изображена *коррелограмма* – график, визуализирующий автокорреляционную функцию. Точками на графике показаны значения автокорреляционной функции. Ее значение в нуле всегда равно 1, так как это автокорреляция ряда с собой же. Также мы видим, что значение $r_{12}$ является локальным максимумом, что означает высокую положительную корреляцию значения ряда за текущий месяц с аналогичным значением год назад. Иными словами, ряд со сдвигом на год ведёт себя «похожим образом», и это подкрепляет наше наблюдение про наличие годичной сезонности. Наоборот, значение $r_{6}$ минимально в своей окрестност и, что означает высокую отрицательную корреляцию значения ряда со значением полгода назад. Закрашенная область визуализирует границу незначимой автокорреляции, то есть тех значений автокорреляции, для которых не выявлена статистически значимое отличие от 0 (иначе говоря, доверительный интервал пересекает 0). Так мы видим, что последняя значимая сезонная автокорреляция это – это $r_{24}$. Кроме нее также значима сезонная корреляция $r_{12}$ и корреляция за половину сезона $r_6$. Из несезонных автокорреляций значимы оказались $r_{1}$ и $r_{2}$. Отсюда можно сделать вывод, что для построения прогноза значения $y_t$ имеет смысл рассматривать признаки $y_{t-1}, y_{t-2}, y_{t-6}, y_{t-12}, y_{t-24}$.\n\n![ex_1_6fd71c0161.webp](https://yastatic.net/s3/education-portal/media/ex_1_6fd71c0161_ef125825e0.webp)\n\n![ex_1_autocorr_77d8a02254.webp](https://yastatic.net/s3/education-portal/media/ex_1_autocorr_77d8a02254_20f571b267.webp)\n\nРассмотрим временной ряд потребления электричества в Австралии с дискретностью 30 минут. По графику мы можем заметить две разных сезонности – суточную и недельную. Кроме того, при наличии большего количества данных мы смогли бы увидеть еще и годовую сезонность. На данном графике видно повышенное потребление электричества в январе-феврале, когда в Австралии жарко и работает много кондиционеров. По графику автокорреляций мы видим, что наибольшую корреляцию имеют соседние измерения, а также значения сутки назад, двое суток назад, и т.д. Наоборот, значения 12, 36, ... часов назад имеют отрицательную корреляцию. \n\n\n![ex_2_edd214b6d4.webp](https://yastatic.net/s3/education-portal/media/ex_2_edd214b6d4_4e74f3807d.webp)\n\n![ex_2_autocorr_0728c487f9.webp](https://yastatic.net/s3/education-portal/media/ex_2_autocorr_0728c487f9_d664a5bf1f.webp)\n\n## Стационарные временные ряды\n\t\nВременной ряд $y_t$ называется **стационарным**   \n* **в узком смысле**, если для любых $\\ t_1, ..., t_n, \\tau$ вектор $(y_{t_1+\\tau}, ..., y_{t_n+\\tau})$ совпадает по распределению с $(y_{t_1}, ..., y_{t_n})$, то есть при сдвиге всех моментов времени на одно и тоже число совместное распределение значений временного ряда в эти моменты времени не поменяется.   \n* **в широком смысле**, если \n    * $\\mathbb{E} y_t^2 < +\\infty$ для любого $t$. \n    * $\\mathbb{E} y_t$ не зависит от $t$, то есть в среднем значение временного ряда постоянно.   \n    * $cov(y_{t+\\tau}, y_{s+\\tau}) = cov(y_{t}, y_{s})$ для любых $t, s, \\tau$, то есть значение автокорреляции зависит только от длины отрезка времени между двумя значениями.  \n* **для гауссовских распределений**, то есть для случая, когда все векторы вида $(y_{t_1}, ..., y_{t_n})$ имеют нормальное распределение, определения эквивалентны. Это следует из того, что распределение гауссовского случайного вектора полностью определяется математическим ожиданием и ковариациями.\n\t\t\n*Пример.* Рассмотрим временной ряд $y_t = \\xi_1 \\cos t + \\xi_2 \\sin t$, где $\\xi_1, \\xi_2$ и независимы и одинаково распределены, причем $\\mathsf{P}(\\xi_1=1) = \\mathsf{P}(\\xi_1=-1) = 1/2$.\n\t\nМожем заметить, что $\\mathbb{E} y_1 = 0$ и $cov(y_t, y_s) = \\cos t\\cos s\\ \\mathsf{D} \\xi_1 + \\sin t\\sin s\\ \\mathsf{D} \\xi_2 = \\cos (t-s)$. Тем самым имеем стационарность в широком смысле.\n\t\nНо при $t=0$ получаем $y_0 = \\xi_1 \\in \\{-1, 1\\}$, а при $t = \\pi/4$ получаем \n\n$$y_{\\pi/4} = \\frac{\\xi_1 + \\xi_2}{\\sqrt{2}} \\in \\left\\{-\\sqrt{2}, 0, \\sqrt{2}\\right\\}.$$\n\nМы получили разные распределения, поэтому нет стационарности в узком смысле.   \n\n**Некоторые примеры нестационарных временных рядов:**\n* *Случайное блуждание* – пример: $y_t = y_{t-1} + \\varepsilon_t$, где $\\varepsilon_t$ – белый шум, то есть независимые одинаково распределенные случайные величины. Математическое ожидание постоянно, но ряд не является стационарным, поскольку $\\mathsf{D} y_t$ бесконечно растет. \n* *Временной ряд с трендом* – пример: $y_t = \\alpha + \\beta t + \\varepsilon_t$, где $\\varepsilon_t$ – белый шум. Ряд не стационарен, так как $\\mathbb{E} y_t$ меняется с течением времени. \n* *Временной ряд с сезонностью* – пример: $y_t = \\sin t + \\varepsilon_t$, где $\\varepsilon_t$ – белый шум. Не стационарен, так как \n\n$$\\mathbb{E} y_t=\\begin{cases}\n-1, \\text{ при }t = -\\pi/2 + 2\\pi k; \\\\ \n1, \\text{ при }t = t = \\pi/2 + 2\\pi k.\n\\end{cases}$$\n\nСтационарный ряд визуально не имеет предсказуемых закономерностей. Если посмотреть на график такого ряда издалека, то он будет горизонтален. \n\t\nРяд можно проверить строго на станционарность с помощью различных статистических критериев. Наиболее популярны следующие критерии:\n* критерий KPSS (Kwiatkowski–Phillips–Schmidt–Shin): если p-value $\\leqslant 0.05$, то отвергаем стационарность; \n* критерий Дики-Фуллера: если p-value $\\leqslant 0.05$, то отвергаем \\textbf{НЕ}стационарность.\n\nРассмотрим несколько примеров временных рядов:\n* ряды **а**, **c**, **d**, **e**, **f**, **i** не стационарны, поскольку они имеют тренд;\n* ряд **b** скорее всего стационарный, имеется выброс;\n* ряды **d**, **g**, **h**, **i** не стационарны, потому что имеют сезонность.\n\n![stationary_1_d37b1e56c7.webp](https://yastatic.net/s3/education-portal/media/stationary_1_d37b1e56c7_6a2ecf5808.webp)\n\nКогда вы определяете, чем вызвано изменение данных – трендом или шумом – стоит учитывать природу данных. Например, колебания значений ряда **f** теоретически можно было бы объяснить шумом в данных, но по временной оси мы видим, что данные представлены за 15 лет, соответственно, понимаем данные колебания как изменения тренда. Аналогично, для ряда **d** мы говорим о наличии меняющегося тренда помимо годовой сезонности.\n\n### Приведение к стационарным: стабилизация дисперсии\n\t\n**Зачем?**\n\t\nДанные методы рекомендуется использовать, если задача требует некоторой аналитики временного ряда. Если же требуется только построить точечный прогноз на будущее без построения предсказательных интервалов, то стабилизация дисперсии не является необходимой процедурой. Если же нас интересует предсказательный интервал, то многие методы лучше обрабатывают именно стационарные ряды, поэтому имеет смысл стабилизировать дисперсию.\n\t\n**Преобразования:**\n* Класс преобразований Бокса-Кокса с параметром $\\lambda$:\n\n$$z_t = \n\\begin{cases} \\ln y_t, & \\lambda = 0 \\\\\n  (y_t^\\lambda - 1) / \\lambda, & \\lambda \\not=0 \n  \\end{cases}.$$  \n   \n\n* Если есть предположения о зависимости $\\mathsf{D} y_t$ от $t$, то можно рассмотреть ряд $z_t = y_t \\left/ \\sqrt{\\mathsf{D} y_t} \\right.$.\n\t\nПосле построения прогноза для преобразованного ряда нужно сделать обратное преобразование.  \n\n### Приведение к стационарным: тренд и сезонность\n\t\n**Преобразования:**\n\n* Дифференцирование ряда, то есть переход к ряду $(y'_t, t \\in \\{2, ..., T\\})$, где $y'_t = y_t - y_{t-1}$. Данное преобразование используется для снятие тренда.\n* Сезонное дифференцирование ряда, то есть переход к ряду $(y'_t, t \\in \\{s+1, ..., T\\})$, где $y'_t = y_t - y_{t-s}$, $s$ – длина сезона. \n\t\nПреобразования можно применять несколько раз. Обычно сначала применяют сезонное дифференцирование.  \n\nПосмотрим на пример. В критерии KPSS для исходного ряда $pvalue < 0.01$, то есть ряд можно считать нестационарным. После логарифмирования ряда $pvalue < 0.01$, а после ещё и сезонного дифференцированная $pvalue > 0.1$, тем самым полученный ряд мы уже не можем отличить от стационарного.\n\n![ex_5_log_diff_43309ae800.webp](https://yastatic.net/s3/education-portal/media/ex_5_log_diff_43309ae800_072a5d4f53.webp)\n\n### Модели вида экспоненциального сглаживания\n\t\n#### Простое экспоненциальное сглаживание\n\nНе редко временной ряд выглядит довольно шумным, что может достаточно плохо сказаться на работе других моделей и подходов к анализу этого временного ряда. В таком случае можно попытаться сгладить значения ряда. Далее мы рассмотрим несколько моделей сглаживания ряда, в том числе при наличии тренда и сезонности ряда. Помимо сглаживания истории ряда, с помощью данных методов можно также осуществлять простое прогнозирование ряда.\n\t\nПусть имеется временной ряд $y_t$. В результате экспоненциального сглаживания получается новый временной ряд $\\widehat{y}$ по правилу\n\n$$\\widehat{y}_{t+1\\vert t} = \\alpha y_t + (1 - \\alpha) \\widehat{y}_{t\\vert t - 1},$$\n\nгде $\\widehat{y}_{t+h\\vert t}$ – прогноз значения $y_{t+h}$ в момент времени $t$, а $\\alpha$ – *параметр сглаживания*.\n\nСмысл преобразования следующий – сглаженное значение в момент времени $t+1$ есть взвешенная комбинация предыдущего значения ряда $y_t$ и предыдущего сглаженного значения ряда $\\widehat{y}_{t\\vert t - 1}$.\n\t\nСвойства:\n* при $\\alpha \\approx 1$ больший вес последнему значению ряда, поэтому получается слабое сглаживание $\\widehat{y}_{T+1\\vert T} \\approx y_T$; \n* при $\\alpha \\approx 0$ больший вес отдается предыдущему сглаженному значению, и получается сильное сглаживание, что в пределе вырождается в среднее $\\widehat{y}_{T+1\\vert T} \\approx \\overline{y}$;\n* Оптимальное значение $\\alpha^{\\ast}$ можно подобрать либо по графику, либо оптимизируя\n\n$$\\sum\\limits_{t=t_0}^T \\left(\\widehat{y}_{t}(\\alpha) - y_t\\right)^2 \\to \\min_{\\alpha}.$$\n\nСуществуют следующие эмпирические правила:\n* если $\\alpha^{\\ast} \\in (0, 0.3)$ то ряд стационарен, можно применять экспоненциальное сглаживание без риска большой потери информации; \n* если $\\alpha^{\\ast} \\in (0.3, 1)$ то ряд нестационарен, применение экспоненциального сглаживания может привести к потере информации или смещению.\n\nПримеры: на каждом из графиков изображен исходный ряд (синий) и сглаженный ряд (оранжевый) для разных значений параметра сглаживания. Если имеется тренд или сезонность, то при большом сглаживании полученный ряд начинает «запаздывать» за исходным рядом.\n\n![es001_5ecc7e857a.webp](https://yastatic.net/s3/education-portal/media/es001_5ecc7e857a_061711ef44.webp)\n\n![es01_9f507d59c5.webp](https://yastatic.net/s3/education-portal/media/es01_9f507d59c5_ec54dd8b9a.webp)\n\t\n**Откуда взялась эта формула экспоненциального сглаживания?**\n\t\nПокажем, что сглаженное значение соответствует прогнозу величины $x$ в момент времени $T+1$, подбираемому по правилу\n\n$$\\sum\\limits_{t = 0}^T\\beta^{T - t}(y_{t} - x)^2 \\rightarrow \\min\\limits_x.$$ \n\t\nИначе говоря, для прогнозирования мы берем взвешенный MSE с экспоненциально убывающими по времени весами.\n\t\nПриравняем производную к нулю:\n\n$$2\\sum\\limits_{t = 0}^T\\beta^{T - t}(y_{t} - x) = 0$$ \n\t\t\nОтсюда выразим $x$ и воспользуемся разложением функции $\\frac{1}{1-x}$ в ряд Тейлора  \n\n$$x = \\dfrac{\\sum\\limits_{t = 0}^{T}\\beta^{T - t}y_t}{\\sum\\limits_{t = 0}^{T}\\beta^t} \n\t \\approx \\dfrac{\\sum\\limits_{t = 0}^{T}\\beta^{T - t}y_t}{1/(1 - \\beta)} \n\t  =(1 - \\beta) \\sum\\limits_{t = 0}^T\\beta^{T - t}y_t =$$ \n\n$$ =  (1 - \\beta)  y_T + (1 - \\beta) \\beta \\sum\\limits_{t=0}^{T - 1}\\beta^{T - 1 - t}y_t \n\t = (1 - \\beta)y_T + \\beta \\widehat{y}_{T|T - 1}$$ \n\t\nТем самым мы получили модель экспоненциального сглаживания для $\\beta = 1 - \\alpha$.\n\t\n### Модель Хольта\n\t\nАддитивный линейный тренд:\n\t\nПрогноз на $d$ шагов вперед выражается с помощью линейной функции от числа шагов, где коэффициенты меняются по формулам, аналогичным экспоненциальному сглаживанию\n\n$$\\widehat{y}_{t+d|t} = a_t + b_t \\cdot d,$$\n\n$$a_t = \\alpha y_t + (1-\\alpha) (a_{t-1} + b_{t-1})$$\n\n$$b_t = \\beta (a_t - a_{t-1}) + (1-\\beta) b_{t-1}$$  \n\t\nМодель для мультипликативного линейного тренда выглядит аналогично\n\n$$\\widehat{y}_{t+d|t} = a_t b_t^d,$$\n\n$$a_t = \\alpha y_t + (1-\\alpha) (a_{t-1} b_{t-1})$$\n\n$$b_t = \\beta \\frac{a_t}{a_{t-1}} + (1-\\beta) b_{t-1}$$ \n\t\n**Модель Хольта: пояснение формул**\n\t\nПоясним на примере аддитивного тренда, почему формулы для $a_t$ и $b_t$ получаются именно такими.\n\t\nЗаметим, что для $d=0$ и $d=1$ и момента времени $t+1$ получаем $\\widehat{y}_{t + 1\\vert t + 1} = a_{t + 1}$, $\\widehat{y}_{t + 1\\vert t} = a_{t} + b_{t}$. Хотелось бы, чтобы эти прогнозы примерно совпадали, то есть чтобы имело место $a_{t + 1} - a_{t} \\approx b_{t}$.\n\n* Рассмотрим ряд разностей $\\Delta y_t = a_{t + 1} - a_{t}$ и задачу константного прогноза для него (то есть $\\Delta \\widehat{y}_{t \\vert t - 1} = b$) методом простого экспоненциального сглаживания\n$$\\sum\\limits_{i = 0}^{t}(1 - \\beta)^{t - i}(\\Delta y_i - b)^2 \\rightarrow \\min_b.$$\n\n  Ее решение мы уже получили ранее:\n  \n  $$b_t = \\beta \\Delta y_{t - 1} + (1 - \\beta)b_{t - 1} = \\beta (a_t - a_{t-1}) + (1-\\beta) b_{t-1}.$$ \n\t\n  Получилась формулу для $b_t$ в модели аддитивного тренда.\n\t\n* Далее, мы хотим, чтобы имело место $a_{t + 1} \\approx b_{t} + a_{t}$. Рассматривая для $y_t$ экспоненциальное сглаживание, в котором в качестве предыдущего значения сглаженного ряда берется $b_t+a_t$, а в качестве нового – $a_{t + 1}$, получаем\n\n  $$a_t = \\alpha y_t + (1-\\alpha) (a_{t-1} + b_{t - 1}).$$\n\t\n### Модель Хольта-Уинтерса\n\t\n**Аддитивная сезонность с трендом:**\n\n$$\\widehat{y}_{t+d|t} = a_t + db_t + s_{t-m+(d \\text{ mod } m)},$$\n\n$$a_t = \\alpha (y_t - s_{t-m}) + (1-\\alpha) (a_{t-1} + b_{t-1})$$\n\n$$b_t = \\beta (a_t - a_{t-1}) + (1-\\beta) b_{t-1}$$\n\n$$s_t = \\gamma(y_t - a_t) + (1-\\gamma)s_{t-m}$$\n\nгде $m$ – длина сезона \n\n**Мультипликативная сезонность**\n\t\n*Без тренда*\n\n$$\\widehat{y}_{t+d|t} = a_t \\cdot s_{t-m+(d \\text{ mod } m)},$$\n\n$$a_t = \\alpha (y_t / s_{t-m}) + (1-\\alpha) a_{t-1}$$\n\n$$s_t = \\gamma(y_t / a_t) + (1-\\gamma)s_{t-m}$$\n\t\n*С линейным трендом*\n\n$$\\widehat{y}_{t+d|t} = (a_t + db_t) s_{t-m+(d \\text{ mod } m)},$$\n\n$$a_t = \\alpha \\frac{y_t}{s_{t-m}} + (1-\\alpha) (a_{t-1} + b_{t-1})$$\n\n$$b_t = \\beta (a_t - a_{t-1}) + (1-\\beta) b_{t-1}$$\n\n$$s_t = \\gamma\\frac{y_t}{a_t} + (1-\\gamma)s_{t-m}$$\n\n**Разные модели с трендом и сезонностью**\n\n![trends_variants_338d57ad2e.webp](https://yastatic.net/s3/education-portal/media/trends_variants_338d57ad2e_6cd82b851a.webp)\n\n### Адаптивное сглаживание\n\nВ примерах выше мы видели, что при изменении локального тренда ряда экспоненциальное сглаживание запазывает за значениями ряда при использовании сильного сглаживания. Если же использовать слабое сглаживание, то существенного запаздывания не проиходит, но ряд остается шумным. Если для ряда предполагаются значительные структурные изменения, можно использовать модель адаптивного экспоненциального сглаживания, в которой параметр сглаживания может меняться для разных отрезков временного ряда.\n\nПусть $\\widehat{y}_t$ – прогноз значения $y_t$ в момент времени $t-1$ обычным экспоненциальным сглаживанием, а $\\widehat{\\varepsilon}_t = y_t - \\widehat{y}_t$ – ошибка прогноза, сделанного на шаге $t-1$.  \n\t\nОпределим следующие значения\n* Среднее значение ошибки:\n\n$$E_t = \\gamma \\widehat{\\varepsilon}_t + (1-\\gamma)E_{t-1}.$$\n\n* Средний разброс ошибки: \n\n$$A_t = \\gamma \\left|\\widehat{\\varepsilon}_t\\right| + (1-\\gamma)A_{t-1}.$$\n\n* $K_t = E_t/A_t$ – статистика, которая сигнализирует, насколько адекватно модель работает в момент времени $t$.  \n    * $K_t \\approx \\pm 1$ – модель систематически ошибается в одну сторону. \n    * $K_t \\approx 0$ – модель работает адекватно. \n\t\nОбычно берут значения $\\gamma \\in (0.05, 0.1)$. \nЧтобы экспоненциальное сглаживание быстро приспосабливалось к резким структурным изменениям берут $\\alpha_t = \\min \\left(|K_t|, 1\\right)$.\n\nОднако, у данного подхода есть и недостатки, например, \n* плохо реагирует на одиночные выбросы;\n* требует подбора $\\gamma$. \n\n![adaptive_7840bb4683.webp](https://yastatic.net/s3/education-portal/media/adaptive_7840bb4683_0b340f664c.webp)",
        "handbook": "Учебник по машинному обучению",
        "title": "Аналитика временных рядов",
        "description": null
    },
    {
        "path": "/handbook/ml/article/modeli-vida-arima",
        "content": "Прежде чем перейти к рассмотрению модели ARIMA, познакомимся сначала с двумя другими моделями: скользящего среднего и моделью авторегрессии.\n\n## Модель скользящего среднего MA($q$)\n\t\nМодель скользящего среднего порядка $q$ или просто MA($q$) предполагает следующую зависимость даннных:\n\n$$y_t\\ =\\ \\mu + \\varepsilon_t + \\theta_1 \\varepsilon_{t-1} + ... + \\theta_q \\varepsilon_{t-q},$$\n\nгде $y_t$ &mdash; стационарный ряд со средним $\\mu$, а $\\varepsilon_t$ &mdash; гауссовский белый шум, то есть $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$ и независимы. \n\t\nПо сути наш ряд $y_t$ выражается через сумму некоторого фиксированного среднего $\\mu$, значения белого шума в текущий момент времени $\\varepsilon_t$ и не более $q$ предыдущих значений белого шума, домноженных на некоторые коэффициенты, которые являются параметрами модели. \n\nРассмотрим некоторые свойства модели MA($q$). Как уже было упомянуто выше, ряд $y_t$ будет являтьcя стационарным со средним $\\mu$. Найдем также $\\mathsf{D}y_t$. Воспользовавшись свойством независимости для $\\varepsilon_t$, можем заключить, что \n\n$$\\mathsf{D}y_t = \\left(1 + \\theta_1^2 + \\dots + \\theta_q^2\\right)\\sigma^2.$$\n\nПосчитаем автоковариационную функцию для ряда $y_t$, то есть найдем значение $cov(y_t, y_{t + \\tau})$. Легко понять, что если $\\tau > q$, то $cov(y_t, y_{t+\\tau})$ = 0, т.к. $\\varepsilon_t$ независимы. Если же $\\tau \\leq q$, то тогда \n\n$$cov(y_t, y_{t+\\tau}) = \\left(\\theta_{\\tau} + \\theta_1\\theta_{\\tau + 1} + \\dots + \\theta_{q-\\tau}\\theta_{q}\\right)\\sigma^2.$$\n\nЗаписав более компактно, можем получить:\n\n$$\ncov(y_t, y_{t+\\tau}) = \\begin{cases}\n\\sigma^2\\sum_{j=0}^{q-\\tau}\\theta_j\\theta_{\\tau + j}, & \\tau \\leq q; \\\\\n0 & \\tau > q;\n\\end{cases}\n$$\n\nгде $\\theta_0 = 1$. Из посчитанных значений для дисперсии и ковариационной функции, можете попробовать получить выражение и для автокорреляционной функции. Ее особенностью будет как раз равенство нулю на лаге, превосходящим $q$.\n\nПосмотрим на визуализацию:\n\n![ma2_modeling_a6f7777dc7.svg](https://yastatic.net/s3/education-portal/media/ma2_modeling_a6f7777dc7_1901e89036.svg)\n\t\n## Модель авторегрессии AR($p$)\nМодель авторегрессии для временного ряда можно записать следующим образом:\n\n$$\ny_t\\ =\\ \\alpha + \\varphi_1 y_{t-1} + ... + \\varphi_p y_{t-p} + \\varepsilon_t,\n$$\n\nгде $y_t$ &mdash; стационарный ряд, а $\\varepsilon_t$ &mdash; гауссовский белый шум, то есть $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$ и независимы. Отметим, что, вообще говоря,  для стационарности нужны некоторые условия на коэффициенты $\\varphi_1, ..., \\varphi_p$.\n\t\nПо сути наш ряд $y_t$ выражается через сумму некоторого фиксированного числа $\\alpha$, значения белого шума в текущий момент времени $\\varepsilon_t$ и не более $p$ предыдущих значений этого же ряда, домноженных на некоторые коэффициенты, которые являются параметрами модели.\n\t\nДругими словами, модель AR($p$) &mdash; это модель $\\textit{линейной регрессией}$ для которой \n* **Таргет:** $y_t$ &mdash; значение ряда в момент времени $t$ \n* **Признаки:** $y_{t-1}, ..., y_{t-p}$ &mdash; значения ряда в предыдущие моменты времени\n\t\t\nВведем **$L$ &mdash; оператор сдвига**, обладающий следующими свойствами:\n* применение $L$ к ряду дает предыдущее значение этого же ряда: $Ly_t = y_{t-1}.$  \n* применение $L$ к белому шуму дает предыдущее значение шума: $L\\varepsilon_t = \\varepsilon_{t-1}.$  \n* применение $L$ к константе &mdash; это константа: $Lc = c.$\n\nОператор $L$ иногда называют также **лаговым** оператором. Можно рассматривать функции от оператора сдвига, например, кратное применение оператора $L$: $L^2 y_t = L(L y_t) = L(y_{t-1}) = y_{t-2}$ или $L^{-1} y_t= y_{t+1}$. Для записей некоторых моделей временных рядов будет удобно использовать лаговый многочлен: \n\n$$\\varphi(L) = \\sum_{i=1}^p \\varphi_i L^{i} $$\n\nОбратным к оператору $\\varphi(L)$ называют оператор $\\varphi^{-1}(L)$ такой, что:\n\n$$\\varphi(L)\\varphi^{-1}(L)y_t = \\varphi^{-1}(L)\\varphi(L)y_t=y_t$$\n\nТак, например, для $\\lvert \\varphi \\rvert < 1$ можно заключить, что:\n$$\\frac{1}{1 - \\varphi L} = \\left(1-\\varphi L \\right)^{-1} = \\sum_{i=1}^{\\infty}\\varphi^{i}L^{i}$$\n\nРассмотрим модель AR($p$):\n\n$$y_t\\ =\\ \\alpha + \\varphi_1 y_{t-1} + ... + \\varphi_p y_{t-p} + \\varepsilon_t$$ \n \nС помощью оператора сдвига ее можно представить в следующем виде:\n\n$$a(L) y_t\\ =\\ \\alpha + \\varepsilon_t,$$\n\nгде $a(z) = 1 - \\varphi_1 z - ... - \\varphi_p z^p$ &mdash; характеристический полином.   \n\t\nСформулируем пару важных утверждений:\n* Любой стационарный (в широком смысле) процесс представим в виде $MA(\\infty)$, то есть в виде модели скользящего среднего с неограниченным количеством слагаемых (конечное или бесконечное число). Этот результат так же известен как **теорема Волда** о декомпозиции временного ряда.\n* Модель $AR(p)$ задает стационарный временной ряд $\\Longleftrightarrow$ все комплексные корни $a(z)=0$ лежат вне единичного круга. \n\t\nПриведем пояснение второго утверждения. В самом деле, пусть $z_1, ..., z_p$ &mdash; все его комплексные корни (их ровно $p$ с учетом кратности), тогда справедливо представление:\n\n$$a(z) = (z-z_1)...(z-z_p) = z_1...z_p \\left(1 - \\frac{z}{z_1}\\right) ... \\left(1 - \\frac{z}{z_p}\\right)$$\n\nТогда при представлении временного ряда в виде\n\n$$y_t\\ =\\ \\frac{\\alpha + \\varepsilon_t}{a(L)}$$\n\nи дальнейшего его разложения на простые дроби возникнут слагаемые вида\n\n$$\\frac{\\varepsilon_t}{1 - \\frac{L}{z_j}}.$$\n\nЕсли при этом $z_j$ лежит внутри единичного круга или на его границе, то соответствующий ряд будет расходящимся. На самом деле, случай $z_j=1$ мы в дальнейшем учтем.\n\nВ качестве примера рассмотрим подробнее модель $AR(1)$.\nЗависимость имеет вид $y_t = \\alpha + \\varphi y_{t - 1} + \\varepsilon_t$, где $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2)$. Для данного ряда можно выписать следующие свойства:\n* Уравнение $1 - \\varphi z = 0$, имеет корень $\\lambda = 1/\\varphi$. \n* Тем самым, $AR(1)$ стационарен $\\Longleftrightarrow$ $\\lvert\\varphi\\rvert < 1$. Кроме того, чем меньше $\\varphi$, тем предыдущее значение ряда вносит меньший вклад в текущее значение.\n* Если ряд стационарен, то:\n\t* $\\mathsf{E} y_t = \\frac{\\alpha}{1-\\varphi}$\n\t* $\\mathsf{D} y_t = \\dfrac{\\sigma^2}{1-\\varphi^2}$\n\t* $cov (y_t, y_{t - h}) = \\varphi^h \\cdot \\dfrac{\\sigma^2}{1-\\varphi^2}$.\n\nРазберем первое равенство, остальные получаются аналогично. Возьмем математическое ожидание в уравнении ряда\n\n$$\\mathsf{E} y_t = \\alpha + \\varphi \\mathsf{E} y_{t - 1} +\\mathsf{E} \\varepsilon_t$$\n\nПоскольку ряд стационарен, то его математическое ожидание не меняется во времени, а для белого шума математическое ожидание равно нулю. Тем самым мы получаем уравнение на $m = \\mathsf{E} y_t$, откуда следует доказываемая формула.\n\nТаким образом, в зависимости от значения $\\varphi$ мы можем получить следующие результаты:\n* Если $\\lvert\\varphi\\rvert < 1$, то $y_t = \\mu + \\sum\\limits_{j = 0}^{\\infty}\\varphi^j\\varepsilon_{t - j}$ &mdash; представление ряда в виде MA($\\infty$). \n* Если $\\lvert\\varphi\\rvert = 1$, то $AR(1)$ &mdash; это случайное блуждание. \n* Если $\\lvert\\varphi\\rvert > 1$, то $AR(1)$ &mdash; экспоненциально растущий процесс. \n\nПосмотрим на визуализацию.\n\n![ar1_modeling_2e6dc1d6f7.svg](https://yastatic.net/s3/education-portal/media/ar1_modeling_2e6dc1d6f7_82d4f46e94.svg)\n\n* В первом случае мы имеем модель $y_t = - 0.5 y_{t - 1} + \\varepsilon_t$, отрицательный коэффициент является следствием больших колебаний ряда. \n\n* Во втором случае модель $y_t = 0.9 y_{t - 1} + \\varepsilon_t$, большой положительный коэффициент делает ряд менее шумным. \n\n* В третьем случае показано несколько рядов вида случайного блуждания $y_t = y_{t - 1} + \\varepsilon_t$, что соответствует случаю $\\varphi=1$. \n\n* В четвертом случае показан экспоненциальный процесс $y_t = 1.1 y_{t - 1} + \\varepsilon_t$, на графике шум уже не заметен из-за масштаба.\n\nНа немного вернемся к модели MA($q$). Чуть выше мы выяснили, что при некоторых условиях на коэффиценты $\\varphi$ временной ряд модели AR($p$) будет стационарным, а значит имеет представление в виде MA($\\infty$). На самом деле, модель скользящего среднего порядка $q$ тоже можно представить с помощью оператора $L$ следующим образом:\n\n$$y_t\\ =\\ \\mu + \\varepsilon_t + \\theta_1 \\varepsilon_{t-1} + ... + \\theta_q \\varepsilon_{t-q}\\ =\\  \n\t\t\\mu + b(L)\\varepsilon_t$$\n\nгде $b(z) = 1 + \\theta_1 z + ... + \\theta_q z^q$ &mdash; **характеристический многочлен**. Для простоты изложения пусть $\\mu = 0$. Важным при такой записи оказывается понятие обратимости, то есть представления в виде\n\n$$\n\\varepsilon_t = b^{-1}(L)y_t,\n$$\n\nкоторое означает, что ряд можно представить в виде бесконечной авторегрессионной модели.\nЗдесь, как и в рассуждениях выше, можно заключить, что временной ряд $y_t$ обратим, если все комплексные корни $b(z) = 0$ лежат вне единичного круга. \n\n## Модель ARMA($p, q$)\n\t\nМодель ARMA($p, q$) по сути является суммой моделей $AR(p)$ и $MA(q)$, иначе говоря, модель есть сумма нескольких предыдущих значений ряда и нескольких предыдущих значений белого шума с некоторым коэффициентами.\n\n$$y_t\\ =\\ \\alpha + \\varphi_1 y_{t-1} + ... + \\varphi_p y_{t-p}\n\t + \\varepsilon_t + \\theta_1 \\varepsilon_{t-1} + ... + \\theta_q \\varepsilon_{t-q}$$\n\t\nЭквивалентную запись ряда в терминах оператора сдвига можно получить, рассмотрев два многочлена\n\n$$a(L) y_t = \\alpha + b(L) \\varepsilon_t$$\n\nили\n\n$$y_t = \\mu + \\frac{b(L)}{a(L)} \\varepsilon_t,$$\n\nгде $a(z) = 1 - \\varphi_1 z - ... - \\varphi_p z^p,$ и $b(z) = 1 + \\theta_1 z + ... + \\theta_q z^q$.\nЗаметим, что во втором представлении константа $\\alpha$ заменена на $\\mu = \\mathsf{E} y_t$. На самом деле, стационарность такого ряда будет определяться только его AR($p$) компонентой, то есть значениями коэффициентов $\\varphi$, так ряд в модели MA($q$) всегда является стационарным.\n\n## Модель ARIMA($p, d, q$)\n\t\nМодель ARIMA($p, d, q$) &mdash; это расширение моделей типа ARMA на нестационарные временные ряды, которые однако могут стать стационарным после применениея процедуры дифференцирования ряда. Модель ARIMA($p, d, q$) для ряда $y_t$ определяется как модель ARMA($p, q$) для ряда разностей порядка $d$ ряда $y_t$.  \n\t\n* Разность порядка 1: $y_t - y_{t-1} = (1 - L) y_t$.\n* Разность порядка 2: $(1 - L)^2 y_t = (1 - L) (y_t - y_{t-1}) = (y_t - y_{t-1}) - (y_{t-1} - y_{t-2}) = y_t - 2y_{t-1} + y_{t-2}$.\n\t\nПолучаем формулу модели ARIMA:\n\n$$a(L) (1 - L)^d y_t = \\alpha + b(L) \\varepsilon_t$$\n\nили\n\n$$(1 - L)^d y_t = \\mu + \\frac{b(L)}{a(L)} \\varepsilon_t.$$ \n\nТо есть многочлен $\\widetilde{a}(z) = a(z) (1-z)^d$ имеет $d$ единичных корней. \nТем самым такая модель позволяет учесть нестационарности, в частности, тренд. \n\nВ качестве примера рассмотрим процесс случайного блуждания:\n\n$$y_t = y_{t-1} + \\varepsilon_t, $$\n\nгде $\\varepsilon_t$ &mdash; белый шум. Как уже упомяналось ранее, такой ряд не является стационарным. Однако, если мы применим операцию дифференцирования, то можем перейти к новому, уже стационарном ряду $y'_t = y_t - y_{t-1}$, который можно записать в виде:\n\n$$ y'_t = \\varepsilon_t$$\n\n## Частичная автокорреляция\n\nДля модели скользящего среднего порядка $q$ мы выяснили, что значения автокорреляционной функции для такого ряда оказывается равной нулю после лага $q$. Эта особенность позволяет использовать автокорреляционную функцию для определения порядка модели скользящего среднего. Возникает разумный вопрос, как оценить порядок $p$ для модели AR($p$)? Здесь оказывается полезным понятие частичной (частной) автокорреляционной функции. \n\n**Частичная автокорреляция (PACF)** &mdash; корреляция ряда с собой после снятия линеной зависимости от промежуточных значений ряда. Иначе говоря, мы хотим как-то учесть опосредованного влияние промежуточных значений ряда и оценить непосредственное влияние $y_{t - \\tau}$ на $y_t$. Чуть более формально частичную автокорреляцию можно записать следующим образом:\n\n$$\n\\gamma_{\\tau} = \\begin{cases} corr(y_{t+1}, y_t), & \\tau=1; \n\t\\\\ corr\\left(y_{t+\\tau} - y_{t+\\tau}^{h-1}, y_t - y_t^{\\tau-1}\\right), & \\tau\\geqslant2, \\end{cases}\n$$\n\nгде $y_t^{\\tau-1}$ &mdash; линейная регрессия на $y_{t-1}, y_{t-2}, ..., y_{t - (\\tau-1)}$: \n* $y_t^{\\tau-1} = \\varphi_1 y_{t-1} + \\varphi_2 y_{t-2} + ... + \\varphi_{\\tau-1} y_{t - (\\tau-1)}$ \n* $y_{t+\\tau}^{\\tau-1} = \\varphi_1 y_{t+\\tau-1} + \\varphi_2 y_{t+\\tau-2} + ... + \\varphi_{\\tau-1} y_{t+1}$\n\nПример для $\\tau=2$:\n\n$$\\gamma_{2} = corr\\left(y_{t+2} - \\varphi_1 y_{t+1}, y_t - \\varphi_1 y_{t-1}\\right)$$\n\t\t\nгде $\\varphi_1$ &mdash; МНК-оценка в модели $y_t = \\varphi y_{t-1}$.\n\nМожно показать, что значение частиной автокорреляции для модели авторегресии AR($p$) будет ненулевой для лагов $\\tau \\leq p$ и равняться нулю для лагов $\\tau > p$. Имеет место быть полная аналогия с автокорреляционной функцией и моделью MA($q$). Таким образом, исследование поведения автокорреляционной и частичной автокорреляционной функции может быть использовано для определения порядка $q$ модели скользящего среднего и порядка $p$ модели авторегрессии соответсвтенно.\n\n## Оценка коэффициентов в ARIMA\n\t\nПусть гиперпараметры $p, d, q$ фиксированы.\tВ предположении, что $\\varepsilon_t$ &mdash; гауссовский белый шум, в нашей модели мы можем выписать функцию правдоподобия $L_y(\\theta, \\varphi, \\alpha) = p_{\\theta, \\varphi, \\alpha}(y_1, ..., y_T),$ где $ p_{\\theta, \\varphi, \\alpha}(a_1, ..., a_T)$ &mdash; соместная плотность. Из-за того, что $\\varepsilon_t$ имеют нормальное распределение, она будет иметь разумный вид. Соответственно, в качестве оценок параметров берется оценка максимального правдоподобия.   \n\nДля поиска начальных приближение для параметров $p$ и $q$ воспользуемся автокорреляционной и частичной автокорреляционной функцией.\n* Начальное приближение $p$: последний значимый пик у PACF.\n* Начальное приближение $q$: последний значимый пик у ACF.\n\nДалее обычно используется поиск по сетке вокруг подобранных значений, минимизируя информационный критерий:\n* $AIC = -2\\ell^* + 2(p+q+1)$ &mdash; критерий Акаике; \t\n* $AIC_c = -2\\ell^* + \\frac{2(p+q+1)(p+q+2)}{T-p-q-2}$ &mdash; критерий Акаике (короткие ряды); \n* $BIC = -2\\ell^* + (\\log T - 2)(p+q+1)$ &mdash; Байесовский информационный критерий или критерий Шварца,\n\t\nгде $\\ell^* = \\ln L_y\\left(\\widehat{\\theta}, \\widehat{\\varphi}, \\widehat{\\alpha}\\right)$ &mdash; логарифм функции правдоподобия, $T$ &mdash; длина временного ряда.\n\t\nПриведем некоторый план при применению модели ARIMA для прогнозирования временных рядов.\n\t\n1. Анализ выбросов: замена нерелевантых выбросов на `NA` или усреднение по соседним элементам.  \t\n2. Стабилизация дисперсии (преобразования).    \n3. Дифференцирование, если ряд не стационарен.    \t\n4. Выбор пилотных $p$ и $q$ по PACF и ACF.    \t\n5. Вокруг этих параметров подбираем оптим. модель по $AIC$/$AIC_c$.    \n6. Пошаговое построение прогноза:               \n\t  — для $t \\leqslant T$: $\\varepsilon_t \\Longrightarrow \\widehat{\\varepsilon}_t = y_t - \\widehat{y}_t$;  \n\t  — для $t > T$: $\\varepsilon_t \\Longrightarrow 0$;  \n\t  — для $t > T$: $y_t \\Longrightarrow \\widehat{y}_t$. \n\t\t\n7. Построение предсказательного интервала:  \n\t\t\n\t— если остатки модели нормальны и гомоскедастичны (дисперсия постоянна), то строится теоретический предсказательный интервал\n\n\t$$\\widehat \\sigma^2(h) = \\widehat \\sigma^2 \\left(1 + \\sum\\limits_{i = 1}^{h - 1} \\widehat{\\psi}_i^2\\right)$$\n\n\tгде $h$ &mdash; горизонт прогнозирования, $\\widehat\\sigma^2$ &mdash; оценка на дисперсию шума $\\varepsilon_t$, $\\widehat{\\psi}_i$ &mdash; коэф. для ряда при его представлении в виде бесконечного процесса скользящего среднего. И $\\widehat\\sigma^2$, и $\\widehat{\\psi}_i$ могут быть выражены через оценки на параметры $\\varphi$ и $\\theta$.       \n\t— иначе интервалы строятся с помощью бутстрепа.\n\n## Модели SARIMA и ARIMAX\n\nРассмотрим некоторые расширение модели ARIMA. Обобщение модели ARIMA на ряды с наличием сезонной составляющей назвается SARIMA. Пусть $s$ &mdash; известная сезонность ряда. Добавим в модель ARIMA($p, d, q$) компоненты, отвечающие за значения в предыдущие сезоны. Тогда модель SARIMA $(p, d, q)\\times (P, D, Q)_s$ может быть записана следующим образом:\n\n$$(1 - L)^d (1 - L^s)^D y_t = \\mu + \\frac{b(L) B(L^s)}{a(L) A(L^s)} \\varepsilon_t,$$\n\nгде \n\n$$a(z) = 1 - \\varphi_1 z - ... - \\varphi_p z^p,$$ \n\n$$b(z) = 1 + \\theta_1 z + ... + \\theta_q z^q,$$\n\n$$A(z) = 1 - \\varphi_1^s z - \\dots - \\varphi_P z^P,$$\n\n$$B(z) = 1 + \\theta^s_1 z + \\dots + \\theta_Q^s z^Q.$$\n\nПараметр сезонного дифференцирования $D$, а также параметры $P, Q$ подбираются из тех же соображений, что и для $p, d, q$, но только с поправкой, что делается это с учетом сезонности $s$. ARIMAX &mdash; обобщение модели ARIMA, которая учитывает некоторые экзогенные факторы. Пусть $x_t \\in \\mathbb{R}^n$ &mdash; ряд регрессоров, *известный до начала прогноза*.\n\nПростой вариант:\n\n$$(1 - L)^d y_t = \\mu + \\sum_{i=1}^n \\frac{\\beta_i}{a(L)} x_t^i + \\frac{b(L)}{a(L)} \\varepsilon_t$$\n\nОбщий случай:\n\n$$(1 - L)^d y_t = \\mu + \\sum_{i=1}^n \\frac{u_i(L)}{v_i(L)} x_t^i + \\frac{b(L)}{a(L)} \\varepsilon_t$$\n\n*Пример:* $x_t = I \\{\\text{в момент времени t праздник}\\}$\n\nВышеукзанные модели можно объединить и получить SARIMAX $(p, d, q)\\times (P, D, Q)_s $:\n\t\n$$(1 - L)^d (1 - L^s)^D y_t = \\mu + \\sum_{i=1}^n \\frac{u_i(L)}{v_i(L)} x_t^i + \\frac{b(L) B(L^s)}{a(L) A(L^s)} \\varepsilon_t$$\n\t\nПроведем аналогию с линейной регрессией. Это линейная по признакам модель, в которой\n* **Отклик:** $y_t$ &mdash; значение ряда в моменты времени $t$\n* **Признаки:**  \n\t* $y_{t-1}, ..., y_{t-p}$ &mdash; значения ряда в предыдущие моменты времени  \n\t* Значение ряда за предыдущие сезоны  \n\t* Значения признаков в предыдущие моменты времени  \n\t* Значения признаков в предыдущие сезоны  \n* **Ошибка:** сумма шума за предыдущие моменты времени и предыдущие сезоны.",
        "handbook": "Учебник по машинному обучению",
        "title": "Модели вида ARIMA",
        "description": null
    },
    {
        "path": "/handbook/ml/article/zadacha-ranzhirovaniya",
        "content": "Человек, который пользуется интернетом, часто начинает решение своих задач с поиска. Поисковая система по запросу помогает найти самую полезную для пользователя информацию, будь то поиск видео или научных статей. Для решения такой задачи необходимо отсортировать по полезности имеющуюся в базе информацию и выдать самую необходимую. Обычно такую сортировку называют *ранжированием*, полезность — *релевантностью*, а соответствующую задачу — *задачей ранжирования*.\n\nОпишем задачу формально и введём обозначения.\n\n$$D\\ -\\  \\text{коллекция документов (или других объектов)}\n$$\n\n$$Q\\ -\\  \\text{множество запросов}\n$$\n\n$$\\forall q \\in Q\\ D_q \\in D\\ -\\  \\text{набор документов, потенциально релевантных запросу}\n$$\n\n**Задача:** Отсортировать документы внутри $D_q$ по убыванию релевантности запросу.\n\nУже по формулировке задачи видно, что построение решения разбивается на несколько стадий. Сначала нужно сформировать набор кандидатов $D_q$, а уже потом строить финальную сортировку. Подробнее об этом в разделе про методы ранжирования.\n\n## Примеры\n\n### WEB-поиск\n\nКлассический пример задачи ранжирования — поиск информации в интернете. Пользователь задаёт запрос, и под этот запрос формируется выдача, в которой сайты (документы) расположены по убыванию полезности. В наших обозначениях:\n\n$$D\\ -\\  \\text{база веб-страниц, проиндексированных поисковой системой}\n$$\n\n$$Q\\ -\\  \\text{множество запросов пользователей}\n$$\n\nЧтобы решать задачу ранжирования с помощью машинного обучения, необходимо иметь датасет с оценками асессоров. Обычно по парам (запрос, документ) собирают данные о том, насколько документ релевантен запросу. Такие оценки называются метками релевантности.\n\n### Поиск синонимов\n\nЗадача подбора синонимов по слову тоже может восприниматься как задача ранжирования, поскольку похожесть слов друг на друга — неоднозначное свойство, и некоторые пары слов больше похожи, чем другие. Поэтому можно сортировать слова по похожести на слово из запроса. Если $V$ — доступный словарь, то:\n\n$$D = V\\ -\\  \\text{список всех слов}\n$$\n\n$$Q = V\\ -\\  \\text{cлова, для которых можно искать синонимы}\n$$\n\nДля построения моделей можно использовать датасет пар синонимичных слов. Обучив модель классификации, обычно мы получаем предсказатор вероятности положительного класса. Отсортировав слова по предсказанной вероятности синонимичности, мы решим задачу ранжирования.\n\n### Рекомендательная система\n\nРекомендательные системы встроены во многие онлайн сервисы. Если вы заходите на сервис с фильмами, система порекомендует фильмы для вас, если в социальную сеть — посты или новые видео, которые вас заинтересуют. Это тоже отбор самых полезных объектов, но «запрос» в данном случае — это сам пользователь.\n\n$$D = I\\ -\\  \\text{список айтемов, доступных на сайте (объявления, фильмы)}\n$$\n\n$$Q = U\\ -\\  \\text{пользователь вместе с его историей}\n$$\n\nДля решения задачи построения рекомендаций используются свои методы, они рассмотрены в отдельной главе.\n\n## Метрики качества ранжирования\n\nПредположим, мы решили задачу ранжирования. Обычно это делается обучением некоторой функции от запроса и документа $a_\\theta(q, d)$ ($\\theta$ — это параметры модели). Если такая функция готова, то выдача по запросу $q \\in Q$ получается сортировкой множества $D_q$ по убыванию $a_\\theta(q, d)$.\n\nЗдесь и далее, не нарушая общности, будем считать, что мы решаем задачу WEB-поиска. Выберем множество тестовых запросов $Q_{t}$, на которых оценим качество нашего решения.\n\nДля формул метрик качества введём следующие обозначения:\n\n$$T_K(q)\\ -\\  \\text{первые } K \\text{ элементов выдачи по запросу } q \n$$\n\n$$d_q^{(k)}\\ -\\ k \\text{ по порядку документ в выдаче}\n$$\n\nСоответственно, $T_K(q) = \\{ d_q^{(1)}, \\dots, d_q^{(k)} \\}$\n\n### Бинарная релевантность\n\nВеличина, которая обозначает, насколько документ подходит запросу, называется *релевантностью*. Способов измерить эту величину много. Обычно решение о том, релевантен документ запросу или нет, принимают асессоры — специальные люди, которые размечают данные для обучения ML-моделей. Собранные оценки называются *метками релевантности*, будем обозначать метку для запроса $q$ и документа $d$ за $y(q, d)$.\n\nДля начала введём метрики для случая бинарной релевантности, когда $y(q, d) \\in \\{0, 1\\}$.\n\n#### Precision / Recall\n\nЕсли у релевантности есть всего 2 класса, то можно вспомнить метрики классификации и обобщить их для задачи ранжирования.\n\nБудем считать, что ранжирующая модель считает релевантными те документы, которые попали в первые $K$ элементов выдачи, то есть $T_K(q)$. Тогда можно вычислить метрики precision и recall в зависимости от $K$.\n\n$$Precision@K = \\frac{\\text{число релевантных в топе}}{K} = \\frac{\\sum\\limits_{d \\in T_K(q)} I\\{y(q, d) = 1\\}}{K} \n$$\n\n$$Recall@K = \\frac{\\text{число релевантных в топе}}{\\text{всего релевантных}} = \\frac{\\sum\\limits_{d \\in T_K(q)} I\\{y(q, d) = 1\\}}{\\min(K, \\sum\\limits_{d \\in D} I\\{y(q, d) = 1\\})} \n$$\n\nВ случае с recall приходится брать минимум в знаменателе, поскольку в такой постановке модель не может выявить больше, чем $K$ релевантных документов.\n\n#### Mean Average Precision\n\nЗаметим, что метрики precision и recall хоть и показывают качество нашей ранжирующей системы, но совсем не смотрят на порядок элементов в $T_K(q)$. Чтобы его учесть, посмотрим на Precision по тем позициям, где стоят релевантные документы, и усредним их. Такая величина называется Average Precision.\n\n$$AP(q) = \\frac{1}{K} \\sum\\limits_{k = 1}^K Precision@k \\cdot y(q, d_q^{(k)})\n$$\n\nТеперь, чтобы получить труднопереводимую на русский язык метрику Mean Average Precision, нужно усреднить значения AP по всем запросам из набора.\n\n$$MAP(q) = \\frac{1}{|Q_t|} \\sum\\limits_{q \\in Q_t} AP(q)\n$$\n\n#### Mean Reciprocal Rank\n\nНазвание этой метрики переводится как средний обратный ранг. Ранжирование работает тем лучше, чем ближе к началу выдачи релевантный для пользователя документ. Для каждого запроса найдём позицию первого релевантного документа, возьмём обратное от этого числа и усредним по всем запросам.\n\n$$MRR = \\frac{1}{|Q|} \\sum\\limits_{q \\in Q} \\min\\left(i\\ |\\ y(q, d_q^{(i)}) = 1\\right)^{-1} \n$$\n\nОбозначим релевантность $k$-го документа в выдаче как $R_k = y(q, d_q^{(k)})$.\n\nТогда формулу можно переписать в следующем виде:\n\n$$MRR = \\frac{1}{|Q|} \\sum\\limits_{q \\in Q}\\sum\\limits_{i} \\prod\\limits_{k=1}^{i - 1}(1 - R_k) \\cdot R_i \\cdot \\frac{1}{i}\n$$\n\nПроизведение в формуле будет равно $1$ только в случае, когда $i$ документ релевантный, а все до него нет. В остальных случаях произведение равно $0$.\n\n## Вещественная релевантность\n\nРассмотрим теперь метрики для случая, когда релевантность может принимать вещественные значения.\n\n### Expected Reciprocal Rank\n\nПусть теперь $R_i = P(q, d_q^{(i)})$ — вероятность того, что документ $d_q^{(i)}$ релевантен. Например, если $y_i$ — метка релевантности, а $Y_{max}$ — максимальное её значение, то можно определить $R_i = \\frac{2^{y_i}}{2^{Y_{max}}}$.\n\nБудем считать, что пользователь листает выдачу документ за документом. В каждом он находит информацию, которая ему нужна, с вероятностью $R_i$. Если информацию он нашел, то он заканчивает поиск.\n\nВ такой модели хорошая система позволит пользователю найти информацию как можно быстрее. Но в отличие от бинарной релевантности позиция, где пользователь закончил поиск, теперь случайная величина, как и обратная позиция. Поэтому будем считать матожидание этой величины.\n\n$$ERR(q) = \\sum\\limits_i P(\\text{пользователь дошёл до док-та и остановился}) \\cdot \\frac{1}{i}\n$$\n\nЕсли пользователь остановился на позиции $i$, это значит, что на предыдущих документах задачу он не решил, а остановился именно на $i$-ом. В модели эти события предполагаем независимыми, поэтому вероятности можно перемножить.\n\n$$ERR(q) = \\sum\\limits_{i} \\prod\\limits_{k=1}^{i - 1}(1 - R_k) \\cdot R_i \\cdot \\frac{1}{i}\n$$\n\nЧтобы получить финальную метрику, усредняем эту величину по всем запросам.\n\n$$ERR = \\frac{1}{|Q|} \\sum\\limits_{q \\in Q}\\sum\\limits_{i} \\prod\\limits_{k=1}^{i - 1}(1 - R_k) \\cdot R_i \\cdot \\frac{1}{i}\n$$\n\nЗаметим, что формула совпала с формулой для метрики MRR для бинарной релевантности.\n\n### pFound\n\nРассмотрим ещё одну метрику, которая основывается на модели поведения пользователя. Метрика pFound была придумана в Яндексе и некоторое время была основной для ранжирования.\n\nПусть релевантность задаётся одним из классов $y(q, d) \\in \\mathbb{Y} = \\{\\text{Not Rel}, \\text{Rel-}, \\text{Rel+}, \\text{Useful}, \\text{Vital}\\}$\n\nПо историческим данным считаются соответствующие вероятности найти нужное в документе в зависимости от класса $P_q(d) = \\{0, 0.07, 0.14, 0.41, 0.61\\}$\n\nОтличием от предыдущей модели является введённая константа $P_{break} = 0.15$ — вероятность бросить искать информацию и листать выдачу.\n\nПосчитаем вероятность $P_i$ того, что пользователь дошёл до позиции $i$. Для этого он должен дойти до документа на позиции $i - 1$, не устать искать, и при этом не найти нужного в предыдущем документе. Опять же перемножаем вероятности.\n\n$$P_1 = 1;\\ P_i = P_{i - 1} \\cdot \\left(1 - P_{break}\\right) \\cdot \\left(1 - P_q(d_q^{(i - 1)})\\right)\n$$\n\nТеперь $pFound$ — это вероятность найти нужное в выдаче\n\n$$pFound(q) = \\sum\\limits_{i = 1}^n P_i \\cdot P_q(d_q^{(i)}) \n$$\n\nЧтобы теперь посчитать финальную метрику, усредняем $pFound$ по всем запросам в тестовом множестве $Q_t$.\n\n### nDCG\n\nВведём метрику DCG (Discounted Cumulative Gain).\n\nБудем считать, что релевантный документ в топе приносит некоторую пользу (gain) в зависимости от своей релевантности. При этом до низкого документа в выдаче могут и не долистать, поэтому он приносит меньше пользы, то есть она уменьшается. Будем дисконтировать пользу в зависимости от позиции (discount).\n\n$$DCG_n(q) = \\sum\\limits_{i = 1}^n G_q(d_q^{(i)}) \\cdot D(i) \n$$\n\nЗдесь $G_q(d)$ — функция пользы, а $D$ — функция дисконтирования от позиции. Для этих функций возможны разные вариации, рассмотрим классический и упрощённый.\n\nКлассический вариант: $G_q(d) = 2^{y(q, d) - 1};\\ D(i) = \\frac{1}{\\log_2(i + 1)}$\n\nУпрощённый вариант: $G_q(d) = y(q, d);\\ D(i) = \\frac{1}{i + 1}$\n\nИногда при реализации поисковой системы может быть понимание, как падает внимание пользователя с ростом позиции в зависимости от типа запроса. В этом случае функция дисконтирования может стать запросозависимой.\n\nОднако низкое значение метрики $DCG$ не всегда означает, что ранжирование отработало плохо. Могло быть так, что по запросу просто нет релевантных документов, или же их очень мало. Чтобы избавиться от этой проблемы, значение $DCG$ нормируют на эту метрику при идеальном ранжировании, когда документы отсортированы по истинным значениям релевантности.\n\n$$nDCG(q) = \\frac{DCG(q)}{\\max DCG(q)}\n$$\n\nКак и всегда, для получения метрики по набору запросов, считают среднее значение $nDCG.$\n\n## Дополнительные метрики\n\n### Другие сигналы и экосистема\n\nОписанные выше метрики были введены для агрегации релевантности документов в топе выдачи. Но те же рассуждения и формулы могут быть применены для других сигналов, сопоставляющих запрос и документ. Вы можете придумать любую инструкцию для асессоров и собрать разметку под вашу задачу. Одним из полезных сигналов может быть свежесть документа, которую можно понять и по времени создания документа.\n\nОбычно в противовес релевантности смотрят на кликабельность элементов выдачи. Поисковым системам интересно получить больше кликов пользователей, тем не менее могут встречаться «кликбейтные» документы, которые побуждают кликать, но не решают на самом деле задачу пользователя. Кликабельность можно замерять как DCG предсказатора вероятности клика.\n\nТакже важно следить за чистотой выдачи. Нужно не допускать в топ мошеннические документы, шокирующие документы и документы 18\\+ в поиске для детей. В качестве метрики можно замерять DCG или MAP «плохих» документов в топе.\n\n### Разнообразие и метрики рекомендаций\n\nБывает полезно следить за тем, как документы в топе соотносятся друг с другом. В частности, нужно не допускать, чтобы все документы выдачи были с одного хоста и чтобы в них не было написано одно и то же. Для этого используются алгоритмы группировки и дедупликации.\n\nТакже, если рассматривать поиск как решение задачи рекомендации документов, можно измерять метрики новизны и serendipity, про которые подробнее рассказано в главе о рекомендательных системах.\n\n## Методы обучения ранжированию\n\nРассмотрим некоторую модель $a_\\theta(q, d)$, по предсказаниям которой мы будем сортировать документы $d$ по запросу $q$ (здесь $\\theta$ — это параметры модели). Мы хотим обучить модель так, чтобы у неё было оптимальное значение одной из метрик ранжирования, например, NDCG. Заметим, что если совсем немного поменять $\\theta$, то предсказания модели $a_\\theta(q, d)$ изменятся тоже несильно. Но небольшие изменения в предсказаниях могут не привести к изменению порядка документов. Тогда не изменится и метрика NDCG. Получается, что NDCG как функция от параметров $\\theta$ является кусочно постоянной, поэтому нельзя оптимизировать её напрямую.\n\nНаша дальнейшая задача — представить методы, позволяющие получить модель, оптимальную по NDCG или другой аналогичной метрике ранжирования.\n\nМетоды обучения ранжированию обычно делят на 3 типа:\n\n**Поточечный (pointwise) подход**\n\nВ этом подходе у нас известны некоторые оценки релевантности каждой пары запрос-документ, и модель учится предсказывать эти оценки. Взаимоотношения между разными документами внутри $D_q$ не рассматриваются.\n\n**Попарный (pairwise) подход**\n\nЗдесь во время обучения используют тройки $(q, d_1, d_2)$, где $d_1, d_2$ — документы из $D_q$, причём $d_1$ релевантнее $d_2$ по запросу $q$. При этом модель всё равно может давать предсказания релевантности по паре $(q, d)$.\n\n**Списочный (listwise) подход**\n\nВ данном подходе для обучения используются перестановки документов из $D_q$. Например, асессорские оценки дают наилучшую известную сортировку. Для её получения нужно сначала показать на выдаче докумены с самой высокой оценкой, затем со следующей по порядку и т.д.\n\nБудем рассматривать каждый из подходов по очереди.\n\n### Поточечный подход\n\n#### Сведение к регрессии и классификации\n\nРассмотрим простейшую постановку задачи, в которой у нас есть набор запросов $Q$, для каждого запроса $q \\in Q$ имеется набор документов $D_q$, который необходимо отсортировать, а в качестве обучающей выборки известны асессорские оценки релевантности для некоторых пар запрос-документ $(q, d)$. Будем обозначать множество возможных оценок $\\mathbb{Y}$, конкретную оценку — $y(q, d)$.\n\nПусть $\\mathbb{Y} = \\mathbb{R}$ — множество действительных чисел. Тогда мы можем обучить любую модель регрессии на признаках пар $(q, d)$ для предсказания оценок асессоров. Это может быть и линейная модель, и градиентный бустинг, и нейронная сеть. Обучать модель можно, например, оптимизируя MSE:\n\n$$\\sum_{q \\in Q} \\sum_{d \\in D_q} (\\widehat{y}(q, d) - y(q, d)) ^ 2 \\rightarrow \\min \n$$\n\nАналогично можно сводить задачу к классификации, если метки релевантности $y$ бинарны или категориальны. Например, при шкале $\\mathbb{Y} = \\{0, 1, 2, 3, 4, 5\\}$. Оптимизировать в данном случае можно кросс-энтропийную функцию потерь.\n\n#### PRank\n\nВ случае классификации мы учим модель разделять классы, но никаким образом не задаём, что на метках имеется порядок. Мы не даём алгоритму никакой информации о том, что метка `4` находится между метками `5` и `3` и наоборот. Чтобы побороть эту проблему, была придумана модификация линейной модели, которая получила название PRank и была описана в статье  [Pranking with ranking](https://proceedings.neurips.cc/paper/2001/file/5531a5834816222280f20d1ef9e95f69-Paper.pdf).\n\nЕсли предположить, что метки релевантности — это целые числа от $0$ до $K$, то есть $\\mathbb{Y} = \\{0, 1, 2, \\dots, K\\}$, то можно ввести пороги для значений ранжирующей функции, которые разделяют классы друг от друга.\n\nВ качестве ранжирущей функции возьмём обычную линейную, то есть $\\langle\\theta, x\\rangle$, где $x$ — вектор признаков. Обозначим через $b_1, b_2, \\dots, b_{K - 1}$ границы классов. Они будут изменяться в процессе обучения. Также фиктивно введём $b_{K} = \\infty$.\n\nЧтобы предсказать класс, будем искать первую границу, которая больше вычисленной линейной функции:\n\n$$\\widehat{y}(q, d) = \\min \\{r\\ :\\ x^\\top\\theta - b_r < 0\\} \n$$\n\nКоротко опишем процесс обучения. Представим, что мы получили очередной объект и вычислили линейную функцию $\\langle\\theta, x\\rangle$. Отметим на оси её значение и границы классов:\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_10_8b1b6f1483_380be5fa8a.svg)\n\nЕсли предсказан ранг `1`, а правильный класс для объекта `4`, то необходимо, во-первых, обновить вектор $\\theta$, а во-вторых, сдвинуть границы других классов в сторону получившегося предсказания.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_13_40ecabc386_a88d0d99de.svg)\n\nПосле осуществления сдвигов, предсказание на точке из обучающей выборки становится ближе к правильному.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_11_ba670b3f82_0b65fa0438.svg)\n\nМы не будем приводить конкретные формулы для обновления обучаемых параметров; вы можете посмотреть их в статье.\n\n### Попарный подход\n\nНачнём рассмотрение попарного подхода. Чтобы его применить, нужен датасет, состоящий из троек $(q, d_1, d_2)$, где $d_1, d_2\\in D_q$, причём известно, что по запросу $q$ документ $d_1$ релевантнее, чем $d_2$. Будем обозначать такое соотношение $d_2 \\prec d_1$.\n\n**Замечание**. Такие данные можно собирать с использованием асессорской Side-by-Side разметки, в которой асессоры отмечают, какой из двух предложенных документов релевантнее по заданному запросу. Также можно собирать данные с помощью пользовательских логов. Например, если пользователь пролистал первые 3 документа по запросу $q$, а решил свою задачу только на 4-ом, можно считать, что первые 3 документа были хуже. Пользовательских логов достаточно много, с их помощью можно обучать разные модели для ранжирования на основе кликов. Но надо помнить, что совсем не всегда те документы, на которые первоначально хочется кликнуть, релевантны и содержат необходимую информацию. Чтобы учесть это в модели, можно рассматривать только клики, после которых пользователь надолго остался на странице. Дополнительно можно смешивать модели на кликах с моделями на оценках асессоров, что поможет избежать проблемы смещения обучающей выборки в текущее ранжирование. Поясним, из-за чего может возникнуть эта проблема. Логи строятся по результатам взаимодействия пользователя с нашей ранжирующей моделью, и может оказаться так, что обучающая выборка будет состоять только из документов, уже попавших в топ выдачи.\n\n#### Классификатор на тройках\n\nВ качестве самого простого решения снова рассмотрим сведение задачи ранжирования к уже известным задачам машинного обучения. А именно, будем решать задачу классификации троек $(q, d_1, d_2)$. В качестве целевой переменной запишем $0$, если лучше документ $d_1$, и $1$, если лучше $d_2$. Собрав признаки для каждой тройки, можем обучить любой классификатор. Для этого можем взять и нейронную сеть, и линейную модель, и методы на основе деревьев.\n\nЧтобы отсортировать документы внутри $D_q$ по запросу $q$, можем воспользоваться стандартным алгоритмом сортировки с компаратором, задаваемым предсказаниями нашего классификатора.\n\nПроблема в том, что компаратор должен быть как минимум транзитивным. Гарантировать такое свойство для большинства моделей машинного обучения мы не можем.\n\n#### RankingSVM\n\nНо если ввести модель специальным образом, можно гарантировать транзитивность предсказаний. Снова воспользуемся линейной моделью.\n\n**Задача**. Найти вектор весов $\\theta$, для которого $\\forall q \\in Q \\ \\forall d_i, d_j\\ :\\ d_i \\prec d_j$ было бы выполнено $\\langle x_i, \\theta\\rangle < \\langle x_j, \\theta\\rangle$. Здесь $x_i$, $x_j$ – векторы признаков для пар $(q, d_i)$ и $(q, d_j)$ соответственно.\n\nТак как требуется выполнение скалярных произведений вида $\\langle x_i - x_j, \\theta \\rangle$, где $x_i - x_j$ — вектор поэлементной разницы признаков, можно обучить линейную модель на парах, где признак пары – это как раз вектор $x_i - x_j$.\n\nЕсли в качестве модели взять SVM, получится классический метод обучения ранжированию, который называется RankingSVM.\n\nЧтобы сравнить 2 документа по запросу, надо сравнить $\\langle x_i - x_j, \\theta\\rangle$ с нулём. Получается, что для двух одинаковых документов это выражение всегда $0$. Кроме того, выполнена требуемая от компаратора транзитивность.\n\n#### RankNet\n\nПусть имеется обучающая выборка, в которой известны метки релевантности для пар запрос-документ.\n\n$$\\begin{align*}\nX &= \\{x_i\\} \\ \\text{– признаковые описания $(q_i, d_i)$}, \\\\\nY &= \\{y_i\\} \\ \\text{– асессорские оценки}, \\\\\nQ &= \\{q_i\\} \\ \\text{– запросы}. \\\\\n\\end{align*}\n$$\n\nВведём модель для ранжирующей функции $\\widehat{y}_\\theta(x)$, дифференцируемую по $\\theta$. Например, это может быть линейная модель или нейронная сеть. Также возможно применение композиций деревьев. Ниже мы будем описывать оптимизационную процедуру для моделей, которые обучаются с помощью градиентного спуска; для деревьев потребуются другие методы.\n\nБудем рассматривать события $x_i \\succ x_j$, то есть события вида «документ $d_i$ релевантнее $d_j$ по запросу $q_i = q_j = q$».\n\nИз разметки асессоров мы можем задать вероятности таких событий.\n\n$$ Q_{ij} =\n\\begin{cases}\n    1, \\text{если } y_i > y_j \\\\\n    0, \\text{если } y_i < y_j \\\\\n    \\frac{1}{2}, \\text{если } y_i = y_j\n\\end{cases}\n$$\n\nЕсли асессорских оценок на каждый документ несколько, можем по-разному агрегировать эти оценки в $Q_{ij}$. Если же доступна попарная разметка (какой из документов $d_i$ и $d_j$ релевантнее запросу $q$), то вероятностью можно назвать долю оценок, в которых $d_i$ признан лучше, чем $d_j$.\n\nДалее введём оценку вероятности этого события, порождённую моделью.\n\n$$P_{ij} = \\frac{1}{1 + e^{-\\sigma(s_i - s_j)}},\\ \\ s_i = \\widehat{y}_\\theta(x_i),\\  s_j = \\widehat{y}_\\theta(x_j)\n$$\n\nДля пары $(x_i, x_j)$ рассмотрим случайную величину\n\n$$\\xi_{ij} = \\mathbb{I}[x_i \\succ x_j]\n$$\n\nСогласно асессорам, $\\xi_{ij} \\sim Bern(Q_{ij})$. Согласно модели, $\\xi_{ij} \\sim Bern(P_{ij})$. Задача обучения в том, чтобы уравнять эти два распределения между собой для всех пар документов. Поэтому в качестве функции потерь будем использовать KL-дивергенцию. Введём для каждой пары лосс\n\n$$C_{ij} = \\text{KL}(Bern(Q_{ij})\\,\\vert\\vert\\, Bern(P_{ij})) = Q_{ij}\\log\\frac{Q_{ij}}{P_{ij}} + (1 - Q_{ij}) \\log\\frac{1 - Q_{ij}}{1 - P_{ij}} = \n$$\n\n$$= H(Q_{ij}) - Q_{ij}\\log P_{ij} - (1 - Q_{ij})\\log(1 - P_{ij}) \n$$\n\nТут $H(Q_{ij})$ – энтропия, не зависящая от $P_{ij}$, а значит и от параметров модели $\\theta$.\n\nДля определённых выше $Q_{ij}$ выполнены следующие свойства:\n\n$$\\begin{align*}\nC_{ij} &= \\log(1 + e^{-\\sigma(s_i - s_j)}), \\text{если $y_i > y_j$} \\\\\nC_{ij} &= \\log(1 + e^{-\\sigma(s_j - s_i)}), \\text{если $y_i < y_j$} \\\\\nC_{ij} &= \\log2, \\text{если $y_i = y_j$ и $s_i \\neq s_j$} \\\\\nC_{ij} &= 0, \\text{если $y_i = y_j$ и $s_i = s_j$}\n\\end{align*}\n$$\n\nВидно, что для двух документов с разными истинными метками релевантности такой метод обучения штрафует модель за одинаковые предсказания. Это свойство очень полезно, поскольку в случае одинаковых предсказаний непонятно, в каком порядке располагать документы.\n\nПолная функция потерь выглядит следующим образом:\n\n$$Q(\\theta) = \\sum_{q \\in Q}\\sum_{i, j: q_i = q_j = q} C_{ij} \\ \\rightarrow\\  \\min_{\\theta} \n$$\n\nМинимизировать её можно при помощи градиентного спуска или различных его модификаций.\n\n$$\\theta_k^{t + 1} = \\theta_k^t - \\eta \\sum_{i, j: q_i = q_j = q} \\frac{\\partial C_{ij}}{\\partial \\theta_k} (\\theta_k^t) = \n$$\n\n$$= \\theta_k^t - \\eta  \\sum_{i, j: q_i = q_j = q}\\left(\\frac{\\partial C_{ij}}{\\partial s_i}\\frac{\\partial s_i}{\\partial \\theta_k} + \\frac{\\partial C_{ij}}{\\partial s_j}\\frac{\\partial s_j}{\\partial \\theta_k}\\right) \n$$\n\nВычислим производные функции потерь по $s_i$.\n\nПусть $y_i > y_j$. Тогда:\n\n$$\\frac{\\partial C_{ij}}{\\partial s_i} = \\frac{-\\sigma e^{-\\sigma(s_i - s_j)}}{1 + e^{-\\sigma(s_i - s_j)}} = \\frac{-\\sigma}{1 + e^{\\sigma(s_i - s_j)}}\n$$\n\n$$\\frac{\\partial C_{ij}}{\\partial s_j} = \\frac{\\sigma e^{-\\sigma(s_i - s_j)}}{1 + e^{-\\sigma(s_i - s_j)}} = \\frac{\\sigma}{1 + e^{\\sigma(s_i - s_j)}},\n$$\n\nто есть $\\frac{\\partial C_{ij}}{\\partial s_i} = -\\frac{\\partial C_{ij}}{\\partial s_j}$.\n\nПодставим полученное выражение в производную функции потерь по весам.\n\n$$\\frac{\\partial C_{ij}}{\\partial \\theta_k} = \\frac{\\partial C_{ij}}{\\partial s_i}\\frac{\\partial s_i}{\\partial \\theta_k} + \\frac{\\partial C_{ij}}{\\partial s_j}\\frac{\\partial s_j}{\\partial \\theta_k} = \\underbrace{\\frac{-\\sigma}{1 + e^{\\sigma(s_i - s_j)}}}_\\text{обозначаем $\\lambda_{ij}$} \\left(\\frac{\\partial s_i}{\\partial \\theta_k} - \\frac{\\partial s_j}{\\partial \\theta_k}\\right)\n$$\n\nАналогично получаем выражения для остальных случаев соотношения между $y_i$ и $y_j$.\n\nОпределим теперь\n\n$$\\lambda_i = \\sum\n\\limits_{j:\\ x_i \\succ x_j} \\lambda_{ij} - \\sum\n\\limits_{j:\\ x_i \\prec x_j} \\lambda_{ij}$$\n\nТогда получаем\n\n$$\\frac{\\partial Q}{\\partial \\theta_k} = \\sum\\limits_i \\lambda_i \\frac{\\partial s_i}{\\partial \\theta_k}\n$$\n\nИтерацию градиентного спуска теперь можно записать в более простом виде:\n\n$$\\theta^{t + 1} = \\theta^t - \\eta \\sum\\limits_i \\lambda_i \\nabla_{\\theta^t} s_i \n$$\n\nТаким образом, мы можем делать SGD не по парам документов, а по отдельным документам. Это увеличивает скорость сходимости.\n\nПолучается, что $\\lambda_{i}$ зависит от номера документа и от попарных разностей скоров модели на документах $s_i - s_j$, при этом не зависит от производных самих $s$ по параметру $\\theta$. Введённые $\\lambda_i$ можно представить в виде стрелок, которые прикреплены к каждому документу в поисковой выдаче. Направление стрелки означает, куда мы хотим перенести документ, чтобы выросла нужная метрика, а длина – насколько сильно.\n\n![lambdas](https://yastatic.net/s3/education-portal/media/lambdas_f0c41a1edb_554aa553d9.webp)\n\n#### LambdaRank\n\nЗадача этого метода в том, чтобы соединить RankNet и наше желание напрямую оптимизировать введённые ранее кусочно постоянные метрики качества, например, NDCG. Обозначим через $Z(q, \\widehat{y}) = Z(q, s)$ значение этой метрики для запроса $q$ при ранжировании функцией $\\widehat{y}$. Попытаемся придумать гладкую попарную функцию потерь\n\n$$\\overline{Q} = \\sum_{i, j\\, q_i = q_j = q}\\overline{C}_{ij},\n$$\n\nгде\n\n$$\\overline{C}_{ij} = \\overline{C}_{ij}(s_i - s_j),\n$$\n\nоптимизация которой была бы эквивалентна оптимизации $Z$.\n\nЗаметим, впрочем, что для обучения сама $\\overline{Q}$ нам не нужна, а нужны только производные, которые, как и в случае RankNet, можно записать в виде\n\n$$\\nabla_{\\theta_k}\\overline{C}_{ij} = \\overline{\\lambda}_{ij}(\\nabla_{\\theta_k}s_i - \\nabla_{\\theta_k}s_j)\n$$\n\nВ данном случае мы хотели бы задать $\\overline{\\lambda}_{ij}$ специальным образом: так, чтобы сдвиг в направлении антиградиента вёл к уменьшению метрики $Z$. Ясно, что не любое выражение для $\\lambda_i$ может задавать градиент. Чтобы проверить существование функции потерь $\\overline{C}$, применим следующий частный случай леммы Пуанкаре:\n\n**Лемма**. Пусть $f_1(\\theta_1, \\dots, \\theta_n), f_2(\\theta_1, \\dots, \\theta_n), \\dots, f_n(\\theta_1, \\dots, \\theta_n)$ – функции, такие что\n\n$$\\forall i, j\\ \\ \\ \\frac{\\partial f_i}{\\partial \\theta_j} = \\frac{\\partial f_j}{\\partial \\theta_i}.\n$$\n\nТогда существует функция $F$, такая что $\\forall i\\ \\ \\frac{\\partial F}{\\partial \\theta_i} = f_i$.\n\nЗначит, нужно ввести лямбды таким образом, чтобы совпадали смешанные производные.\n\nОпределим $y_{ij}$ – функцию релевантности, в которой поменяли местами $x_i$ и $x_j$:\n\n$$ y_{ij} =\n\\begin{cases}\n    y(x_j), \\text{если } x = x_i \\\\\n    y(x_i), \\text{если } x = x_j \\\\\n    y(x)\\  \\text{иначе}\n\\end{cases}\n$$\n\nОбозначим также через $\\Delta Z_{ij} = Z(q, \\widehat{y}_{ij}) - Z(q, \\widehat{y})$ приращение метрики при перестановке местами $x_i$ и $x_j$. В методе LambdaRank $\\lambda_{ij}$ определяется следующим образом:\n\n$$\\lambda_{ij} = \\frac{-\\sigma}{1 + e^{\\sigma(s_i - s_j)}} |\\Delta Z_{ij}|,\n$$\n\nгде $\\sigma$ – некоторая константа. Множитель $\\vert\\Delta Z_{ij}\\vert$ кусочно постоянен, так что не повлияет на градиент.\n\n**Вопрос на подумать**. Проверьте, что для указанных $\\lambda_{ij}$ действительно выполнено условие леммы Пуанкаре.\n\nАвторы метода проверяли его для оптимизации NDCG. Они пытались случайными сдвигами параметра улучшить NDCG после оптимизации через LambdaRank. Доля успешных сдвигов оказалось очень мала, так что экспериментально подтверждается успешная оптимизация этим методом недифференцируемых метрик ранжирования.\n\n#### LambdaMART\n\nЭтот метод является конкретной реализацией подхода LambdaRank. В нём для предсказания $\\widehat{y}_{\\theta}(x)$ строится модель градиентного бустинга на решающих деревьях.\n\nКаждое дерево обучается на градиент функции потерь предыдущей итерации алгоритма (и градиент мы как раз умеем считать, хотя саму функцию потерь – нет). Структура дерева определяется жадными по MSE разделениями.\n\nПри этом размер шага (коэффициент, с которым берётся значение в следующем дереве) задаётся не один для всей модели, а подбирается во всех листах каждого дерева при помощи метода Ньютона.\n\nБолее подробно о последних трёх методах можно почитать в оригинальной статье от Microsoft: [From RankNet to LambdaRank to LambdaMART](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/MSR-TR-2010-82.pdf).\n\n### Списочный подход\n\n#### SoftRank\n\nВспомним, что основной проблемой, из-за которой невозможно оптимизировать NDCG и похожие метрики напрямую, является их кусочная линейность. Идея метода SoftRank — сгладить метрику, чтобы при небольших изменениях параметров модели она тоже изменялась. Для этого оценку релевантности документа будем рассматривать не как константу, а как случайную величину.\n\nСглаживание метрики рассмотрим на примере. Пусть имеются документы $d_1$, $d_2$, $d_3$ для запроса $q$, а ранжирующая модель дала им соответственно оценки релевантности $s_1$, $s_2$, $s_3$. Тогда, если это случайные величины, то они константны и их распределение вырождено. В связи с этим порядок документов на выдаче тоже определён однозначно, и первое место занимает документ с наибольшей оценкой.\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_12_25ad9e8ab4_0e140919b1.svg)\n\nЧтобы поменять метрику, будем считать, что оценка релевантности документа $d_i$ по нашей модели имеет распределение $\\mathcal{N}(s_i, \\sigma^2)$, где $\\sigma^2$ — гиперпараметр метода. Чтобы отсортировать документы, будем генерировать число из этого распределения и ранжировать по нему. Тогда может случиться так, что документ с самым большим $s_i$ окажется на последнем месте. Но с наибольшей вероятностью он всё равно будет первым. И распределение позиций документов на выдаче будет выглядеть примерно так:\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_9_c873c9b6e0_a10dea05ea.svg)\n\nТеперь, чтобы получить метрику, осталось только в формуле NDCG заменить дискаунт на его математическое ожидание.\n\n$$G_{soft} = \\frac{1}{G_{max}} \\sum\\limits_{j = 1}^N g(d_j) \\mathbb{E} D(j) \n$$\n\nМожно заметить, что теперь небольшие сдвиги параметров будут менять распределение позиций документов, а значит и $G_{soft}$ будет изменяться. Поэтому функция становится дифференцируемой, и её можно использовать как функцию потерь. При этом для того, чтобы вычислить распределение рангов, необходимо использовать отсортированный список документов. А значит, хоть напрямую оптимизируемый функционал и не зависит от перестановок, этот метод можно отнести к списочному подходу.\n\nПодробнее об этом методе можно прочитать в [статье](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/SoftRankWsdm08Submitted.pdf).\n\n#### ListNet\n\nСледующие 2 метода, которые мы рассмотрим, работают с перестановками документов для одного запроса. Если заданы оценки релевантности $y(q, d_i)$, $i = 1, \\dots, N$ для запроса $q$, то они формируют распределение на перестановках.\n\nПусть дана перестановка  $\\pi = (q_1, \\dots, q_N)$. Определим её вероятность следующим образом:\n\n$$P(\\pi \\vert y) = \\prod\\limits_{j = 1}^N \\frac{y(q, d_j)}{\\sum\\limits_{k=j}^N y(q, d_k)} \n$$\n\nТакая вероятностная модель называется моделью Люcа-Плакетта.\n\nДля примера рассмотрим 3 документа и оценки $y$. Тогда вероятность перестановки $ABC$ запишется так:\n\n$$P(ABC \\vert y) = P(\\text{A на первом месте}) \\cdot \n$$\n\n$$P(\\text{B на втором месте}\\setminus\\text{vert A на первом месте})\\cdot\n$$\n\n$$P(\\text{С на третьем месте}\\setminus\\text{vert A на первом месте и}\\text{B на втором месте})=\n$$\n\n$$= \\frac{y(A)}{y(A) + y(B) + y(C)} \\cdot \\frac{y(B)}{y(B) + y(C)} \\cdot \\frac{y(C)}{y(C)} \n$$\n\nАналогично методу RankNet, мы имеем распределение, которое можно сформировать из оценок асессоров $y$ и из оценок модели $\\widehat{y}$. А значит можно в качестве функции потерь использовать KL-дивергенцию между этими распределениями.\n\n$$\\text{KL}(P(\\pi | y)\\,\\vert\\vert\\, P(\\pi | \\widehat{y}_\\theta)) \\rightarrow \\min\\limits_{\\theta},\n$$\n\nгде $\\theta$ — параметр модели.\n\nОднако различных перестановок получается $N!$, а значит, даже чтобы просто вычислить дивергенцию Кульбака-Лейблера, потребуется немало времени, не говоря уже про оптимизацию этой функции потерь.\n\nПоэтому вместо того, чтобы рассматривать вероятность полной перестановки, смотрят на распределение индекса первого документа на выдаче.\n\n$$P_{\\widehat{y}}(j) = \\frac{\\widehat{y}(q, d_j)}{\\sum\\limits_{d \\in D_q} \\widehat{y}(q, d)} \n$$\n\n$$P_{y}(j) = \\frac{y(q, d_j)}{\\sum\\limits_{d \\in D_q} y(q, d)} \n$$\n\nОптимизируют KL-дивергенцию между этими распределениями:\n\n$$\\text{KL}(P_y\\,\\vert\\vert\\, P_{\\widehat{y}}) \\rightarrow \\min\\limits_{\\theta} \n$$\n\n#### ListMLE\n\nВ этом методе рассматривают вероятность одной «правильной» перестановки. В данном случае под правильной перестановкой $\\pi_q$ понимается та, которая получается, если упорядочить документы из $D_q$ по убыванию асессорских оценок $y$. Логично, что хорошая модель должна давать большую вероятность такой перестановке, поэтому именно она и максимизируется.\n\n$$P(\\pi_q | \\widehat{y}_\\theta) \\rightarrow \\max\\limits_\\theta\n$$\n\nВсё сводится к поиску оценки максимального правдоподобия, поэтому метод и называется ListMLE.\n\n## Практические советы\n\n### Популярные признаки\n\nВыше показано, как можно построить модель, если уже известны признаки для пар запрос-документ $(q, d)$, а также, как можно собрать целевые переменные для обучения. Но какие стоит взять признаки, чтобы получить хорошую модель?\n\nПризнаки для моделей ранжирования можно разделить на 3 типа: *запросные*, *документные* и *запросно-документные*. Первые зависят только от запросы, вторые только от документа, а третьи от всей пары, то есть для их вычисления необходимо сопоставить запрос и документ.\n\nКонечно, наибольший интерес представляют запросно-документные факторы. Но и другие группы факторов могут быть полезны.\n\nЗапросными являются, например, следующие факторы:\n\n* Количество слов в запросе\n* Язык запроса\n* Страна, из которой задали запрос\n* Значение классификаторов\n  * $P(\\text{запрос про машинное обучение})$\n  * $P(\\text{запрос пиратский})$\n\nМногие модели могут подстроиться под эти факторы и отдельно обучиться под различные значения запросных признаков. Например, так модель может по-разному реагировать на запросы из разных стран.\n\n#### TF-IDF\n\nЧтобы сопоставить запрос и документ, можно использовать TF-IDF слов запроса. Например, можно просуммировать его по всем словам из запроса и получить фактор для ранжирования. Подробно о том, как считать TF-IDF, можно прочитать в главе про NLP.\n\n#### DSSM и другие нейросетевые факторы\n\nЗапросно-документные факторы можно получать, «соединяя» векторные представления запроса и документа. Классическим способом такого соединения является простой подсчёт косинуса угла между векторами.\n\nЕсли обучить модель, которая для пар, где документ релевантен запросу, выдаёт вектора, похожие на сонаправленные, то скалярное произведение становится оценкой релевантности. Если оно близко к единице, векторы сонаправлены, а значит документ подходит запросу. При этом обычно нормируют векторы на выходе, чтобы косинус и скалярное произведение были одним и тем же.\n\nВ качестве модели эмбеддинга можно использовать полносвязную нейронную сеть. На вход такой сети можно подать BagOfWords вектор или же вектор TfIdf. Эти векторы большой размерности нейросеть преобразует в меньшие. Обычно размер выходного слоя выбирают, балансируя между качеством и ресурсами, необходимыми на расчёт и хранение выхода сети.\n\nЭтот подход был назван `Deep Structured Semantic Models` и описан в [статье](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/cikm2013_DSSM_fullversion.pdf) от Microsoft. Идею можно применять в целом в любой задаче ранжирования для своих типов «документов».\n\nПосмотреть, как она была воплощена в Web поиске для поиска по смыслу, можно в [блоге](https://habr.com/ru/company/yandex/blog/314222/) Яндекса. Если вкратце, у модели следующие особенности:\n\n* На входе у модели не все тексты, а только заголовок документа и запрос;\n* Для уменьшения размера входа текст разбит на буквенные триграммы, вектор на входе - это Bag Of Trigrams;\n* Архитектура обработки запроса и документа разная;\n* Особый способ генерации негативных примеров.\n\nСхематически архитектура модели показана на рисунке ниже:\n\n![Artboard](https://yastatic.net/s3/education-portal/media/Artboard_6_6f7cf41862_1ea2758c5a.svg)\n\nКонечно, чтобы заставить простую архитектуру давать хорошее качество, нужно экспериментировать с методами сбора данных и улучшения качества, которые описаны в других главах учебника. Однако при наличии соответствующих мощностей можно улучшать качество, изменяя архитектуру обработки текста. В частности, модели на основе трансформеров (например, BERT) улучшают качество. Это же касается и косинуса, то есть соединительной части. Вполне можно вместо него использовать полносвязную сеть или даже трансформерную архитектуру.\n\nТрансформеры, которые по-отдельности обрабатывают сущности запроса и документа, в Яндексе названы split-моделями и более подробно описаны в том же [блоге](https://habr.com/ru/company/yandex/blog/529658/) на Хабре.\n\n#### Метафичи\n\nВ предыдущем пункте мы уже ввели фактор для модели, который сам является значением модели. Мы улучшили качество с помощью стекинга DSSM и итоговой модели. Аналогичным образом можно использовать предсказания моделей, обученных на разные таргеты и разными способами: их можно добавить к другим фичам для итоговой модели.\n\nК сожалению, если факторов-моделей (метафичей) много, такая модель не будет удовлетворять требованиям по времени работы. В этом случае можно прибегнуть к дистилляции знаний большой модели в более компактную.\n\n#### Фичи, зависящие от времени\n\nИзвестно, что модель машинного обучения работает хорошо (а точнее, ожидаемо) только в случае, когда при её применении распределения данных и факторов похожи на те, которые использовались при обучении. Но в продакшн-системах постоянное выполнение этого свойства невозможно обеспечить.\n\nПоэтому главный совет: настраивайте мониторинги качества ваших ML-систем для того, чтобы не пропускать моменты поломки. Качество может снизиться как из-за изменений в логике других сервисов, на которые вы полагаетесь при вычислении факторов, так и из-за появления новых трендов. Например, это происходит при появлении новых тем, о которых раньше не было запросов. Показательный случай — пандемия вируса COVID-19, который стал резко появляться среди запросов пользователей.\n\nНо бывают факторы, которые зависят от времени сами по себе. Так, для ранжирования новых документов может быть полезно знать возраст документа. Со временем распределение этого фактора сдвигается вправо, поскольку многие старые документы не удаляются из базы. Получается, фактор старого документа меняется, а релевантность нет. Появление фичей вне ожидаемых значений может привести к непредсказуемому поведению модели. Так что их нужно применять с осторожностью, лучше в тех моделях, которые можно быстро обучить и обновить в продакшне. Ещё лучшим решением будет преобразовать или отнормировать фичи таким образом, чтобы их распределение не менялось так кардинально. Наш фактор с возрастом документа можно преобразовать в индикатор того, что возраст документа меньше одного дня. Тогда только один раз за историю документа этот фактор будет изменён, при этом распределение этого фактора в документах изо дня в день будет похожим.\n\n### Многостадийное ранжирование\n\nПредставьте, что вы смогли обучить сложную модель, применив все описанные выше подходы: добавили метафичи, которые сами по себе являются формулами, обучили DSSM, BERT, или даже более тяжёлую нейросеть.\n\nНаконец, вам пришёл запрос от пользователя, и вы намерены отсортировать все документы в базе по оценке релевантности, которую даёт ваша модель. Если вы ранжируете 1000, 10000 или даже 100000 документов, это ещё может получиться, и пользователь дождётся ответа. Но что делать, если в вашей базе миллионы, а то и миллиарды документов?\n\nКонечно же вам на помощь могут прийти распределённые системы, и разбив документы по разным инстансам сервиса, который рассчитывает прогноз, вы ускорите получение ответа. Но даже с учётом распределённых вычислений быстро вычислить BERT миллиард раз будет либо очень дорого, либо очень долго. Поэтому применяется подход многостадийного ранжирования.\n\nТяжёлые модели применяются не сразу. Сначала можно ограничиться применением самых простых оценок релевантности. Как пример, можно просто взять TF-IDF или BM25. Простой моделью отсекаются самые нерелевантные документы, а прошедшие дальше уже сортируются с помощью более ресурсоёмкой и продвинутой модели.\n\nВ зависимости от количества документов в базе вы можете соединить столько уровней, сколько нужно, для получения приемлемого времени ответа. Конечно, количество параметров такой системы возрастает в несколько раз, но это делает возможным быстрое взаимодействие с пользователем.\n\n### Готовые решения\n\nЕсли вы разрабатываете продукт, для которого требуется поиск по текстовым документам, для начала вы можете воспользоваться готовыми решениями.\n\nОдним из самых популярных сервисов для поиска является [Sphinx](http://sphinxsearch.com/). Этот сервис позволяет индексировать текстовые документы и сохранять их в базу данных (как SQL, так и NoSQL). Через специальный SQL-подобный язык запросов он позволяет получать списки релевантных документов и сопутствующие им данные. Таким образом можно доставать только документы, подходящие по заданным фильтрам, отсортированные по релевантности. Это может быть полезно, например, для реализации поиска по интернет-магазину.\n\nБолее того, получив некоторый топ выдачи, вы можете переранжировать его, сразу используя сложную модель или учитывая другие потребности ваших пользователей.\n\nДругие альтернативы для текстового поиска можно посмотреть в [статье](https://medevel.com/os-fulltext-search-solutions/).",
        "handbook": "Учебник по машинному обучению",
        "title": "Задача ранжирования",
        "description": null
    },
    {
        "path": "/handbook/ml/article/obuchenie-s-podkrepleniem",
        "content": "До сих пор опыт, благодаря которому было возможно обучение в наших алгоритмах, был задан в виде обучающей выборки. Насколько такая модель обучения соотносится с тем, как учится, например, человек? Чтобы научиться кататься на велосипеде, печь тортики или играть в теннис, нам не нужны огромные датасеты с примерами того, что нужно делать в каждый момент; вместо этого мы способны обучаться **методом проб и ошибок** (**trial and error**), предпринимая попытки решить задачу, взаимодействуя с окружающим миром, и как-то улучшая своё поведение на основе полученного в ходе этого взаимодействия опыта.\n\nВ **обучении с подкреплением** (**reinforcement learning**, **RL**) мы хотим построить алгоритм, моделирующий обучение методом проб и ошибок. Вместо получения обучающей выборки на вход такой алгоритм будет взаимодействовать с некоторой **средой** (**environment**), окружающим миром, а в роли «разметки» будет выступать **награда** (**reward**) — скалярная величина, которая выдаётся после каждого шага взаимодействия со средой и показывает, насколько хорошо алгоритм справляется с поставленной ему задачей. Например, если вы печёте тортики, то за каждый испечённый тортик вы получаете \\+1, а если вы пытаетесь кататься на велосипеде, то за каждое падение с велосипеда вам прилетает -1.\n\n* Награда не подсказывает, как именно нужно решать задачу и что вообще нужно делать;\n* Награда может быть отложенной во времени (вы нашли в пустыне сокровища, но чтобы получить заслуженные тортики, вам ещё понадобится куча времени, чтобы выбраться из пустыни; а награда приходит только за тортики) или сильно разреженной (большую часть времени давать агенту \\+0). Всё это сильно отличает задачу от обучения с учителем;\n* Награда предоставляет какой-то «сигнал» для обучения (хорошо/плохо), которого нет, например, в обучении без учителя.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/trial_and_error_1a25729c9c_3de10833a7.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — курс <a href=\"http://ai.berkeley.edu/lecture_slides.html\">UC Berkeley AI</a></p>\n  </figcaption>\n</figure>\n\n## Постановка задачи\n\nТеперь попробуем формализовать всю эту концепцию и познакомиться с местной терминологией. Задача обучения с подкреплением задаётся **Марковским Процессом Принятия Решений** (**Markov Decision Process** или сокращённо **MDP**) это четвёрка $(\\mathcal{S}, \\mathcal{A}, \\mathcal{P}, r)$, где:\n\n* $\\mathcal{S}$ — **пространство состояний** (state space), множество состояний, в которых в каждый момент времени может находиться среда.\n* $\\mathcal{A}$ — **пространство действий** (action space), множество вариантов, из которых нужно производить выбор на каждом шаге своего взаимодействия со средой.\n* $\\mathcal{P}$ — **функция переходов** (transition function), которая задаёт изменение среды после того, как в состоянии $s \\in \\mathcal{S}$ было выбрано действие $a \\in \\mathcal{A}$. В общем случае функция переходов может быть стохастична, и тогда такая функция переходов моделируется распределением $p(s' \\mid s, a)$: с какой вероятностью в какое состояние перейдёт среда после выбора действия $a$ в состоянии $s$.\n* $r \\colon \\mathcal{S} \\times \\mathcal{A} \\to \\mathbb{R}$ — **функция награды** (reward function), выдающая скалярную величину за выбор действия $a$ в состоянии $s$. Это наш «обучающий сигнал».\n\nТрадиционно субъект, взаимодействующий со средой и влияющий на неё, называется в обучении с подкреплением **агентом** (agent). Агент руководствуется некоторым правилом, возможно, тоже стохастичным, как выбирать действия в зависимости от текущего состояния среды, которое называется **стратегией** (**policy**; термин часто транслитерируют и говорят **политика**) и моделируется распределением $\\pi(a \\mid s)$. Стратегия и будет нашим объектом поиска, поэтому, как и в классическом машинном обучении, мы ищем какую-то функцию.\n\nВзаимодействие со средой агента со стратегией $\\pi(a \\mid s)$ моделируется так. Изначально среда находится в некотором состоянии $s_0$. Агент сэмплирует действие из своей стратегии $a_0 \\sim \\pi(a_0 \\mid s_0)$. Среда отвечает на это, сэмплируя своё следующее состояние $s_1 \\sim p(s_1 \\mid s_0, a_0)$ из функции переходов, а также выдаёт агенту награду в размере $r(s_0, a_0)$. Процесс повторяется: агент снова сэмплирует $a_1$, а среда отвечает генерацией $s_2$ и скалярной наградой $r(s_1, a_1)$. Так продолжается до бесконечности или пока среда не перейдёт в терминальное состояние, после попадания в которое взаимодействие прерывается, и сбор агентом награды заканчивается. Если в среде есть терминальные состояния, одна итерация взаимодействия от начального состояния до попадания в терминальное состояние называется **эпизодом** (**episode**). Цепочка генерируемых в ходе взаимодействия случайных величин $s_0, a_0, s_1, a_1, s_2, a_2, \\dots$ называется **траекторией** (**trajectory**). *Примечание:* функция награды тоже может быть стохастичной, и тогда награды за шаг тоже будут случайными величинами и частью траекторий, но без ограничения общности мы будем рассматривать детерминированные функции награды.\n\n![MDP](https://yastatic.net/s3/education-portal/media/MDP_8b61770354_32a9e2928e.webp)\n\nИтак, фактически среда для нас — это управляемая марковская цепь: на каждом шаге мы выбором $a$ определяем то распределение, из которого будет генерироваться следующее состояние. Мы предполагаем, во-первых, марковское свойство: что переход в следующее состояние определяется лишь текущим состоянием и не зависит от всей предыдущей истории:\n\n$$p(s_{t+1} \\mid s_{t}, a_{t}, s_{t-1}, a_{t-1}, \\dots, s_0, a_0) = p(s_{t+1} \\mid s_{t}, a_{t})\n$$\n\nВо-вторых, мы предполагаем стационарность: функция переходов $p(s' \\mid s, a)$ не зависит от времени, от того, сколько шагов прошло с начала взаимодействия. Это довольно реалистичные предположения: законы мира не изменяются со временем (стационарность), а состояние — описывает мир целиком (марковость). В этой модели взаимодействия есть только одно нереалистичное допущение: **полная наблюдаемость** (**full observability**), которая гласит, что агент в своей стратегии $\\pi(a \\mid s)$ наблюдает всё состояние $s$ полностью и может выбирать действия, зная об окружающем мире абсолютно всё; в реальности нам же доступны лишь какие-то частичные наблюдения состояния. Такая более реалистичная ситуация моделируется в **частично наблюдаемых MDP** (**Partially observable MDP**, **PoMDP**), но мы далее ограничимся полностью наблюдаемыми средами.\n\nИтак, мы научились на математическом языке моделировать среду, агента и их взаимодействие между собой. Осталось понять, чего же мы хотим. Во время взаимодействия на каждом шаге агенту приходит награда $r_t = r(s_t, a_t)$, однако, состояния и действия $s_t, a_t$ в рамках такой постановки — случайные величины. Один и тот же агент может в силу стохастики как внутренней (в силу случайности выбора действий в его стратегии), так и внешней (в силу стохастики в функции переходов) набирать очень разную суммарную награду $\\sum_{t \\ge 0} r_t$ в зависимости от везения. Мы скажем, что хотим научиться выбирать действия так, чтобы собирать *в среднем* как можно больше награды.\n\nЧто значит в среднем, в среднем по чему? По всей стохастике, которая заложена в нашем процессе взаимодействия со средой. Каждая стратегия $\\pi$ задаёт распределение в пространстве траекторий — с какой вероятностью нам может встретится траектория $\\mathcal{T} = (s_0, a_0, s_1, a_1, \\dots)$:\n\n$$p(\\mathcal{T} \\mid \\pi) = p(s_0, a_0, s_1, a_1, \\dots \\mid \\pi) = \\prod_{t \\ge 0} p(s_{t + 1} \\mid s_t, a_t)\\pi(a_t \\mid s_t)\n$$\n\nВот по такому распределению мы и хотим взять среднее получаемой агентом награды. Записывают это обычно как-нибудь так:\n\n$$\\mathbb{E}_{\\mathcal{T} \\sim \\pi} \\sum_{t \\ge 0} r_t \\to \\max_{\\pi}\n$$\n\nЗдесь мат.ожидание по траекториям — это бесконечная цепочка вложенных мат.ожиданий:\n\n$$\\mathbb{E}_{\\mathcal{T} \\sim \\pi} ( \\cdot ) = \\mathbb{E}_{a_0 \\sim \\pi(a_0 \\mid s_0)} \\mathbb{E}_{s_1 \\sim p(s_1 \\mid s_0, a_0)} \\mathbb{E}_{a_1 \\sim \\pi(a_1 \\mid s_1)} \\dots ( \\cdot )\n$$\n\nВот такую конструкцию мы и хотим оптимизировать выбором стратегии $\\pi$. На практике, однако, вносят ещё одну маленькую корректировку. В средах, где взаимодействие может продолжаться бесконечно долго, агент может научиться набирать бесконечную награду, с чем могут быть связаны разные парадоксы (например, получать \\+1 на каждом втором шаге становится также хорошо, как получать \\+1 на каждом сотом шаге). Поэтому вводят **дисконтирование** (**discounting**) награды, которое гласит: тортик сейчас лучше, чем тот же самый тортик завтра. Награду, которую мы получим в будущем, агент будет дисконтировать на некоторое число $\\gamma$, меньшее единицы. Тогда наш функционал примет такой вид:\n\n$$\\mathbb{E}_{\\mathcal{T} \\sim \\pi} \\sum_{t \\ge 0} \\gamma^t r_t \\to \\max_{\\pi}\n$$\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/discounting_603b057cbc_246b1f7745.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — курс <a href=\"http://ai.berkeley.edu/lecture_slides.html\">UC Berkeley AI</a></p>\n  </figcaption>\n</figure>\n\nЗаметим, что обучение с подкреплением - это в первую очередь задача оптимизации, оптимизации функционалов определённого вида. Если в классическом машинном обучении подбор функции потерь можно считать элементом инженерной части решения, то здесь функция награды задана нам готовая и определяет тот функционал, который мы хотим оптимизировать.\n\n{% cut \"Примеры\" %}\n\nФормализм MDP очень общий, и под него попадает практически всё, что можно назвать «интеллектуальной задачей» (с той оговоркой, что не всегда очевидно, какая функция награды задаёт ту или иную задачу).\n\nСамые простые примеры MDP можно нарисовать «на бумажке». Например, часто рассматривают «клетчатые миры» (GridWorlds): агент находится в некоторой позиции клетчатой доски и может в качестве действий выбирать одно из четырёх направлений. Такие миры могут по-разному реагировать агента за выбор действия «пойти в стену», с некоторой вероятностью перемещать агента не в том направлении, которое он выбрал, содержать предметы в некоторых клетках и так далее. Пространство состояний, в которых может оказаться агент, в таких примерах конечно, как и пространство действий. Такие MDP называют **табличными**: все состояния и действия можно перечислить.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Tabular_MDP_96af6be96e_725a165d54.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — курс <a href=\"http://ai.berkeley.edu/lecture_slides.html\">UC Berkeley AI</a></p>\n  </figcaption>\n</figure>\n\nОгромное разнообразие MDP предоставляют видеоигры. Можно считать, что на вход агенту подаётся изображение экрана видеоигры, и несколько раз в секунду агент выбирает, какие кнопки на контроллере он хочет нажать. Тогда пространство состояний - множество всевозможных картинок, которые вам может показать видеоигра. Множество, в общем-то, конечное (конечное количество пикселей экрана с тремя цветовыми каналами, каждый из который показывает целочисленное значение от 0 до 255), но только очень большое; например, их уже нельзя перечислить или сохранить все возможные варианты в памяти. Но на каждом шаге нужно выбирать действие из конечного набора: какие кнопки нажать, поэтому это задачи **дискретного управления**.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/flappybird_4547e2f1a3_5e870c369a.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — курс <a href=\"http://ai.berkeley.edu/lecture_slides.html\">UC Berkeley AI</a></p>\n  </figcaption>\n</figure>\n\nНаконец, естественный способ создавать среды — использование физических симуляций. В качестве бенчмарка часто используют locomotion — задачу научить какое-нибудь «существо» ходить в рамках той или иной физической модели (примеры можно посмотреть, например, [здесь](https://deepmind.com/blog/article/producing-flexible-behaviours-simulated-environments)). Причём концептуально, в рамках задачи обучения с подкреплением, нам даже неважно, как именно устроена симуляция или как задана функция награды: мы хотим построить общий алгоритм оптимизации этой самой награды. Если награда поощряет перемещение центра масс «существа» вдоль некоторого направления, агент постепенно научится выбирать действия так, чтобы существо перемещалось и не падало, если последнее приводит к завершению эпизода и мешает дальнейшему получению награды.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/locomotion_9da7ae9aaf_87a611b13b.gif\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — статья DeepMind <a href=\"https://deepmind.com/blog/article/producing-flexible-behaviours-simulated-environments\">Producing Flexible Behaviours in Simulated Environments</a></p>\n  </figcaption>\n</figure>\n\nВ таких задачах агент на каждом шаге выбирает несколько вещественных чисел в диапазоне $[-1, 1]$, где -1 — «максимально расслабить» сустав, а \\+1 — «максимально напрячь». Такое пространство действий возникает во многих задачах робототехники, где нужно научиться поворачивать какой-нибудь руль, и у него есть крайнее правое и крайнее левое положение, но можно выбрать и любое промежуточное. Такие задачи называются задачами **непрерывного управления** (continuous control).\n\n{% endcut %}\n\n## Окей, и как такое решать?\n\nВыглядит сложновато, но у человечества есть уже довольно много наработок, как подойти к этой на вид очень общей задаче, причём с основной идеей вы скорее всего уже сталкивались. Называется она **динамическим программированием**.\n\nДело в том, что мы оптимизируем не абы какой функционал, а среднюю дисконтированную кумулятивную награду. Чтобы придумать более эффективное решение, чем какой-нибудь подход, не использующий этот факт (например, эволюционные алгоритмы), нам нужно воспользоваться структурой поставленной задачи. Эта структура задана в формализме MDP и определении процесса взаимодействия агента со средой. Интуитивно она выражается так: вот мы сидим в некотором состоянии $s$ и хотим выбрать действие $a$ как можно оптимальнее. Мы знаем, что после выбора этого действия мы получим награду за этот шаг $r = r(s, a)$, среда перекинет нас в состояние $s'$ и, внимание, дальше нас ждёт *подзадача эквивалентной структуры*: в точности та же задача выбора оптимального действия, только в другом состоянии. Действительно: когда мы будем принимать решение на следующем шаге, на прошлое мы повлиять уже не способны; стационарность означает, что законы, по которым ведёт себя среда, не поменялись, а марковость говорит, что история не влияет на дальнейший процесс нашего взаимодействия. Это наводит на мысль, что задача максимизации награды из текущего состояния тесно связана с задачей максимизации награды из следующего состояния $s'$, каким бы оно ни было.\n\nЧтобы сформулировать это на языке математики, вводятся «дополнительные переменные», вспомогательные величины, называемые **оценочными функциями**. Познакомимся с одной такой оценочной функцией - оптимальной Q-функцией, которую будем обозначать $Q^{*}(s,a)$. Скажем, что $Q^{*}(s,a)$ - это то, сколько максимально награды можно (в среднем) набрать после выбора действия $a$ из состояния $s$. Итак:\n\n$$Q^{*}(s, a) = \\max_{\\pi} \\mathbb{E}_{\\mathcal{T} \\sim \\pi \\mid s_0 = s, a_0 = a} \\sum_{t \\ge 0} \\gamma^t r_t\n$$\n\nЗапись $\\mathcal{T} \\sim \\pi \\mid s_0 = s, a_0 = a$ здесь означает, что мы садимся в состояние $s_0 = s$; выбираем действие $a_0 = a$, а затем продолжаем взаимодействие со средой при помощи стратегии $\\pi$, порождая таким образом траекторию $\\mathcal{T}$. По определению, чтобы посчитать $Q^{*}(s,a)$, нужно перебрать все стратегии, посмотреть, сколько каждая из них набирает награды после выбора $a$ из состояния $s$, и взять наилучшую стратегию. Поэтому эта оценочная функция называется оптимальной: она предполагает, что в будущем после выбора действия $a$ из состояния $s$ агент будет вести себя оптимально.\n\nОпределение неконструктивное, конечно, поскольку в реальности мы так сделать не можем, зато обладает интересным свойством. Если мы каким-то чудом узнали $Q^{*}(s,a)$, то мы знаем оптимальную стратегию. Действительно: представьте, что вы находитесь в состоянии $s$, вам нужно сделать выбор из трёх действий, и вы знаете значения $Q^{*}(s,a)$. Вы знаете, что если выберете первое действие $a = 0$, то в будущем сможете набрать не более чем, допустим, $Q^{*}(s, a = 0) = +3$ награды. При этом вы знаете, что существует какая-то стратегия $\\pi$, на которой достигается максимум в определении оптимальной Q-функции, то есть которая действительно позволяет набрать эти \\+3. Вы знаете, что если выберете второе действие, то в будущем сможете набрать, допустим, $Q^{*}(s, a = 1) = +10$, а для третьего действия $Q^{*}(s, a = 2) = -1$. Вопрос: так как нужно действовать? Интуиция подсказывает, что надо просто выбирать действие $a = 1$, что позволит набрать \\+10, ведь по определению больше набрать никак не получится. Значит, выбор в этом состоянии действия $a = 1$ оптимален. Эта интуиция нас не обманывает, и принцип такого выбора называется **принципом оптимальности Беллмана**.\n\nВыбор того действия, на котором достигается максимум по действиям Q-функции, называется **жадным** (greedy) по отношению к ней. Таким образом, принцип оптимальности Беллмана гласит:\\\n*жадный выбор по отношению к оптимальной Q-функции оптимален*:\n\n$$\\pi^*(s) = \\operatorname{argmax}\\limits_a Q^{*}(s, a)\n$$\n\n*Примечание:* если Q-функция достигает максимума на нескольких действиях, то можно выбирать любое из них.\n\nЗаметим, что эта оптимальная стратегия детерминирована. Этот интересный факт означает, что нам, в общем-то, необязательно искать стохастичную стратегию. Наше рассуждение пока даже показывает, что мы можем просто пытаться найти $Q^{*}(s,a)$, а дальше выводить из неё оптимальную стратегию, выбирая действие жадно.\n\nНо как искать $Q^{*}(s,a)$? Тут на сцене и появляется наше наблюдение про структуру задачи. Оказывается, $Q^{*}(s,a)$ выражается через саму себя. Действительно: рассмотрим некоторую пару состояние-действие $s, a$. С одной стороны, по определению, мы в будущем сможем при условии оптимального поведения получить $Q^{*}(s,a)$ награды. С другой стороны, после того, как мы выберем действие $a$ в состоянии $s$, мы получим награду за один шаг $r(s, a)$, вся дальнейшая награда будет дисконтирована на $\\gamma$, среда ответит нам сэмплированием $s' \\sim p(s' \\mid s, a)$ (на результат этого сэмплирования мы уже никак повлиять не можем и по этой стохастике нашу будущую награду надо будет усреднять), а затем в состоянии $s'$ мы, в предположении оптимальности поведения, выберем то действие $a'$, на котором достигается максимум $Q^{*}(s', a')$. Другими словами, в дальнейшем после попадания в $s'$ мы сможем получить $\\max\\limits_{a'} Q^{*}(s', a')$ награды. А значит, верно следующее рекурсивное соотношение, называемое **уравнением оптимальности Беллмана для Q-функции**:\n\n$$Q^{*}(s, a) = r(s, a) + \\gamma \\mathbb{E}_{s' \\sim p(s' \\mid s, a)} \\max_{a'} Q^{*}(s', a')\n$$\n\nМы получили систему уравнений, связывающую значения $Q^{*}(s,a)$ с самой собой. Это нелинейная система уравнений, но оказывается, что она в некотором смысле «хорошая». У неё единственное решение - и, значит, решение этого уравнения можно считать эквивалентным определением $Q^{*}(s,a)$, - и его можно искать **методом простой итерации**. Метод простой итерации решения систем уравнений позволяет улучшать своё текущее приближение $x$ решения некоторого уравнения вида $x = f(x)$ его подстановкой в правую часть. То есть: инициализируем произвольную функцию $Q_0^*(s, a) \\colon \\mathcal{S} \\times \\mathcal{A} \\to \\mathbb{R}$, которая будет приближать $Q^{*}(s,a)$, затем итеративно будем подставлять её в правую часть уравнений оптимальности Беллмана и полученным значением обновлять наше приближение:\n\n$$Q^{*}_{k+1}(s, a) \\leftarrow r(s, a) + \\gamma \\mathbb{E}_{s' \\sim p(s' \\mid s, a)} \\max_{a'} Q^{*}_k(s', a')\n$$\n\nТакая процедура в пределе приведёт нас к истинной $Q^{*}(s,a)$, а значит и оптимальной стратегии. Кстати, когда вы в прошлом встречались с динамическим программированием, вы скорее всего неявно использовали именно эту идею, разве что часто в задачах для решения уравнений оптимальности Беллмана можно просто последовательно исключать неизвестные переменные; но метод простой итерации даёт более общую схему, применимую всегда. А сейчас для нас принципиально следующее: если у нас есть какое-то приближение $Q^{*}$, то вычисление правой части уравнения оптимальности Беллмана позволит получить приближение лучше.\n\n## А где же метод проб и ошибок?\n\nРешать методом простой итерации уравнения оптимальности Беллмана и таким образом получать $Q^{*}(s,a)$ в реальности можно только при двух очень существенных ограничивающих условиях. Нужно, чтобы, во-первых, мы могли хранить как-то текущее приближение $Q^{*}_k(s, a)$ в памяти. Это возможно только если пространства состояний и действий конечные и не очень большие, то есть, например, в вашем MDP всего 10 состояний и 5 действий, тогда $Q^{*}(s,a)$ — это табличка 10x5. Но что, если вы хотите научиться играть в видеоигру, и состояние — это входное изображение? Тогда множество картинок, которые вам может показать видеоигра, сохранить в памяти уже не получится. Ну, допустим пока, что число состояний и число действий не очень большое, и мы всё-таки можем хранить таблицу в памяти, а позже мы снимем это ограничение, моделируя $Q^{*}(s,a)$ при помощи нейросети.\n\nВо-вторых, нам необходимо уметь считать выражение, стоящее справа в уравнение оптимальности Беллмана:\n\n$$r(s, a) + \\gamma \\mathbb{E}_{s' \\sim p(s' \\mid s, a)} \\max_{a'} Q^{*}_k(s', a')\n$$\n\nМало того, что в сложных средах взять мат.ожидание по функции переходов $\\mathbb{E}_{s' \\sim p(s' \\mid s, a)}$ в реальности мы не сможем, так ещё и обычно мы эту функцию переходов на самом деле не знаем. Представьте, что вы катаетесь на велосипеде: можете ли вы по текущему состоянию окружающего мира, например, положению всех атомов во вселенной, рассказать, с какими вероятностями в каком состоянии мир окажется в следующий момент времени? Это соображение также подсказывает, что было бы здорово, если б мы смогли решать задачу, избегая даже попыток выучить эту сложную функцию переходов.\n\nЧто нам доступно? Мы можем взять *какую-нибудь* стратегию $\\pi$ (важный момент: мы должны сами выбрать какую) и повзаимодействовать ею со средой. «Попробовать решить задачу». Мы можем сгенерировать при помощи $\\pi$ целую траекторию или даже сделать всего один шаг в среде. Таким образом мы *соберём данные*: допустим, мы были в состоянии $s$ и сделали выбор действия $a$, тогда мы узнаем, какую награду $r = r(s, a)$ мы получаем за такой шаг и, самое главное, в какое состояние $s'$ нас перевела среда. Полученный $s'$ — сэмпл из функции переходов $s' \\sim p(s' \\mid s, a)$. Собранная так информация — четвёрка $(s, a, r, s')$ — называется **переходом** (transition), и может быть как-то использована для оптимизации нашей стратегии.\n\nМожем ли мы, используя лишь переходы $(s, a, r, s')$, то есть имея на руках лишь сэмплы $s' \\sim p(s' \\mid s, a)$, как-то пользоваться схемой динамического программирования? Что, если мы будем заменять значение $Q_{k}^{*}(s, a)$ не на\n\n$$r(s, a) + \\gamma \\mathbb{E}_{s' \\sim p(s' \\mid s, a)} \\max_{a'} Q_{k}^{*}(s', a'),\n$$\n\nкоторое мы не можем посчитать, а на его Монте Карло оценку:\n\n$$r(s, a) + \\gamma \\max_{a'} Q^{*}_k(s', a'),\n$$\n\nгде $s'$ — сэмпл из функции переходов из собранного нами опыта? В среднем-то такая замена верная. Такая Монте-Карло оценка правой части для заданного переходика $(s, a, r, s')$ называется **Беллмановским таргетом**, то есть «целевой переменной». Почему такое название — мы увидим чуть позже.\n\nЧтобы понять, как нам нужно действовать, рассмотрим какую-нибудь типичную ситуацию. Допустим, после выполнения действия $a$ из некоторого состояния $s$ среда награждает нас $r(s, a) = 0$ и перекидывает нас с равными вероятностями то в состояние $s'$, для которого $\\max_{a'} Q^{*}_{k}(s', a') = +1$, то в состояние $s'$, для которого $\\max_{a'} Q^{*}_{k}(s', a') = -1$. Метод простой итерации говорит, что на очередной итерации нужно заменить $Q^{*}_{k}(s, a)$ на $0.5 \\gamma \\cdot (+1) + 0.5 \\gamma \\cdot (-1) = 0$, но в реальности мы встретимся лишь с одним исходом, и таргет — Монте-Карло оценка правой части уравнения оптимальности Беллмана — будет с вероятностью 0.5 равен $+\\gamma$, а с вероятностью 0.5 равен $-\\gamma$. Ясно, что нельзя просто взять и жёстко заменять наше текущее приближение $Q^{*}_k(s, a)$ на посчитанный Беллмановский таргет по некоторому одному переходу, поскольку нам могло повезти (мы увидели $+\\gamma$) или не повезти (мы увидели $-\\gamma$). Давайте вместо этого поступать также, как учат среднее по выборке: не сдвигать «жёстко» наше текущее приближение в значение очередного сэмпла, а *смешивать* текущее приближение с очередным сэмплом. То есть: берём переходик $(s, a, r, s')$, и не заменяем $Q^{*}_k(s, a)$ на стохастичную оценку правой части уравнения оптимальности Беллмана, а только сдвигаемся в его сторону:\n\n$$Q^{*}_{k+1}(s, a) \\leftarrow (1 - \\alpha)Q^{*}_k(s, a) + \\alpha (r + \\gamma \\max_{a'} Q^{*}_k(s', a'))\n$$\n\nТаким образом, мы проводим <b>экспоненциальное сглаживание</b> старого приближения $Q^{*}_k(s, a)$ и новой оценки правой части уравнения оптимальности Беллмана со свежим сэмплом $s'$. Выбор $\\alpha$ здесь определяет, насколько сильно мы обращаем внимание на последние сэмплы, и имеет тот же физический смысл, что и learning rate. В среднем по стохастике (а стохастика в этой формуле обновления заложена в случайном $s'$) мы будем сдвигаться в сторону\n\n$$r(s, a) + \\gamma \\mathbb{E}_{s' \\sim p(s' \\mid s, a)} \\max_{a'} Q_{k}^{*}(s', a'),\n$$\n\nи значит применять этакий «зашумлённый» метод простой итерации.\n\nИтак, возникает следующая идея. Будем как-то взаимодействовать со средой и собирать переходики $(s, a, r, s')$. Для каждого перехода будем обновлять одну ячейку нашей Q-таблицы размера число состояний на число действий по вышеуказанной формуле. Таким образом мы получим как бы «зашумлённый» метод простой итерации, где мы на каждом шаге обновляем только одну ячейку таблицы, и не заменяем жёстко значение на правую часть уравнений оптимальности, а лишь сдвигаемся по некоторому в среднем верному стохастичному направлению.\n\nОчень похоже на стохастическую оптимизацию вроде стохастического градиентного спуска, и поэтому гарантии сходимости выглядят схожим образом. Оказывается, такой алгоритм сходится к истинной $Q^{*}(s,a)$, если для любой пары $s, a$ мы в ходе всего процесса проводим бесконечное количество обновлений, а learning rate (гиперпараметр $\\alpha$) в них ведёт себя как learning rate из условий сходимости стохастического градиентного спуска:\n\n$$\\sum_i \\alpha_i = +\\infty, \\qquad \\sum_i \\alpha^2_i < +\\infty\n$$\n\n{% cut \"Пример\" %}\n\nКолобок Колабулька любит играть в лотереи. Допустим, в некотором состоянии $s$ он выполнил действие $a$ «купить билет» и предполагает, что в будущем сможет набрать $Q^{*}(s, a) = +100$ награды. Однако, за покупку билета он платит 10 долларов, и таким образом теряет 10 награды на данном шаге $r(s, a) = -10$, при этом попадая в состояние $s' = s$, где ему снова предлагается купить билет в лотерею (он может выбрать действие «купить» или действие «не купить»). Ну, допустим,  текущая оценка Колабульки будущей награды в случае отказа купить билет равна 0 \\< \\+100, поэтому колобок предполагает, что в будущем из состояния $s'$ он сможет получить $\\max\\limits_{a'} Q^{*}(s', a') = +100$. Для простоты допустим $\\gamma = +1$. Тогда получается, что одношаговое приближение будущей награды $r(s, a) + \\gamma \\max\\limits_{a'} Q^{*}(s', a') = -10 + 100 = 90$. Да, $s'$ здесь — случайная величина, колобку могло повезти или не повезти (и мы, увидев всего один сэмпл из функции переходов, не можем сказать наверняка, повезло ли нам сейчас или нет), но наша формула говорит сдвинуть аппроксимацию $Q^{*}(s,a)$ в сторону Беллмановского таргета.\n\n![Qlearning](https://yastatic.net/s3/education-portal/media/Qlearning_ex1_bb18ea339b_1_e1a76edecb_fbb4604362.svg)\n\nДопустим, learning rate $\\alpha = 0.5$: тогда, сдвигая \\+100 в сторону \\+90, ожидания от будущей награды после покупки лотерейного билета опускаются до 95. Всё ещё $+95 > 0$, поэтому колобку кажется, что покупать билет выгоднее, чем не покупать, поэтому рассмотрим следующий переходик. Допустим, колобок снова купил билет, снова потерял 10 долларов и снова попал в то же самое $s' = s$. Наше обновление снова скажет уменьшать значение $Q^{*}(s,a)$:\n\n![Qlearning](https://yastatic.net/s3/education-portal/media/Qlearning_ex1_bb18ea339b_2_6380b90eda_031106cae9.svg)\n\nВидно, что если колобку продолжит так не везти, таргет будет всё время на 10 меньше, чем текущее приближение, и $Q^{*}(s,a)$ будет всё уменьшаться и уменьшаться, пока не свалится до нуля (а там будет выгоднее уже не покупать билет). Но если на очередной итерации Колабульке повезло, и среда перевела его в $s'$, соответствующее победе в лотерею (а это, видимо, происходит с какой-то маленькой вероятностью), таргет получится очень большим, и аппроксимацию $Q^{*}(s,a)$ наше обновление скажет сильно увеличить:\n\n![Qlearning](https://yastatic.net/s3/education-portal/media/Qlearning_ex1_bb18ea339b_3_2219f47f64_e7a6afb54a.svg)\n\nКуда будет сходиться такой алгоритм? Давайте предположим, что среда на покупку лотерейного билета отвечает с вероятностью $p$ возвращением в то же состояние $s' = s$, где колобку предлагается купить ещё один билет, а с вероятностью $1 - p$ билет оказывается выигрышным, и колобок попадает в такое состояние $s'$, в котором он может забрать приз и получить \\+1000 (после этого взаимодействие со средой, скажем, заканчивается). Давайте запишем уравнение оптимальности Беллмана для действия $a$ «купить билет» в состоянии $s$:\n\n$$Q^{*}(s, a) = r(s, a) + \\gamma \\left( p \\max_{a'} Q^{*}(s' = s, a') + (1 - p) \\cdot (+1000) \\right)\n$$\n\nЗдесь $\\max_{a'} Q^{*}(s' = s, a') = \\max (Q^{*}(s, a), 0)$, поскольку колобок может или покупать билет, или не покупать (это, допустим, принесёт ему 0 награды). Понятно, что если покупка билета не принесёт больше 0 награды, то не имеет смысла его покупать. Подставляя все числа из примера, получаем:\n\n$$Q^{*}(s, a) = -10 + p \\max (Q^{*}(s, a), 0) + 1000(1 - p) \n$$\n\nВидно, что если вероятность проигрыша в лотерею $p = 0.99$, то решением уравнения является $Q^{*}(s, a) = 0$: Колабулька платит за билет 10 долларов и получает 1000 награды с вероятностью 0.01. В этом случае действие «купить билет» и «не покупать» равноценны, и оба в будущем принесут в среднем 0 награды. Если же $p > 0.99$, то покупать билет становится невыгодно, а если $p < 0.99$, то выгодно покупать билет до тех пор, пока не случится победа. Несмотря на то, что в таргете содержится собственная же текущая аппроксимация будущей награды и используется лишь один сэмпл $s'$ вместо честного усреднения по всевозможным исходам, формула обновления постепенно сойдётся к этому решению. Причём колобку истинное значение $p$ неизвестно, и в формуле обновления эта вероятность влияла лишь на появление того или иного $s'$ в очередном таргете.\n\n{% endcut %}\n\nЭтот алгоритм, к которому мы уже практически пришли, называется **Q-learning**, «обучение оптимальной Q-функции». Нам, однако, осталось ответить на один вопрос: так как же нужно собирать данные, чтобы удовлетворить требованиям для сходимости? Как взаимодействовать со средой так, чтобы мы каждую ячейку $s, a$ не прекращали обновлять?\n\n## Дилемма Exploration-exploitation\n\nМы уже встречали дилемму exploration-exploitation (букв. «исследования-использования») в параграфе про [тюнинг гиперпараметров](https://academy.yandex.ru/handbook/ml/article/podbor-giperparametrov). Задача многоруких бандитов, которая там встретилась, на самом деле является частным случаем задачи обучения с подкреплением, в котором после первого выбора действия эпизод гарантированно завершается, и этот частный случай задачи часто используется для изучения этой дилеммы. Рассмотрим эту дилемму в нашем контексте.\n\nДопустим, на очередном шаге алгоритма у нас есть некоторое приближение $Q_k(s, a) \\approx Q^{*}(s, a)$. Приближение это, конечно, неточное, поскольку алгоритм, если и сходится к истинной оптимальной Q-функции, то на бесконечности. Как нужно взаимодействовать со средой? Если вы хотите набрать максимальную награду, наверное, стоит воспользоваться нашей теорией и заниматься **exploitation**-ом, выбирая действие жадно:\n\n$$\\pi(s) = \\operatorname{argmax}_{a} Q_k(s, a)\n$$\n\nУвы, такой выбор не факт что совпадёт с истинной оптимальной стратегией, а главное, он детерминирован. Это значит, что при взаимодействии этой стратегией со средой, многие пары $s, a$ никогда не будут встречаться просто потому, что мы никогда не выбираем действие $a$ в состоянии $s$. А тогда мы, получается, рискуем больше никогда не обновить ячейку $Q_k(s, a)$ для таких пар!\n\nТакие ситуации запросто могут привести к застреванию алгоритма. Мы хотели научиться кататься на велосипеде и получали \\+0.1 за каждый пройденный метр и -5 за каждое попадание в дерево. После первых проб и ошибок мы обнаружили, что катание на велосипеде приносит нам -5, поскольку мы очень скоро врезаемся в деревья и обновляли нашу аппроксимацию Q-функции сэмплами с негативной наградой; зато если мы не будем даже забираться на велосипед и просто займёмся ничего не деланьем, то мы сможем избежать деревьев и будем получать 0. Просто из-за того, что в нашей стратегии взаимодействия со средой никогда не встречались те $s, a$, которые приводят к положительной награде, и жадная стратегия по отношению к нашей текущей аппроксимации Q-функции никогда не выбирает их. Поэтому нам нужно экспериментировать и пробовать новые варианты.\n\nРежим **exploration**-а предполагает, что мы взаимодействуем со средой при помощи какой-нибудь *стохастичной* стратегии $\\forall s, a \\colon \\pi(a \\mid s) > 0$. Например, такой стратегией является случайная стратегия, выбирающая рандомные действия. Как ни странно, сбор опыта при помощи случайной стратегии позволяет побывать с ненулевой вероятностью во всех областях пространства состояний, и теоретически даже наш алгоритм обучения Q-функции будет сходится. Означает ли это, что exploration-а хватит, и на exploitation можно забить?\n\nВ реальности мы понимаем, что добраться до самых интересных областей пространства состояний, где функция награда самая большая, не так-то просто, и случайная стратегия хоть и будет это делать с ненулевой вероятностью, но вероятность эта будет экспоненциально маленькая. А для сходимости нам нужно обновить ячейки $Q_k(s, a)$ для этих интересных состояний бесконечно много раз, то есть нам придётся дожидаться необычайно редкого везения далеко не один раз. Куда разумнее использовать уже имеющиеся знания и при помощи жадной стратегии, которая уже что-то умеет, идти к этим интересным состояниям. Поэтому для решения дилеммы exploration-exploitation обычно берут нашу текущую жадную стратегию и что-нибудь с ней делают такое, чтобы она стала чуть-чуть случайной. Например, с вероятностью $\\varepsilon > 0$ выбирают случайное действие, а с вероятностью $1 - \\varepsilon$ — жадное. Тогда мы чаще всё-таки и знаниями пользуемся, и любое действие с ненулевой вероятностью выбираем; такая стратегия называется $\\varepsilon$-жадной, и она является самым простым способом как-то порешать эту дилемму.\n\nДавайте закрепим, что у нас получилось, в виде табличного алгоритма обучения с подкреплением под названием Q-learning:\n\n1. Проинициализировать $Q^{*}(s,a)$ произвольным образом.\n2. Пронаблюдать $s_0$ из среды.\n3. Для $k = 0, 1, 2, \\dots$:\n\n* с вероятностью $\\varepsilon$ выбрать действие $a_k$ случайно, иначе жадно: ${a_k​}= \\operatorname{argmax}_{a_k}Q^{∗}(s_k​,a_k​)$\n* отправить действие $a_k$ в среду, получить награду за шаг $r_k$ и следующее состояние<br>$s_{k+1}$.\n* обновить одну ячейку таблицы:\n\n$$Q^{*}(s_k, a_k) \\leftarrow (1 - \\alpha)Q^{*}(s_k, a_k) + \\alpha (r_k + \\gamma \\max\\limits_{a'} Q^{*}(s_{k+1}, a'))\n$$\n\n## Добавим нейросеток\n\nНаконец, чтобы перейти к алгоритмам, способным на обучение в сложных MDP со сложным пространством состояний, нужно объединять классическую теорию обучения с подкреплением с парадигмами глубокого обучения.\n\nДопустим, мы не можем позволить себе хранить $Q^{*}(s,a)$ как таблицу в памяти, например, если мы играем в видеоигру и на вход нам подаются какие-нибудь изображения. Тогда мы можем обрабатывать любые имеющиеся у агента входные сигналы при помощи нейросетки $Q^{*}(s, a, \\theta)$. Для тех же видеоигр мы легко обработаем изображение экрана небольшой свёрточной сеточкой и выдадим для каждого возможного действия $a$ вещественный скаляр $Q^{*}(s, a, \\theta)$. Допустим также, что пространство действий всё ещё конечное и маленькое, чтобы мы могли для такой модели строить жадную стратегию, выбирать $\\operatorname{argmax}_{a} Q^{*}(s, a, \\theta)$. Но как обучать такую нейросетку?\n\nДавайте ещё раз посмотрим на формулу обновления в Q-learning для одного переходика $(s, a, r, s')$:\n\n$$\\begin{align*}\nQ^{*}_{k+1}(s, a) \\leftarrow (1 - \\alpha)Q^{*}_k(s, a) + \\alpha (r + \\gamma \\max_{a'} Q^{*}_k(s', a')) = \\\\\n= Q^{*}_k(s, a) + \\alpha (r + \\gamma \\max_{a'} Q^{*}_k(s', a') - Q^{*}_k(s, a))\n\\end{align*}\n$$\n\nТеория Q-learning-а подсказывала, что у процесса такого обучения Q-функции много общего с обычным стохастическим градиентным спуском. В таком виде формула подсказывает, что, видимо,\n\n$$r + \\gamma \\max_{a'} Q^{*}_{k}(s', a') - Q^{*}_{k}(s, a)\n$$\n\n— это стохастическая оценка какого-то градиента. Этот градиент сравнивает Беллмановский таргет\n\n$$r + \\gamma \\max_{a'} Q^{*}_{k}(s', a')\n$$\n\nс нашим текущим приближением $Q^{*}_{k}(s, a)$ и чуть-чуть корректирует это значение, сдвигая в сторону таргета. Попробуем «заменить» в этой формуле Q-функцию с табличного представления на нейросетку.\n\nРассмотрим такую задачу регрессии. Чтобы построить один прецедент для обучающей выборки, возьмём один имеющийся у нас переходик $(s, a, r, s')$. Входом будет пара $s, a$. Целевой переменной, таргетом, будет Беллмановский таргет\n\n$$y = r + \\gamma \\max_{a'} Q^{*}(s', a', \\theta);\n$$\n\nего зависимость от параметров $\\theta$ нашей нейронки мы далее будем игнорировать и будем «притворяться», что это и есть наш ground truth. Именно поэтому Монте-Карло оценка правой части уравнения оптимальности Беллмана и называют таргетом. Но важно помнить, что эта целевая переменная на самом деле «зашумлена»: в формуле используется взятый из перехода $s'$, который есть лишь сэмпл из функции переходов. На самом же деле мы хотели бы выучить среднее значение такой целевой переменной, и поэтому в качестве функции потерь мы возьмём MSE. Как будет выглядеть шаг стохастического градиентного спуска для решения этой задачи регрессии (для простоты — для одного прецедента)?\n\n$$\\begin{aligned}\n\\theta_{k+1} \\leftarrow &\\theta_{k} - \\alpha \\nabla_{\\theta} (y - Q^{*}(s, a, \\theta))^2 = \\\\\n= &\\theta_{k} + 2 \\alpha (y - Q^{*}(s, a, \\theta)) \\nabla_{\\theta} Q^{*}(s, a, \\theta) = \\\\\n= &\\theta_{k} + 2 \\alpha (r + \\gamma \\max_{a'} Q^{*}(s', a', \\theta) - Q^{*}(s, a, \\theta)) \\nabla_{\\theta} Q^{*}(s, a, \\theta)\n\\end{aligned}\n$$\n\nЭто практически в точности повторяет формулу Q-learning, которая гласит, что если таргет $r + \\gamma \\max_{a'} Q^{*}(s', a', \\theta)$ больше $Q^{*}(s, a, \\theta)$, то нужно подстроить веса нашей модели так, чтобы $Q^{*}(s, a, \\theta)$ стало чуть побольше, и наоборот. В среднем при такой оптимизации мы будем двигаться в сторону\n\n$$\\mathbb{E}_{s' \\sim p(s' \\mid s, a)} y = \\mathbb{E}_{s' \\sim p(s' \\mid s, a)} \\left[ r + \\gamma \\max_{a'} Q^{*}(s', a', \\theta) \\right]\n$$\n\n— в сторону правой части уравнения оптимальности Беллмана, то есть моделировать метод простой итерации для решения системы нелинейных уравнений.\n\nЕдинственное отличие такой задачи регрессии от тех, с которыми сталкивается традиционное глубокое обучение — то, что целевая переменная *зависит от нашей же собственной модели*. Раньше целевые переменные были напрямую источником обучающего сигнала. Теперь же, когда мы хотим выучить будущую награду при условии оптимального поведения, мы не знаем этого истинного значения или даже её стохастичных оценок. Поэтому мы применяем идею **бутстрапирования** (**bootstrapping**): берём награду за следующий шаг, и нечестно приближаем всю остальную награду нашей же текущей аппроксимацией $\\max_{a'} Q^{*}(s', a', \\theta)$. Да, за этим кроется идея метода простой итерации, но важно понимать, что такая целевая переменная лишь указывает направление для обучения, но не является истинным приближением будущих наград или даже их несмещённой оценкой. Поэтому говорят, что в этой задаче регрессии очень **смещённые** (**biased**) целевые переменные.\n\nНа практике из-за этого возникает беда. Наша задача регрессии в таком виде меняется после каждого же шага. Если вдруг после очередного шага оптимизации и обновления весов нейросети наша модель начала выдавать какие-то немного неадекватные значения, они рискуют попасть в целевую переменную на следующем шаге, мы сделаем шаг обучения под неадекватные целевые переменные, модель станет ещё хуже, и так далее, начнётся цепная реакция. Алгоритмы, в которых целевая переменная вот так напрямую зависит от текущей же модели, из-за этого страшно нестабильны.\n\nДля стабилизации применяется трюк, называемый **таргет-сетью** (**target network**). Давайте сделаем так, чтобы у нас задача регрессии менялась не после каждого обновления весов нейросетки, а хотя бы раз, скажем, в 1000 шагов оптимизации. Для этого заведём полную копию нашей нейросети («таргет-сеть»), веса которой будем обозначать $\\theta^{-}$. Каждые 1000 шагов будем копировать веса из нашей модели в таргет-сеть $\\theta^{-} \\leftarrow \\theta$, больше никак менять $\\theta^{-}$ не будем. Когда мы захотим для очередного перехода $(s, a, r, s')$ построить таргет, мы воспользуемся не нашей свежей моделью, а таргет-сетью:\n\n$$y = r + \\gamma \\max_{a'} Q^{*}(s', a', \\theta^{-})\n$$\n\nТогда правило, по которому строится целевая переменная, будет меняться раз в 1000 шагов, и мы 1000 шагов будем решать одну и ту же задачу регрессии. Такой процесс будет намного стабильнее.\n\n## Experience Replay\n\nЧтобы окончательно собрать алгоритм **Deep Q-learning** (обычно называемый **DQN**, **Deep Q-network**), нам понадобится сделать последний шаг, связанный опять со сбором данных. Коли мы хотим обучать нейросетку, нам нужно для каждого обновления весов откуда-то взять целый мини-батч данных, то есть батч переходов $(s, a, r, s')$, чтобы по нему усреднить оценку градиента. Однако, если мы возьмём среду, сделаем в ней $N$ шагов, то встреченные нами $N$ переходов будут очень похожи друг на друга: они все придут из одной и той же области пространства состояний. Обучение нейросетки на скоррелированных данных — плохая идея, поскольку такая модель быстро забудет, что она учила на прошлых итерациях.\n\nБороться с этой проблемой можно двумя способами. Первый способ, доступный всегда, когда среда задана при помощи виртуального симулятора — запуск **параллельных агентов**. Запускается параллельно $N$ процессов взаимодействия агента со средой, и для того, чтобы собрать очередной мини-батч переходов для обучения, во всех экземплярах проводится по одному шагу взаимодействия, собирается по одному переходику. Такой мини-батч уже будет разнообразным.\n\nБолее интересный второй способ. Давайте после очередного шага взаимодействия со средой мы не будем тут же использовать переход $(s, a, r, s')$ для обновления модели, а запомним этот переход и положим его себе в коллекцию. Память со всеми встретившимися в ходе проб и ошибок переходами $(s, a, r, s')$ называется **реплей буфером** (**replay buffer** или **experience replay**). Теперь для того, чтобы обновить веса нашей сети, мы возьмём и случайно засэмплируем из равномерного распределения желаемое количество переходов из всей истории.\n\nОднако, использование реплей буфера возможно далеко не во всех алгоритмах обучения с подкреплением. Дело в том, что некоторые алгоритмы обучения с подкреплением требуют, чтобы данные для очередного шага обновления весов были сгенерированы именно текущей, самой свежей версией стратегии. Такие алгоритмы относят к классу **on-policy**: они могут улучшать стратегию только по данным из неё же самой («on policy»). Примером on-policy алгоритмов выступают, например, эволюционные алгоритмы. Как они устроены: например, можно завести популяцию стратегий, поиграть каждой со средой, отобрать лучшие и как-то породить новую популяцию (подробнее про одну из самых успешных схем в рамках такой идеи можно посмотреть [здесь](https://openai.com/blog/evolution-strategies/)). Как бы ни была устроена эта схема, эволюционный алгоритм никак не может использовать данные из, например, старых, плохих стратегий, которые вели себя, скажем, не сильно лучше случайной стратегии. Поэтому неизбежно в эволюционном подходе нужно свежую популяцию отправлять в среду и собирать новые данные перед каждым следующим шагом.\n\nИ вот важный момент: Deep Q-learning, как и обычный Q-learning, относится к **off-policy** алгоритмам обучения с подкреплением. Совершенно неважно, какая стратегия, умная или не очень, старая или новая, породила переход $(s, a, r, s')$, нам всё равно нужно решать уравнение оптимальности Беллмана в том числе и для этой пары $s, a$ и нам достаточно при построении таргета лишь чтобы $s'$ был сэмплом из функции переходов (а она-то как раз одна вне зависимости от того, какая стратегия взаимодействует в среде). Поэтому обновлять модель $Q^{*}(s,a)$ мы можем по совершенно произвольному опыту, и, значит, мы в том числе можем использовать experience replay.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/off_policy_0f8a26897c_087a80257a.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — курс <a href=\"http://ai.berkeley.edu/lecture_slides.html\">UC Berkeley AI</a></p>\n  </figcaption>\n</figure>\n\nВ любом случае, даже в сложных средах, при взаимодействии со средой мы всё равно должны как-то разрешить дилемму exploration-exploitation, и пользоваться, например, $\\varepsilon$-жадной стратегией исследования. Итак, алгоритм DQN выглядит так:\n\n1. Проинициализировать нейросеть $Q^{*}(s, a, \\theta)$.\n2. Проинициализировать таргет-сеть, положив $\\theta^{-} = \\theta$.\n3. Пронаблюдать $s_0$ из среды.\n4. Для $k = 0, 1, 2, \\dots$:\n\n* с вероятностью $\\varepsilon$ выбрать действие $a_k$ случайно, иначе жадно:\n\n$$a_k = \\operatorname{argmax}\\limits_{a_k} Q^{*}(s_k, a_k, \\theta)\n$$\n\n* отправить действие $a_k$ в среду, получить награду за шаг $r_k$ и следующее состояние<br>$s_{k+1}$.\n* добавить переход $(s_k, a_k, r_k, s_{k+1})$ в реплей буфер.\n* если в реплей буфере скопилось достаточное число переходиков, провести шаг обучения. Для этого сэмплируем мини-батч переходиков $(s, a, r, s')$ из буфера.\n* для каждого переходика считаем целевую переменную: $y = r + \\gamma \\max\\limits_{a'} Q^{*}(s', a', \\theta^{-})$\n* сделать шаг градиентного спуска для обновления $\\theta$, минимизируя\n\n$$\\sum (y - Q^{*}(s, a, \\theta))^2\n$$\n\n* если $k$ делится на 1000, обновить таргет-сеть: $\\theta^{-} \\leftarrow \\theta$.\n\nАлгоритм DQN не требует никаких handcrafted признаков или специфических настроек под заданную игру. Один и тот же алгоритм, с одними и теми же гиперпараметрами, можно запустить на любой из 57 игр древней консоли Atari ([пример игры в Breakout](https://www.youtube.com/watch?v=TmPfTpjtdgg)) и получить какую-то стратегию. Для сравнения алгоритмов RL между собой результаты обычно усредняют по всем 57 играм Atari. Недавно алгоритм под названием Agent57, объединяющий довольно много модификаций и улучшений DQN и развивающий эту идею, [смог победить человека сразу во всех этих 57 играх](https://deepmind.com/blog/article/Agent57-Outperforming-the-human-Atari-benchmark).\n\n## А если пространство действий непрерывно?\n\nВсюду в DQN мы предполагали, что пространство действий дискретно и маленькое, чтобы мы могли считать жадную стратегию $\\pi(s) = \\operatorname{argmax}_a Q^{*}(s, a, \\theta)$ и считать максимум в формуле целевой переменной $\\max_a Q^{*}(s, a, \\theta)$. Если пространство действий непрерывно, и на каждом шаге от агента ожидается выбор нескольких вещественных чисел, то как это делать непонятно. Такая ситуация повсюду возникает в робототехнике. Там каждое сочленение робота можно, например, поворачивать вправо / влево, и такие действия проще описывать набором чисел в диапазоне \\[-1, 1\\], где -1 — крайне левое положение, \\+1 — крайне правое, и доступны любые промежуточные варианты. При этом дискретизация действий не вариант из-за экспоненциального взрыва числа вариантов и потери семантики действий. Нам, в общем-то, нужно в DQN только одну проблему решить: как-то научиться аргмаксимум по действиям брать.\n\nА давайте, коли мы не знаем $\\operatorname{argmax}_a Q^{*}(s, a)$, приблизим его другой нейросеткой. А то есть, заведём вторую нейросеть $\\pi(s, \\phi)$ с параметрами $\\phi$, и будем учить её так, чтобы\n\n$$\\pi(s, \\phi) \\approx \\operatorname{argmax}_a Q^{*}(s, a, \\theta).\n$$\n\nКак это сделать? Ну, будем на каждой итерации алгоритма брать батч состояний $s$ из нашего реплей буфера и будем учить $\\pi(s, \\phi)$ выдавать такие действия, на которых наша Q-функция выдаёт большие скалярные значения:\n\n$$\\sum_{s} Q^{*}(s, \\pi(s, \\phi), \\theta) \\to \\max_{\\phi}\n$$\n\nПричём, поскольку действия непрерывные, всё слева дифференцируемо и мы можем напрямую применять самый обычный backpropagation!\n\n![DDPG](https://yastatic.net/s3/education-portal/media/DDPG_b3d646163c_268137e15a.webp)\n\nТеперь когда на руках есть приближение $\\pi(s, \\phi) \\approx \\operatorname{argmax}_a Q^{*}(s, a, \\theta)$, можно просто использовать его всюду, где нам нужны аргмаксимумы и максимумы от нашей Q-функции. Мы получили **Actor-Critic** схему: у нас есть *актёр*, $\\pi(s, \\phi)$ — детерминированная стратегия, и *критик* $Q^{*}(s,a)$, который оценивает выбор действий актёром и предоставляет градиент для его улучшения. Актёр учится выбирать действия, которые больше всего нравятся критику, а критик учится регрессией с целевой переменной\n\n$$y = r + \\gamma \\max_{a'} Q^{*}(s', a', \\theta^{-}) \\approx r + \\gamma Q^{*}(s', \\pi(s', \\phi), \\theta^{-})\n$$\n\nЭта прикольная рабочая эвристика позволяет придумать off-policy алгоритмы для непрерывных пространств действий; к такому подходу относятся такие алгоритмы, как DDPG, TD3 и SAC.\n\n## Policy Gradient алгоритмы\n\nВ рассмотренных алгоритмах есть несколько приниципиальных ограничений, которые вытекают непосредственно из самой идеи подхода. Мы учимся с таргетов, заглядывающих всего на один шаг вперёд, использующих только $s'$; это чревато проблемой накапливающейся ошибки, поскольку если между выполнением действия и получением награды \\+1 проходит 100 шагов, нам нужно на сто шагов «распространять» полученный сигнал. Мы должны учить $Q^{*}(s,a)$ вместо того, чтобы как-то напрямую («end-to-end») запомнить, какие действия в каких состояниях хорошие. Наконец, наша стратегия всегда детерминирована, когда для взаимодействия со средой во время сбора данных, например, нам позарез нужна была стохастичная, чтобы гарантированно обновлять Q-функцию для всех пар $s, a$, и эту проблему пришлось закрывать костылями.\n\nЕсть второй подход model-free алгоритмов RL, называемый **Policy Gradient**, который позволяет избежать вышеперечисленных недостатков за счёт on-policy режима работы. Идея выглядит так: давайте будем искать стратегию в классе стохастичных стратегий, то есть заведём нейросеть, моделирующую $\\pi_{\\theta}(a \\mid s)$ напрямую. Тогда наш функционал, который мы оптимизируем,\n\n$$J(\\theta) = \\mathbb{E}_{\\mathcal{T} \\sim \\pi_{\\theta}} \\sum_{t \\ge 0} \\gamma^t r_t \\to \\max_{\\theta},\n$$\n\nдифференцируем по параметрам $\\theta$, и градиент равен:\n\n$$\\nabla_{\\theta} J(\\theta) = \\mathbb{E}_{\\mathcal{T} \\sim \\pi_{\\theta}} \\sum_{t \\ge 0} \\nabla_{\\theta} \\log \\pi_{\\theta}(a_t \\mid s_t) \\gamma^t R_t,\n$$\n\nгде $R_t$ - reward-to-go с шага $t$, то есть награда, собранная в сыгранном эпизоде после шага $t$:\n\n$$R_t = \\sum_{t' \\ge t} \\gamma^{t' - t} r_{t'}\n$$\n\n{% cut \"Скетч доказательства\" %}\n\nДавайте распишем мат.ожидание по определению, как следующий интеграл:\n\n$$\\nabla_{\\theta} J(\\theta) = \\nabla_{\\theta} \\mathbb{E}_{\\mathcal{T} \\sim \\pi_{\\theta}} \\sum_{t \\ge 0} \\gamma^t r_t = \\nabla_{\\theta} \\int_{\\mathcal{T}} p(\\mathcal{T} \\mid \\pi_{\\theta}) R_0 d\\mathcal{T},\n$$\n\nгде интеграл берётся по пространству всевозможных траекторий, \\$\\$p(\\\\mathcal\\{T\\} \\\\mid \\\\pi_\\{\\\\theta\\})\\$\\$ — вероятность встретить траекторию $\\mathcal{T}$ при взаимодействии со средой стратегии $\\pi_{\\theta}$, а $R_0$ — reward-to-go с шага $t = 0$, то есть суммарная дисконтированная награда за весь эпизод для рассматриваемой траектории $\\mathcal{T}$. Награда от параметров $\\theta$ не зависит; от выбора стратегии зависят лишь вероятности встретить ту или иную траекторию $\\mathcal{T}$. Давайте пронесём градиент внутрь интеграла:\n\n$$\\nabla_{\\theta} J(\\theta) = \\int_{\\mathcal{T}} \\nabla_{\\theta} p(\\mathcal{T} \\mid \\pi_{\\theta}) R_0 d \\mathcal{T},\n$$\n\nи теперь этот сложный интеграл перестал быть каким-то мат.ожиданием. Давайте исправим это при помощи трюка, который называется **log-derivative trick**: для этого домножим и поделим внутри на $p(\\mathcal{T} \\mid \\pi_{\\theta})$, получим:\n\n$$\\nabla_{\\theta} J(\\theta) = \\int_{\\mathcal{T}} p(\\mathcal{T} \\mid \\pi_{\\theta}) \\frac{\\nabla_{\\theta} p(\\mathcal{T} \\mid \\pi_{\\theta})}{p(\\mathcal{T} \\mid \\pi_{\\theta})} R_0 d \\mathcal{T} = \\mathbb{E}_{\\mathcal{T} \\sim \\pi_{\\theta}} \\frac{\\nabla_{\\theta} p(\\mathcal{T} \\mid \\pi_{\\theta})}{p(\\mathcal{T} \\mid \\pi_{\\theta})} R_0\n$$\n\nИтак, мы увидели, что градиент нашего функционала — тоже мат.ожидание по всевозможным траекториям. Осталось заметить, что отношение градиента правдоподобия к значению правдоподобия — градиент логарифма правдоподобия:\n\n$$\\nabla \\log p(x) = \\frac{\\nabla p(x)}{p(x)}\n$$\n\n(откуда и название трюка), чем мы и воспользуемся:\n\n$$\\nabla_{\\theta} J(\\theta) = \\mathbb{E}_{\\mathcal{T} \\sim \\pi_{\\theta}} \\nabla_{\\theta} \\log p(\\mathcal{T} \\mid \\pi_{\\theta}) R_0\n$$\n\nВспоминая, как выглядит trajectory distribution для заданной стратегии $\\pi_{\\theta}$, замечаем, что функция переходов в среде не вносит вклад в наш градиент:\n\n$$\\nabla_{\\theta} \\log p(\\mathcal{T} \\mid \\pi_{\\theta}) = \\nabla_{\\theta} \\log \\prod_{t \\ge 0} p(s_{t + 1} \\mid s_t, a_t) \\pi_{\\theta}(a_t \\mid s_t) = \\sum_{t \\ge 0} \\nabla_{\\theta} \\log \\pi_{\\theta}(a_t \\mid s_t)\n$$\n\nИтого мы получили следующую формулу:\n\n$$\\nabla_{\\theta} J(\\theta) = \\mathbb{E}_{\\mathcal{T} \\sim \\pi_{\\theta}} \\sum_{t \\ge 0} \\nabla_{\\theta} \\log \\pi_{\\theta}(a_t \\mid s_t) R_0\n$$\n\nОтличие этой формулы от приведённой выше в том, что градиент, отвечающий за выбор действия $a_t$ в состоянии $s_t$, взвешивается не на reward-to-go с момента времени $t$, а на всю награду за эпизод, начиная с нулевого момента времени. Это странно, поскольку получается, что награда, собранная в прошлом, до принятия решения в момент времени $t$, как-то влияет на градиент, соответствующий этому выбору. Мы же понимаем, что решение в момент времени $t$ на прошлую награду никак повлиять не могло, и странно, что градиент для решения в момент времени $t$ взвешивается на прошлую награду. Это наблюдение называется **принципом причинности** (causality principle); можно строго показать, что если заменить $R_0$ на $R_t$, то «удалённые» таким образом слагаемые в среднем по траекториям дают нулевой вклад в градиент, и поэтому такая замена математически корректна.\n\n{% endcut %}\n\nЭта формула говорит нам, что градиент нашего функционала — это тоже мат.ожидание по траекториям. А значит, мы можем попробовать посчитать какую-то оценку этого градиента, заменив мат.ожидание на Монте Карло оценку, и просто начать оптимизировать наш функционал самым обычным стохастическим градиентным спуском! А то есть: берём нашу стратегию $\\pi_{\\theta}$ с текущими значениями параметров $\\theta$, играем эпизод (или несколько) в среде, то есть сэмплируем $\\mathcal{T} \\sim \\pi_{\\theta}$, и затем делаем шаг градиентного подъёма:\n\n$$\\theta \\leftarrow \\theta + \\alpha \\sum_{t \\ge 0} \\nabla_{\\theta} \\log \\pi_{\\theta}(a_t \\mid s_t) \\gamma^t R_t\n$$\n\nПочему эта идея приводит к on-policy подходу? Для каждого шага градиентного шага нам обязательно нужно взять $\\mathcal{T} \\sim \\pi_{\\theta}$ с самыми свежими, с текущими весами $\\theta$, и никакая другая траектория, порождённая какой-то другой стратегией, нам не подойдёт. Поэтому для каждой итерации алгоритма нам придётся заново играть очередной эпизод со средой. Это **sample-inefficient**: неэффективно по числу сэмплов, мы собираем слишком много данных и очень неэффективно с ними работаем.\n\nPolicy Gradient алгоритмы пытаются по-разному бороться с этой неэффективностью, опять же обращаясь к теории оценочных функций и бутстрапированным оценкам, позволяющим предсказывать будущие награды, не доигрывая эпизоды целиком до конца. Большинство этих алгоритмов остаются в on-policy режиме и применимы в любых пространствах действий. К этим алгоритмам относятся такие алгоритмы, как Advantage Actor-Critic (A2C), Trust-Region Policy Optimization (TRPO) и Proximal Policy Optimization (PPO).\n\n## Что там ещё?\n\nМы до сих пор разбирали **model-free** алгоритмы RL, которые обходились без знаний о $p(s' \\mid s, a)$ и никак не пытались приближать это распределение. Однако, в каких-нибудь пятнашках функция переходов нам известна: мы знаем, в какое состояние перейдёт среда, если мы выберем некоторое действие в таком-то состоянии. Понятно, что эту информацию было бы здорово как-то использовать. Существует обширный класс **model-based**, который либо предполагает, что функция переходов дана, либо мы учим её приближение, используя $s, a, s'$ из нашего опыта в качестве обучающей выборки. Алгоритм AlphaZero на основе этого подхода [превзошёл человека в игру Го](https://www.youtube.com/watch?v=WXuK6gekU1Y&ab_channel=DeepMind), которая считалась куда более сложной игрой, чем шахматы; причём этот алгоритм возможно запустить обучаться на любой игре: [как на Го, так и на шахматах или сёги](https://deepmind.com/blog/article/alphazero-shedding-new-light-grand-games-chess-shogi-and-go).\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/model_based_d4787dd274_83413342fe.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>источник картинки — курс <a href=\"http://ai.berkeley.edu/lecture_slides.html\">UC Berkeley AI</a></p>\n  </figcaption>\n</figure>\n\nОбучение с подкреплением стремится построить алгоритмы, способные обучаться решать любую задачу, представленную в формализме MDP. Как и обычные методы оптимизации, их можно использовать в виде чёрной коробочки из готовых библиотек, например, [OpenAI Stable Baselines](https://stable-baselines.readthedocs.io/en/master/). Внутри таких коробочек будет, однако, довольно много гиперпараметров, которые пока не совсем понятно как настраивать под ту или иную практическую задачу. И хотя успехи Deep RL демонстрируют, что эти алгоритмы способны обучаться невероятно сложным задачам вроде [победы над людьми в Dota 2](https://openai.com/projects/five/) и [в StarCraft II](https://deepmind.com/blog/article/alphastar-mastering-real-time-strategy-game-starcraft-ii), они требуют для этого колоссального количества ресурсов. Поиск более эффективных процедур — открытая задача в Deep RL.\n\nВ ШАДе есть курс Practical RL, на котором вы погрузитесь глубже в мир глубокого обучения с подкреплением, разберётесь в более продвинутых алгоритмах и попробуете пообучать нейронки решать разные задачки в разных средах.",
        "handbook": "Учебник по машинному обучению",
        "title": "Обучение с подкреплением",
        "description": null
    },
    {
        "path": "/handbook/ml/article/kraudsorsing",
        "content": "## Вступление\n\nДля обучения и проверки качества ML-модели необходимы данные, размеченные человеком. Студенты обычно получают эти данные уже в готовом виде, но в работе над реальными продуктами задачи по сбору и разметке приходится решать самостоятельно, учитывая специфику конкретного продукта.\n\nГотовые наборы зачастую однообразны, а иногда и вовсе мешают достичь требуемых результатов: так, модели компьютерного зрения для беспилотного транспорта необходимо обучать на данных, собранных в той же среде, где используется модель. Кроме того, высокие темпы развития нейросетевых технологий провоцируют все большую необходимость в крупных объемах данных: чем лучше текущее качество модели, тем больше новых данных требуется, чтобы поднять это качество на новый уровень. Как следствие, сбор и разметка данных становится неотъемлемой частью почти любого ML-производства, а качество и количество этих данных напрямую влияет на качество конечного продукта.\n\nКраудсорсинг зарекомендовал себя, как один из эффективных способов сбора и разметки данных в больших масштабах. Его используют в разработке новых технологий, чтобы создавать обучающие датасеты для ML-моделей беспилотных автомобилей, голосовых помощников, чат-ботов, поисковых систем и других разработок.\n\nКачественные данные удается собрать благодаря краудсорсинговым платформам: они помогают снизить количество ошибок с помощью специальных настроек, которые можно найти на платформе, а также дают доступ к огромному количеству исполнителей, способных в любое время присоединиться к работе.\n\nТакже секрет успеха кроется в той последовательности действий, которые нужно соблюдать, создавая проект на карудсорсинговой платформе. Участникам краудсорсинговых платформ под силу выполнить не все задания, а только простые: сложные задания нужно разбивать на несколько небольших. Качество выполняемой ими работы нужно проверять с помощью доступных на платформе инструментов контроля качества. Полученные результаты в некоторых случаях нужно правильно обрабатывать (здесь полезно разобраться в способах агрегации данных). Чтобы исполнители получили оплату только за правильно выполненные задания, нужно сформулировать подходящую модель ценообразования и т. д.\n\nНюансов в работе с краудсорсингом достаточно много, поэтому мы подготовили этот параграф в учебник. Стоит отметить, что в ней мы уделим внимание нетехническим аспектам краудсорсинга для ML. Такой уклон связан с тем, что использование краудсорсинга в качестве инструмента работы с данными требует не только знания технических и математических методов (они пригодятся в финальной части, когда полученные данные необходимо будет обработать), но и умения правильно организовать процесс сбора данных, понимания самого феномена краудсорсинга, который сегодня используется в разных сферах для решения разных задач.\nПо этой причине структура этого параграфа будет выглядеть следующим образом:\n\n<ol>\n    <li> В первой части мы сделаем общий обзор краудсорсинга в ML и объясним, для каких задач он применим. </li>\n    <li> Во второй части мы остановимся на основных этапах запуска краудсорсингового проекта: от деления проекта на небольшие задачи до обработки полученных от исполнителей данных. </li>\n    <li> Кроме того, в этом параграфе мы разберем примеры некоторых ML-задач, которые встречаются в проектах в сфере AI и ML. Это сбор данных для поисковых сетей, разметка изображений для беспилотных автомобилей и сбор аудиозаписей для голосовых помощников. </li>\n</ol>\n\nНадеемся, что вам будет интересно погружаться в мир краудсорсинга для ML. Будем рады, если мы поможем вам разложить все по полочкам, чтобы вы смогли дальше наращивать свои знания и изучать отдельные темы более глубоко.\n\n## Что такое краудсорсинг в ML?\n\nСуществует довольно много определений краудсорсинга, а также близких к нему по значению терминов (например, «человеческие вычисления», «мудрость толпы» и «коллективный разум»). Это связано с тем, что этот метод используется в разных сферах и применяется для решения разного рода задач, в том числе поиска креативных идей, создания контента, сбора денежных средств. Например, автор термина «краудсорсинг», Джефф Хоу, в 2006 году предложил следующее определение этого метода: Краудсорсинг (от англ. crowd — «толпа», source — «использование ресурсов») — это процесс, в котором компания переносит определенные функции, ранее возлагавшиеся на сотрудников, аутсорсинговые предприятия и поставщиков, на неопределенное, достаточно большое количество людей в формате открытого запроса.\n\nЭто определение отражает основную идею краудсорсинга. Однако его недостаточно в контексте рассматриваемой нами темы. Мы говорим о краудсорсинге в машинном обучении. Это значит, что мы передаем облаку исполнителей те задачи, которые связаны со сбором и разметкой данных, а также с оценкой этих данных для разного рода проектов. Разработчики используют эти данные, чтобы обучать машины, а именно модели этих машин, выполнять требуемые задачи. Поэтому в машинном обучении краудсорсинг — это дополнительный вычислительный кластер, который помогает командам создавать и улучшать их продукты.\n\nОдин из первых проектов, который задействовал краудсорсинг в получении данных для обучения модели, — проект [Distributed Proofreaders](https://www.pgdp.net/c/) (с англ. — «Распределенные корректоры»). Его главная цель — цифровизация печатных книг с помощью программы для оптического распознавания символов (OCR). Вовлекая тысячи волонтёров, проект Distributed Proofreaders оцифровывает печатные книги и улучшает программу для распознавания текстов. Чем больше данных модель этой программы получает от волонтеров, тем лучше она считывает текст с отсканированных страниц книг. Соответственно, чем лучше становится эта модель, тем меньше времени и усилий человека требуется для того, чтобы находить и исправлять ее ошибки.\n\nРассмотрим этот проект подробнее:\n\n<ol>\n    <li>Добровольцам предлагают сравнить отсканированное изображение страницы и текст этой страницы, распознанный с помощью программного обеспечения для оптического распознавания символов (OCR).</li>\n    <li>Поскольку программа оптического распознавания текста не справляется с задачей в полном объеме, в тексте часто появляются ошибки. Задача добровольца — исправить ошибки OCR и загрузить файл обратно на сайт.</li>\n    <li>Выполненная работа передается второму добровольцу, он проверяет ее, исправляет ошибки.</li>\n    <li>Книга аналогичным образом проходит третий этап корректуры и два этапа форматирования с использованием одного и того же веб-интерфейса.</li>\n    <li>После того, как все страницы книги прошли через несколько этапов проверки, постпроцессор собирает их в электронную книгу и отправляет в архив проекта <a href=\"https://www.gutenberg.org/\">«Гутенберг»</a>.</li>\n    <li>Отредактированные страницы книг в дальнейшем используются разработчиками, как данные для обучения OCR. Модель программы обучается на данных и в дальнейшем совершает меньше ошибок при распознавании текста на изображениях.</li>\n</ol>\n\nДругой пример использования краудсорсинга в ML — сервис [reCaptcha](https://www.google.com/recaptcha/about/). Он был запущен учеными Университета Карнеги-Меллона в 2007 году и стал продолжением проекта Captcha, появившегося в 2000 году. Напомним, что Captcha — это программа, которая защищает сайты от интернет-ботов. Посещая сайт и совершая на нем определенные действия, пользователь получает просьбу заполнить веб-форму. Его задача — вписать в эту форму буквы и цифры, которые он видит на изображении. Люди с хорошим зрением могут легко распознать эти символы, а боты не могут. Так сервис определяет, кто из посетителей сайта человек, а кто — бот. Ботам доступ к сайтам закрывается, так как они наносят вред сайтам.\n\nСоздатели проекта Captcha пошли дальше. Они подсчитали, что у каждого человека уходит примерно 10 секунд на ввод одной капчи. А у человечества (10 умножаем на 200 млн) — 500 000 часов. Тогда появилась идея о том, что время, потраченное на ввод капчи, можно использовать с пользой для людей. Это стало началом проекта reCaptcha. Отличие этого проекта от проекта Captcha состоит в том, что вы не только печатаете капчу и подтверждаете, что вы человек, но и одновременно делаете минимальное полезное усилие. В 2007 году таким усилием была оцифровка книг, а с 2012 года reCaptcha стали использовать для распознавания изображений из онлайн-карт. Мы расскажем про инициативу, вошедшую в историю под девизом Stop Spam, Read Books. В чем она заключалась?\n\n<ol>\n    <li>Каждая страница книги сканируется.</li>\n    <li>Компьютер расшифровывает слова на каждом отсканированном изображении. Для этого используется технология OCR — та, же технология, что и в первом проекте.</li>\n    <li>При распознавании текста OCR допускает ошибки. Их особенно много в распознанных текстах старых книг, поскольку в некоторых местах чернила выцвели и страницы пожелтели. Например, в книгах, написанных более 50 лет назад, компьютер не может распознать более 30% слов.</li>\n    <li>Все нераспознанные слова направляются людям, чтобы они их распознали, когда вводят капчу в интернете. Задача добровольцев — ввести слова, взятые из отсканированных книг, которые компьютер не смог распознать.</li>\n    <li>Добровольцу необходимо распознать два слова из книги. Почему именно два? Одно из слов взято из книги, и оно неизвестно компьютеру. Соответственно, проверить ответ добровольца компьютер не может. Поэтому волонтер получает второе слово — его компьютер знает. Мы не говорим, какое из слов известно компьютеру, и просим добровольца ввести оба. Если доброволец вводит известное слово правильно, система получает подтверждение, что он — человек, а также получает уверенность в правильности ввода другого слова.</li>\n    <li>Одно и то же слово, которое неизвестно компьютеру, направляется десяти участникам проекта. Если все они вводят его одинаково, то есть их ответы совпадают, то это слово отправляется в книгу.</li>\n    <li>Как и в случае с первым проектом, данные, полученные от добровольцев, используются для обучения технологии OCR.</li>\n</ol>\n\nИнициативой проекта reCaptcha впечатлилось множество владельцев сайтов. Новый сервис взамен традиционной Captcha установили такие сайты, как Tiketmaster, Facebook, Twitter и примерно 350 000 других сайтов. Каждый день на этих сайтах вплоть до 2012 года люди оцифровывали примерно 100 млн слов в день. Это 2,5 млн книг в год. В результате, в течение пяти лет с момента его запуска в проекте по оцифровке книг поучаствовали минимум 750 млн людей (это 10% всего населения). Книги, оцифрованные в рамках этого проекта сегодня представлены на сайте [books.google.com](https://books.google.com/).\n\nПодводя итоги вышесказанного, сформулируем определение краудсорсинга в ML. Краудсорсинг в ML — это способ сбора данных, которые необходимы разработчикам, чтобы обучать машины выполнять необходимые действия. С помощью краудсорсинга разработчики вовлекают в процесс выполнения задач обычных людей, которые не владеют определенными навыками и экспертизой. В рамках четко заданных инструкций они выполняют нужное количество заданий. Результаты этих заданий — собранные, размеченные или оцененные данные — входят в те датасеты, которые используются для обучения машин.\n\n## Ключевые принципы краудсорсинга в ML\n\nПрименение краудсорсинга в машинном обучении значительно ускорило процесс развития AI продуктов. Беспилотные автомобили, голосовые помощники, поисковые системы, онлайн-карты, машинный перевод появились и развиваются во многом благодаря данным, полученным с помощью краудсорсинга. Например, чтобы поисковая система смогла точно отвечать на вопросы пользователей, нужно проделать большую работу по разметке данных: проанализировать запросы и поведение пользователя, оценить возможные результаты на соответствие запросу, сравнить разные варианты поисковых выдач и выбрать лучший. Все эти данные ложатся в основу моделей, которые учатся искать лучшие ответы, опираясь на размеченные людьми образцы. Такие задачи, на первый взгляд, кажутся трудозатратными и продолжительными по времени. Но если воспользоваться возможностями краудсорсинга и подойти к ним, как к инженерной проблеме, эти сложности будут преодолены.\n\nВ этом тезисе содержится основная идея краудсорсинга для AI и машинного обучения: **чтобы решить задачу по разметке данных для обучения или оценки качества модели, нужно подойти к ней как к инженерной проблеме**. Это значит, что нужно организовать выполнение задачи таким образом, чтобы конечный результат зависел от качества самого процесса, а не от добросовестности или экспертности отдельных исполнителей.\n\nТакой подход требует соблюдения ряда правил. Прежде всего, чтобы проект был доступен максимальному количеству исполнителей и не зависел от редких компетенций, его необходимо разделить на сценарии или небольшие задачи. Принцип деления сложной задачи на несколько микрозадач называется **декомпозицией**. Это основополагающий принцип для каждого краудсорсингового проекта, создаваемого для задач машинного обучения.\n\nКаждую микрозадачу необходимо детально продумать. Определить элементы, которые будут ее сопровождать. Некоторые из них (например, инструкции или интерфейсы) обязательно должны присутствовать в проекте. Другие — такие как предварительная фильтрация исполнителей или отслеживание их поведения в проекте — используются в случае необходимости. Все эти элементы решают вопрос качества данных: чем лучше продуман проект, чем эффективнее он «сопровождает» исполнителя во время разметки, тем меньше остается пространства для ошибок или недобросовестного поведения.\n\nДетальную схему проекта, состоящую из цепочки микрозадач и сопровождающих их элементов, называют пайплайном (от англ. pipeline — «линия, очередь»). Его создают на этапе планирования проекта и обращаются к нему как к «дорожной карте».\n\n## ML-задачи, где используется разметка\n\nКраудсорсинг помогает решить разнообразный спектр ML-задач. Разделим их на две основные группы — разметка и сбор данных.\n\n## Разметка данных\n\nК этой группе относится целый ряд задач, в рамках которых пользователю краудсорсинговой платформы необходимо выполнить некоторое действие с уже полученными данными. Например, его могут попросить перевести записи из аудио в текст (транскрипция аудио) или выделить в запросе пользователя в поисковой системе определенные смысловые части, такие как тип продукта, цвет, бренд (NLP-задания). Также в эту группу входят задачи по проверке автоматического перевода, модерации контента, разметке видео или сегментации объектов на изображениях.\n\nВ качестве примера рассмотрим задачи по сегментации изображений. Как правило, они нужны для обучения алгоритмов компьютерного зрения. Они используются, например, для создания беспилотного транспорта, который должен распознавать всевозможные препятствия на дорогах: людей, светофоры, разметку, дорожные знаки, дома, заборы, искусственные неровности и т. д. Чтобы эти модели были качественными и могли без труда распознавать любые объекты на своем пути, им нужно показать большое количество изображений и в, более сложных случаях, видео с выделенными на них объектами разных классов.\n\nВыделением этих объектов занимаются пользователи краудсорсинговых платформ. На 2D и 3D изображениях, а также видео, снятых во время движения с помощью камер, радаров и лидаров, они находят нужные объекты и обводят их. Изображения и видео, размеченные по требованиям инструкции, используются для обучения моделей компьютерного зрения.\n\nСамый простой пайплайн задачи по сегментации изображений для беспилотных автомобилей состоит из трех проектов (рис. 1). В первом проекте исполнители отвечают на вопрос, есть ли на фото нужные объекты (например, дорожные знаки). Те изображения, на которых эти объекты есть, перенаправляются в проект номер два. В нем вторая группа исполнителей обводит дорожные знаки с помощью прямоугольников. Эту разметку проверяет еще одна группа исполнителей в следующем проекте, третьем по счету. Далее включается схема так называемой отложенной приёмки заданий. В случае отклонения задание отправляется на повторную разметку. Верно выполненная работа включается в итоговый датасет.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_1_8977ae8a73_f5dff3ce7f.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Пайплайн проекта по разметке данных для обучения модели компьютерного зрения\n  </figcaption>\n</figure>\n\nПодобные пайплайны, но еще более многоступенчатые, используются для обучения моделей компьютерного зрения Яндекса. В январе 2020 года инженерам компании удалось продемонстрировать одну из моделей на конференции Consumer Electronics в Лас-Вегасе. Беспилотные автомобили со встроенной моделью проследовали по маршруту с разными дорожными сценариями: нерегулируемыми перекрестками, сложными поворотами со встречным разъездом, пешеходными переходами и многополосными участками. Всего эти автомобили преодолели более 7 тысяч км.\n\n## Сбор данных\n\nСуть задач, связанных со сбором контента, заключается в поиске материалов (изображений, фотографий, фактов), необходимых для решения проблемы. Например, используя краудсорсинг, инженеры собирают фразы для обучения голосового помощника (рис. 2).\n\nПайплайн такого проекта выглядит довольно просто: исполнители записывают необходимую фразу, например, «Привет, Алиса», и загружают ее в интерфейс задания на краудсорсинговой платформе. Далее другая группа исполнителей проверяет эти записи на предмет ошибок и других требований: если запись соответствует инструкции, вторая группа подтверждает ее, а если в записи допущены ошибки, отклоняет. В следующем проекте еще одна группа исполнителей записывает недостающие фразы, затем они вновь проходят проверку. Этот процесс повторяется по кругу, пока не будет собрано достаточное количество фраз нужного качества.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_2_4fc89b9858_f97e437e8c.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Пайплайн проекта по сбору данных для обучения модели распознавания голоса\n  </figcaption>\n</figure>\n\n## Краудсорсинговые платформы\n\nМасштабируемость и скорость выполнения задач по разметке данных напрямую зависят от доступа заказчика к большому облаку исполнителей. Залог успеха здесь — использование открытых краудсорсинговых платформ, которые позволяют постоянно пополнять это облако и, следовательно, масштабировать процессы сбора или разметки данных.\n\nОткрытые краудсорсинговые платформы — например, Amazon Mechanical Turk или Толока — работают по принципу маркетплейсов. Заказчик может создать на такой платформе свой проект, найти для него нужных исполнителей, обучить их и поручить им выполнение задания, контролируя качество результата. Пользователи открытой платформы, в свою очередь, могут выбрать интересующий их проект, выполнить задания и получить за проделанную работу вознаграждение. Свой выбор проекта они могут сделать как на основе рейтинга проекта, так и с учетом итогового вознаграждения — либо просто потому, что какая-то задача им интересна больше других.\n\nОткрытые краудсорсинговые платформы — инструмент для тех, кто планирует самостоятельно контролировать разметку данных. А это, как правило, большинство проектов в сфере AI и машинного обучения. Для ML-разработчиков крайне важно, чтобы кропотливая работа по написанию инструкций, проектированию интерфейсов, отбору и обучению участников, настройке контроля качества была выполнена в точности так, как это запланировано в пайплайне проекта. Все эти шаги напрямую влияют на качество тренировочных данных, а от них в немалой степени зависит успех продукта.\n\nПри выборе краудсорсинговой платформы важно учесть и то, какими инструментами они располагают. Например, с готовыми шаблонами можно быстрее спроектировать интерфейс задания, а инструменты контроля качества помогут отсеять роботов и недобросовестных исполнителей. Кроме того, выбор платформы во многом определит то, с какими исполнителями будет вестись работа. Изучение их характеристик даст понимание, в каких странах они проживают, на каких языках разговаривают и, что немаловажно, сталкивались ли они с проектами, подобными тому, над которым планируется работа.\n\nАльтернативой платформам-маркетплейсам могут стать проекты, которые предлагают готовые датасеты и помощь в разметке данных для проекта. Это, например, Scale AI, Hive Data, Alegion. Такие платформы подойдут не всем — выше уже шла речь о том, что некоторые проекты (как, например, обучение алгоритмов компьютерного зрения) нуждаются в специфическом контексте для сбора датасета.\n\nКроме того, построенные по общим принципам краудсорсинга проекты могут запускаться и на внутреннее облако исполнителей, связанных с компанией какими-либо договорными отношениями. Это важно в случаях, если речь идет о разметке чувствительных данных. Однако такой процесс тяжело поддается масштабированию, потому что требует больших ресурсов для сопровождения сотрудников.\n\n## Границы применимости краудсорсинга\n\nНесмотря на все многообразие задач, которые можно решить с помощью краудсорсинга, есть случаи, когда его применение затруднено либо просто нецелесообразно.\n\nВо-первых, необходимо оценить затраты, сопутствующие запуску проекта. Создание и настройка эффективного пайплайна для сбора или обработки данных требуют времени и квалификации высокоуровневого специалиста. Потраченный им ресурс может не окупиться, если требуется лишь один раз разметить небольшое количество данных.\n\nОблаку исполнителей с трудом поддаются задачи, требующие серьезного включения и поддержания контекста. Секрет краудсорсинга — в создании небольших автономных заданий, каждое из которых может быть решено согласно несложной инструкции. Если исполнителю требуется учитывать большой объем сопутствующей информации, чтобы выполнить задачу верно — скорее всего, ее лучше выполнять без использования краудсорсинга. Например, облако исполнителей вряд ли сможет осуществить перевод книги: ее не стоит разбивать на отдельные предложения, ведь перевод должен быть последовательным и согласованным. В то же время, краудсорсинг может помочь при переводе отдельных фраз в конечном контексте, например, отдельных реплик для голосового ассистента.\n\nНаконец, если задача требует крайне специфических навыков, то поиск или обучение подходящего исполнителя на краудсорсинговой платформе сравнится с наймом эксперта. В таких случаях стоит оценить возможность декомпозиции задачи так, чтобы она оказалась разбита на ряд менее сложных действий. Если сделать это невозможно (например, для выполнения задания требуется знание редкого языка), оптимальным способом поиска исполнителя могут стать профессиональные сообщества.\n\n## Этапы создания краудсорсингового проекта\n\nТипичная краудсорсинговая задача состоит из шести этапов:\n\n<ol> \n    <li>Декомпозиция;</li>\n    <li>Инструкция и интерфейс;</li>\n    <li>Контроль качества;</li>\n    <li>Отбор и обучение исполнителей;</li>\n    <li>Выбор схемы оплаты и бонусирования;</li>\n    <li>Агрегация ответов.</li>\n</ol>\n\nРазберем каждый из этапов на примере уже упомянутого проекта по сбору данных для обучения беспилотных автомобилей. Мы запустим этот проект на краудсорсинговой платформе «Толока».\n\n## Декомпозиция\n\nВ качестве исходных данных возьмем объемный набор фотографий с изображением улиц. После запуска краудсорсингового проекта мы должны получить те же изображения, но с выделенными на них дорожными знаками. Наша задача — выделить прямоугольниками дорожные знаки на каждой фотографии.\n\nПример того, как должен выглядеть итоговый датасет с выделенными на них объектами приведен на рисунке 3.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_3_949da01146_62c973987e.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Изображение с выделенными на нем дорожными знаками с помощью полигонов\n  </figcaption>\n</figure>\n\nМожем ли мы поручить нашу задачу участникам краудсорсинговой платформы напрямую? В данном случае — нет. Изображения для разметки могут полностью не соответствовать нашему запросу. Например, на изображениях может не быть нужных объектов. Некоторые фотографии могут не загрузиться в интерфейсе (появится ошибка). Чтобы избежать подобных ситуаций, нам нужно отобрать фотографии с подходящими объектами. Отбор фото или их фильтрация станет первой микрозадачей или **первым пулом** (так называется набор заданий в рамках проекта на платформе «Толока») нашего проекта.\n\nЧто дальше? Когда мы получили фотографии с дорожными знаками, мы сможем запустить проект по выделению объектов на изображениях. Наша задача — выделить на фотографиях все дорожные знаки прямоугольниками. Чтобы создать подобное задание на краудсорсинговой платформе «Толока», можно воспользоваться готовым шаблоном. Он предусматривает специальный инструмент, «полигон», который с легкостью позволяет выполнять подобные задания.\n\nНа этом мы могли бы остановиться. Получили изображения с выделенными объектами — задача выполнена. Однако для данного проекта потребуется запустить еще одно микрозадание. Фотографии с выделенными объектами необходимо проверить. Кто-то из исполнителей может пропустить некоторые знаки или выделить их неверно. Таким образом, проверка размеченных изображений в конкретном проекте необходима. Но специфика задачи такова, что мы не можем просто сравнить работу отдельного исполнителя с заведомо верным примером: выделенные области могут отличаться на несколько пикселей, но это не будет означать, что ответ неверен.\n\nИтак, что мы делаем? Мы создаем новый пул заданий, в котором спрашиваем «Верно ли выделены объекты на фото?». Участники отвечают на вопрос, после чего фото с верно отмеченными объектами отправляются в итоговый датасет и оплачиваются. Фото с неверно выделенными объектами отклоняются и не оплачиваются. Все фотографии, которые не проходят проверку, отправляются на переразметку (т. е. размечаются повторно).\n\nКакие выводы мы можем сделать по итогу разбора декомпозиции проекта? Самый главный вывод — решение о декомпозиции задачи следует принимать, исходя из типа задачи и данных, которые есть на входе — это могут быть изображения, видео, ссылки, точки на карте, координаты этих точек. Также следует различать типичные случаи, в которых декомпозиция особенно рекомендована для проекта. Речь идет об объемных проектах, многослойных задачах, задачах со множеством вариантов ответов и объемных процессах:\n\n<ul>\n    <li><i>Объемные проекты</i>. Если в рамках проекта нужно ответить на несколько вопросов, то лучше сделать это поочередно или в выбранной последовательности.</li>\n    <li><i>Многослойные задачи</i>. Если в рамках одной задачи нужно выполнить более одного действия (например, отнести объект к определенной группе и ответить на вопрос, предназначен ли он только для взрослых), то лучше сделать это поочередно или в выбранной последовательности.</li>\n    <li><i>Задачи со множеством вариантов ответов</i>. Если в задании есть один вопрос и 10 и более вариантов ответа, то лучшим решением будет группировка ответов по темам, а затем создание отдельного проекта для каждой группы ответов.</li>\n    <li><i>Объемные процессы</i>. Если задача включает сложные механизмы контроля качества и отложенную проверку, необходимо создать отдельный проект, в котором одна группа исполнителей будет проверять другую.</li>\n</ul>\n\nЕсть ли случаи, когда декомпозировать задачу не нужно? Да. Нет необходимости разбивать задачу на части, если соблюдаются два критерия: инструкции к задаче помещаются на половине листа бумаги формата А4, или задача выполнена с помощью одного действия, например, выбора из нескольких категорий.\n\n## Инструкция\n\nПосле декомпозиции нашего проекта нам необходимо создать для него инструкцию. Инструкция потребуется для каждой микрозадачи. В нашем случае нам необходимо создать три инструкции.\n\nКакие пункты мы обязательно в них укажем?\n\nПервым пунктом инструкции станет описание задачи. В нем мы объясним участнику, что предстоит сделать и где будет использован результат этой работы. Например:\n\n<p style=\"padding: 0 50px;\"><i>\n    Вашему вниманию представлен проект, результаты которого помогут сделать беспилотные автомобили безопасным транспортом. Ваша задача — определить, есть ли дорожные знаки на изображении. Выберите ответ «Да», если изображение содержит дорожные знаки. Выберите ответ «Нет», если на изображении дорожных знаков нет. На изображении, представленном ниже, есть несколько дорожных знаков. Значит, правильный ответ — «Да». </i></p>\n\n![Picture](https://yastatic.net/s3/education-portal/media/Picture_3_949da01146_62c973987e.webp)\n\nДалее, мы подробно опишем условия входа в задание: расскажем, будет ли обучение и экзамен, с каким качеством его нужно пройти, есть ли в проекте повторный экзамен для тех, кто не прошел испытание с первого раза. Также опишем ценообразование. Например:\n\n<p style=\"padding: 0 50px;\"><i>\n    Чтобы выполнить это задание, вам потребуется пройти обучение на тренировочном пуле. В тренировочный пул войдут задания аналогичные тем, что будут в основном проекте. После обучения мы предложим вам пройти экзамен. В экзамен войдут 5 изображений.</i></p>\n\nСледующий элемент инструкции — технические нюансы. Здесь мы расскажем, с какого устройства потребуется выполнить задание — со смартфона или с компьютера — и какие дополнительные настройки браузера будут необходимы. Этот пункт в особенности важен для второго задания в рамках нашего проекта. Разметить дорожные знаки прямоугольниками участники смогут только с компьютера:\n\n<p style=\"padding: 0 50px;\"><i>\n    Мы рекомендуем выполнять это задание с персонального компьютера. Это необходимо, чтобы вы смогли корректно выделить все необходимые объекты на изображении.</i></p>\n\nКраткое описание интерфейса задания — еще один важный пункт в инструкции. Для большей наглядности мы сделаем скриншот с комментариями о том, для чего нужны те или иные блоки и кнопки. Если в задании простой интерфейс, эту часть можно пропустить. Например:\n\n<p style=\"padding: 0 50px;\"><i>\n    Используйте желтый квадрат («полигон») в левой части экрана, чтобы выделять дорожные знаки на изображении.</i></p>\n\nТеперь о самом задании. Чтобы избежать ошибок, мы пошагово опишем все частые сценарии, которые могут случиться при выполнении наших задач. Также мы укажем, что делать с нестандартными случаями. Добавим примеры: несколько кейсов сделают теорию намного понятнее. Справочные материалы — глоссарий, faq — важное дополнение к этим сценариям. Наконец, мы расскажем, куда направлять вопросы по заданию или проекту в целом.\n\nНа что мы обратим внимание при написании текста?\n\nПервое, за чем стоит проследить — сам язык, которым написана инструкция. Мы откажемся от профессионального сленга и не будем использовать терминологию. Некоторые термины, например, «полигоны», мы объясним или заменим синонимами — «прямоугольники». Наша задача — сделать инструкцию простой и понятной для большого числа участников. Следуя этой же задаче, мы упростим стиль и синтаксис (одна мысль = одно предложение; одна тема = один абзац), не будем использовать пояснения в скобках и сделаем форматирование единообразным.\n\nГотовый текст инструкции мы обязательно проверим, выполнив некоторое количество заданий. Такое упражнение быстро покажет, какие случаи еще не описаны в инструкции, а какие описаны мало. Кроме того, оно позволит проверить как выглядит наше задание на разных устройствах: умещаются ли все картинки и скриншоты на экранах мобильного телефона, планшета и компьютера.\n\nВ итоге каждая инструкция не займет больше двух экранов. Это максимальное количество пространства для инструкции, за пределы которого лучше не выходить. Если инструкция все же не вписывается в такой объем, вероятно, задача слишком многосоставная и ее нужно декомпозировать.\n\n## Агрегация результатов\n\nПредставим, что мы запустили наш проект и получили необходимые данные. В краудсорсинговых проектах данные обычно собираются в перекрытии (мнения большинства) — это один из распространенных механизмов контроля качества исполнителей и улучшения качества итогового набора данных. Но как выбрать из нескольких оценок финальную?\n\nВ данном случае нам помогут механизмы агрегации данных. Что они делают? Они обрабатывают файлы с ответами исполнителей и выбирают из нескольких ответов тот, который с наибольшей вероятностью окажется верным. Рассмотрим принцип работы механизмов агрегации данных на примере первого пула с заданиями (см. рис. 4).\n\nУ нас есть набор изображений, и наша цель — отнести каждое изображение к группе «изображения с дорожными знаками» или к группе «изображения без дорожных знаков». В соответствии с принципом краудсорсинга задание должно быть распределено между несколькими исполнителями, каждый из которых размечает некое подмножество изображений. В результате для каждого изображения у нас есть несколько результатов разметки. Цель метода агрегации — объединить эти результаты в один качественный ответ.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_9_988c50db8c_57b0a666f3.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Агрегация данных, полученных с помощью краудсорсинга\n  </figcaption>\n</figure>\n\n### Мнение большинства\n\nАлгоритм агрегации данных «Мнение большинства» основан на предположении, что правильный ответ — этот тот, который выбирают большинство исполнителей (рис. 5). Самый популярный ответ становится финальным ответом.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_10_b7ecea26b9_72e8ca5e09.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Агрегация данных по методу, основанному на мнении большинства\n  </figcaption>\n</figure>\n\nПрактика показывает, что при помощи метода, основанного на мнении большинства, можно получить достойные результаты. Поэтому этот метод с успехом применяется во многих проектах. Также одно из преимуществ этого метода заключается в том, что он весьма нагляден и логика его работы понятна. Однако в проектах краудсорсинга существуют определенные временные и бюджетные ограничения. Наша цель в том, чтобы собрать минимальный объем данных, необходимый для достижения желаемой точности. С этой точки зрения, метод, основанный на мнении большинства, далеко не всегда будет оптимальным выбором. Чтобы осознать слабые стороны метода, рассмотрим его модель.\n\n#### Модель\n\nМодель, лежащая в основе метода, проста. Есть N изображений и M исполнителей. Каждое изображение $j \\in {1, ..., N}$ подразумевает некий неизвестный ответ («изображения с дорожными знаками» или «изображения без дорожных знаков» в нашем случае). При использовании модели, основанной на мнении большинства, предполагается, что если исполнитель $i$ разметил изображение $j$, его ответ является правильным с некоторой вероятностью $p > \\frac{1}{2}$\n\n$$P(Исполнитель\\,i\\,отвечает\\,на\\,вопрос\\,j\\,верно) = p\n$$\n\nПри этом вероятность правильного ответа полагается одинаковой для каждого исполнителя и вопроса. Допущение, что $p > 1/2$ учитывает, что для каждого исполнителя вероятность правильного ответа выше, чем неправильного. В таком случае, поскольку число разметок для каждого изображения достаточно велико, мнение большинства с высокой вероятностью даст истинные ответы.\n\n#### Ограничения\n\nВ силу своей простоты, метод основанный на мнении большинства имеет ряд ограничений:\n\n<ul>\n    <li>**Однородность исполнителей.**Во-первых, данный метод предполагает, что все исполнители обладают одинаковыми способностями. Иными словами,<i>для каждого конкретного вопроса вероятность того, что исполнитель правильно ответит на вопрос, одинакова для всех исполнителей.</i> Однако на практике пул исполнителей на краудсорсинговых платформах чрезвычайно разнообразен: кто-то из них очень аккуратно и скрупулезно выполняет задачи, а кто-то небрежен и чаще допускает ошибки. Таким образом, одно из направлений совершенствования модели, основанной на мнении большинства, — это учет различия в способностях исполнителей в рамках модели.</li>\n    <li>**Однородность вопросов.**Во-вторых, модель, основанная на мнении большинства, предполагает, что вопросы имеют одинаковую сложность. Другими словами, <i>вероятность того, что исполнитель правильно ответит на вопрос, одинакова для всех вопросов.</i> Однако некоторые вопросы в рамках проекта могут быть сложнее других. Таким образом, еще одно направление по улучшению модели на основании мнения большинства — это учесть в модели разную степень сложности вопросов.</li>\n</ul>\n\nДалее мы рассмотрим оба направления развития модели и расскажем о других алгоритмах, учитывающих особенности краудсорсинговых заданий.\n\n### Агрегация с учетом способностей исполнителей\n\nРассмотрим модель, которая учитывает неоднородность исполнителей при агрегации ответов.\n\n#### Модель\n\nЕстественный способ учесть различия в способностях исполнителей — ввести параметр качества для каждого исполнителя. Если есть $M$ исполнителей, то мы можем связать каждого исполнителя $i \\in {1, ..., M}$ с неизвестным параметром качества $p_i \\in [0, 1]$. Чем выше параметр качества исполнителя, тем больше вероятность того, что исполнитель ответит на вопрос правильно:\n\n$$P(Исполнитель\\,i\\,отвечает\\,на\\,вопрос\\,j\\,верно) = p_i\n$$\n\nДругими словами, вероятность того, что исполнитель правильно ответит на вопрос, своя для каждого исполнителя (но от вопроса она все еще не зависит).\n\n#### Методы\n\nВ ситуации, когда у исполнителей разные способности, логично присваивать больший вес ответам более сильных исполнителей и меньший вес — ответам более слабых. Однако проблема в том, что параметры качества для исполнителей априори нам не известны. Основная идея двух методов модели агрегации данных с учетом способностей исполнителей заключается том, чтобы одновременно оценить параметры качества для исполнителей и ответы на поставленные вопросы. Рассмотрим каждый их них.\n\n#### Использование большого объема контрольных заданий\n\nКонтрольные вопросы (также <i>honeypots</i>, <i>golden sets</i>) — это задания, на которые заказчик заранее знает правильные ответы. На практике мы часто добавляем в набор данных определенное количество контрольных вопросов, чтобы контролировать качество работы исполнителей. Когда этих вопросов достаточно много, мы можем использовать их для оценки качества работы. Предположим, что у нас есть $G$ контрольных вопросов и некий исполнитель $i$, который правильно ответил на $k_i$ вопросов из $G$ контрольных вопросов. Тогда мы можем оценить параметр качества для исполнителя следующим образом:\n\n$$\\hat{p_i} = \\frac{k_i}{G}\n$$\n\nТеперь, когда у нас есть оценка параметра качества, мы можем оценить ответ каждого исполнителя по-разному. Эта идея подводит нас к концепции взвешенного мнения большинства (от англ. <i>Weighted majority vote</i>).\n\nИдея этого метода проиллюстрирована на рисунке ниже (рис. 6). Предположим, что у нас есть нестандартное изображение, на котором столб похож на дорожный знак. В этом случае модель, основанная на простом мнении большинства, не делает отличия между ответами исполнителей с меньшими способностями (первых двух исполнителей) и ответами исполнителя-эксперта (последнего исполнителя) и допускает ошибку. Напротив, модель взвешенного мнения большинства дополнительно взвешивает каждый ответ полученным коэффициентом качества исполнителя. Такая модель приводит к правильному ответу, поскольку мнение исполнителя-эксперта в таком случае перевешивает мнения двух других исполнителей.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_11_9e711249e4_63a4e528be.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Агрегация данных по методу, основанному на взвешенном мнении большинства\n  </figcaption>\n</figure>\n\n### Когда контрольных вопросов не так много\n\nМетод взвешенного мнения большинства подходит для тех случаев, когда в проекте есть достаточное количество контрольных заданий, необходимых для оценки качества работы исполнителя. Однако зачастую контрольных заданий в проекте не хватает, в связи с чем оценки могут быть довольно неточными. Кроме того, исполнители могут коллективно выявить контрольные вопросы и начать обманывать систему, давая правильные ответы на контрольные вопросы и случайные ответы на другие. В этом случае, чтобы оценить параметры качества исполнителей при ответе на неизвестные вопросы, мы можем использовать метод Дэвида — Скина:\n\n### Метод Дэвида-Скина (Dawid, Skene, 1979)\n\n**Метод Дэвида-Скина** одновременно находит значения качества исполнителей и ответы на вопросы, которые согласуются с наблюдаемыми данными в наибольшей степени.\nМы имеем в качестве данных $n_{ik}^u$ — количество раз, при которых разметчик $u \\in U$ поставил класс $k \\in K$ объекту $i \\in I$ (возможно, разметчик видел этот объект несколько раз). Обозначим через\n\n$$Y_{ik} = I\\{\\text{объект } i \\text{ класса } k\\},\n$$\n\nэто наши латентные величины.\n\nВ качестве параметров имеем\n\n* $\\pi_{k\\ell}^u$ — вероятность того, что разметчик $u$ поставил класс $\\ell$ вместо правильного класса $k$.\n* $\\rho_k$ — вероятность класса $k$.\n\nПримем также обозначения:\n\n* $N_i = \\{n^u_{ik}\\text{ по всем } u \\text{ и } k \\text{ для объекта } i \\}$,\n* $N_i ^ u = \\{n^u_{ik} \\text{ для разметчика } u \\text{ и объекта i}\\}$,\n* $Y_i = \\{Y_{ik} \\text{ по всем } k \\text{ для объекта } i\\}$.\n\nПоймём, какой будет функция неполного правдоподобия в этой задаче. Прежде всего,\n\n$$p_{\\pi,p}(N, Y) = \\prod_{i\\in I}p(N_i, Y_i),\n$$\n\nЕсли $k$ – номер класса $i$-го объекта, то\n\n$$p(N_i, Y_i)=\\underbrace{p(\\text{объект $i$ класса $k$})}_{=\\rho_k}p(N_i\\mid\\text{объект $i$ класса $k$})\n$$\n\n(значения $Y_{it}$ однозначно определяются номером истинного класса, поэтому справа $Y_i$ пропадает). Далее, мы считаем, что разметчики действуют независимо, поэтому\n\n$$p(N_i\\mid\\text{объект $i$ класса $k$}) = \\prod_{u\\in U}p(N_i^u\\mid\\text{объект $i$ класса $k$}).\n$$\n\nРазберёмся с величиной \\$p(N_i\\^u\\\\mid\\\\text\\{объект $i$ класса $k$\\})\\$. Она отвечает за то, какие классы $u$-й разметчик ставил $i$-му объекту. Мы считаем, что встречи разметчика с объектом упорядочены по времени, тогда\n\n$$p(\\text{$u$-й разметчик отнёс $i$-й объект к классам $k'_1,\\ldots,k'_r$}\\mid\\text{объект $i$ класса $k$}) =\n$$\n\n$$\\begin{matrix}=\\prod_{s}p(\\text{в $s$-ю встречу с $i$-м объектом $u$-й разметчик отнёс его к классу $k'_s$}\\mid \\\\ \\text{объект $i$ класса $k$})\\end{matrix}\n$$\n\nЭту вероятность можно переписать в виде\n\n$$\\prod_{\\ell \\in K} \\left( \\pi_{k\\ell}^u \\right)^{n_{i\\ell}^u},\n$$\n\nа итоговое неполное правдоподобие предстаёт в виде\n\n$$p_{\\pi,p}(N, Y) = \\prod_{i\\in I}\\prod_{k \\in K} \\left( \\rho_k \\prod_{u\\in U} \\prod_{\\ell \\in K} \\left( \\pi_{k\\ell}^u \\right)^{n_{i\\ell}^u} \\right)^{Y_{ik}}\n$$\n\nЕго нам нужно максимизировать по $\\pi$ и $\\rho$\n\n**Пояснение к формуле:**\n\nВне больших скобок фиксируются объект и его класс, сама скобка возводится в степень 1, если рассматривается правильный класс объекта, и в степень 0 иначе. Внутри сначала записана вероятность того, что объект имеет данный класс, а затем — перебор по всем пользователям и всем классам, которые мог поставить данный пользователь. Наконец, записывается вероятность того, что пользователь нашему объекту поставил некоторый класс, которая возводится в степень того, сколько раз он поставил этот класс. Например, если пользователь видел изображение котика 5 раз, при этом 3 раза он сказал, что котик, а два раза — песик, то вероятность $\\pi_{cat,cat}^u$ для данного котика учтется 3 раза, а вероятность $\\pi_{cat,dog}^u$ — 2 раза.\n\nРассмотрим концепцию метода Дэвида-Скина на простом примере (рис. 7).\nПредположим, что у нас есть только $N = 4$ вопросов и $M = 3$ исполнителей. Каждый исполнитель отвечает на все вопросы. В этом случае наблюдаемые данные — это ответы исполнителей на вопросы.\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_12_47efa2f8ab_77489f4daf.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Агрегация данных по методу Дэвида-Скина\n  </figcaption>\n</figure>\n\nДавайте разберемся в том, каким образом метод Дэвида — Скина позволяет найти параметры качества для исполнителей и те ответы на вопросы, которые лучше всего соответствуют наблюдаемым данным. Для этого рассмотрим два варианта, показанные на картинках ниже (см. рис. 7.1). Каждая картинка предполагает свой набор параметров. Посмотрим, какой из предложенных вариантов лучше соответствует наблюдаемым данным.\n\n![Picture](https://yastatic.net/s3/education-portal/media/Picture_13_bdb5e67f0e_54cc7bdb1b.webp)\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/Picture_14_6506818225_b4c85e3412.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    Агрегация данных по методу Дэвида-Скина\n  </figcaption>\n</figure>\n\nВо-первых, обратите внимание, что на обоих изображениях предложенные ответы согласуются с ответами исполнителя, у которого, по оценкам, высокий параметр качества. Но какой выбор параметров подходит данным лучше всего? Чтобы ответить на этот вопрос, обратите внимание, что ответы второго и третьего исполнителей полностью совпадают. Если параметры качества для этих исполнителей соответствуют первой картинке $\\hat{p_2} = \\hat{p_3} = 0.5$, тогда, если верить этой модели, эти два исполнителя отвечают наугад. В таком случае высокая степень согласия между исполнителями нас бы скорее удивила, поскольку отвечая наугад, они должны время от времени расходиться в своих ответах. Напротив, если исполнители 2 и 3 — эксперты, как на втором изображении $\\hat{p_2} = \\hat{p_3} = 1$, тогда мы ожидаем, что у них будет высокая степень согласия, и это то, что мы видим в данных. Интуитивно, второй набор параметров лучше согласуется с наблюдаемыми данными. Приведенный простой пример показывает, что концепция согласованности между потенциальными параметрами и наблюдаемыми данными позволяет нам исключить те варианты, которые плохо согласуются с наблюдаемыми данными.\n\nОба метода — взвешенное мнение большинства и агрегация по методу Дэвида — Скина — входят в стандартный функционал Толоки. В двух наших пулах, в первом и третьем, мы будем использовать метод Дэвида — Скина. Он позволит нам получить наиболее точные данные для нашего проекта. Подробнее узнать о том, как получить агрегированные результаты из размеченного пула, можно в [документации](https://yandex.ru/support/toloka-requester/concepts/result-aggregation.html?lang=ru).\n\n### Агрегация с учетом сложности вопросов\n\nМетод Дэвида-Скина и метод, основанный на мнении взвешенного большинства, — основа современного краудсорсинга. Многие создатели проектов повышают качество данных, используя эти методы агрегации. Однако существуют и другие современные подходы. Например, есть группа подходов, которые учитывают сложность вопроса при агрегировании ответов.\n\n### Параметрический подход\n\nАналогично тому, как мы замеряли качество для каждого исполнителя, вводя параметр качества $p_i$, точно так же для каждого исполнителя мы можем ввести параметр сложности $d_j$ для каждого вопроса. Тем не менее, главная проблема заключается в том, как описать взаимодействие между качеством исполнителя и сложностью вопроса, и в результате рассчитать вероятность того, что конкретный исполнитель правильно ответит на выбранный вопрос. В работе Уайтхилла с соавторами (2009) предлагается следующее решение.\n\n1. Во-первых, параметр качества для исполнителя, который раньше мерился в диапазоне $[0, 1]$, теперь задается в интервале $(-\\infty, \\infty)$. В частности, возможно нулевое качество $p = 0$, которое соответствует ситуации, когда исполнитель отвечает на все вопросы наугад. Положительные значения качества подразумевают, что работник с большей вероятностью даст правильный ответ, а отрицательные значения означают, что исполнитель настроен враждебно и с большей вероятностью даст неправильный ответ.\n2. Во-вторых, для параметра сложности каждого вопроса $d \\in (0, \\infty)$ также может быть дана интуитивная интерпретация: низкая сложность вопроса $(d \\approx 0)$ означает что вопрос настолько прост, что любой исполнитель ответит на него правильно с вероятностью, близкой к 1. Чем выше уровень сложности, тем меньше вероятность того, что конкретный исполнитель ответит на вопрос правильно.\n\nОбъединив эти параметры, модель предполагает, что вероятность для конкретного исполнителя $i$ при ответе на конкретный вопрос $j$ может быть корректно описана следующим параметрическим выражением:\n\n$$P(Исполнитель\\,i\\,отвечает\\,на\\,вопрос\\,j\\,верно) = \\frac{1}{\\exp{\\left(-\\frac{p_i}{d_j}\\right)}}\n$$\n\nСледует заметить, что в таком случае вероятность является функцией и самого исполнителя, и вопроса, на который исполнитель отвечает. Как только мы выбрали параметрическое уравнение для описания взаимосвязи между уровнем качества исполнителя и сложностью вопроса, с одной стороны, и вероятностью правильного ответа, с другой, мы можем применять все те же принципы, что и для расчета параметров по модели Дэвида – Скина. Таким образом мы можем оценить не только параметры модели, но и полученные ответы на вопросы. Более подробно об этом можно почитать в [статье](https://arxiv.org/pdf/1602.03481.pdf).\n\nНесмотря на то, что параметрические модели позволяют делать весьма эффективные выводы, в них неизбежно заложены сильные допущения о когнитивных процессах, присущих исполнителям при ответе на вопросы. Эти допущения обычно невозможно проверить, поэтому неясно, насколько хорошо они согласуются с реальностью. Соответственно, если допущения параметрической модели неверны, то и методы, используемые такой моделью, могут дать неожиданные результаты. Это подводит нас к идее непараметрического подхода, где можно попробовать избежать сильных допущений о мыслительных процессах.\n\n### Непараметрический подход\n\nНепараметрический подход предложил Нихар Б. Шах с коллегами в 2016 году. Вместо моделирования вероятностей, что исполнитель $i$ верно ответит на вопрос $j$, считается, что между этими вероятностями есть взаимосвязь. При этом модель использует два ключевых допущения:\n\n1. Во-первых, предполагается, что исполнителей можно выстроить в ряд в порядке возрастания способностей. Если исполнитель $i_1$ занимает в этом ряду более высокую позицию, чем исполнитель $i_2$, то при ответе на каждый вопрос исполнитель $i_1$ с большей вероятностью даст правильный ответ, чем исполнитель $i_2$.\n2. Во-вторых, предполагается, что вопросы можно выстроить в&nbsp;ряд в&nbsp;зависимости от&nbsp;их&nbsp;сложности. Если вопрос $j_1$ сложнее вопроса $j_2$, то&nbsp;любой исполнитель совершит ошибку при ответе на&nbsp;вопрос $j_1$ с&nbsp;не&nbsp;меньшей вероятностью, что и&nbsp;отвечая на&nbsp;вопрос $j_2$.\n\nСтоит заметить, что эти допущения гораздо слабее, чем в параметрической модели. В самом деле, параметрическая модель не только предполагает существование таких упорядоченных рядов, но и задает все вероятности. С другой стороны, непараметрический подход делает всего лишь естественное предположение о существовании последовательных рядов, но не ограничивает набор когнитивных механизмов, характерных для исполнителей. Было показано, что в некоторых случаях непараметрическая модель позволяет лучше делать выводы. Более подробно об этом можно почитать в [полном тексте статьи](https://arxiv.org/pdf/1606.09632.pdf).\n\nКак мы уже говорили, эти подходы еще достаточно новые и не успели стать классикой краудсорсинга. Если сложность вопросов в вашем проекте существенно варьируется, мы рекомендуем более основательно изучить упомянутые методы и лежащие в их основе допущения, а затем опробовать их на практике.\n\n**Использованная литература**\n\n<ol>\n    <li>Jeff Howe, <a href='https://www.wired.com/2006/06/crowds/?pg=1&topic=crowds&topic_set='>The Rise of Crowdsourcing</a>, The Wired, 2006.</li>\n    <li>Джефф Хау, Краудсорсинг: Коллективный разум как инструмент развития бизнеса, Альпина Паблишер, 2012.</li>\n    <li>Omar Alonso, The Practice of Crowdsourcing, 2019.</li>\n    <li><a href='https://theoryandpractice.ru/posts/5001-camaya-bogataya-chast-planety-rabotaet-besplatno-vo-vremya-pereryvov-na-kofe-redaktor-wired-dzheff-khau-o-kraudsorsinge'>«Cамая богатая часть планеты работает бесплатно во время перерывов на кофе»: редактор Wired Джефф Хау о краудсорсинге</a>, T&P, 2012.</li>\n    <li>Р. А. Долженко, А. В. Бакаленко, Краудсорсинг как инструмент мобилизации интеллектуальных ресурсов: опыт использования в Сбербанке России, Российский журнал менеджмента, Том 14, №3, 2016, С. 77–102.</li>\n    <li><a href='https://yandex.ru/company/services_news/2020/2020-01-14-1'>Беспилотные автомобили Яндекса на CES 2020: 7 тысяч км без водителя за рулём по улицам Лас-Вегаса</a>, Новости Яндекса, 2020.</li>\n    <li><a href='https://www.jstor.org/stable/2346806?seq=1'>Метод Дэвида и Скина</a></li> \n</ol>\n",
        "handbook": "Учебник по машинному обучению",
        "title": "Краудсорсинг",
        "description": null
    },
    {
        "path": "/handbook/ml/article/bias-variance-decomposition",
        "content": "В данном параграфе мы изучим инструмент, который позволяет анализировать ошибку алгоритма в зависимости от некоторого набора факторов, влияющих на итоговое качество его работы. Этот инструмент в литературе называется **bias-variance decomposition** — разложение ошибки на смещение и разброс. В разложении, на самом деле, есть и третья компонента — случайный шум в данных, но ему не посчастливилось оказаться в названии. Данное разложение оказывается полезным в некоторых теоретических исследованиях работы моделей машинного обучения, в частности, при анализе свойств ансамблевых моделей.\n\nНекоторые картинки в тексте кликабельны. Это означает, что они были заимствованы из какого-то источника и при клике вы сможете перейти к этому источнику.\n\n## Вывод разложения bias-variance для MSE\n\nРассмотрим задачу регрессии с квадратичной функцией потерь. Представим также для простоты, что целевая переменная $y$ — одномерная и выражается через переменную $x$ как:\n\n$$\n    y = f(x) + \\varepsilon,\n$$\n\nгде $f$ — некоторая детерминированная функция, а $\\varepsilon$ — случайный шум со следующими свойствами:\n\n$$\n     \\mathbb{E} \\varepsilon = 0, \\, \\mathbb{V}\\text{ar} \\varepsilon = \\mathbb{E} \\varepsilon^2 = \\sigma^2.\n$$\n\nВ зависимости от природы данных, которые описывает эта зависимость, её представление в виде точной $f(x)$ и случайной $\\varepsilon$ может быть продиктовано тем, что: \n\n1) данные на самом деле имеют случайный характер;\n\n2) измерительный прибор не может зафиксировать целевую переменную абсолютно точно;\n\n3) имеющихся признаков недостаточно, чтобы исчерпывающим образом описать объект, пользователя или событие.\n\nФункция потерь на одном объекте $x$ равна\n\n$$\n    MSE = (y(x) - a(x))^2\n$$\n\nОднако знание значения MSE только на одном объекте не может дать нам общего понимания того, насколько хорошо работает наш алгоритм. Какие факторы мы бы хотели учесть при оценке качества алгоритма? Например, то, что выход алгоритма на объекте $x$ зависит не только от самого этого объекта, но и от выборки $X$, на которой алгоритм обучался:\n\n$$\n    X = ((x_1, y_1), \\ldots, (x_\\ell, y_\\ell))\n$$\n\n$$\n    a(x) = a(x, X)\n$$\n\nКроме того, значение $y$ на объекте $x$ зависит не только от $x$, но и от реализации шума в этой точке:\n\n$$\n    y(x) = y(x, \\varepsilon)\n$$\n\nНаконец, измерять качество мы бы хотели на тестовых объектах $x$ — тех, которые не встречались в обучающей выборке, а тестовых объектов у нас в большинстве случаев более одного. При включении всех вышеперечисленных источников случайности в рассмотрение логичной оценкой качества алгоритма $a$ кажется следующая величина:\n\n$$\n    Q(a) = \\mathbb{E}_x \\mathbb{E}_{X, \\varepsilon} [y(x, \\varepsilon) - a(x, X)]^2\n$$\n\nВнутреннее матожидание позволяет оценить качество работы алгоритма в одной тестовой точке $x$ в зависимости от всевозможных реализаций $X$ и $\\varepsilon$, а внешнее матожидание усредняет это качество по всем тестовым точкам. \n\n**Замечание.** Запись $\\mathbb{E}_{X, \\varepsilon}$ в общем случае обозначает взятие матожидания по совместному распределению $X$ и $\\varepsilon$. Однако, поскольку $X$ и $\\varepsilon$ независимы, она равносильна последовательному взятию матожиданий по каждой из переменных: $\\mathbb{E}_{X, \\varepsilon} = \\mathbb{E}_{X} \\mathbb{E}_{\\varepsilon}$, но последний вариант выглядит несколько более громоздко.\n\nПопробуем представить выражение для $Q(a)$ в более удобном для анализа виде. Начнём с внутреннего матожидания:\n\n$$\n    \\mathbb{E}_{X, \\varepsilon} [y(x, \\varepsilon) - a(x, X)]^2 = \\mathbb{E}_{X, \\varepsilon}[f(x) + \\varepsilon - a(x, X)]^2 = \n$$\n\n$$\n    = \\mathbb{E}_{X, \\varepsilon} [ \\underbrace{(f(x) - a(x, X))^2}_{\\text{не зависит от $\\varepsilon$}} + \n       \\underbrace{2 \\varepsilon \\cdot (f(x) - a(x, X))}_{\\text{множители независимы}} + \\varepsilon^2 ] = \n$$\n\n$$\n    = \\mathbb{E}_X \\left[\n        (f(x) - a(x, X))^2\n    \\right] + 2 \\underbrace{\\mathbb{E}_\\varepsilon[\\varepsilon]}_{=0} \\cdot \\mathbb{E}_X (f(x) - a(x, X)) + \\mathbb{E}_\\varepsilon \\varepsilon^2 =\n$$\n\n$$\n    = \\mathbb{E}_X \\left[ (f(x) - a(x, X))^2 \\right] + \\sigma^2\n$$\n\nИз общего выражения для $Q(a)$ выделилась шумовая компонента $\\sigma^2$. Продолжим преобразования:\n\n$$\n    \\mathbb{E}_X \\left[ (f(x) - a(x, X))^2 \\right] = \\mathbb{E}_X \\left[\n        (f(x) - \\mathbb{E}_X[a(x, X)] + \\mathbb{E}_X[a(x, X)] - a(x, X))^2 \n    \\right] = \n$$\n\n$$\n    = \\mathbb{E}_X\\underbrace{\\left[ \n        (f(x) - \\mathbb{E}_X[a(x, X)])^2 \n    \\right]}_{\\text{не зависит от $X$}} + \\underbrace{\\mathbb{E}_X \\left[ (a(x, X) - \\mathbb{E}_X[a(x, X)])^2 \\right]}_{\\text{$=\\mathbb{V}\\text{ar}_X[a(x, X)]$}} + \n$$\n\n$$\n    + 2 \\mathbb{E}_X[\\underbrace{(f(x) - \\mathbb{E}_X[a(x, X)])}_{\\text{не зависит от $X$}} \\cdot (\\mathbb{E}_X[a(x, X)] - a(x, X))] = \n$$\n\n$$\n    = (\\underbrace{f(x) - \\mathbb{E}_X[a(x, X)]}_{\\text{bias}_X a(x, X)})^2 + \\mathbb{V}\\text{ar}_X[a(x, X)] + 2 (f(x) - \\mathbb{E}_X[a(x, X)]) \\cdot \\underbrace{(\\mathbb{E}_X[a(x, X)] - \\mathbb{E}_X [a(x, X)])}_{=0} =\n$$\n\n$$\n    = \\text{bias}_X^2 a(x, X)+ \\mathbb{V}\\text{ar}_X[a(x, X)]\n$$\n\nТаким образом, итоговое выражение для $Q(a)$ примет вид\n\n$$\n    Q(a) = \\mathbb{E}_x \\mathbb{E}_{X, \\varepsilon} [y(x, \\varepsilon) - a(x, X)]^2 = \\mathbb{E}_x \\text{bias}_X^2 a(x, X) + \\mathbb{E}_x \\mathbb{V}\\text{ar}_X[a(x, X)] + \\sigma^2,\n$$\n\nгде\n\n$$\n    \\text{bias}_X a(x, X) = f(x) - \\mathbb{E}_X[a(x, X)]\n$$\n\n— **смещение** предсказания алгоритма в точке $x$, усреднённого по всем возможным обучающим выборкам, относительно истинной зависимости $f$;\n\n$$\n    \\mathbb{V}\\text{ar}_X[a(x, X)] = \\mathbb{E}_X \\left[ a(x, X) - \\mathbb{E}_X[a(x, X)] \\right]^2\n$$\n\n— **дисперсия (разброс)** предсказаний алгоритма в зависимости от обучающей выборки $X$;\n\n$$\n    \\sigma^2 = \\mathbb{E}_x \\mathbb{E}_\\varepsilon[y(x, \\varepsilon) - f(x)]^2\n$$\n\n— неустранимый **шум** в данных.\n\nСмещение показывает, насколько хорошо с помощью данного алгоритма можно приблизить истинную зависимость $f$, а разброс характеризует чувствительность алгоритма к изменениям в обучающей выборке. Например, деревья маленькой глубины будут в большинстве случаев иметь высокое смещение и низкий разброс предсказаний, так как они не могут слишком хорошо запомнить обучающую выборку. А глубокие деревья, наоборот, могут безошибочно выучить обучающую выборку и потому будут иметь высокий разброс в зависимости от выборки, однако их предсказания в среднем будут точнее. На рисунке ниже приведены возможные случаи сочетания смещения и разброса для разных моделей:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/20_1_1d2027dbc2_589b8146f1.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://scott.fortmann-roe.com/docs/BiasVariance.html\">Источник</a>\n  </figcaption>\n</figure>\n\nСиняя точка соответствует модели, обученной на некоторой обучающей выборке, а всего синих точек столько, сколько было обучающих выборок. Красный круг в центре области представляет ближайшую окрестность целевого значения. Большое смещение соответствует тому, что модели в среднем не попадают в цель, а при большом разбросе модели могут как делать точные предсказания, так и довольно сильно ошибаться.\n\nПолученное нами разложение ошибки на три компоненты верно только для квадратичной функции потерь. Для других функций потерь существуют более общие формы этого разложения ([Domigos, 2000](https://www.researchgate.net/publication/221345426_A_Unifeid_Bias-Variance_Decomposition_and_its_Applications), [James, 2003](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=193A2D240404AB056822F188BAB09F94?doi=10.1.1.95.4138&rep=rep1&type=pdf)) с похожими по смыслу компонентами. Это позволяет предполагать, что для большинства основных функций потерь имеется некоторое представление в виде смещения, разброса и шума (хоть и, возможно, не в столь простой аддитивной форме).\n\n### Пример расчёта оценок bias и variance\n\nПопробуем вычислить разложение на смещение и разброс на каком-нибудь практическом примере. Наши обучающие и тестовые примеры будут состоять из зашумлённых значений целевой функции $f(x)$, где $f(x)$ определяется как\n\n$$\n    f(x) = x \\sin x\n$$\n\nВ качестве шума добавляется нормальный шум с нулевым средним и дисперсией $\\sigma^2$, равной во всех дальнейших примерах 9. Такое большое значение шума задано для того, чтобы задача была достаточно сложной для классификатора, который будет на этих данных учиться и тестироваться. Пример семпла из таких данных:\n\n![20_2_141d5e1768.webp](https://yastatic.net/s3/education-portal/media/20_2_141d5e1768_b27b188f9d.webp)\n\nПосмотрим на то, как предсказания деревьев зависят от обучающих подмножеств и максимальной глубины дерева. На рисунке ниже изображены предсказания деревьев разной глубины, обученных на трёх независимых подвыборках размера 20 (каждая колонка соответствует одному подмножеству):\n\n![20_3_2d4e194d90.webp](https://yastatic.net/s3/education-portal/media/20_3_2d4e194d90_98a6743fb5.webp)\n\nГлядя на эти рисунки, можно выдвинуть гипотезу о том, что с увеличением глубины дерева смещение алгоритма падает, а разброс в зависимости от выборки растёт. Проверим, так ли это, вычислив компоненты разложения для деревьев со значениями глубины от 1 до 15. \n\nДля обучения деревьев насемплируем 1000 случайных подмножеств $X_{train} = (x_{train}, y_{train})$ размера 500, а для тестирования зафиксируем случайное тестовое подмножество точек $x_{test}$ также размера 500. Чтобы вычислить матожидание по $\\varepsilon$, нам нужно несколько экземпляров шума $\\varepsilon$ для тестовых лейблов: \n\n$$\n    y_{test} = y(x_{test}, \\hat \\varepsilon) = f(x_{test}) + \\hat \\varepsilon\n$$\n\nПоложим количество семплов случайного шума равным 300. Для фиксированных $X_{train} = (x_{train}, y_{train})$ и $X_{test} = (x_{test}, y_{test})$ квадратичная ошибка вычисляется как\n\n$$\n    MSE = (y_{test} - a(x_{test}, X_{train}))^2\n$$\n\nВзяв среднее от $MSE$ по $X_{train}$, $x_{test}$ и $\\varepsilon$, мы получим оценку для $Q(a)$, а оценки для компонент ошибки мы можем вычислить по ранее выведенным формулам. \n\nНа графике ниже изображены компоненты ошибки и она сама в зависимости от глубины дерева:\n\n![20_4_e63b7825cc.webp](https://yastatic.net/s3/education-portal/media/20_4_e63b7825cc_10f788ced7.webp)\n\nПо графику видно, что гипотеза о падении смещения и росте разброса при увеличении глубины подтверждается для рассматриваемого отрезка возможных значений глубины дерева. Правда, если нарисовать график до глубины 25, можно увидеть, что разброс становится равен дисперсии случайного шума. То есть деревья слишком большой глубины начинают идеально подстраиваться под зашумлённую обучающую выборку и теряют способность к обобщению:\n\n![20_5_4a62f68894.webp](https://yastatic.net/s3/education-portal/media/20_5_4a62f68894_18c97c4dd9.webp)\n\nКод для подсчёта разложения на смещение и разброс, а также код отрисовки картинок можно найти в данном [ноутбуке](https://github.com/yandexdataschool/ML-Handbook-materials/blob/main/chapters/ensembles/bias_variance.ipynb).\n\n## Bias-variance trade-off: в каких ситуациях он применим\n\nВ книжках и различных интернет-ресурсах часто можно увидеть следующую картинку:\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/20_6_bc989ef14a_4b92bebba1.webp\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <a href=\"http://scott.fortmann-roe.com/docs/BiasVariance.html\">Источник</a>\n  </figcaption>\n</figure>\n\nОна иллюстрирует утверждение, которое в литературе называется **bias-variance trade-off**: чем выше сложность обучаемой модели, тем меньше её смещение и тем больше разброс, и поэтому общая ошибка на тестовой выборке имеет вид $U$-образной кривой. С падением смещения модель всё лучше запоминает обучающую выборку, поэтому слишком сложная модель будет иметь нулевую ошибку на тренировочных данных и большую ошибку на тесте. Этот график призван показать, что существует оптимальная сложность модели, при которой соблюдается баланс между переобучением и недообучением и ошибка при этом минимальна.\n\nСуществует достаточное количество подтверждений bias-variance trade-off для непараметрических моделей. Например, его можно наблюдать для метода $k$ ближайших соседей при росте $k$ и для ядерной регрессии при увеличении ширины окна $\\sigma$ [(Geman et al., 1992)](http://doursat.free.fr/docs/Geman_Bienenstock_Doursat_1992_bv_NeurComp.pdf):\n\n![20_7_e0e912a783.webp](https://yastatic.net/s3/education-portal/media/20_7_e0e912a783_6127767bd7.webp)\n\nЧем больше соседей учитывает $k$-NN, тем менее изменчивым становится его предсказание, и аналогично для ядерной регрессии, из-за чего сложность этих моделей в некотором смысле убывает с ростом $k$ и $\\sigma$. Поэтому традиционный график bias-variance trade-off здесь симметрично отражён по оси $x$.\n\nОднако, как показывают последние исследования, непременное возрастание разброса при убывании смещения не является абсолютно истинным предположением. Например, для нейронных сетей с ростом их сложности может происходить снижение и разброса, и смещения. Одна из наиболее известных статей на эту тему — статья [Белкина и др. (Belkin et al., 2019)](https://arxiv.org/pdf/1812.11118.pdf), в которой, в частности, была предложена следующая иллюстрация:\n\n![20_8_7351c6ce34.webp](https://yastatic.net/s3/education-portal/media/20_8_7351c6ce34_b6564b41f3.webp)\n\nСлева — классический bias-variance trade-off: убывающая часть кривой соответствует недообученной модели, а возрастающая — переобученной. А на правой картинке — график, называемый в статье **double descent risk curve**. На нём изображена эмпирически наблюдаемая авторами зависимость тестовой ошибки нейросетей от мощности множества входящих в них параметров ($\\mathcal H$). Этот график разделён на две части пунктирной линией, которую авторы называют interpolation threshold. Эта линия соответствует точке, в которой в нейросети стало достаточно параметров, чтобы без особых усилий почти идеально запомнить всю обучающую выборку. Часть до достижения interpolation threshold соответствует «классическому» режиму обучения моделей: когда у модели недостаточно параметров, чтобы сохранить обобщающую способность при почти полном запоминании обучающей выборки. А часть после достижения interpolation threshold соответствует «современным» возможностям обучения моделей с огромным числом параметров. На этой части графика ошибка монотонно убывает с ростом количества параметров у нейросети. Авторы также наблюдают похожее поведение и для «древесных» моделей: Random Forest и бустинга над решающими деревьями. Для них эффект проявляется при одновременном росте глубины и числа входящих в ансамбль деревьев.\n\nВ качестве вывода к этому разделу хочется сформулировать два основных тезиса:\n1. Bias-variance trade-off нельзя считать непреложной истиной, выполняющейся для всех моделей и обучающих данных.\n2. Разложение на смещение и разброс не влечёт немедленного выполнения bias-variance trade-off и остаётся верным и для случая, когда все компоненты ошибки (кроме неустранимого шума) убывают одновременно. Этот факт может оказаться незамеченным из-за того, что в учебных пособиях часто разговор о разложении дополняется иллюстрацией с $U$-образной кривой, благодаря чему в сознании эти два факта могут слиться в один.\n\n## Список литературы\n\n- [Блог-пост](https://link.medium.com/X5Cpg1WITjb) про bias-variance от \nЙоргоса Папахристудиса\n- [Блог-пост](http://scott.fortmann-roe.com/docs/BiasVariance.html) про bias-variance от Скотта Фортмана-Роу \n- Статьи от [Домингоса (2000)](https://www.researchgate.net/publication/221345426_A_Unifeid_Bias-Variance_Decomposition_and_its_Applications) и [Джеймса (2003)](http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=193A2D240404AB056822F188BAB09F94?doi=10.1.1.95.4138&rep=rep1&type=pdf) про обобщённые формы bias-variance decomposition\n- [Блог-пост](https://www.bradyneal.com/bias-variance-tradeoff-textbooks-update#double-descent) от Брейди Нила про необходимость пересмотра традиционного взгляда на bias-variance trade-off\n- [Статья](http://doursat.free.fr/docs/Geman_Bienenstock_Doursat_1992_bv_NeurComp.pdf) Гемана и др. (1992), в которой была впервые предложена концепция bias-variance trade-off\n- [Статья](https://arxiv.org/pdf/1812.11118.pdf) Белкина и др. (2019), в которой был предложен double-descent curve",
        "handbook": "Учебник по машинному обучению",
        "title": "Bias-variance decomposition",
        "description": "Классический взгляд на на то, почему слишком сложные модели переобучаются"
    },
    {
        "path": "/handbook/ml/article/teoriya-glubokogo-obucheniya-vvedenie",
        "content": "Центральной теоретической проблемой обучения с учителем является проблема обобщающей способности.\n\nВ самом деле, как можно гарантировать, что модель, обученная на некотором наборе данных, будет показывать хорошие результаты на данных, которых в обучении не было? Для классических моделей было доказано много содержательных результатов, которые, может быть, не давали ответы на все вопросы, но позволяли многое понять о работе моделей. Что же касается нейросетей, для них теория ещё только создаётся, и в этом разделе мы познакомим вас с рядом направлений развития этой науки.\n\nНейронная сеть фиксированной архитектуры реализует некоторый класс моделей $\\mathcal{F}$. Например, разные элементы этого класса могут соответствовать различным наборам весов. Когда такой класс фиксирован, мы обычно решаем задачу минимизации некоторой функции ошибки или, как чаще говорят в теории ML, задачу минимизации **эмпирического риска**\n\n$$\\hat R_m(f) = \\mathbb{E}_{x,y \\in S_m} r(y,f(x))$$ \n\nсреди моделей $f$ из класса $\\mathcal{F}$, где $S_m$ – обучающий датасет из $m$ примеров, выбранных независимо из распределения данных $\\mathcal{D}$, а $r(y,\\hat y)$ – функция риска, например, $\\mathbb{I}[y \\ne \\hat y]$.\n\nНаша цель, однако, минимизировать не эмпирический, а **истинный риск**, то есть\n\n$$R(f) = \\mathbb{E}_{x,y \\sim \\mathcal{D}} r(y,f(x)),$$\n\nгде математическое ожидание берётся по распределению данных, а не по выборке (математическое ожидание риска на всех мыслимых данных, не только на выборке). К сожалению, в рамках задачи обучения с учителем доступа к истинному распределению данных у нас нет, поэтому минимизировать истинный риск напрямую не удаётся, но мы можем попробовать его оценить. Часто для этого используют риск на валидации, но в этом разделе учебника мы постараемся получить теоретические оценки.\n\nПусть $\\hat f_m$ – модель из класса $\\mathcal{F}$, которую мы построили исходя из выборки $S_m$. Интересно оценить, насколько её истинный риск отличается от эмпирического, то есть оценить разность\n\n$$R(\\hat f_m) - \\hat R_m(\\hat f_m).$$\n\nВ случае нейронных сетей очень трудно предсказать, к какой именно модели $\\hat f_m$ сойдётся наш метод обучения (например, градиентный спуск) на данной выборке $S_m$. Тем не менее, разницу рисков всегда можно оценить сверху супремумом по всем моделям из класса:\n\n$$R(\\hat f_m) - \\hat R_m(\\hat f_m) \\leq \\sup_{f \\in \\mathcal{F}} (R(f) - \\hat R_m(f)).$$\n\nВ этом случае риск можно оценить сверху величиной\n\n$$\\tilde R := \\hat R_m + \\sup_{f \\in \\mathcal{F}} (R(f) - \\hat R_m(f)).$$\n\nТакие оценки называются **равномерными** (**uniform bounds**); мы рассмотрим их подробно в [соответствующем параграфе](https://academy.yandex.ru/handbook/ml/article/obobshayushaya-sposobnost-klassicheskaya-teoriya).\n\nПонятно, что подобная оценка становится бесполезной (vacuous), если в классе содержится модель, которая идеально работает на фиксированной выборке $S_m$ ($\\hat R_m(f) = 0$), но на какой-либо другой (потенциально тестовой) выборке из тех же данных работает плохо ($R(f)$ велик). Так, известно, что модели класса VGG способны выучить ImageNet даже с перемешанными метками классов (см. статью [Understanding deep learning requires rethinking generalization](http://arxiv.org/abs/1611.03530)). Понятно, что истинный риск у такой модели будет близок к риску случайного угадывания. «Плохую» модель можно построить следующим образом. Пусть $\\mathcal{A}$ – наш исходный алгоритм обучения, например, градиентный спуск. Он принимает на вход выборку и выдаёт обученную модель. Возьмём датасет, составленный из двух частей: \n\n* $S_m$ – это самая обычная выборка, в которой объекты насэмплированы из распределения $\\mathcal{D}$,\n\n* $\\tilde S_M$ – выборка, объекты которой сгенерированы из того же распределения, но метки перепутаны.\n\nРассмотрим модель $\\tilde f_{m,M} = \\mathcal{A}(S_m \\cup \\tilde S_M)$. Чем больше $M$ будет по сравнению с $m$, тем ближе будет построенная модель к случайному угадыванию. При этом, если суммарный размер двух выборок не слишком велик, то наша модель сможет запомнить их обе, в частности, $S_m$. Таким образом, эмпирический риск $\\hat R_m(\\tilde f_m)$ такой модели окажется мал, а истинный – велик.\n\nИнтуитивно понятно, что чем «сложнее» класс $\\mathcal{F}$, тем больше шансов найти в нём подобную модель. Одной из классических мер сложности класса моделей является **размерность Вапника-Червоненкиса**, или **VC-размерность**, предложенная в 1971 году в статье В. Н. Вапника и А. Я. Червоненкиса «О равномерной сходимости частот появления событий к их вероятностям». Она даёт следующую равномерную оценку:\n\n$$\\sup_{f \\in \\mathcal{F}} (R(f) - \\hat R_m(f)) \\leq O\\left(\\sqrt{\\frac{\\mathrm{VC}(\\mathcal{F})\\log{\\mathrm{VC}(\\mathcal{F})}}{m}}\\right).$$\n\nКак и следовало ожидать, правая часть растёт со сложностью модели и падает с размером выборки.\n    \nИзвестно, что для полносвязных сетей VC-размерность растёт как $\\Theta(n N)$, где $n$ – ширина сети (число нейронов в слое), а $N$ – общее число параметров; см. статью [Nearly-tight VC-dimension and Pseudodimension Bounds for Piecewise Linear Neural Networks](https://arxiv.org/pdf/1703.02930.pdf). Рассмотрим полносвязную сеть с одним скрытым слоем. Тогда общее число параметров сети пропорционально ширине, а значит, VC-размерность пропорциональна квадрату ширины. Соответствующая оценка на истинный риск принимает вид:\n\n$$\\tilde R(n) \\leq \\hat R_m(n) + \\frac{C n}{\\sqrt{m}},$$\n\nгде $C$ – константа из равномерной оценки разницы рисков с помощью VC-размерности, а $\\hat R_m(n)$ – эмпирический риск сети ширины $n$, обученной на данной выборке $S_m$.\n\nКак правило, эмпирический риск монотонно убывает с ростом ширины, пока не достигнет нуля (в самом деле, чем больше ширина, тем сложнее класс моделей и тем больше шансов обнаружить в нём модель, запоминающую фиксированную выборку). В результате $\\tilde R(n)$ может вести себя немонотонно: у этой величины может обнаружиться минимум строго левее точки, где $\\hat R_m(n)$ впервые достигает нуля: \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/risk_curve_classic_0e42fbd733_8fd79aecea.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Схематическое изображение изменения эмпирического риска $\\hat R_m$ (синяя кривая) и предсказанного риска $\\tilde R$ (красная кривая) в зависимости от ширины сети.</p>\n  </figcaption>\n</figure>\n\nПравее минимума предсказанный риск монотонно растёт. Но оказывается, что реальный истинный риск, напротив, убывает, выходя на асимптоту: \n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/risk_curve_cifar_2868f12199_cb902d8cae.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Зависимость эмпирического риска $\\hat R_m$ (бирюзовая кривая) и истинного риска $R$ (синяя кривая) для полносвязной сети с одним скрытым слоем, обученной на наборе данных CIFAR10, в зависимости от ширины сети; подробности см. в работе <a href='http://arxiv.org/abs/1412.6614'>B. Neyshabur, R. Tomioka, N. Srebro, In Search of the Real Inductive Bias: On the Role of Implicit Regularization in Deep Learning</a>.</p>\n  </figcaption>\n</figure>\n\n\nВозникает вопрос: если у истинного риска есть асимптота, то как ведут себя нейронные сети в пределе бесконечной ширины? Мы остановимся на этом вопросе в [соответствующем параграфе](https://academy.yandex.ru/handbook/ml/article/seti-beskonechnoj-shiriny).\n\nУпомянутый выше эксперимент с перемешиванием меток классов на части обучающей выборки можно рассматривать как модификацию не данных, а алгоритма обучения. А именно, давайте представим алгоритм, который, получая на вход выборку $S_m$, сделает с ней следующее:\n\n1. Каким-то образом делит её на две части: $S_m = S_{m_1}'\\cup S_{m_2}''$,\n2. Заменяет в $S_{m_2}''$ метки на случайные.\n3. Обучает модель на объединении $S_{m_1}'$ и «испорченной» $S_{m_2}''$.\n\nТакой «испорченный» алгоритм обучения приводит к модели, которая запоминает $S_{m_1}'$ и поэтому на исходной обучающей выборке $S_m$ работает не так уж и плохо. Но на тестовых данных он показывает качество, сравнимое со случайным угадыванием. Работающие на практике алгоритмы, например, градиентный спуск, тоже могут обучить модель, которая «запомнила» обучающую выборку. Тем не менее, на тестовой выборке обученная модель будет давать нормальное качество (см. опять же вторую картинку в начале параграфа). Возникает вопрос: почему так? Почему среди всех конфигураций весов, для которых риск на обучающей выборке равен нулю, градиентный спуск не выбирает те, для которых истинный риск сравним со случайным угадыванием? Явление, при котором среди всех эквивалентных по эмпирическому риску решений алгоритм выбирает определённые, называется **implicit bias**, и будет рассмотрен в [соответствующем параграфе](https://academy.yandex.ru/handbook/ml/article/implicit-bias).\n\nЕсли даже известно, какие конфигурации весов «предпочитает» наш алгоритм обучения, это никак не повлияет на равномерную оценку разницы рисков. В [параграфе про PAC-байесовские оценки](https://academy.yandex.ru/handbook/ml/article/pac-bajesovskie-ocenki-riska) будет рассмотрен класс оценок, которые позволяют учесть предпочтения алгоритма. А именно, пусть обученная модель случайна (это действительно так из-за случайности инициализации весов и, например, шума стохастического градиентного спуска), то есть алгоритм строит распределение на моделях – назовём его апостериорным распределением. Пусть дано другое распределение, не зависящее от выборки, назовём его априорным. Тогда роль сложности в наших оценках будет играть расстояние Кульбака-Лейблера (KL-дивергенция) между апостериорным и априорным распределениями на моделях. Если априорное распределение покрывает «предпочтительные» решения и не покрывает остальные, то KL-дивергенция мала и оценка разницы рисков невелика. Из-за внешней схожести некоторых величин, возникающих в этой теории, с объектами из байесовской статистики, такие оценки называется **PAC-байесовскими** (**PAC-bayesian bounds**, от **probably approximately correct**).\n\nВыше мы негласно предполагали, что используемый алгоритм обучения успешно решает задачу минимизации эмпирического риска. Для нейронных сетей наиболее популярный алгоритм – градиентный спуск или его разновидности. Если бы функция потерь была выпуклой как функция от весов сети, то это гарантировало бы сходимость в глобальный минимум. В общем случае теория оптимизации не даёт таких гарантий. Тем не менее, для сетей реалистичного размера градиентный спуск успешно сходится в глобальный минимум, что толкает нас на предположение о том, что все локальные минимумы таких сетей глобальны. Это предположение действительно можно доказать в некоторых частных случаях; см. [параграф про ландшафт функции потерь](https://academy.yandex.ru/handbook/ml/article/landshaft-funkcii-poter).\n\nВ качестве необходимого дополнения следует также гарантировать, что градиентный спуск (или его разновидности) не сходится в возможные седловые точки. При определённых условиях на минимизируемую функцию можно доказать, что для сходимости в седловую точку необходимо инициализировать функцию на множестве меры ноль. Более подробно вы можете почитать в работе [Gradient descent only converges to minimizers](https://arxiv.org/pdf/1602.04915.pdf) или в её обобщениях [Gradient Descent Only Converges to Minimizers: Non-Isolated Critical Points and Invariant Regions](https://arxiv.org/pdf/1605.00405v1.pdf) и [On the almost sure convergence of stochastic gradient descent in non-convex problems](https://arxiv.org/pdf/2006.11144.pdf).\n\nВпрочем, гарантии сходимости, как правило, формулируются для фиксированной архитектуры сети и ничего не говорят о скорости сходимости. Хотелось бы также иметь гарантии на то, что какой бы широкой или глубокой сеть не была, градиентный спуск сойдётся в минимум за разумное время. А для этого необходимо понимать, что на самом первом шаге градиентного спуска градиент не будет гаснуть или «взрываться» с ростом ширины или глубины. Известен ряд эвристик для инициализации весов, помогающих с этим бороться: например, инициализации Глоро (Xavier Glorot) и Хе (Kaiming He). Подробнее про них вы можете прочитать в параграфе про [тонкости обучения нейросетей](https://academy.yandex.ru/handbook/ml/article/tonkosti-obucheniya).",
        "handbook": "Учебник по машинному обучению",
        "title": "Введение в теорию глубокого обучения",
        "description": "Введение в теорию глубокого обучения"
    },
    {
        "path": "/handbook/ml/article/obobshayushaya-sposobnost-klassicheskaya-teoriya",
        "content": "Как мы уже видели во введении, мы не можем напрямую оптимизировать **истинный риск** модели $f(x)$\n\n$$R(f) = \\mathbb{E}_{x,y \\sim \\mathcal{D}} r(y,f(x)),$$\n\nтак как нам недоступно полное распределение данных $\\mathcal{D}$. Поэтому вместо задачи минимизации истинного риска, мы будем минимизировать **эмпирический риск**\n\n$$\\hat R_m(f) = \\mathbb{E}_{x,y \\in S_m} r(y, f(x))$$\n\nна доступном нам наборе данных $S_m$.\n\nКлассическая теория предлагает оценивать разность эмпирического и истинного равномерно, что даёт\n    \n$$R(\\hat f_m) \\leq \\hat R_m(\\hat f_m) + \\sup_{f \\in \\mathcal{F}} (R(f) - \\hat R_m(f)).$$\n\nТакая оценка не зависит от алгоритма обучения; она зависит лишь от класса моделей $\\mathcal{F}$, в котором происходит поиск. Так, в случае нейронных сетей в качестве класса $\\mathcal{F}$ можно взять класс всех нейронных сетей фиксированной архитектуры, отличающихся только весами.\n\nЕсли класс $\\mathcal{F}$ настолько велик, что для большинства наборов данных размера $m$ содержит модель $f$, у которой эмпирический риск мал, а истинный велик, то оценка выше теряет смысл. Работа <a href=\"http://arxiv.org/abs/1611.03530\">Understanding deep learning requires rethinking generalization</a> показала, что именно это и происходит в нейронных сетях, применяемых на практике, на реальных наборах данных. А именно, пусть $\\mathcal{A}$ – алгоритм, применяемый для обучения сети, например, градиентный спуск. Предположим, что с высокой вероятностью $\\hat R_m(\\mathcal{A}(S_m)) = 0$, если только размер выборки $m$ не слишком велик. Пусть $S_m$ – наша выборка, а $S'_{m'}$ – датасет, в котором примеры берутся из выборки, а разметка случайна. По предположению, модель $\\hat f_{m,m'} = \\mathcal{A}(S_m \\cup S'_{m'})$, обученная на объединённом датасете, имеет нулевой риск на «настоящем» датасете $S_m$, если только $m+m'$ не слишком велик. С другой стороны, если $m' \\gg m$, то $\\hat f_{m,m'} \\approx \\mathcal{A}(S'_{m'})$ – истинный риск такой модели близок к риску случайного угадывания.\n\nТем не менее, если в качестве $\\mathcal{F}$ взять не все модели, реализуемые данной архитектурой нейронной сети, а лишь реализуемые данным алгоритмом обучения на наборах данных из распределения с высокой вероятностью, то можно надеятся, что равномерная оценка окажется осмысленной.\n\nМы говорим «с высокой вероятностью» для того, чтобы исключить «нереалистичные» наборы данных, обучение на которых ведёт к плохим результатам, а также ничтожно-редкие случаи реализации шума в алгоритме обучения, при котором последний сходится в «плохие» решения. Подробнее о том, какие модели реализуются градиентным спуском, мы обсудим в параграфе про [implicit bias](https://academy.yandex.ru/handbook/ml/article/implicit-bias).\n\n## Оценка супремума\n\nПопробуем оценить супремум разницы рисков. Будем считать, что выборка $S_m$ выбирается случайным (и равновероятным) образом из распределения данных $\\mathcal{D}$. Некоторые из выборок могут быть катастрофически плохими, поэтому мы будем рассматривать оценки, которые верны не обязательно всегда, а просто с достаточно большой вероятностью.\n\nПредположим сначала, что класс моделей $\\mathcal{F}$ конечен. Тогда\n\n$$\\mathbb{P}\\left(\\sup_{f\\in\\mathcal{F}} (R(f) - \\hat R_m(f)) \\geq \\epsilon\\right) =$$\n\n$$= \\mathbb{P}(\\exists f\\in\\mathcal{F}: \\; (R(f) - \\hat R_m(f)) \\geq \\epsilon) \\leq$$\n\n$$\\leq\\sum_{f\\in\\mathcal{F}} \\mathbb{P}(R(f) - \\hat R_m(f) \\geq \\epsilon) \\leq$$\n\n$$\\leq\\vert\\mathcal{F}\\vert \\sup_{f\\in\\mathcal{F}} \\mathbb{P}(R(f) - \\hat R_m(f) \\geq \\epsilon)\n        \\quad\n        \\forall \\epsilon > 0$$\n\nЗаметим, что $R(f) = \\mathbb{E}_{S_m \\sim \\mathcal{D}^m} \\hat R_m(f)$. Поэтому при фиксированном $f$ разницу рисков $\\hat R_m(f) - R(f)$ можно оценить с помощью неравенства Хёффдинга.\n\n**Неравенство Хёффдинга (Hoeffding's inequality)**. Пусть $X_1,\\ldots,X_m$ – независимые одинаково распределённые случайные величины со значениями в $[0,1]$. Тогда для всех $\\epsilon > 0$ имеют место неравенства\n\n$$\\mathbb{P}\\left(\\sum_{i=1}^m X_i - \\mathbb{E} \\sum_{i=1}^m X_i \\geq \\epsilon \\right) \\leq\n            e^{-\\frac{2\\epsilon^2}{m}},$$\n\n$$\\mathbb{P}\\left(\\mathbb{E} \\sum_{i=1}^m X_i - \\sum_{i=1}^m X_i \\geq \\epsilon \\right) \\leq\n            e^{-\\frac{2\\epsilon^2}{m}}.$$\n\n\nКак следствие неравенства Хёффдинга, получаем, что для любого $\\epsilon > 0$ и для любой $f \\in \\mathcal{F}$.\n\n$$\n        \\mathbb{P}(R(f) - \\hat R_m(f) \\geq \\epsilon) \\leq\n        e^{-2 m \\epsilon^2}  \n$$\n\nЗаметим, что тогда для любой $f \\in \\mathcal{F}$,\n\n$$R(f) - \\hat R_m(f) \\leq\n        \\sqrt{\\frac{1}{2m} \\log \\frac{1}{\\delta}}\n        \\quad\n        \\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$.}\n$$\n\nНесмотря на то, что эта оценка является оценкой на обобщающую способность, она не имеет смысла, так как модель $f$ в ней задана априори и не зависит от $S_m$. Другими словами, она верна для необученных моделей $f$.\n\nВозвращаясь к нашей оценке, получаем:\n\n$$\n        \\mathbb{P}\\left(\\sup_{f\\in\\mathcal{F}} (R(f) - \\hat R_m(f)) \\geq \\epsilon\\right)\n        \\leq |\\mathcal{F}| e^{-2 m \\epsilon^2}\n        \\quad\n        \\forall \\epsilon > 0,\n$$\n\nгде $\\vert\\mathcal{F}\\vert$ – мощность класса $\\mathcal{F}$. Следовательно,\n\n$$\\color{#348FEA}{\\sup_{f\\in\\mathcal{F}} (R(f) - \\hat R_m(f)) \\leq\n        \\sqrt{\\frac{1}{2m} \\left(\\log \\frac{1}{\\delta} + \\log |\\mathcal{F}| \\right)}\n        \\quad\n        \\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$.}}\n$$\n\n\nВ случае бесконечного $\\mathcal{F}$ используем следующее обобщение неравенства Хёффдинга:\n\n\n**Неравенство МакДайармида (McDiarmid's inequality)**. Пусть $X_{1},\\ldots,X_m$ – независимые одинаково распределённые случайные величины, $g$ – скалярная функция с $m$ аргументами, такая что\n\n$$\\sup_{x_{1},\\ldots,x_m,\\tilde x_i} |g(x_1,\\ldots,x_i,\\ldots,x_m) - g(x_{1},\\ldots \\tilde x_i,\\ldots x_{m})| \\leq c_i\n            \\quad\n            \\forall i = 1,\\ldots,m\n$$\n\nдля некоторых $c_i$. Тогда для любого $\\epsilon > 0$ имеет место неравенство\n\n$$\n\\mathbb{P}\\left( g(X_1,\\ldots,X_m) - \\mathbb{E} g(X_1,\\ldots,X_m) \\geq \\epsilon \\right) \\leq\n            e^{-\\frac{2\\epsilon^2}{\\sum_{i=1}^m c_i^2}}.\n$$\n\n\nПрименяя теорему к $g(\\{(x_i,y_i)\\}_{i=1}^m) = \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R_m(f))$, получаем:\n\n\n\n$$\\mathbb{P}_{S_m} \\left(\\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R_m(f)) - \\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R'_m(f)) \\geq \\epsilon\\right) \\leq\n        e^{-2 m \\epsilon^2},\n$$\n\n\n\nиз чего следует:\n\n\n$$\n            \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R_m(f)) \\leq\n        \\color{#FFC100}{\\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R'_m(f))} + \\sqrt{\\frac{1}{2m} \\log \\frac{1}{\\delta}}\n        \\quad\n        \\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$,}\n$$\n\n\nгде $\\hat R'_m(f)$ – эмпирический риск на выборке $S'_m$. В следующем подразделе мы постараемся оценить жёлтое слагаемое.\n\n### Симметризация и сложность Радемахера\n\nОценим сверху матожидание супремума:\n\n\n$$\\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R'_m(f))\n        = \\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(\\mathbb{E}_{S''_m} \\hat R''_m(f) - \\hat R'_m(f))\n        \\leq\n$$\n\n\n\n$$\\leq \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}}(\\hat R''_m(f) - \\hat R'_m(f)) =$$\n\n\n\n$$= \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m (r(y''_i,f(x''_i)) - r(y'_i,f(x'_i)))\\right).$$\n\n\nЭтот шаг называется «симметризация»: теперь выражение выше зависит от двух равнозначных обучающих выборок $S'_m$ и ${S_m''}$. Ниже для краткости будем обозначать $r'_i(f) = r(y'_i,f(x'_i))$ и ${r_i''}(f) = r({y_i''},f({x_i''}))$.\n\nКак оценить сверху супремум разности рисков? Наивная оценка, супремум суммы, слишком слаба: в самом деле, при фиксированном наборе данных вполне вероятно может существовать модель, имеющая большой риск на нём (достаточно взять модель, обученную на тех же данных, но с «неправильными» метками), поэтому матожидание супремума эмпирического риска может быть велико.\n\nДля обхода этой сложности заметим, что выражение выше симметрично относительно перестановки местами двух выборок:\n\n$$\n        \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m (r''_i(f) - r'_i(f))\\right)\n        = \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m (r'_i(f) - r''_i(f))\\right).\n$$\n\nБолее того, так как элементы обеих выборок выбираются независимо, значение выражения не меняется и при перестановке местами отдельно $i$-ых элементов двух выборок. А именно, для любого набора $\\sigma_1,\\ldots,\\sigma_m \\in \\{-1,1\\}^m$\n\n$$\n        \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m (r''_i(f) - r'_i(f))\\right) =\n$$\n\n$$\n        = \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i (r''_i(f) - r'_i(f))\\right).\n$$\n\nБудем выбирать $\\sigma_i$ независимо и равновероятно из $\\{-1,1\\}$. Такие случайные величины называются *переменными Радемахера*.\n\nПоскольку оценки выше были верны для любых сигм, они верны и в среднем по переменным Радемахера, выбранным независимо от выборки:\n\n$$\n        \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m (r''_i(f) - r'_i(f))\\right) =\n$$\n\n$$\n        = \\mathbb{E}_{\\sigma_{1:m}} \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i (r''_i(f) - r'_i(f))\\right).\n$$\n\nПосле введения переменных Радемахера оценка супремума разницы рисков через сумму супремумов становится не такой плохой. В самом деле, рассмотрим бинарную классификацию с помощью линейной модели. Если данные хорошо разделяются плоскостью, то $\\mathbb{E}_{S_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m r_i(f)\\right)$ будет большим, так как в качестве $f$ можно взять линейную модель с противоположно ориентированной разделяющей плоскостью для $S_m$. В то же время для того, чтобы $\\mathbb{E}_{\\sigma_{1:m}} \\mathbb{E}_{S_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r_i(f)\\right)$ было большим, необходимо, чтобы существовала модель, отвечающая правильно на тех примерах, где $\\sigma_i=-1$, и неправильно, где $\\sigma_i=1$; для линейной модели это невозможно при большинстве конфигураций сигм.\n\nВеличина \n\n$$\n\\mathrm{Rad}_{\\mathcal{D},m}(\\mathcal{H}) =\n\\mathbb{E}_{z_{1:m} \\sim \\mathcal{D}^m} \\mathbb{E}_{\\sigma_{1:m} \\sim U(\\{-1,1\\}^m)} \\sup_{h \\in \\mathcal{H}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i h(z_i)\\right).\n$$\n\nназывается **сложностью Радемахера** класса функций $\\mathcal{H}: \\, \\mathbb{X} \\to \\mathbb{R}$ (для распределения $\\mathcal{D}$ на $\\mathbb{X}$ и длины выборок $m$). Она велика, если в классе $\\mathcal{H}$ содержатся функции, принимающие большие значения с заданными знаками на любом наборе данных фиксированного размера. Другими словами, сложность Радемахера измеряет, насколько выходы функций из класса $\\mathcal{H}$ могут коррелировать со случайным шумом.\n\nДля нас актуальна сложность Радемахера классов вида $\\mathcal{H} = r \\circ \\mathcal{F}$, то есть композиций моделей из класса $\\mathcal{F}$ и функции риска $r$. Если $\\mathcal{F}$ – класс линейных моделей в пространстве размерности меньшей, чем $m$, то сложность Радемахера невелика. В то же время если $\\mathcal{F}$ – множество всех возможных решающих деревьев, то, если только наборы данных непротиворечивы, она равна единице. В самом деле, решающее дерево способно запомнить всю обучающую выборку, то есть добиться единичной корреляции с любым случайным шумом.\n\nВернёмся к оценке разницы рисков:\n\n$$\n\\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R'_m(f))\n\\leq \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m (r''_i(f) - r'_i(f))\\right)\n=\n$$\n\n$$\n= \\mathbb{E}_{\\sigma_{1:m}} \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i (r''_i(f) - r'_i(f))\\right)\n\\leq\n$$\n\n\n\n$$\n\\leq \\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\mathbb{E}_{\\sigma_{1:m}} \\left(\\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r''_i(f)\\right) + \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r'_i(f)\\right)\\right)\n=\n$$\n\n$$= 2 \\mathbb{E}_{S'_m} \\mathbb{E}_{\\sigma_{1:m}} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r(y'_i,f(x'_i))\\right) =\n$$\n\n$$\n        = \\color{#FFC100}{2 \\mathrm{Rad}_{\\mathcal{D},m}(r \\circ \\mathcal{F})}.\n$$\n\n### Оценка для «0/1-риска»\n\nСложность Радемахера зависит от функции риска. Рассмотрим задачу бинарной классификации с классами $+1$ и $-1$. Возьмём в качестве функции риска индикатор ошибки бинарной классификации, или «0/1-риск»: \n\n$$r(y,z) = r_{0/1}(y,z) = \\mathbb{I}[y z < 0].$$\n\nНазвание «0/1-риск» обусловлено тем, что риск принимает значения $0$ и $1$.\n\nЗаметим следующее:\n\n$$\n\\mathbb{E}_{\\sigma_{1:m}} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r_i(f) \\right)\n= \\mathbb{E}_{\\sigma_{1:m}} \\max_{f \\in \\mathcal{F}_{S_m}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r_i(f) \\right),\n$$\n\nгде $\\mathcal{F}_{S_m}$ – класс эквивалентности функций из $\\mathcal{F}$, в котором две функции считаются эквивалентными тогда и только тогда, когда их образы на выборке $S_m$ имеют одинаковые знаки. Другими словами, среди всех функций, принимающих одни и те же знаки на $S_m$, мы выберем по одной и сформируем из них множество $\\mathcal{F}_{S_m}$. Заметим, что это множество конечно: $\\vert\\mathcal{F}_{S_m}\\vert \\leq 2^m$.\n\nНам понадобится следующая\n\n**Лемма**. Пусть $X$ – случайная величина со значениями в $[a,b]$ и нулевым средним. Тогда для любых $ s > 0$ имеет место неравенство\n\n$$\n        \\mathbb{E} e^{sX} \\leq\n        e^{\\frac{(b-a)^2 s^2}{8}}.\n$$\n\nС её помощью получаем:\n\n$$\n\\mathbb{E}_{\\sigma_{1:m}} \\sup_{f \\in \\mathcal{F}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r_i(f) \\right) =\n\\mathbb{E}_{\\sigma_{1:m}} \\max_{f \\in \\mathcal{F}_{S_m}} \\left(\\frac{1}{m} \\sum_{i=1}^m \\sigma_i r_i(f) \\right)\n=\n$$\n\n$$= \\frac{1}{m s} \\log \\exp \\left(s \\mathbb{E}_{\\sigma_{1:m}} \\max_{f \\in \\mathcal{F}_{S_m}} \\left(\\sum_{i=1}^m \\sigma_i r_i(f) \\right)\\right) \\leq\n$$\n\n$$\n\\leq\\frac{1}{m s} \\log \\mathbb{E}_{\\sigma_{1:m}} \\exp \\left(s \\max_{f \\in \\mathcal{F}_{S_m}} \\left(\\sum_{i=1}^m \\sigma_i r_i(f) \\right)\\right)\n\\leq\n$$\n\n$$\n\\leq \\frac{1}{m s} \\log \\sum_{f \\in \\mathcal{F}_{S_m}} \\mathbb{E}_{\\sigma_{1:m}} \\exp \\left(s \\sum_{i=1}^m \\sigma_i r_i(f) \\right) =\n$$\n\n$$\n= \\frac{1}{m s} \\log \\sum_{f \\in \\mathcal{F}_{S_m}} \\prod_{i=1}^m \\mathbb{E}_{\\sigma_i} \\left(e^{s \\sigma_i r_i(f)}\\right)\n\\leq\n$$\n\n$$\n\\leq \\frac{1}{m s} \\log \\sum_{f \\in \\mathcal{F}_{S_m}} e^{\\frac{m s^2}{2}}\n= \\frac{1}{m s} \\log \\left(|\\mathcal{F}_{S_m}| e^{\\frac{m s^2}{2}}\\right) =\n$$\n\n$$\n= \\frac{1}{m s} \\log |\\mathcal{F}_{S_m}| + \\frac{s}{2}.\n$$\n\nЭта оценка верна для любого $s > 0$. Минимизируем её по $s$. Легко видеть, что оптимальное $s$ равняется $\\sqrt{(2 / m) \\log \\vert\\mathcal{F}_{S_m}\\vert}$; подставляя его, получаем:\n\n$$\n\\color{#348FEA}{\n\\mathrm{Rad}_{\\mathcal{D},m}(r \\circ \\mathcal{F}) \\leq\n\\mathbb{E}_{S_m} \\sqrt{\\frac{2}{m} \\log |\\mathcal{F}_{S_m}|}.\n\\qquad (1)\n}\n$$\n\nОпределим **функцию роста** класса $\\mathcal{F}$ как\n\n$$\\Pi_\\mathcal{F}(m) = \\max_{S_m} |\\mathcal{F}_{S_m}|.$$\n\nЭта функция показывает, сколько различных разметок класс функций $\\mathcal{F}$ может породить на наборе данных, в зависимости от размера этого набора. Очевидно, что $\\Pi_\\mathcal{F}(m) \\leq 2^m$ и монотонно не убывает.\n\nНапример, для линейной модели на $d$-мерном пространстве признаков $\\Pi_\\mathcal{F}(m) = 2^m$ при $m \\leq d+1$ (любое подмножество $d+1$ точек в общем положении в $d$-мерном пространстве всегда можно отделить гиперплоскостью), но строго меньше этого числа при $m > d+1$ (например, если точки – углы квадрата на плоскости, его диагонали нельзя разделить прямой).\n\nКогда $\\vert\\mathcal{F}_{S_m}\\vert = 2^m$, будем говорить, что «$\\mathcal{F}$ разделяет $S_m$».\n\nОпределим **размерность Вапника-Червоненкиса** (или **VC-размерность**) как максимальное $m$, при котором семейство $\\mathcal{F}$ разделяет любой датасет $S_m$:\n\n$$\n\\mathrm{VC}(\\mathcal{F}) =\n\\max \\{m\\mid \\Pi_\\mathcal{F}(m) = 2^m\\}.\n$$\n\nТаким образом, VC-размерность линейной модели равна $d+1$.\n\nСледующая лемма даёт связь между размерностью Вапника-Червоненкиса и функцией роста:\n\n**Лемма** (Sauer–Shelah, см. подробнее [здесь](https://en.wikipedia.org/wiki/Sauer%E2%80%93Shelah_lemma)) \n\n$$\\Pi_\\mathcal{F}(m) \\leq \\sum_{k=0}^{\\mathrm{VC}(\\mathcal{F})} \\binom{m}{k}$$\n\nИзучим асимптотическое поведение сложности Радемахера при $m\\to\\infty$. Обозначим $D = \\mathrm{VC}(\\mathcal{F})$. Для $m \\leq D$ имеем $\\Pi_\\mathcal{F}(m) = 2^m$, а для $m > D$:\n\n$$\n\\Pi_\\mathcal{F}(m) \\leq\n\\sum_{k=0}^{D} \\binom{m}{k} \\leq\n\\left(\\frac{m}{D}\\right)^{D} \\sum_{k=0}^{D} \\binom{m}{k} \\left(\\frac{D}{m}\\right)^{k} \\leq\n$$\n\n$$        \n\\leq\n\\left(\\frac{m}{D}\\right)^{D} \\sum_{k=0}^{m} \\binom{m}{k} \\left(\\frac{D}{m}\\right)^{k} =\n\\left(\\frac{m}{D}\\right)^{D} \\left(1 + \\frac{D}{m}\\right)^m \\leq\n\\left(\\frac{e m}{D}\\right)^D.\n$$\n\nПодставляя это выражение в (1), получаем окончательную оценку на сложность Радемахера:\n\n$$\n\\mathrm{Rad}_{\\mathcal{D},m}(r \\circ \\mathcal{F}) \\leq\n\\sqrt{\\frac{2}{m} \\mathrm{VC}(\\mathcal{F}) \\left(1 + \\log m - \\log(\\mathrm{VC}(\\mathcal{F}))\\right)} = \n$$\n\n$$\n=\\Theta_{m\\to\\infty}\\left(\\sqrt{\\mathrm{VC}(\\mathcal{F}) \\frac{\\log m}{m}}\\right).\n$$\n\nСоответствующая оценка на истинный риск тогда примёт вид:\n\n$$\n\\color{#348FEA}{R(\\hat f_m) \n\\leq \\hat R_m(\\hat f_m) + \\sqrt{\\frac{1}{2m} \\log \\frac{1}{\\delta}} + \\Theta_{m\\to\\infty}\\left(\\sqrt{\\mathrm{VC}(\\mathcal{F}) \\frac{\\log m}{m}}\\right)\n\\quad\n\\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$.}}\n$$\n\nДля того, чтобы эта оценка была осмыслена, необходимо гарантировать $\\mathrm{VC}(\\mathcal{F}) < m/(2\\log m)$. Для линейных моделей, при условии $m \\gg d$ (данных намного больше, чем признаков), оценки действительно получаются осмысленными. \n\nК сожалению, для нейронных сетей это подчас неверно. В работе [Nearly-tight VC-dimension and Pseudodimension Bounds for Piecewise Linear Neural Networks](https://arxiv.org/pdf/1703.02930.pdf) показано, что если $\\mathcal{F}$ обозначает класс моделей, реализуемых полносвязной сетью ширины $n$ с $N$ параметрами, то $\\mathrm{VC}(\\mathcal{F}) = \\Theta(n N)$. Таким образом, наша оценка на сложность Радемахера становится бесполезной в реалистичных сценариях, когда число весов сети $N$ много больше числа примеров в обучающей выборке $m$.\n\nЕсли априори известно, что результат обучения лежит в некотором классе $\\mathcal{F}_B$, то в оценке сложности Радемахера можно использовать именно этот класс, а не полный класс моделей $\\mathcal{F}$. Очевидно, что сложность $\\mathcal{F}_B$, лежащего в $\\mathcal{F}$, не больше сложности $\\mathcal{F}$. Так, в работе [Spectrally-normalized margin bounds for neural networks](https://arxiv.org/pdf/1706.08498.pdf) получены оценки для сложности полносвязной сети с липшицевыми функциями активации при условии, что нормы весов ограничены; см. также [полный конспект лекций](https://arxiv.org/pdf/2012.05760.pdf). В этом случае под $\\mathcal{F}_B$ будем понимать класс сетей с весами нормы не больше $B$. Обозначим соответствующую оценку через $\\mathcal{B}$:\n\n$$\n\\sup_{f \\in \\mathcal{F}_B} (R(f) - \\hat R_m(f))\n\\leq \\mathcal{B}(B, \\delta)\n\\quad\n\\text{с вероятностью $\\geq 1-\\delta$ по $S_m$.}\n$$\n    \nК сожалению, нет гарантий, что градиентный спуск всегда сходится в решение с нормой меньше какого-то числа. Чтобы обойти это ограничение, используют следующую технику. Возьмём последовательность ограничений $B_j$, такую что \n\n$$\\mathcal{F}_{B_j} \\subset \\mathcal{F}_{B_{j+1}}\\text{ и }\\bigcup_{j=1}^\\infty \\mathcal{F}_{B_j} = \\mathcal{F}.$$\n\nТакже возьмём последовательность $\\delta_j$, монотонно убывающую к нулю и суммирующуюся в $\\delta$. Тогда для любого $j \\geq 1$\n\n$$\n\\sup_{f \\in \\mathcal{F}_{B_j}} (R(f) - \\hat R_m(f))\n\\leq \\mathcal{B}(B_j, \\delta_j)\n\\quad\n\\text{с вероятностью $\\geq 1-\\delta_j$ по $S_m$.}\n$$\n\nА значит,\n\n$$\n\\sup_{f \\in \\mathcal{F}_{B_j}} (R(f) - \\hat R_m(f))\n\\leq \\mathcal{B}(B_j, \\delta_j) \\quad \\forall j \\geq 1\n\\quad\n\\text{с вероятностью $\\geq 1-\\sum_{j=1}^ \\infty \\delta_j = 1-\\delta$ по $S_m$.}\n$$\n\nИз этого следует, что\n\n$$\nR(\\hat f_m) - \\hat R_m(\\hat f_m)\n\\leq \\mathcal{B}(B_{\\hat j_m}, \\delta_{\\hat j_m})\n\\quad\n\\text{с вероятностью $\\geq 1-\\delta$ по $S_m$,}\n$$\n\nгде $\\hat j_m$ – минимальное $j$, при котором $\\hat f_m \\in B_{j}$.\n\nТакая техника используется, например, в работах [Spectrally-normalized margin bounds for neural networks](https://arxiv.org/pdf/1706.08498.pdf) и [A PAC-Bayesian Approach to Spectrally-Normalized Margin Bounds for Neural Networks](https://arxiv.org/pdf/1707.09564.pdf).\n\n\n## Фундаментальная проблема равномерных оценок\n\n<figure>\n  <img src=\"https://yastatic.net/s3/education-portal/media/uniform_bound_failure_example_738fe9b23c_45b4ff7033_74e9c67df1.svg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n  <figcaption>\n    <p>Пример модели (розовая кривая), имеющей малый истинный риск, но большой эмпирический на заданном наборе данных (кружочки). Данные одного класса лежат на желтом круге, другого – на голубом; оптимальная разделяющая поверхность обозначена пунктиром. Имея набор из кружочков, мы строим противоположный набор, обозначенный крестиками; заметим, что он мог прийти из того же распределения. Если алгоритм обучения старается отодвинуть границу классов как можно дальше от примеров, то результатом обучения на наборе крестиков может стать розовая кривая. Пример взят из работы <a href='https://arxiv.org/pdf/1902.04742.pdf'>Uniform convergence may be unable to explain generalization in deep learning</a>.</p>\n  </figcaption>\n</figure>\n\nНапомним, что построение равномерных оценок проходило в несколько шагов:\n\n1. Оценка супремумом\n$$\nR(\\hat{f}_m)-\\hat{R}_m(\\hat{f}_m)\\leq\\sup_{f\\in\\mathcal{F}}(R(f)-\\hat{R}_m(f))\n$$\n\n2. Применение неравенства макДайармида:\n\n$$\n\\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R_m(f)) \\leq\n\\color{#FFC100}{\\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R'_m(f))} + \\sqrt{\\frac{1}{2m} \\log \\frac{1}    {\\delta}}\n\\quad\n\\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$,}\n$$\n\n\n3. Оценка матожидания супремума (жёлтое слагаемое выше) с помощью симметризации с дальнейшим выходом на сложность Радемахера:\n\n$$\n\\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R'_m(f)) =\n\\mathbb{E}_{S'_m} \\sup_{f \\in \\mathcal{F}}(\\mathbb{E}_{S''_m} \\hat R''_m(f) - \\hat R'_m(f)) \\leq\n\\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}}(\\hat R''_m(f) - \\hat R'_m(f)).\n$$\n\nНа каждом шаге предыдущая величина оценивается сверху, и потенциально каждое из этих неравенств может оказаться слишком слабым и привести к бессмысленной оценке. Давайте это проиллюстрируем.\n\nВыше мы уже отмечали, что если класс $\\mathcal{F}$ содержит модель, для которой $\\hat R_m(f)$ мал, а $R(f)$ велик, то равномерная оценка становится бессмысленной. По этой причине, имеет смысл выбирать класс $\\mathcal{F}$ как можно более маленьким. Самым лучшим из возможных классов мог бы быть класс моделей, к которым сходится наш алгоритм обучения с высокой вероятностью.\n\nРассмотрим случай, близкий к идеальному: тот, в котором существует $\\epsilon > 0$, для которого при любых $f \\in \\mathcal{F}$ имеем $R(f) < \\epsilon$. Иными словами, предположим, что все модели класса $\\mathcal{F}$ хорошо обобщают. В этом случае оценка выше близка к идеальной:\n\n$$\nR(\\hat f_m) - \\hat R_m(\\hat f_m) \\leq\n\\epsilon\n\\quad\n\\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$.}\n$$\n\nНо что будет, если мы начнём честно воспроизводить процесс построения равномерных оценок? После второго шага мы получаем оценку вида\n\n$$\nR(\\hat f_m) - \\hat R_m(\\hat f_m) \\leq\n$$\n\n$$\n\\sup_{f \\in \\mathcal{F}}(R(f) - \\hat R_m(f)) \\leq\n\\epsilon + \\sqrt{\\frac{1}{2m} \\log \\frac{1}{\\delta}}\n\\quad\n\\text{с вероятностью $\\geq 1 - \\delta$ по $S_m$,}\n$$\n\nкоторая не сильно хуже предыдущей, но в которой всё равно появилось лишнее слагаемое. \n\nНо допустим, что мы хотим честно проделать третий шаг процедуры получения равномерных оценок. Для этого нам необходимо было оценить матожидание супремума, которое после симметризации получает вот такую верхнюю оценку:\n\n$$\n\\mathbb{E}_{S'_m} \\mathbb{E}_{S''_m} \\sup_{f \\in \\mathcal{F}}(\\hat R''_m(f) - \\hat R'_m(f)).\n$$\n\nТаким образом, малость истинного риска не гарантирует малость эмпирического риска на любом наборе данных. Так, авторы статьи [Uniform convergence may be unable to explain generalization in deep learning](https://arxiv.org/pdf/1902.04742.pdf) предъявили пример, в котором для любого $S_m''$ существует модель $\\tilde f_m \\in \\mathcal{F}$, такая что $\\hat R''_m(\\tilde f_m) \\approx 1$, но при этом $\\hat R_m(\\tilde f_m)$ и $R(\\tilde f_m)$ малы. Иллюстрация такой ситуации приведена в начале параграфа. Тогда $\\sup_{f \\in \\mathcal{F}}(\\hat R''_m(f) - \\hat R'_m(f))$ велик, и оценки теряют смысл.\n\nК счастью, даже эта фундаментальная проблема не ставит крест на равномерных оценках. Так, работы [Uniform Convergence of Interpolators: Gaussian Width, Norm Bounds, and Benign Overfitting](https://arxiv.org/pdf/2106.09276.pdf) и [Stability and Deviation Optimal Risk Bounds with Convergence Rate $O (1/n)$](https://arxiv.org/pdf/2103.12024.pdf) рассматривают равномерную оценку в классе интерполирующих моделей, то есть, имеющих нулевой эмпирический риск:\n\n$$\nR(\\hat f_m) - \\hat R_m(\\hat f_m)\n\\leq \\sup_{f \\in \\mathcal{F}: \\, \\hat R_m(f) = 0} R(f).\n$$\n\nДля таких моделей контрпример выше не работает.",
        "handbook": "Учебник по машинному обучению",
        "title": "Обобщающая способность – классическая теория",
        "description": "Обобщающая способность – классическая теория"
    },
    {
        "path": "/handbook/ml/article/pac-bajesovskie-ocenki-riska",
        "content": "В предыдущем параграфе рассматривались равномерные оценки разницы истинного и эмпирического рисков. Если в рассматриваемом классе моделей есть «плохие», то равномерные оценки становятся слишком пессимистичными. Часто нельзя гарантировать, что что наш алгоритм обучения их никогда не выбирает, поэтому класс моделей $\\mathcal{F}$ для равномерной оценки не получится сузить до класса только «хороших» моделей. Но можно надеяться, что плохие выучиваются не слишком часто. Например, известно, что градиентный спуск обычно сходится к хорошим моделям (об этом мы ещё поговорим в [параграфе про implicit bias](https://academy.yandex.ru/handbook/ml/article/implicit-bias)). В этом параграфе мы разберём элегантный способ учесть «предпочтения» алгоритма обучения в оценке разницы рисков.\n\nВспомним равномерную оценку для конечного $\\mathcal{F}$:\n\n$$\n\\mathbb{P}\\left(\\sup_{f\\in\\mathcal{F}} (R(f) - \\hat R_m(f)) \\geq \\epsilon\\right) =\n\\mathbb{P}\\left(\\exists f\\in\\mathcal{F}: \\; (R(f) - \\hat R_m(f)) \\geq \\epsilon\\right) \\leq$$\n\n$$\\leq\n\\sum_{f\\in\\mathcal{F}} \\mathbb{P}(R(f) - \\hat R_m(f) \\geq \\epsilon) \\leq\n\\vert\\mathcal{F}\\vert e^{-2 m \\epsilon^2}\n\\quad\n\\forall \\epsilon > 0,\n$$\n\nгде $\\vert\\mathcal{F}\\vert$ – мощность класса $\\mathcal{F}$. Эта оценка формально верна и для бесконечного $\\mathcal{F}$, но смысл её теряется. Давайте попробуем исправить это.\n\nПусть $\\mathcal{F}$ не более, чем счётно. Для каждого $f \\in \\mathcal{F}$ возьмём своё $\\epsilon(f)$. Если взять $\\epsilon(f)$ таким, чтобы $\\sum_{f \\in \\mathcal{F}} e^{-2 m \\epsilon^2(f)}$ было конечным, то приходим к осмысленной оценке:\n\n$$\n\\mathbb{P}\\left(\\exists f\\in\\mathcal{F}: \\; (R(f) - \\hat R_m(f)) \\geq \\epsilon(f)\\right) \\leq\n$$\n\n$$\n\\sum_{f\\in\\mathcal{F}} \\mathbb{P}\\left(R(f) - \\hat R_m(f) \\geq \\epsilon(f)\\right) \\leq\n\\sum_{f \\in \\mathcal{F}} e^{-2 m \\epsilon^2(f)}. \n$$\n\nРассмотрим теперь некоторое вероятностное распределение $P(f)$ на $\\mathcal{F}$. В качестве $\\epsilon(f)$ возьмём\n\n$$e^{-2 m \\epsilon^2(f)} = P(f) e^{-2 m \\tilde\\epsilon^2},$$\n\nгде $\\tilde\\epsilon \\in \\mathbb{R}_+$. Из этого уравнения получаем следующее выражение для $\\epsilon(f)$:\n\n$$\n\\epsilon(f) =\n\\sqrt{\\tilde\\epsilon^2 + \\frac{1}{2m} \\log\\frac{1}{P(f)}}.\n$$\n\nВ итоге, для любого $\\tilde\\epsilon > 0$ получаем оценку:\n\n$$\n\\mathbb{P}\\left(\\exists f\\in\\mathcal{F}: \\; (R(f) - \\hat R_m(f)) \\geq \\sqrt{\\tilde\\epsilon^2 + \\frac{1}{2m} \\log\\frac{1}{P(f)}}\\right) \\leq\ne^{-2 m \\tilde\\epsilon^2}.\n$$\n\nИли, что то же самое, с вероятностью $\\geq 1 - \\delta$ по $S_m$ для любого $f \\in \\mathcal{F}$:\n\n$$\nR(f)-\\hat{R}_m(f)\\leq\\sqrt{\\frac{1}{2m}\\left(\\log\\frac{1}{\\delta}+\\log\\frac{1}{P(f)}\\right)}\n$$\n\nЗаметим, что если $\\mathcal{F}$ конечно, а $P(f)$ – равномерное распределение, то оценка выше совпадает с равномерной оценкой. Если же наш алгоритм обучения предпочитает выбирать модели, для которых $P(f)$ велико, то оценка улучшается по сравнению с равномерной. Таким образом, распределение $P(f)$ «кодирует» наши представления о предпочтениях алгоритма. Будем называть $P(f)$ «априорным распределением».\n\nКак обобщить оценку выше на несчётные классы моделей? В первую очередь, предположим, что наш алгоритм обучения $\\mathcal{A}$ стохастичен, а значит, на выходе даёт не одну модель, а распределение:\n\n$$\n\\hat f_m \\sim \n\\hat Q_m =\n\\mathcal{A}(S_m).\n$$\n\nБудем называть это распределение «апостериорным». Такое рассуждение осмысленно, например, для стохастического градиентного спуска: очевидно, что результат его работы на невыпуклой функции потерь недетерминирован (он может сходиться в разные локальные минимумы).\n    \nЗаметим, что главное отличие апостериорного распределения от априорного в том, что первое зависит от данных, а второе – нет. Важно понимать при этом, что, несмотря на названия, эти два распределения не связаны между собой никаким вариантом формулой Байеса. Сходство с байесовским подходом скорее внешнее. Поэтому слова «априорное» и «апостериорное» имеет смысл писать в кавычках, но для экономии места мы их будем в дальнейшем опускать.\n\nОценки разности рисков, о которых речь пойдёт ниже, называются **PAC-байесовскими** (**PAC-bayesian**, где PAC – probably approximately correct).\n\nСформулируем одну из классических оценок из этого класса:\n\n**Теорема Макаллестера**. Пусть $\\mathcal{F}$ – множество моделей и $P$ – распределение на $\\mathcal{F}$. Тогда для любого $\\delta \\in (0,1)$ с вероятностью $\\geq 1 - \\delta$ по $S_m$ имеем:\n\n$$\nR(\\hat Q_m) \\leq\n\\hat R_m(\\hat Q_m) + \\sqrt{\\frac{1}{2m-1} \\left(\\log \\frac{4m}{\\delta} + \\mathrm{KL}(\\hat Q_m\\;\\vert\\vert P) \\right)},\n$$\n\nгде $R(Q) = \\mathbb{E}_{f \\sim Q} R(f)$ и $\\hat R_m(Q) = \\mathbb{E}_{f \\sim Q} \\hat R_m(f)$.\n\nВидим, что оценка тем лучше, чем ближе апостериорное распределение к априорному. Здесь работает следующая интуиция. Если для большинства обучающих наборов данных апостериорное распределение близко к априорному, то оно почти не зависит от данных, а значит, истинный риск и риск на обучающей выборке должны быть близки с высокой вероятностью. Если же апостериорное зависит от данных сильно, то, скорее всего, модель сильно переобучается, а значит, оценка не может быть хорошей; в нашем случае она велика из-за большой KL-дивергенции.\n\nДля доказательства теоремы нам понадобятся две леммы:\n\n**Лемма 1**. Для любого распределения $P$ на $\\mathcal{F}$ и для любого $\\delta \\in (0,1)$ с вероятностью $\\geq 1 - \\delta$ по $S_m$ имеем:\n\n$$\n\\mathbb{E}_{f \\sim P} e^{(2m-1) (\\Delta_m(f))^2} \\leq\n\\frac{4m}{\\delta},\n$$\n\nгде $\\Delta_m(f) = \\vert R(f) - \\hat R_m(f)\\vert$.\n\n**Лемма 2 (лемма Донскера-Вередана, Donsker-Varadhan)**. Пусть $P$ и $Q$ – вероятностные распределения на множестве $X$. Тогда для любого $h: \\; X \\to \\mathbb{R}$\n\n\n$$\n\\mathbb{E}_{x\\sim Q} h(x) \\leq\n\\log\\mathbb{E}_{x \\sim P} e^{h(x)} + \\mathrm{KL}(Q\\vert\\vert P).\n$$\n\n{% cut \"Доказательство теоремы\" %}\n\nПрименим лемму 2 к $X = \\mathcal{F}$, $h = (2m-1) \\Delta_m^2$ и $Q = \\hat Q_m$:\n\n  \n$$\n        \\mathbb{E}_{f \\sim \\hat Q_m} (2m-1) (\\Delta_m(f))^2 \\leq\n        \\log\\mathbb{E}_{f \\sim P} e^{(2m-1) (\\Delta_m(f))^2} + \\mathrm{KL}(\\hat Q_m\\;\\vert\\vert\\;P).\n$$\n  \n\nТогда по лемме 1 с вероятностью $\\geq 1 - \\delta$ по $S_m$ имеем:\n\n$$\n        \\mathbb{E}_{f \\sim \\hat Q_m} (2m-1) (\\Delta_m(f))^2 \\leq\n        \\log\\frac{4m}{\\delta} + \\mathrm{KL}(\\hat Q_m\\;\\vert\\vert\\;P).\n$$\n\nДоказательство, таким образом, легко завершается:\n\n$$\n        R(\\hat Q_m) - \\hat R_m(\\hat Q_m) \\leq\n        \\vert\\mathbb{E}_{f\\sim \\hat Q_m} (R(f) - \\hat R_m(f))\\vert \\leq\n$$\n\n\n$$\n\\leq\\mathbb{E}_{f\\sim \\hat Q_m} |R(f) - \\hat R_m(f)| =\n\\mathbb{E}_{f\\sim \\hat Q_m} \\Delta_m(f) \\leq\n$$\n\n\n$$\n        \\leq\\sqrt{\\mathbb{E}_{f\\sim \\hat Q_m} (\\Delta_m(f))^2} \\leq\n$$\n\n$$\n        \\sqrt{\\frac{1}{2m-1} \\left(\\log \\frac{4m}{\\delta} + \\mathrm{KL}(\\hat Q_m\\;\\vert\\vert\\;P) \\right)}.\n$$\n\n{% endcut %}\n\n{% cut \"Доказательство леммы 2\" %}\n\nМы рассмотрим лишь простой случай, когда и у $P$, и у $Q$ есть плотности, и они нигде не обращаются в ноль.\n\n  \n$$\n        \\mathbb{E}_{x \\sim Q} h(x) - \\mathrm{KL}(Q\\vert\\vert P) =\n        \\mathbb{E}_{x \\sim Q} \\left(h(x) - \\log\\left(\\frac{q(x)}{p(x)}\\right)\\right) =\n$$\n\n\n\n$$\n        =\\mathbb{E}_{x \\sim Q} \\log\\left(e^{h(x)} \\frac{p(x)}{q(x)}\\right) \\leq\n        \\log \\mathbb{E}_{x \\sim Q} \\left(e^{h(x)} \\frac{p(x)}{q(x)}\\right) =\n        \\log \\mathbb{E}_{x \\sim P} e^{h(x)}.\n$$\n  \n{% endcut %}\n\n{% cut \"Доказательство леммы 1\" %}\n\nНам понадобится\n\n**Неравенство Маркова**. Пусть $X$ – неотрицательная случайная величина. Тогда для любого $ a > 0$ имеем\n\n$$\n        \\mathbb{P}(X \\geq a) \\leq\n        \\frac{\\mathbb{E} X}{a}.\n$$\n\n\nВ качестве $X$ и $a$ из неравенства Маркова возьмём \n\n$$X = \\mathbb{E}_{f \\sim P} e^{(2m-1) (\\Delta_m(f))^2},\\qquad a = 4m / \\delta$$\n\nТогда \n\n$$\n\\mathbb{P}\\left(\\vphantom{\\frac14}\\mathbb{E}_{f \\sim P} e^{(2m-1) (\\Delta_m(f))^2} \\leq\n        \\frac{4m}{\\delta}\\right) \\leq\n$$\n\n\n$$\n\\leq\\frac{\\delta}{4m}\\mathbb{E}_{S_m} \\mathbb{E}_{f \\sim P} e^{(2m-1) (\\Delta_m(f))^2}\n$$\n\n\nЗначит, нам достаточно доказать, что\n\n\n$$\n        \\mathbb{E}_{S_m} \\mathbb{E}_{f \\sim P} e^{(2m-1) (\\Delta_m(f))^2} \\leq\n        4m.\n$$\n\n\nМы докажем даже более сильное соотношение:\n\n$$\n\\mathbb{E}_{S_m}e^{(2m-1)(\\Delta_m(f))^2}\\leq4m\\quad\\forall f\\in\\mathcal{F}\n$$\n\nЗаметим, что из неравенства Хёффдинга будет следовать\n\n$$\n\\mathbb{P}_{S_m}(\\Delta_m(f)\\geq\\epsilon)\\leq2e^{-2m\\epsilon^2}\\quad\\forall\\epsilon>0\\quad\\forall f\\in\\mathcal{F}\n$$\n\nДля простоты предположим, что распределение $\\Delta_m(f)$ имеет плотность для любого $f \\in \\mathcal{F}$; обозначим её $p_f(\\Delta)$. В этом случае мы можем ограничить матожидания по $S_m$ напрямую:\n\n$$\n        \\mathbb{E}_{S_m} e^{(2m-1) (\\Delta_m(f))^2} =\n        \\int_0^\\infty e^{(2m-1) \\epsilon^2} p_f(\\epsilon) \\, d\\epsilon =\n$$\n\n$$\n        \\int_0^\\infty e^{(2m-1) \\epsilon^2} \\frac{d}{d\\epsilon} \\left(-\\int_\\epsilon^\\infty p_f(\\Delta) \\, d\\Delta\\right) \\, d\\epsilon =\n$$\n\n\n$$\n        =\n        \\left.-\\left(e^{(2m-1) \\epsilon^2} \\int_\\epsilon^\\infty p_f(\\Delta) \\, d\\Delta\\right) \\right|_{\\epsilon=0}^\\infty +\n        2 (2m-1) \\int_0^\\infty \\epsilon\\,e^{(2m-1) \\epsilon^2} \\int_\\epsilon^\\infty p_f(\\Delta) \\, d\\Delta \\, d\\epsilon \\leq\n$$\n\n\n$$\n        \\leq\n        \\int_0^\\infty p_f(\\Delta) \\, d\\Delta +\n        2 (2m-1) \\int_0^\\infty \\epsilon\\,e^{(2m-1) \\epsilon^2} \\int_\\epsilon^\\infty p_f(\\Delta) \\, d\\Delta \\, d\\epsilon \\leq\n$$\n\n$$          \n        \\leq\n        2 + 4 (2m-1) \\int_0^\\infty \\epsilon\\,e^{(2m-1) \\epsilon^2} e^{-2m \\epsilon^2} \\, d\\epsilon =\n$$\n\n$$\n        2 + 4 (2m-1) \\int_0^\\infty \\epsilon\\,e^{-\\epsilon^2} \\, d\\epsilon =\n        2 + 2 (2m-1) =\n        4m.\n$$\n\nВ общем случае, мы не можем предполагать наличие плотности у $\\Delta_m(f)$. Доказательство в этом случае можно найти в оригинальной работе D. A. McAllester [Some pac-bayesian theorems](https://link.springer.com/content/pdf/10.1023%2FA%3A1007618624809.pdf), а также в [конспекте лекций](https://arxiv.org/pdf/2012.05760.pdf) автора этого параграфа.\n\n{% endcut %}  \n\nТеорема Макаллестера – не единственная из возможных пак-байесовских оценок. Например, несколько улучшенную версию той же оценки можно найти в работе [Bounds for averaging classifiers](https://www.cs.cmu.edu/~jcl/papers/averaging/averaging_tech.pdf). Другие оценки подобного типа можно найти в монографии [PAC-Bayesian supervised classification: the thermodynamics of statistical learning](https://arxiv.org/pdf/0712.0248.pdf).\n\n## Применение пак-байесовских оценок к детерминированным алгоритмам обучения\n\nВыше были рассмотрены две PAC-байесовские оценки: одна для не более, чем счётного множества моделей, другая – для произвольного. За возможность использования несчётных классов моделей мы заплатили тем, что алгоритм обучения должен быть недетерминированным (для детерминированных алгоритмов KL-дивергенция в Теореме Макаллестера может вырождаться в бесконечность; например, это так, если априорное распределение гауссово). Чаще всего класс моделей $\\mathcal{F}$ всё-таки несчетён: например, если это класс всех сетей фиксированной архитектуры, то он индексируется весами, которых несчётное множество. При этом, хотя используемый алгоритм обучения и в самом деле недетерминирован (стохастический градиентный спуск зависит от случайного выбора батчей и от инициализации весов) и теорема Макаллестера выполняется, финальное распределение моделей очень сложно охарактеризовать, и из-за этого непонятно, как считать KL-дивергенцию.\n\nПредположим, что алгоритм обучения всё-таки детерминирован; этого можно добиться, зафиксировав сид генератора случайных чисел при обучении. Как получить осмысленную PAC-байесовскую оценку для детерминированного алгоритма на несчётном множестве моделей?\n\nМы рассмотрим **два способа**.\n    \nПервый способ – добавить известный шум в финальную модель, выданную детерминированным алгоритмом. Так, для нейронных сетей, результатом работы алгоритма обучения является набор весов. Если добавить в этот набор гауссовский шум, а также в качестве априорного распределения взять гауссовское, то KL-дивергенцию в теореме Макаллестера можно будет посчитать аналитически.\n\nДисперсию шума в апостериорном распределении тоже можно обучить с помощью градиентного спуска одновременно с весами, тем самым минимизируя правую часть оценки из вышеупомянутой теоремы.   Если в найденную модель удастся добавить шум так, чтобы KL-дивергенция значительно уменьшилась, но при этом риск на обучающей выборке не сильно вырос, то оценка на истинный риск получится хорошей. \n\nЭто рассуждение связывает PAC-байесовские оценки и гипотезу о том, что «плоские» («широкие») минимумы хорошо обобщают. В самом деле, если минимум «плоский», то в модель из него можно добавить много шума, не испортив качество на обучении. Оценки, основанные на этом принципе, можно найти в работах [Computing nonvacuous generalization bounds for deep (stochastic) neural networks with many more parameters than training data](https://arxiv.org/pdf/1703.11008.pdf) и [A PAC-Bayesian Approach to Spectrally-Normalized Margin Bounds for Neural Networks](https://arxiv.org/pdf/1707.09564.pdf).\n\nВторой способ состоит в том, чтобы взять дискретное кодирование $c$ и применить дискретную PAC-байесовскую оценку к закодированной модели вместо оригинальной. Обозначим закодированную модель $f$ через $f_c$. Следуя работе [Non-vacuous Generalization Bounds at the ImageNet Scale: a PAC-Bayesian Compression Approach](https://arxiv.org/pdf/1804.05862.pdf), возьмём априорное распределение с массой, убывающей с ростом длины кода:\n\n$$\nP_c(f_c) =\n\\frac{1}{Z} m(\\vert f_c\\vert ) 2^{-|f_c|}.\n$$\n\n\nЗдесь $\\vert f_c\\vert $ – длина кода модели $f$, $m(k)$ – некоторое вероятностное распределение на $\\mathbb{N}$, а $Z$ – нормализующая константа. Тогда KL-дивергенция примет следующий вид:\n\n$$\n\\mathrm{KL}(\\delta_{f_c}\\vert\\vert {P_c}) =\n\\log Z + \\vert f_c\\vert  \\log 2 - \\log(m(\\vert f_c\\vert )).\n$$\n\nДля того, чтобы KL-дивергенция выше была как можно меньше, необходимо, чтобы наш алгоритм обучения на реалистичных данных сходился в модели с маленькой длиной кода. Для этого будем применять наше кодирование не к оригинальной модели, а к сжатой с помощью некоторого алгоритма сжатия. Здесь мы предполагаем, что модели, к которым сходится наш алгоритм обучения, можно сжать с малыми потерями до моделей с малой длиной кода. Другими словами, мы опираемся на предположение, что обученные модели в некоторым смысле «простые».\n\nЕсли модель параметризована весами $\\theta$, типичный алгоритм сжатия выдаст набор $(S,Q,C)$, где\n\n\n* $S = s_{1:k} \\subset [\\dim\\theta]$ – позиции ненулевых весов;\n* $C = c_{1:r} \\subset \\mathbb{R}$ – «словарь» весов;\n* $Q = q_{1:k}$, $q_i \\in [r]$ $\\forall i \\in [k]$ – квантизованные значения весов.\n\nВыход алгоритма будет выглядеть как $\\mathcal{C}(\\theta)_i = c_{q_j}$, если $i = s_j$, иначе $0$.\n\nТогда наивное 32-битное кодирование даст следующую длину:\n\n$$\n\\vert\\mathcal{C}(\\theta)\\vert_c =\n\\vert S\\vert_c + \\vert Q\\vert_c + \\vert C\\vert_c \\leq\nk (\\log\\dim\\theta + \\log r) + 32 r.\n$$\n\nВ работе [Non-vacuous Generalization Bounds at the ImageNet Scale: a PAC-Bayesian Compression Approach](https://arxiv.org/pdf/1804.05862.pdf) описанный выше способ применяется к модели MobileNet (свёрточной сети, сконструированной специально для мобильных устройств), обученной на наборе данных ImageNet, и получают верхнюю оценку на истинный риск, равную $96.5\\%$ (риск случайного угадывания – $99.9\\%$). Хотя такой результат и выглядит очень скромным, но это первая осмысленная оценка обобщающей способности реально используемой нейронной сети на реалистичном наборе данных.",
        "handbook": "Учебник по машинному обучению",
        "title": "PAC-байесовские оценки риска",
        "description": "PAC-байесовские оценки риска"
    },
    {
        "path": "/handbook/ml/article/seti-beskonechnoj-shiriny",
        "content": "Во введении обсуждалось, что истинный риск нейронной сети выходит на асимптоту при стремлении ширины сети (то есть числа нейронов в слое) к бесконечности. Это намекает нам на то, что существует предельная модель, «бесконечно широкая сеть». В этом параграфе мы обсудим подходы к анализу её поведения.\n\nДинамика обучения нейронной сети описывается эволюцией в пространстве весов – например, правилом обновления весов в градиентном спуске. Но в каком виде можно записать эволюцию бесконечно широкой сети, в которой весов бесконечно много? Есть два способа это сделать.\n\n### Первый способ – ввести меру в пространстве весов\n\nВ качестве примера рассмотрим нейронную сеть с одним скрытым слоем, скалярным выходом и скалярным входом:\n\n$$\nf(x) = \\frac{1}{n} \\sum_{i=1}^n a_i \\phi(w_i x).\n$$\n\nЭто выражение можно представить в виде $f(x) = \\int_{\\mathbb{R}^2} a \\phi(w x) \\, d\\mu_n(a,w)$, где мера $\\mu_n$ на $\\mathbb{R}^2$ сосредоточена в весах, ассоциированных с каждым из нейронов скрытого слоя:\n\n$$\n\\mu_n(a,w) = \\frac{1}{n} \\sum_{i=1}^n \\delta_{a_i}(a) \\delta_{w_i}(w).\n$$\n\nЗдесь $\\delta_x$ – мера, сосредоточенная в $x$.\n    \nПри стремлении ширины $n$ к бесконечности $\\mu_n$ может иметь предел. Так, если все веса насемплированы независимо из стандартного нормального распределения $\\mathcal{N}(0,1)$, предельная мера принимает вид двумерного стандартного нормального распределения $\\mathcal{N}(0,I_{2\\times 2})$, а предсказание предельной сети можно записать в виде $f(x) = \\mathbb{E}_{a,w \\sim \\mathcal{N}(0,1)} a \\phi(w x)$.\n\nЗаметим, что множитель $1/n$ в определении модели выше принципиально важен для того, чтобы предельная мера и представление предельной сети в виде интеграла по мере были определены. Такая параметризация носит название **mean-field parameterization**.\n\nДинамику эволюции весов также можно представить в виде эволюции меры. В самом деле, в случае конечной ширины градиентный спуск говорит нам о том, как за один шаг оптимизации меняются веса, ассоциированные с каждым из нейронов, или, что то же самое, как меняется мера $\\mu_n$. Заменив в этом выражении меру $\\mu_n$ на предельную, можно получить эволюцию предельной меры.\n\nК сожалению, представление эволюции предельной сети в виде эволюции меры не даёт сказать много о свойствах предельной модели. Так, известно, что предельная модель всегда сходится в глобальный минимум на обучающей выборке, см статью [On the global convergence of gradient descent for over-parameterized models using optimal transport](https://arxiv.org/pdf/1805.09545.pdf), но мало что известно о её обобщающей способности.\n\nБолее того, лишь сети с одним скрытым слоем допускают простую формулировку в форме эволюции меры в пределе бесконечной ширины, см. статьи [Mean field analysis of neural networks: A central limit theorem](https://arxiv.org/pdf/1808.09372.pdf), [On the global convergence of gradient descent for over-parameterized models using optimal transport](https://arxiv.org/pdf/1805.09545.pdf) и [Trainability and accuracy of neural networks: An interacting particle system approach](https://arxiv.org/pdf/1805.00915.pdf). Для сетей с большим числом слоёв подобная формулировка также возможна, см. статьи [A mean-field limit for certain deep neural networks](https://arxiv.org/pdf/1906.00193.pdf) и [A rigorous framework for the mean field limit of multilayer neural networks](https://arxiv.org/pdf/2001.11443.pdf), но анализ усложняется.\n\nТак, сходимость в глобальный минимум для сети с двумя скрытыми слоями была доказана лишь совсем недавно в работе [Global convergence of three-layer neural networks in the mean field regime](https://arxiv.org/pdf/2105.05228.pdf); для более глубоких сетей подобные результаты пока неизвестны.\n\n### Второй способ – вместо эволюции весов рассматривать эволюцию предсказаний модели в каждой точке $x$\n\nДля простоты рассмотрим задачу минимизации квадратичной функции потерь на наборе данных $(\\vec x, \\vec y)$ размера $m$: \n\n$$\\frac{1}{2} \\sum_{j=1}^m (y_j - f(x_j; \\theta))^2 \\to \\min_\\theta.$$\n\nБудем оптимизировать эту функцию потерь градиентным спуском с шагом $\\eta$:\n\n$$\n\\theta_{k+1} - \\theta_k\n= -\\eta \\nabla_\\theta\\left(\\frac{1}{2} \\sum_{j=1}^m (y_j - f(x_j; \\theta_k))^2\\right)\n=\n$$\n\n$$\n=\\eta \\sum_{j=1}^m (y_j - f(x_j; \\theta_t)) \\nabla_\\theta f(x_j; \\theta_k).\n$$\n\nНиже нам будет удобнее рассматривать градиентный спуск с непрерывным временем вместо дискретного:\n\n$$\n\\dot\\theta_t\n= \\sum_{j=1}^m (y_j - f(x_j; \\theta_t)) \\nabla_\\theta f(x_j; \\theta_t).\n$$\n\nПереход к непрерывному времени соответствует устремлению к нулю шага $\\eta$, если при этом число шагов растёт как $k = [t / \\eta]$, где округление применяется в любую сторону.\n    \nОбозначим через $f_t(x)$ предсказание в точке $x$ модели в момент времени $t$. Оно зависит от времени следующим образом:\n\n$$\n\\dot f_t(x)\n= \\dot\\theta_t^T \\nabla f_t(x)\n= \\sum_{j=1}^m (y_j - f_t(x_j)) \\nabla_\\theta^T f_t(x_j) \\nabla_\\theta f_t(x).\n$$\n\nВведём обозначение:\n\n$$\n\\color{#348FEA}{\\hat\\Theta_t(x,x')\n= \\nabla_\\theta^T f_t(x) \\nabla_\\theta f_t(x').}\n$$\n\nС помощью него уравнение выше можно записать более коротко:\n\n$$\n\\dot f_t(x)\n= \\hat\\Theta_t(x,\\vec x) (\\vec y - f_t(\\vec x)).\n\\quad(1)\n$$\n\nЗдесь и дальше мы будем считать, что $\\hat\\Theta_t(x,\\vec x)$ имеет размерность $1 \\times m$.\n\nФункция $\\hat\\Theta_t(x,x')$ называется **эмпирическим нейрокасательным ядром** (**Neural Tangent Kernel**, **NTK**); подробнее о ядрах мы поговорим ниже в параграфе про ядровые методы.\n\nЗаметим, что в уравнении $(1)$ вся информация о весах содержится в ядре, которое является отображением из $\\mathbb{X} \\times \\mathbb{X}$ в $\\mathbb{R}$. Как мы увидим ниже, при определённых условиях, при стремлении ширины сети к бесконечности ядро имеет предел и он не зависит от $t$.\n\nОбозначив этот предел через $\\Theta$, мы приходим к следующему виду эволюции предсказаний бесконечно широкой сети:\n\n$$\n\\dot f_t(x)\n= \\Theta(x,\\vec x) (\\vec y - f_t(\\vec x)).\\quad(2)\n$$\n\nЗдесь и далее будем называть $\\Theta$ (не эмпирическим) **нейрокасательным ядром** или **NTK**. Такой термин был введён в оригинальной работе [Neural tangent kernel: Convergence and generalization in neural networks](https://arxiv.org/pdf/1806.07572.pdf).\n\nВ этом случае динамика предсказаний интегрируется следующим образом. На обучающей выборке\n\n$$\n\\dot f_t(\\vec x)\n= \\Theta(\\vec x,\\vec x) (\\vec y - f_t(\\vec x)),\n$$\n\nчто даёт\n\n$$\nf_t(\\vec x)\n= f_0(\\vec x) - \\left(I - e^{-\\Theta(\\vec x, \\vec x) t}\\right) (f_0(\\vec x) - \\vec y).\n$$\n\nПодставляя решение в $(2)$, получаем\n\n$$\n\\dot f_t(x)\n= \\Theta(x,\\vec x) e^{-\\Theta(\\vec x, \\vec x) t} (\\vec y - f_0(\\vec x)),\n$$\n\nи, наконец,\n\n$$\nf_t(x) \n= f_0(x) - \\Theta(x, \\vec x) \\Theta^{-1}(\\vec x, \\vec x) \\left(I - e^{-\\Theta(\\vec x, \\vec x) t}\\right) (f_0(\\vec x) - \\vec y).\\quad(3)\n$$\n\nПрежде, чем доказывать сходимость ядра, мы обсудим, как может применяться предельное ядро и представление эволюции предсказаний в форме (1).\n\n\n## Применение NTK-анализа\n\n### NTK как математический аппарат\n\nНам удалось проинтегрировать динамику предсказаний в явном виде. Что это даёт?\n\nВо-первых, мы получаем достаточное условие на сходимость в глобальный минимум на обучающей выборке. Таким условием является положительная определённость матрицы Грама ядра: $\\Theta(\\vec x,\\vec x) \\geq \\lambda_0$ для некоторого $\\lambda_0 > 0$.\n\nВ самом деле, в этом случае,\n\n$$\n\\frac{d}{dt}\\left(\\frac{1}{2} \\| \\vec y - f_t(\\vec x) \\|_2^2\\right)\n= -(\\vec y - f_t(\\vec x))^T \\Theta(\\vec x, \\vec x) (\\vec y - f_t(\\vec x))\n\\leq -\\lambda_0 \\| \\vec y - f_t(\\vec x) \\|_2^2,\n$$\n\nчто даёт\n\n$$\n\\| \\vec y - f_t(\\vec x) \\|_2^2\n\\leq e^{-\\lambda_0 t} \\| \\vec y - f_0(\\vec x) \\|_2^2\n\\to 0 \\quad \\text{при $t \\to \\infty$}.\n$$\n\nВо-вторых, раз явное решение известно, можно написать оценку на обобщающую способность.\n    \nОба этих результата опираются на то, что ядро постоянно. Как мы покажем ниже, постоянство нейрокасательного ядра нейронной сети можно гарантировать лишь в пределе бесконечной ширины. Тем не менее, если сеть конечна, но достаточно широка, можно показать, что её ядро достаточно близко к предельному, и оценки сохраняют силу.\n\nНапример, для обоснования сходимости в глобальный минимум достаточно показать, что наименьшее собственное значение эмпирического ядра с высокой вероятностью остаётся отделённым от нуля в течение обучения: $\\hat\\Theta_t \\geq \\lambda_0/2$ $\\forall t \\geq 0$ с вероятностью $\\geq 1-\\delta$ для $n \\geq n^*(\\delta)$. В самом деле, из этого следует, что\n\n$$\n\\frac{d}{dt}\\left(\\frac{1}{2} \\| \\vec y - f_t(\\vec x) \\|_2^2\\right)\n= -(\\vec y - f_t(\\vec x))^T \\hat\\Theta_t(\\vec x, \\vec x) (\\vec y - f_t(\\vec x))\n\\leq -\\frac{\\lambda_0}2 \\| \\vec y - f_t(\\vec x) \\|_2^2,\n$$\n\nа значит,\n\n$$\n\\| \\vec y - f_t(\\vec x) \\|_2^2\n\\leq e^{-\\lambda_0 t / 2} \\| \\vec y - f_0(\\vec x) \\|_2^2\n\\to 0 \\quad \\text{при $t \\to \\infty$}.\n$$\n\nФормальное доказательство вы можете найти в работе [Gradient Descent Provably Optimizes Over-parameterized Neural Networks](https://arxiv.org/pdf/1810.02054.pdf), а также в [конспекте лекций](https://arxiv.org/pdf/2012.05760.pdf) автора этого параграфа.\n\nВот ещё несколько результатов, полученных в этом направлении:\n\n* улучшенные оценки на минимальную ширину в работе [Quadratic suffices for over-parametrization via matrix chernoff bound](https://arxiv.org/pdf/1906.03593v1.pdf); \n* оценки для случая глубоких сетей в работе [Gradient descent finds global minima of deep neural networks](https://arxiv.org/pdf/1811.03804.pdf); \n* оценки на обобщающую способность, полученные через близость ядра к предельному, в работе [Fine-Grained Analysis of Optimization and Generalization for Overparameterized Two-Layer Neural Networks](https://arxiv.org/pdf/1901.08584.pdf).\n\n\n### Определение патологий обучения\n\nКак мы увидим позже, NTK реальных, стандартно параметризованных, имеющих конечную ширину сетей может меняться за время обучения существенным образом: см. эмпирическую работу [Deep learning versus kernel learning](https://arxiv.org/pdf/2010.15110.pdf) и теоретический анализ для сетей с одним скрытым слоем [Dynamically Stable Infinite-Width Limits of Neural Classifiers](https://arxiv.org/pdf/2006.06574.pdf).\n\nТем не менее, ядро в инициализации может выявить определённые патологии соответствующей нейронной сети. Рассмотрим один из примеров применения.\n\nВ некоторых состоящих из однородных блоков архитектурах (скажем, ResNet) можно увеличивать (и даже устремлять к бесконечности) число слоёв или блоков, и логично задаться вопросом о том, как при этом будет вести себя процесс обучения. \n\nНеобходимым условием обучаемости является хороший первый шаг обучения. Если он исчезающе мал, то сеть не обучится ни на первом, ни на каком-либо другом шаге. Если он слишком велик, то обучение разойдётся на первом же шаге. Как мы увидим ниже, индикатором проблем является плохая обусловленность NTK в инициализации. Например, его собственные значения могут с ростом глубины стремиться к нулю или, наоборот, к бесконечности. В первом случае какие-то из компонент выборки никогда не выучатся, во втором обучение невозможно ни при каком конечном темпе обучения.\n\nЧтобы в этом убедиться, рассмотрим разложение матрицы Грама ядра по собственным векторами: \n\n$$\\Theta(\\vec x, \\vec x) = \\sum_{j=1}^m \\lambda_j \\vec v_j \\vec v_j^T,$$\n\nгде $\\lambda_1 \\geq \\ldots \\geq \\lambda_m \\geq 0$, а векторы $\\vec v_1,\\ldots,\\vec v_m$ образуют ортонормированный базис. Разложим предсказание сети по этому базису: $f_t(\\vec x) = \\sum_{j=1}^m u_{t,j} \\vec v_j$. Так как базис ортонормированный, каждая из компонент эволюционирует независимо от других. В самом деле, для дискретного градиентного спуска с шагом $\\eta$ имеем\n\n$$\nu_{k+1,j}\n= u_{k,j} + \\eta \\lambda_j (\\vec v_j^T \\vec y - u_{t,j}).\n$$\n\nТаким образом, если $\\lambda_j=0$, то $u_{t,j}$ никогда не сойдётся к $\\vec v_k^T \\vec y$.\n\nКроме того, для того, чтобы процесс сходился, шаг $\\eta$ должен убывать обратно пропорционально наибольшему собственному числу $\\lambda_1$. Если последнее стремится к бесконечности, то $\\eta$ стремится к нулю, а значит, $\\eta \\lambda_j$ будем мало для всех $j$, для которых $\\lambda_j$ конечен; соответствующие компоненты также никогда не сойдутся.\n\nПодробности см. в работе [Rapid training of deep neural networks without skip connections or normalization layers using Deep Kernel Shaping](https://arxiv.org/pdf/2110.01765.pdf), а также в более ранних работах [Exponential expressivity in deep neural networks through transient chaos](https://arxiv.org/pdf/1606.05340.pdf), [Deep information propagation](https://arxiv.org/pdf/1611.01232.pdf), [Resurrecting the sigmoid in deep learning through dynamical isometry](https://arxiv.org/pdf/1711.04735.pdf), [Dynamical isometry and a mean field theory of cnns](https://arxiv.org/pdf/1806.05393.pdf), в которых использовалась похожая идея, но не использовалось понятие NTK явно. См. также главу про инициализацию в [конспекте лекций](https://arxiv.org/pdf/2012.05760.pdf).\n\n\n## NTK и Ядровые методы\n\nПредельное NTK нейронной сети можно использовать в любом ядровом методе, например, в SVM. Обсудим это поподробнее и заодно разберёмся, почему NTK вообще называют ядром.\n\nРассмотрим задачу линейной регрессии:\n\n$$\n\\hat\\theta_\\lambda\n= \\text{argmin}_{\\theta \\in \\mathbb{R}^d} \\sum_{j=1}^m \\mathcal{L}(y_j, \\theta^T x_j) + \\lambda \\| \\theta \\|_2^2\\quad(4)\n$$\n\nЭту же задачу можно эквивалентно переписать следующим образом:\n\n$$\n\\hat f_\\lambda\n= \\text{argmin}_{f \\in \\mathcal{H}} \\sum_{j=1}^m \\mathcal{L}(y_j, f(x_j)) + \\lambda \\| f \\|_\\mathcal{H}^2,\\quad(5)\n$$\n\nгде $\\mathcal{H}$ – пространство линейных отображений $f_{\\theta}(x) = \\theta^T x$ с некоторой нормой $\\| f \\|_\\mathcal{H}$ на нём. \n\nСделаем линейное пространство $\\mathcal{H}$ евклидовым, введя на нём следующее скалярное произведение. Для $f(x) = \\theta^T x$ и $\\tilde f(x) = \\tilde\\theta^T x$ определим\n\n$$\\langle f, \\tilde f \\rangle = \\theta^T \\tilde\\theta.$$\n\nЭто скалярное произведение порождает норму $\\| f \\|_\\mathcal{H} = \\| \\theta \\|_2$, что и делает формулировку (5) эквивалентной формулировке (4).\n\nПространство линейных моделей слишком узко, однако ничто не мешает нам рассмотреть задачу вида (5), в которой $\\mathcal{H}$ будет произвольным нормированным пространством функций. Наиболее хорошо изучен случай, когда функции из $\\mathcal{H}$ являются линейными моделями в некотором (возможно, бесконечномерном) гильбертовом пространстве признаков: $f(x) = \\langle \\Phi(x), \\theta \\rangle$, где $\\Phi$ отображает $x$ в это пространство. Если последнее всё же конечномерно, то мы можем использовать матричную запись $f(x) = \\theta^T \\Phi(x)$; элементы $\\theta$ в этой записи обычно называют первичными переменными (primal variables).\n\nПространство функций $\\mathcal{H}$ также оказывается гильбертовым: соответствующее скалярное произведение имеет вид \n\n$$\\langle f_{\\theta}, f_{\\theta'} \\rangle_\\mathcal{H} = \\langle \\theta, \\theta' \\rangle$$\n\n\nТаким образом, $\\| f_{\\theta} \\|_\\mathcal{H}^2 = \\langle f_{\\theta}, f_{\\theta} \\rangle_\\mathcal{H} = \\langle \\theta, \\theta \\rangle$, если $f_{\\theta}(x) = \\langle \\Phi(x), \\theta \\rangle$.\n\n\nЛюбому отображению $\\Phi$ можно сопоставить симметричную положительно-определённую функцию $K(x,x') = \\langle\\Phi^T(x), \\Phi(x')\\rangle$; функции такого вида называются ядрами.\n\nВ силу [фундаментальной теоремы о представителе](https://en.wikipedia.org/wiki/Representer_theorem) любое решение задачи (4) принимает вид \n\n$$f(x) = \\sum_{j=1}^m \\alpha_j K(x,x_j) = K(x, \\vec x) \\vec\\alpha.$$\n\nВ отличие от $\\theta$, вектор $\\alpha$ всегда конечномерен: его размерность равна размеру обучающей выборки. Элементы $\\alpha$ называют двойственными (dual) переменными.\n    \nУпомянутый результат позволяет перейти от минимизации $f$ в бесконечномерном пространстве функций (или, что то же самое, минимизации $\\theta$ в бесконечномерном пространстве признаков), к минимизации в конечномерном пространстве двойственных переменных:\n\n$$\n\\vec\\alpha\n= \\text{argmin}_{\\vec\\alpha \\in \\mathbb{R}^m} \\sum_{j=1}^m \\mathcal{L}\\left(y_j, K(x_j, \\vec x) \\vec\\alpha\\right) + \\lambda \\vec\\alpha^T K(\\vec x, \\vec x) \\vec\\alpha.\\quad(6)\n$$\n\nЕсли в качестве функции потерь взять квадратичную $\\mathcal{L}(y,z) = \\frac{1}{2} (y-z)^2$, то получим ядровую регрессию; если же взять hinge loss $\\mathcal{L}(y,z) = [1- yz]_+$, то SVM.\n    \nЗаметим, что двойственная задача полностью сформулирована в терминах ядра $K$: отображение в потенциально бесконечное пространство признаков $\\Phi$ более нигде не возникает. Поэтому мы можем использовать в качестве $K$ любую симметричную положительно определённую функцию двух переменных, не думая о том, для какого пространства признаков оно будет ядром (есть теорема, что такие функции всегда являются ядрами). Это может быть очень полезно. Так, если для эмпирического NTK в инициализации $\\hat\\Theta_0(x,x')$ имеем $\\Phi(x) = \\nabla_\\theta f(x; \\theta_0)$, но совершенно неочевидно, какое отображение $\\Phi$ соответствует предельному NTK: $\\Theta(x,x') = \\lim_{n \\to \\infty} \\hat\\Theta_0(x,x')$. \n    \nТаким образом, мы можем использовать $\\Theta$ в качестве ядра $K$ в двойственной задаче (6) наряду с линейным $K(x,x') = x^T x'$ или гауссовским ядром $K(x,x') = e^{-\\frac{1}{2\\sigma^2} \\|x-y\\|_2^2}$. Такой подход привлекателен тем, что обучение ядровых методов более устойчиво и имеет меньше гиперпараметров. При этом можно надеяться, что результат обучения ядрового метода с NTK в качестве ядра будет близок к результату обучения соответствующей нейронной сети.\n\nОсновная проблема ядровых методов в том, что они требуют вычисления матрицы Грама ядра на обучающем наборе данных $K(\\vec x, \\vec x)$. Её размер $m \\times m$ (где $m$ – размер выборки), так что применение ядровых методов на больших данных сильно усложняется. Более того, наивное вычисление динамики $f_t$ из формулы (3) требует обращения матрицы Грама, которое занимает $O(m^3)$ времени. \n\nТем не менее, определённые оптимизации существуют. Так например, в работе [Kernel methods through the roof](https://arxiv.org/pdf/2006.10350.pdf) предлагается способ приближённого вычисления ($f_t$) за $O(m^{3/2} \\log m)$ памяти и времени. Другие подходы см. в работах [Fast Finite Width Neural Tangent Kernel](https://arxiv.org/pdf/1806.07572.pdf) и [Neural tangents: Fast and easy infinite neural networks in python](https://arxiv.org/pdf/1912.02803.pdf).\n    \nТак или иначе, на малых наборах данных выражение (3) можно вычислить точно, см. результаты в работе [Harnessing the power of infinitely wide deep nets on small-data tasks](https://arxiv.org/pdf/1910.01663.pdf). Существуют также примеры задач, в которых матрицу Грама ядра достаточно посчитать только для малых $m$, см., например, [Simple, Fast, and Flexible Framework for Matrix Completion with Infinite Width Neural Networks](https://arxiv.org/pdf/2108.00131.pdf).\n\nЕщё одна проблема использования NTK в ядровых методах состоит в том, что явный подсчёт предельного NTK доступен только для сетей, состоящих из слоёв из определённого класса. В этот класс входят полносвязные и свёрточные слои, average pooling, ряд нелинейностей с одним аргументом (включая, например, ReLU и erf), layer norm, но не входят max pooling и batch norm, часто используемые в реальных архитектурах. Явный подсчёт предельного NTK для «хороших» сетей реализован в [библиотеке NeuralTangents](https://github.com/google/neural-tangents); часть явных формул для подсчёта можно найти в статье [On exact computation with an infinitely wide neural net](https://arxiv.org/pdf/1904.11955.pdf).\n\nТем не менее, даже в тех случаях, когда посчитать предельное NTK не представляется возможным, в качестве ядра для ядрового метода можно использовать эмпирическое NTK в инициализации \n\n$$\\hat\\Theta_0(x,x') = \\nabla^T_\\theta f(x;\\theta_0) \\nabla_\\theta f(x';\\theta_0)$$\n\nТакое ядро можно рассматривать как шумную и смещённую оценку предельного; для уменьшения шума можно использовать Монте-Карло оценку матожидания. Некоторые оптимизации подсчёта эмпирического ядра см. в работе [Neural tangents: Fast and easy infinite neural networks in python](https://arxiv.org/pdf/1912.02803.pdf).\n\nNTK не единственное ядро, которое можно сопоставить нейронной сети. Так, NNGP-ядро $K(x,x') = \\mathbb{E} f(x) f(x')$ – это ядро гауссовского процесса, реализуемого сетью в пределе бесконечной ширины. Подробнее можно почитать в работах [Deep Neural Networks as Gaussian Processes](https://arxiv.org/pdf/1711.00165.pdf), [Wide neural networks of any depth evolve as linear models under gradient descent](https://arxiv.org/pdf/1902.06720.pdf), [Random neural networks in the infinite width limit as Gaussian processes](https://arxiv.org/pdf/2107.01562.pdf) или в [конспекте лекций](https://arxiv.org/pdf/2012.05760.pdf). Можно показать, что оно соответствует NTK-ядру для сети, в которой учится лишь выходной слой.\n\nТак как, в отличие от NTK, для подсчёта NNGP-ядра не требуется обратный проход (backward pass), последнее более вычислительно эффективно; [Towards nngp-guided neural architecture search](https://arxiv.org/pdf/2011.06006.pdf) – пример работы, в которой предпочтение отдаётся NNGP-ядру именно по этой причине.\n\n## Сходимость эмпирического ядра\n\nВы этом параграфе мы покажем, что при определённой параметризации эмпирическое NTK не зависит ни от времени, ни от инициализации. Мы начнём с иллюстративного примера, прежде чем формулировать строгую теорему.\n\nРассмотрим сеть с одним скрытым слоем, скалярным выходом и гауссовской инициализацией весов; вход для простоты тоже положим скалярным:\n\n$$\nf(x; a_{1:n}, w_{1:n})\n= \\sum_{i=1}^n a_i \\phi(w_i x),\n\\quad\na_{1:n} \\sim \\mathcal{N}(0, n^{-1} I),\n\\quad\nw_{1:n} \\sim \\mathcal{N}(0, I).\n$$\n\nЗдесь $n$ – ширина скрытого слоя.\n\nСледуя одной из стандартных схем инициализации из статьи [Delving deep into rectifiers: Surpassing human-level performance on imagenet classification](https://arxiv.org/pdf/1502.01852.pdf), дисперсия каждого слоя выбирается обратно пропорционально числу входных нейронов (подробнее см. в параграфе про [тонкости обучения нейросетей](https://academy.yandex.ru/handbook/ml/article/tonkosti-obucheniya)).\n\nНазовём описанную выше параметризацию стандартной.\n\nДля сходимости ядра нам придётся несколько её видоизменить:\n\n$$\nf(x; a_{1:n}, w_{1:n})\n= \\frac{1}{\\sqrt{n}} \\sum_{i=1}^n a_i \\phi(w_i x),\n\\quad\na_{1:n} \\sim \\mathcal{N}(0, I),\n\\quad\nw_{1:n} \\sim \\mathcal{N}(0, I).\n$$\n\nНазовём новую параметризацию NTK-параметризацией.\n\nОтметим, что распределение выходов нейронов в инициализации остаётся неизменным при переходе от стандартной к NTK-параметризации. Что меняется – это динамика градиентного спуска:\n\n$$\n\\dot a_k \n= \\frac{1}{\\sqrt{n}} \\sum_{j=1}^m \\phi(w_k x_j)(y_j - f_t(x_j)),\n$$\n\n$$\n\\dot w_k\n= \\frac{1}{\\sqrt{n}} \\sum_{j=1}^m a_k \\phi'(w_k x_j) x_j(y_j - f_t(x_j)).\n$$\n\nПри $t=0$ приращения весов для такой параметризации имеют порядок $O(n^{-1/2})$, в то время как сами веса имеют порядок $O(1)$ при $t=0$. Поэтому $a_k(t) \\to a_k(0)$ и $w_k(t) \\to w_k(0)$ при $n \\to \\infty$ для любого данного $k \\in \\mathbb{N}$ и $t \\in \\mathbb{R}_+$. Другими словами, с ростом размера скрытого слоя градиент будет стремиться к нулю, и каждый из весов в пределе останется в начальной точке.\n\nСравним с градиентным спуском в стандартной параметризации:\n\n$$\n\\dot a_k \n= \\sum_{j=1}^m \\phi(w_k x_j)(y_j - f_t(x_j)),\n$$\n\n$$\n\\dot w_k \n= \\sum_{j=1}^m a_k \\phi'(w_k x_j) x_j(y_j - f_t(x_j))\n$$\n\nВ этом случае веса выходного слоя имеют порядок $O(n^{-1/2})$ при $t=0$, но получают приращения порядка $O(1)$ в этот момент времени, в то время как веса входного слоя имеют порядок $O(1)$ при $t=0$, но получают в этот момент времени приращения порядка $O(n^{-1/2})$.\n\nВ новой параметризации эмпирическое NTK выглядит следующим образом:\n\n$$\n\\hat\\Theta_t(x,x')\n= \\sum_{i=1}^n \\left(\\partial_{a_i} f(x) \\partial_{a_i} f(x') + \\partial_{w_i} f(x) \\partial_{w_i} f(x')\\right)\n=\n$$\n\n$$      \n= \\frac{1}{n} \\sum_{i=1}^n \\left(\\phi(w_i(t) x) \\phi(w_i(t) x') + a_i^2(t) \\phi'(w_i(t) x) \\phi'(w_i(t) x') x x'\\right).\n$$\n\nТак как $a_k(t) \\to a_k(0)$ и $w_k(t) \\to w_k(0)$ при $n \\to \\infty$ для любых заданных $k \\in \\mathbb{N}$ и $t \\in \\mathbb{R}_+$, выражение выше асимптотически эквивалентно\n\n$$\n\\hat\\Theta_0(x,x')\n= \\frac{1}{n} \\sum_{i=1}^n \\left(\\phi(w_i(0) x) \\phi(w_i(0) x') + a_i^2(0) \\phi'(w_i(0) x) \\phi'(w_i(0) x') x x'\\right),\n$$\n\nа значит, сходится к\n\n$$\n\\Theta(x,x')\n= \\mathbb{E}_{a,w \\sim \\mathcal{N}(0,1)} \\left(\\phi(w x) \\phi(w x') + a^2 \\phi'(w x) \\phi'(w x') x x'\\right)\n$$\n\nпри $n \\to \\infty$ в силу закона больших чисел.\n\nПредельное ядро $\\Theta(x,x')$ не зависит ни от времени $t$, ни от инициализации. Мы будем называть это ядро **нейрокасательным** или просто **NTK** (его не стоит путать с эмпирическим NTK $\\hat\\Theta_t$).\n\nЕщё раз подчеркнём, что это работает для NTK-параметризации, но не для стандартной. Для стандартной параметризации эмпирическое NTK в инициализации расходится с шириной:\n\n$$\n\\hat\\Theta_0(x,x')\n= \\sum_{i=1}^n \\left(\\phi(w_i(0) x) \\phi(w_i(0) x') + a_i^2(0) \\phi'(w_i(0) x) \\phi'(w_i(0) x') x x'\\right)\n\\sim\n$$\n\n$$\n\\sim n \\cdot \\mathbb{E}_{w \\sim \\mathcal{N}(0,1)} \\phi(w x) \\phi(w x').\n$$\n\nПодробнее мы поговорим об этом в одном из следующих параграфов.\n\nДля NTK-параметризации сходимость эмпирического ядра выполняется не только для сетей с одним скрытым слоем. Так, рассмотрим полносвязную сеть с $L$ слоями:\n\n$$\nf(x) = h_L(x),\n\\quad\nh_l(x) = \\frac{1}{\\sqrt{n_{l-1}}} W_l x_{l-1}(x),\n\\quad\nx_{l-1}(x) = \\phi(h_{l-1}(x)),\n\\quad\nx_0(x) = x.\n$$\n\nЗдесь $W_1 \\in \\mathbb{R}^{n_1 \\times n_0}$, $W_L \\in \\mathbb{R}^{1 \\times n_{L-1}}$ и $W_l \\in \\mathbb{R}^{n_l \\times n_{l-1}}$ для всех остальных $l$. \n\nПоложим, что веса инициализируются из стандартного нормального распределения. Поставим задачу оптимизации дифференцируемой функции потерь $\\mathcal{L}$:\n\n$$\n\\dot\\theta_t\n= -\\nabla_\\theta\\left(\\sum_{j=1}^m \\mathcal{L}(y_j, f(x_j; \\theta_t))\\right)\n= \\sum_{j=1}^m \\left.\\frac{\\partial \\mathcal{L}(y_j, z)}{\\partial z}\\right|_{z=f(x_j; \\theta_t)} \\nabla_\\theta f(x_j; \\theta_t),\n$$\n\nгде $\\theta$ – объединение всех весов $W_{1:L}$ сети.\n\nТеорема ниже доказана в [оригинальной работе по NTK](https://arxiv.org/pdf/1806.07572.pdf):\n\n**Теорема**. В предположениях выше, если $\\phi$ из $C^2$ и липшицева и $\\mathcal{L}$ из $C^1$ и липшицева, то $\\hat\\Theta_t(x,x')$ сходится к $\\Theta(x,x')$ по вероятности при $n_{1:L-1} \\to \\infty$ последовательно $\\forall x,x' \\in \\mathbb{X}$ $\\forall t \\geq 0$.\n\nОказывается, что эта теорема верна не только для полносвязных сетей с гладкими активациями.\n\nОпределим **тензорную программу** как начальный набор переменных определённых типов и последовательность команд. Каждая команда порождает новую переменную, действуя на уже имеющиеся.\n\nПеременные бывают трёх типов:\n\n* $\\mathsf{A}$: $n \\times n$ матрицы с независимыми элементами из $\\mathcal{N}(0,1)$;\n* $\\mathsf{G}$: вектора размера $n$ с асимптотически независимыми нормальными элементами;\n* $\\mathsf{H}$: образы $\\mathsf{G}$-переменных относительно поэлементных нелинейностей.\n\nДля переменной $W$ запись $W: \\mathsf{A}$ будет означать, что $W$ имеет тип $\\mathsf{A}$.\n\nКоманды бывают следующие:\n\n* trspop: $W: \\mathsf{A} \\to W^T: \\mathsf{A}$ (перевести переменную типа $\\mathsf{A}$ со значением $W$ в переменную типа $\\mathsf{A}$ со значением $W^T$);\n*  matmul: $(W: \\mathsf{A}, \\ x: \\mathsf{H}) \\to \\frac{1}{\\sqrt{n}} W x: \\mathsf{G}$;\n*  lincomb: $(\\{x_i: \\mathsf{G}, \\; a_i \\in \\mathbb{R}\\}_{i=1}^k) \\to \\sum_{i=1}^k a_i x_i: \\mathsf{G}$;\n* nonlin: $(\\{x_i: \\mathsf{G}\\}_{i=1}^k, \\; \\phi: \\mathbb{R}^k \\to \\mathbb{R}) \\to \\phi(x_{1:k}): \\mathsf{H}$ (здесь мы несколько выходных векторов $x_i$ агрегируем в один с помощью покоординатной, возможно, нелинейной функции).\n\nФормализм тензорных программ позволяет представить прямой и обратный проход широкого класса нейронных архитектур, который включает свёрточные сети, рекуррентные сети, сети с residual слоями. Хотя и ни одна из операций выше не может порождать новые $\\mathsf{A}$-переменные (веса), любое наперёд заданное число шагов градиентного спуска можно представить в рамках одной тензорной программы (посредством «развёртывания» шагов градиентного спуска).\n    \nНазовём величину $n$ шириной тензорной программы.\nОсновная «предельная» теорема тензорных программ представлена ниже:\n\n**Master theorem** (G. Yang, [Tensor programs III: Neural matrix laws](https://arxiv.org/pdf/2009.10685.pdf)). Рассмотрим тензорную программу с $M$ $\\mathsf{G}$-величинами, удовлетворяющую определённым начальным условиям. Пусть все нелинейности $\\phi$ и функция $\\psi: \\, \\mathbb{R}^M \\to \\mathbb{R}$ полиномиально ограничены. Тогда\n\n$$\n\\frac{1}{n} \\sum_{\\alpha=1}^n \\psi(g^1_\\alpha,\\ldots,g^M_\\alpha)\n\\to \\mathbb{E}_{Z \\sim \\mathcal{N}(\\mu,\\Sigma)} \\psi(Z)\n$$\n\nпочти наверное при $n \\to \\infty$, где $\\mu$ и $\\Sigma$ могут быть вычислены по некоторым рекурентным правилам.\n\nОказывается, что если тензорная программа выражает прямой и обратной проход в некоторой нейронной сети, то NTK сети в инициализации всегда можно представить в виде $\\frac{1}{n} \\sum_{\\alpha=1}^n \\psi(g^1_\\alpha,\\ldots,g^M_\\alpha)$ для некоторой функции $\\psi$, см. [Tensor programs II: Neural tangent kernel for any architecture](https://arxiv.org/pdf/2006.14548.pdf).Таким образом, теорема выше доказывает существование и детерминированность предельного ядра в инициализации, а также даёт способ его вычисления. Более того, это верно и для ядра в любой фиксированный момент времени, см. [Tensor Programs IIb](https://arxiv.org/pdf/2105.03703.pdf).\n\nВ качестве иллюстрации обратимся вновь к сети с одним скрытым слоем. Рассмотрим тензорную программу, вычисляющую прямой и обратный проходы на входах $x$ и $x'$. Такая программа порождает следующие $\\mathsf{G}$-величины: $g^1 = w(0) x$, $g^2 = w(0) x'$, $g^3 = a(0) x$ и $g^4 = a(0) x'$. Напомним, что эмпирическое NTK равно\n\n$$\n\\hat\\Theta_0(x,x')\n= \\frac{1}{n} \\sum_{i=1}^n \\left(\\phi(w_i(0) x) \\phi(w_i(0) x') + a_i^2(0) \\phi'(w_i(0) x) \\phi'(w_i(0) x') x x'\\right).\n$$\n\nПоложив \n\n$$\\psi(g^1_\\alpha,\\ldots,g^4_\\alpha) = \\phi(g^1_\\alpha) \\phi(g^2_\\alpha) + \\phi'(g^1_\\alpha) \\phi'(g^2_\\alpha) g^3_\\alpha g^4_\\alpha,$$\n\nполучим выражение как раз в виде, требуемом Master Theorem.\n\n\n## Стандартная параметризация и эволюция ядра\n\nКак было отмечено в предыдущем параграфе, эмпирическое NTK двухслойной сети расходится с шириной при стандартной параметризации.\n\n$$\n\\hat\\Theta_t(x,x')\n= \\sum_{i=1}^n \\left(\\phi(w_i(t) x) \\phi(w_i(t) x') + a_i^2(t) \\phi'(w_i(t) x) \\phi'(w_i(t) x') x x'\\right).\n$$\n\nПри $t=0$, так как $w_i$ независимы и имеют порядок $O(1)$, сумма расходится пропорционально $n$.Так как для квадратичной функции потерь $\\dot f_t(x) = \\hat\\Theta_t(x,\\vec x) (\\vec y - f_t(\\vec x))$, предсказание модели в любой точке $x$ получает приращение порядка $O(n)$ на первом же шаге обучения; для задачи регрессии такая модель теряет смысл.\n\nОднако для классификации величина предсказаний не играет роли: для бинарной классификации важен лишь знак, а для многоклассовой – индекс максимального логита. Таким образом, в этом случае, несмотря на расходящееся ядро, предел при бесконечной ширине имеет смысл, см. [Dynamically Stable Infinite-Width Limits of Neural Classifiers](https://arxiv.org/pdf/2006.06574.pdf).\n\nРассмотрим нормализованное эмпирическое NTK $\\tilde\\Theta_t(x,x') = \\hat\\Theta_t(x,x') / n$. Его предел в инициализации равен $\\mathbb{E}_{w \\sim \\mathcal{N}(0,1)} \\phi(w x) \\phi(w x')$. Назовём этот предел нормализованным NTK и обозначим $\\tilde\\Theta(x,x')$.\n\nВ отличие от ядра в NTK-параметризации, нормализованное NTK при стандартной параметризации зависит от времени:\n\n$$\n\\frac{d\\tilde\\Theta_t(x,x')}{dt}\n= \\frac{1}{n} \\sum_{i=1}^n \\left(\\phi(w_i(t) x) \\phi'(w_i(t) x') x' + \\phi'(w_i(t) x) \\phi(w_i(t) x') x\\right) \\frac{dw_i(t)}{dt} \n+\n$$\n\n$$      \n\\phantom{\\frac{d\\tilde\\Theta_t(x,x')}{dt}}\n+ \\frac{1}{n} \\sum_{i=1}^n a_i^2(t) x x' \\left(\\phi'(w_i(t) x) \\phi''(w_i(t) x') x' + \\phi''(w_i(t) x) \\phi'(w_i(t) x') x\\right) \\frac{dw_i(t)}{dt}\n+\n$$\n\n$$\n\\phantom{\\frac{d\\tilde\\Theta_t(x,x')}{dt}}\n+ \\frac{1}{n} \\sum_{i=1}^n 2 a_i(t) \\phi'(w_i(t) x) \\phi'(w_i(t) x') x x' \\frac{da_i(t)}{dt}.\n$$\n\nНапомним, как выглядит градиентный спуск в стандартной параметризации:\n\n$$\n\\frac{a_k(t)}{dt} \n= \\sum_{j=1}^m \\phi(w_k(t) x_j),\n\\quad\n\\frac{w_k(t)}{dt} \n= \\sum_{j=1}^m a_k(t) \\phi'(w_k(t) x_j) x_j.\n$$\n\nПри $t=0$, $\\dot a_k = O(1)$, в то время как $\\dot w_k = O(n^{-1/2})$. Так как $a_k(0) = O(n^{-1/2})$ и $w_k(0) = O(1)$, для любого $t > 0$, не зависящего от $n$, $a_k(t) = O(1)$, $\\dot a_k(t) = O(1)$, $w_k(t) = O(1)$ и $\\dot w_k(t) = O(1)$.\n\nНаивная оценка сумм даёт $\\frac{d\\tilde\\Theta_t(x,x')}{dt} = O(1) + O(1) + O(1) = O(1)$ для любого $t > 0$, не зависящего от $n$. Таким образом, нормализованное ядро зависит от времени даже в пределе бесконечной ширины. Экспериментальный анализ эволюции ядра реальной нейронной сети в стандартной параметризации см. в работе [Deep learning versus kernel learning](https://arxiv.org/pdf/2010.15110.pdf).\n    \nПреимущество нейронных сетей над ядровыми методами, в том числе с NTK, может быть связано, в частности, с зависимостью предельного ядра от времени. В самом деле, ядро измеряет «похожесть» в некотором пространстве признаков. Для NTK это пространство фиксировано, в то время как нейронная сеть меняет своё ядро по ходу обучения, возможно, делая его более подходящим для задачи.",
        "handbook": "Учебник по машинному обучению",
        "title": "Сети бесконечной ширины",
        "description": "Сети бесконечной ширины"
    },
    {
        "path": "/handbook/ml/article/landshaft-funkcii-poter",
        "content": "Задача обучения параметрической модели $f_\\theta$ ставится как задача минимизации эмпирического риска \n\n$$\\hat R_m(\\theta) = \\mathbb{E}_{x,y \\in S_m} r(y, f_\\theta(x)),$$\n\nгде $S_m$ – выборка размера $m$, а $r$ – функция риска, например, $r(y, \\hat{y}) = \\mathbb{I}[y \\neq \\hat y]$. Часто интересующая нас функция риска не дифференцируема по второму аргументу, что делает градиентную оптимизацию неприменимой. По этой причине вместо исходной функции риска $r$ вводят её дифференцируемый выпуклый суррогат, то есть некоторую выпуклую и дифференцируемую по второму аргументу функцию $\\ell \\geq r$. Новый функционал эмпирического риска имеет вид\n\n$$\\hat{\\mathcal{L}}_m(\\theta) = \\mathbb{E}_{x,y \\in S_m} \\ell(y, f_\\theta(x)).$$\n\nЕсли $f_\\theta$ дифференцируема по $\\theta$, то из дифференцируемости $\\ell$ следует дифференцируемость $\\hat{\\mathcal{L}}_m$, что делает возможной градиентную оптимизацию. А если $f_\\theta$ выпукла по $\\theta$, то из выпуклости $\\ell$ следует выпуклость $\\hat{\\mathcal{L}}_m$, что даёт гарантии на сходимость градиентного спуска в глобальный минимум.\n\nУвы, в общем случае нейронные сети не выпуклы как функции своих весов. Это можно увидеть на простом примере. Пусть $f_\\theta(x) = u v x$, где $u$, $v$ и $x$ – скаляры, а $\\theta = (u,v)$. Гессиан $f$ как функции $\\theta$ в любой точке равен $\\binom{0 \\; x}{x \\; 0}$; его собственные числа равны $x$ и $(-x)$, что и означает, что для любого ненулевого $x$ функция $f$ не выпукла.\n\nТаким образом, даже для выпуклой $\\ell$ функция потерь $\\hat{\\mathcal{L}}_m$ нейронной сети не обязана быть выпуклой функцией весов.\n\nУ невыпуклых функций могут быть минимумы, не являющиеся глобальными, в которых может «застревать» градиентный спуск. Тем не менее, на практике часто оказывается, что градиентный спуск всегда находит точку со сколь угодно близким к глобальному минимуму значением функции потерь.\n\nЭто наблюдение приводит к гипотезе, что, хотя поверхность функции потерь не обязана быть выпуклой, все её минимумы глобальны для используемых нами сетей и тех наборов данных, на которых мы их обучаем.\n\nИзвестны два случая, для которых эту гипотезу удаётся доказать. Первый – это линейные сети. Второй – это достаточно широкие нелинейные сети (ширина одного из слоёв не меньше числа примеров в выборке). К сожалению, оба примера нереалистичны: выразительная способность линейных сетей не выше, чем у обыкновенной линейной модели, а ширина реальных нейронных сетей не настолько велика (порядка $10^3$ нейронов против $10^6$ примеров в ImageNet), причём улучшить оценку на ширину в общем случае невозможно, см. Q. Nguyen [A note on connectivity of sublevel sets in deep learning](https://arxiv.org/pdf/2101.08576.pdf). Возможно, для получения лучших оценок исследователям предстоит научиться учитывать структуру данных обучающей выборки.\n\nИсторически первое доказательство глобальности всех локальных минимумов линейной сети содержится в работе [Deep learning without poor local minima](https://arxiv.org/pdf/1605.07110.pdf). Более простое доказательство в немного более общем случае можно найти в работе [Depth creates no bad local minima](https://arxiv.org/pdf/1702.08580v1.pdf). Ещё более простое доказательство есть в работе [Deep linear networks with arbitrary loss: All local minima are global](https://arxiv.org/pdf/1712.01473.pdf), но оно подходит только для сетей без боттлнеков ($n_l \\geq \\min(n_0,n_{L+1})$ $\\forall l \\in 1,\\ldots,L$). Последнее подробно разобрано в [конспекте лекций](https://arxiv.org/pdf/2012.05760.pdf) автора этого параграфа.\n\nЗдесь мы разберём только второй случай (достаточно широкие нелинейные сети) как потенциально более перспективный.\n\n## Все минимумы достаточно широкой нелинейной сети глобальны\n\nРассмотрим нейронную сеть с одним скрытым слоем:\n\n$$\nf(x) = W_1 x_1(x) \\in \\mathbb{R}^{n_2},\n\\quad\nx_1(x) = \\phi(h_1(x)) \\in \\mathbb{R}^{n_1},\n\\quad\nh_1(x) = W_0 x \\in \\mathbb{R}^{n_1},\n\\quad\nx \\in \\mathbb{R}^{n_0},\n$$\n\nгде функция активации $\\phi$ применяется поэлементно. Рассмотрим набор данных $(X,Y)$ размера $m$, где $X \\in \\mathbb{R}^{n_0 \\times m}$, а $Y \\in \\mathbb{R}^{n_2 \\times m}$. Применяя соотношения выше к этому набору, получим следующие значения выходов слоёв:\n\n$$\n\\hat Y = W_1 X_1 \\in \\mathbb{R}^{n_2 \\times m},\n\\quad\nX_1 = \\phi(H_1) \\in \\mathbb{R}^{n_1 \\times m},\n\\quad\nH_1 = W_0 X \\in \\mathbb{R}^{n_1 \\times m},\n\\quad\nX \\in \\mathbb{R}^{n_0 \\times m}.\n$$\n\nПоставим задачу оптимизации квадратичной функции потерь \n\n$$\\mathcal{L}(W_{0:1}) = \\vert\\vert Y - \\hat Y \\vert\\vert_F^2 \\to \\min_{W_{0:1}},$$\n\nгде $\\vert\\vert\\cdot\\vert\\vert_F$ – норма Фробениуса.\n\n**Теорема 1** ([On the local minima free condition of backpropagation learning](https://ieeexplore.ieee.org/document/410380)) Если $\\phi$ аналитична, ограничена и не тождественно равна нулю, ширина скрытого слоя $n_1$ не меньше $m$ и все столбцы матрицы $X$ различны, то все локальные минимумы $\\mathcal{L}(W_{0:1})$ глобальны.\n\n\n**Доказательство**. Пусть $W_{0:1}^*$ – локальный минимум $\\mathcal{L}(W_{0:1})$, и пусть $H_1^*$, $X_1^*$ – соответствующие ему скрытые представления. Тогда $W_1^*$ – локальный минимум $\\mathcal{L}_{W_0^*}(W_1) = \\vert\\vert Y - W_1 X_1^* \\vert\\vert_F^2$.\n\nЗадача оптимизации $\\mathcal{L}_{W_0^*}(W_1)$ выпуклая, поэтому $W_1^*$ – глобальный минимум $\\mathcal{L}_{W_0^*}(W_1)$.\n\nЕсли $\\text{rk} X_1^* = m$, то система $Y_i = W_{1,i} X_1^*$, где $W_{1,i}$ – неизвестная матрица, гарантировано имеет решение для каждого $i \\in 1\\ldots,n_2$. Следовательно, \n\n$$\\mathcal{L}(W_{0:1}^*) = \\mathcal{L}_{W_0^*}(W_1^*) = \\min \\mathcal{L}_{W_0^*}(W_1) = 0,$$\n\nа значит, $W_{0:1}^*$ – глобальный минимум $\\mathcal{L}(W_{0:1})$.\n\nЗаметим, что для выполнения равенства $\\text{rk} X_1^* = m$ необходимо $n_1 \\geq m$.\n\nПусть теперь $\\text{rk} X_1^* < m$. Если тем не менее $\\min \\mathcal{L}_{W_0^*}(W_1^*) = 0$, то $W_{0:1}^*$ – по-прежнему глобальный минимум $\\mathcal{L}(W_{0:1})$. Пусть \n\n$$\\mathcal{L}(W_{0,1}^*) = \\mathcal{L}_{W_0^*}(W_1^*) = \\min \\mathcal{L}_{W_0^*}(W_1) > 0.$$\n\nДокажем, что $W_{0,1}^*$ не может быть локальным минимумом $\\mathcal{L}$ до тех пор, пока выполнены условия следующей леммы, которую мы докажем позже:\n\n**Лемма 1**. Если $n_1 \\geq m$, функция $\\phi$ аналитична, ограничена и не тождественно равна нулю, а все столбцы матрицы $X$ различны, то лебегова мера множества $\\{W_0 \\in \\mathbb{R}^{n_1 \\times n_0}: \\; \\text{rk} X_1 < m\\}$ равна нулю.\n\nТак как $\\mathcal{L}(W_{0,1}^*) > 0$ и $\\mathcal{L}$ – непрерывна как функция от $W_{0,1}$, существует $\\epsilon > 0$, для которого\n\n$$\\forall W_{0,1} \\in B_\\epsilon(W_{0,1}^*):\\quad\\mathcal{L}(W_{0,1}) > 0,$$\n\nгде через $B_\\epsilon(W_{0,1}^*)$ мы обозначили $\\epsilon$-окрестность точки $W_{0,1}^*$ в пространстве весов.\n\nИз леммы 1 следует, что для любого $\\delta > 0$ найдётся $W_0' \\in B_\\delta(W_0^*)$, для которого $\\text{rk} X_1' = m$. Возьмём $\\delta \\in (0,\\epsilon)$. Для соответствующего $W_0'$ имеем $\\mathcal{L}(W_0',W_1^*) > 0$; при этом $\\text{rk} X_1' = m$. Как было отмечено выше, задача минимизации $\\mathcal{L}_{W_0'}(W_1)$ выпуклая, и оптимум её равен нулю, так как $\\text{rk} X_1' = m$. Поэтому градиентный спуск, применённый к $\\mathcal{L}_{W_0'}$ и стартующий в $W_1^*$, сойдётся в некоторую точку $W_1^{*,\\prime}$, для которой $\\mathcal{L}_{W_0'}(W_1^{*,\\prime}) = 0$.\n\nМы знаем, что в нашей эпсилон-окрестности функция потерь положительна, значит, найденная точка находится вне её: $(W_0',W_1^{*,\\prime}) \\notin B_\\epsilon(W_{0,1}^*)$.\n\nТаким образом, найдётся $\\epsilon > 0$ такое, что для любых $\\delta \\in (0,\\epsilon)$ существует пара $(W_0',W_1^*) \\in B_\\delta(W_{0,1}^*)$ такая, что градиентный спуск, примененный к $\\mathcal{L}$, стартующий в $(W_0',W_1^*)$ и действующий только на $W_1$, сходится в точку $(W_0',W_1^{*,\\prime}) \\notin B_\\epsilon(W_{0,1}^*)$.\n\nОчевидно, что если «для любых $\\delta \\in (0,\\epsilon)$» заменить на «для любых $\\delta > 0$», утверждение выше останется верным. Это означает, что динамика градиентного спуска, действующего только на $W_1$, не устойчива по Ляпунову в точке $W_{0,1}^*$. Следовательно, $W_{0,1}^*$ не может быть точкой минимума (иначе градиентный спуск был бы устойчив), а значит, условие $\\mathcal{L}(W_{0,1}^*) > 0$ невыполнимо в условиях леммы 1. Таким образом, все локальные минимумы $\\mathcal{L}$ глобальны. **Теорема 1 доказана**.\n\n**Доказательство леммы 1**. Пусть $I_m$ – наборов индексов из $1,\\ldots,n_1$ длины $m$. Рассмотрим $X_{1,I_m} \\in \\mathbb{R}^{m \\times m}$ – подматрицу матрицы $X_1$, состоящую из строк $X_1$, проиндексированных набором $I_m$. В терминах $I_m$ условие $\\text{rk} X_1 < m$ эквивалентно $\\det X_{1,I_m} = 0$ $\\forall I_m$.\n\nТак как $\\phi$ аналитична, а определитель – аналитическая функция элементов матрицы, $\\det X_{1,I_m}$ – аналитическая функция от $W_0$ для любого $I_m$.\n\nНам понадобится следующая лемма, доказательство которой вы можете найти в [The loss surface of deep and wide neural networks](https://arxiv.org/pdf/1704.08045.pdf) (лемма 4.3):\n\n**Лемма 2.** В условиях леммы 1, найдётся $W_0$, для которого $\\text{rk} X_1 = m$.\n\nИз леммы 2 и эквивалентности выше следует, что найдётся $W_0$, такой что для некоторого $I_m$ имеет место неравенство $\\det X_{1,I_m} \\neq 0$. Так как определитель $X_{1,m}$ – аналитическая функция $W_0$, а всякая не тождественно нулевая аналитическая функция принимает значение ноль лишь на множестве меры ноль по Лебегу, то лебегова мера множества $\\{W_0: \\; \\det X_{1,I_m} = 0\\}$ равна нулю. Таким образом, **лемма 1 доказана**.\n\n## Обобщения\n\nПри доказательстве теоремы 1 мы воспользовались следующими условиями:\n\n* Все обучающие примеры (столбцы матрицы $X$) различны;\n* Число скрытых слоёв $L$ равно одному;\n* Ширина (последнего) скрытого слоя не меньше числа примеров: $n_L \\geq m$;\n* Функция активации $\\phi$ аналитична, ограничена и не тождественно равна нулю;\n* Функция ошибки квадратична.\n\nМожем ли мы ослабить какие-то из них?\n\nЕсли какие-то из примеров совпадают и соответствующие метки также одинаковы, теорема обобщается тривиально. Если же метки не совпадают, то нулевая ошибка, вообще говоря, недостижима. Тем не менее, доказательство меняется по большому счёту лишь в том, что вместо $m$ будет фигурировать число различных примеров.\n\nРассмотрим сеть с $L$ скрытыми слоями, действующую на набор данных $X_0$ размера $m$:\n\n$$\n\\hat Y = W_L X_L \\in \\mathbb{R}^{n_{L+1} \\times m},\n\\quad\nX_l = \\phi(H_l) \\in \\mathbb{R}^{n_l \\times m},\n\\quad\nH_l = W_{l-1} X_{l-1} \\in \\mathbb{R}^{n_l \\times m} \\quad \\forall l \\in [L],\n\\quad\nX_0 \\in \\mathbb{R}^{n_0 \\times m}.\n$$\n\nДля обобщения теоремы 1 на глубокие сети с широким последним скрытым слоем, достаточно обобщить лемму 1. Например, можно воспользоваться следующим результатом (лемма 4.4 из [The loss surface of deep and wide neural networks](https://arxiv.org/pdf/1704.08045.pdf))\n\n**Лемма 3**. Пусть $\\phi$ аналитична, ограничена и не тождественно равна нулю, и пусть $l \\in 1,\\ldots,L$. Тогда если $n_l \\geq m$ и все строки матрицы $X_0$ различны, то лебегова мера множества $\\{W_{0:l-1}: \\; \\text{rk} X_l < m\\}$ равна нулю.\n\nТретье предположение можно попытаться ослабить с двух сторон.\n\nВо-первых, можно требовать меньшего числа нейронов в скрытом слое. В общем случае этот подход не работает: в статье [A note on connectivity of sublevel sets in deep learning](https://arxiv.org/pdf/2101.08576.pdf) доказывается, что $m$ – это наименьшая ширина, при которой теорема выполняется для набора данных общего вида с различными примерами. Тем не менее, для реальных нейронных сетей градиентный спуск нередко находит глобальный минимум, хотя их ширина часто гораздо меньше размера набора данных, на которых они обучаются. Возможно, оценки на минимальную ширину удастся улучшить, если учесть структуру данных: например, если все примеры разбиваются на подмножества с элементами, находящимися близко друг к другу и имеющими одинаковые метки.\n\nВо-вторых, можно предположить, что самым широким является не последний скрытый слой, а один из промежуточных: $n_l \\geq m$ для некоторого $l < L$. Но тогда задача $\\mathcal{L}_{W_{0:l-1}^*}(W_{l:L})$ не выпукла, а значит, из $\\text{rk} X_l^* = m$ не следует, что $\\mathcal{L}(W_{0:L}^*) = 0$, и градиентный спуск, действующий на $W_{l:L}$, не обязан сходиться в точку, в которой $\\mathcal{L} = 0$ (он может застрять в локальном минимуме). Тем не менее, поставив ряд дополнительных условий, теорему 1 можно обобщить:\n\n**Теорема 2**. Пусть $W_{0:L}^{\\ast}$ – локальный минимум $\\mathcal{L}(W_{0:L}) = \\| \\hat Y - Y \\|_F^2$ и выполнены следующие условия:\n\n1. $\\phi$ аналитична, ограничена, не тождественно равна нулю;\n2. производная $\\phi$ нигде не обращается в ноль;\n3. $n_l \\geq m$;\n4. $\\text{rk} W_{l'}^* = n_{l'+1}$ $\\forall l' \\in \\{l+1,\\ldots,L\\}$;\n5. $\\det(\\nabla^2_{W_{l+1:L}} \\mathcal{L}(W_{0:L}^*)) \\neq 0$.\n\nТогда $W_{0:L}^*$ – глобальный минимум $\\mathcal{L}(W_{0:L})$.\n\nУсловие 4 необходимо, чтобы из $\\text{rk} X_l^* = m$ следовало $\\mathcal{L}(W_{0:L}^*) = 0$. Отметим, что из условия 4 также следует, что $n_l \\geq n_{l+1}$ $\\forall l' > L$, то есть нейронная сеть должна сужаться, начиная со следующего после самого широкого слоя.\n\nУсловие 5 необходимо, чтобы в случае $\\text{rk} X_l^* < m$ построить малое возмущение минимума $W_{0:L}^*$, которое снова является минимумом, но для которого $\\text{rk} X_l = m$; невырожденный гессиан позволяет применить для этого теорему об обратной функции.\n\nЕсли функция активации $\\phi$ не аналитична, то лемма 3 неверна. В самом деле, для однородной $\\phi$ (например, для ReLU или leaky ReLU) паттерны активаций, $\\phi'(H_1)$, не меняются при малом возмущении весов. Значит, мы, вообще говоря, не можем найти такое малое возмущение, для которого ранг $X_1$ будет полным. \n\nВместо малого возмущения в работе [On Connected Sublevel Sets in Deep Learning](https://arxiv.org/pdf/1901.07417.pdf) явно строятся пути в пространстве весов, на которых функция потерь не возрастает и достигает нуля. Если такой путь можно построить из произвольной точки, то все (строгие) локальные минимумы глобальны. Оказывается, что для построения такого пути аналитичность функции активации не требуется. Более того, при определённых условиях можно доказать, что из любых двух точек в пространстве весов можно построить соответствующие пути так, чтобы они сходились в одной точке. Это значит, что *множество подуровня* $\\mathcal{L}^{-1}((-\\infty, \\mathcal{E}))$ связно при любом $\\mathcal{E} > 0$ – эффект, впервые эмпирически обнаруженный в работах [Loss surfaces, mode connectivity, and fast ensembling of DNNs](https://arxiv.org/pdf/1802.10026.pdf) и [Essentially No Barriers in Neural Network Energy Landscape](https://arxiv.org/pdf/1803.00885.pdf).\n\nСвязность множеств подуровня сильнее глобальности всех строгих минимумов. В самом деле, если бы существовал строгий локальный минимум уровня $\\mathcal{E} > 0$, то для достаточно малого $\\epsilon > 0$ ему бы соответствовала отдельная связная компонента множества подуровня $\\mathcal{E} + \\epsilon$. С другой стороны, если все локальные минимумы глобальны, но изолированы, то множество подуровня $\\epsilon$ несвязно для достаточно малого $\\epsilon > 0$.\n\nВместо того, чтобы строить пути, на которых функция потерь достигает нуля, можно строить пути, на которых функция потерь достигает сколь угодно малого значения $\\epsilon > 0$. Это позволяет обобщить результат на функции потерь $\\ell(y,\\hat y)$, для которых минимум по второму аргументу, ответу сети, не достигается. Пример такой функции – кросс-энтропия. Так мы приходим к следующей теореме:\n\n**Теорема** ([On Connected Sublevel Sets in Deep Learning](https://arxiv.org/pdf/1901.07417.pdf)). Пусть выполнены следующие условия:\n\n1. $\\phi(\\mathbb{R}) = \\mathbb{R}$, $\\phi$ строго монотонна и не найдётся ненулевых $(\\lambda_i,a_i)_{i=1}^p$ с $a_i \\neq a_j$ $\\forall i \\neq j$, таких что $\\forall x \\in \\mathbb{R}$ $\\phi(x) = \\sum_{i=1}^p \\lambda_i \\phi(x - a_i)$;\n2. $\\ell(y,\\hat y)$ выпукла по второму аргументу и $\\inf_{\\hat y} \\ell(y,\\hat y) = 0$ для любого $y$;\n3. Существует $l \\in \\{1,\\ldots,L\\}$, для которого $\\text{rk} X_l = m$ и $n_{l'} > n_{l'+1}$ для всех $l' \\in \\{l+1,\\ldots,L\\}$.\n\nТогда если $\\mathcal{L}(W_{0:L}) = \\sum_{j=1}^m \\ell(y_j, f_{W_{0:L}}(x_j))$, то\n\n1. Для каждого $\\epsilon > 0$ найдутся веса $W_{0:L}$, для которых $\\mathcal{L}(W_{0:L}) < \\epsilon$;\n2. Множество подуровня $\\mathcal{L}^{-1}((-\\infty, \\mathcal{E}))$ связно для каждого $\\mathcal{E} > 0$.",
        "handbook": "Учебник по машинному обучению",
        "title": "Ландшафт функции потерь",
        "description": "Ландшафт функции потерь"
    },
    {
        "path": "/handbook/ml/article/implicit-bias",
        "content": "Под термином **implicit bias** мы будем понимать явление, состоящее в том, что алгоритм обучения среди всех возможных моделей с нулевым эмпирическим риском выбирает определённые. Это явление можно наблюдать уже на очень простом примере. Рассмотрим задачу линейной регрессии с квадратичной функцией потерь. Пусть имеется $m$ обучающих примеров в евклидовом пространстве размерности $N > m$. В этом случае наша задача $\\frac{1}{2} \\| X w - y \\|_2^2 \\to \\min_w$ недоопределена: семейство решений составляет линейное многообразие в пространстве весов. Предположим, что матрица объекты-признаки $X \\in \\mathbb{R}^{m \\times N}$ имеет полный ранг по строкам: $\\text{rk} X = m < N$. \n\nРассмотрим динамику градиентного спуска с шагом $\\eta$ и нулевой инициализацией весов:\n\n$$\nw_{k+1} = w_k + \\eta X^T (y - X w_k),\n\\quad\nw_0 = 0.\n$$\n\nНам будет удобнее вместо дискретного градиентного спуска рассматривать его непрерывный аналог\n\n$$\n\\frac{dw}{dt} = X^T (y - X w),\n\\quad\nw(t) = 0,\n$$\n\nпереход к которому соответствует стремлению $\\eta$ к нулю и выбору параметризации по $t$, для которой $k = [t / \\eta]$ (округление берётся в любую сторону).\n\nРассмотрим сингулярное разложение $X = U \\Sigma V^T$, где $U$ и $V$ ортогональны, а $\\Sigma$ – прямоугольная диагональная матрица. Тогда\n\n$$X^T X = V \\Sigma^T \\Sigma V^T \\in \\mathbb{R}^{N \\times N}$$\n\nи $\\text{rk}(X^T X) = m$. \n\nОбозначая $\\tilde w = V^T w$ и $\\tilde y = V^T X^T y = \\Sigma^T U^T y$, получаем:\n\n$$\n\\frac{d\\tilde w}{dt} = \\tilde y - \\Sigma^T \\Sigma \\tilde w,\n\\quad\n\\tilde w(0) = 0.\n$$\n\nВ координатном виде имеем следующее:\n\n$$\n\\frac{d\\tilde w_i}{dt} = \\tilde y_i - \\sigma_i^2 \\tilde w_i,\n\\quad\n\\tilde w_i(0) = 0\n\\qquad\n\\forall i \\in [1:m]\n$$\n\nи\n\n$$\n\\frac{d\\tilde w_i}{dt} = 0,\n\\quad\n\\tilde w_i(0) = 0\n\\qquad\n\\forall i \\in [m+1:N]\n$$\n\nтак как $\\Sigma^T \\Sigma$ – диагональная матрица, у которой лишь первые $m$ элементов на диагонали не равны нулю, и у вектора $\\tilde y = \\Sigma^T U^T y$ тоже лишь первые $m$ координат ненулевые.\n\nТак как все $\\sigma_i$ для $i=1,\\ldots,m$ ненулевые, при $t \\to \\infty$ получаем следующее решение:\n\n$$\n\\tilde w_i(\\infty) = \\frac{\\tilde y_i}{\\sigma_i^2}\n\\quad \\forall i \\in\\{1,\\ldots,m\\},\n\\qquad\n\\tilde w_i(\\infty) = 0 \n\\quad \\forall i \\in \\{m+1,\\ldots,N\\}.\n$$\n\nЭто можно записать в эквивалентном матричном виде: $\\tilde w(\\infty) = (\\Sigma^T \\Sigma)^+ \\tilde y = \\Sigma^+ U^T y$, где «+» обозначает взятие псевдообратной матрицы.\n\nЗначит, $w(\\infty) = V \\Sigma^{+} U^T y = X^{+} y = X^T (X X^T)^{-1} y$ в силу того, что матрица $X$ имеет полный ранг по строкам.\n\nПокажем теперь, что это частное решение, найденное градиентным спуском с нулевой инициализацией, имеет наименьшую евклидову норму среди всех минимумов функции потерь $\\frac{1}{2} \\vert\\vert X w - y \\vert\\vert_2^2$.\n\nРассмотрим соответствующую функцию Лагранжа:\n\n$$\nL(w; \\lambda) = \\frac{\\| w \\|_2^2}{2} + \\lambda^T (y - X w).\n$$\n\nЗдесь $\\lambda \\in \\mathbb{R}^{m}$. Покажем, что пара $(w(\\infty), \\lambda^* = (X X^T)^{-1} y)$ является критической точкой этой функции:\n\n$$\n\\nabla_\\lambda L(w(\\infty); \\lambda^*) \n= y - X w(\\infty)\n= y - X X^T (X X^T)^{-1} y \n= 0;\n$$\n\n$$\n\\nabla_w L(w(\\infty); \\lambda^*)\n= w(\\infty) - X^T \\lambda^*\n= X^T((X X^T)^{-1} y - (X X^T)^{-1} y)\n= 0.\n$$\n\nВ силу выпуклости функции Лагранжа эта критическая точка является точкой глобального минимума.\n\n\n## Случай линейных сетей\n\nКаков implicit bias нейронных сетей? Сходится ли градиентный спуск в решение наименьшей нормы и если да, то о какой норме идёт речь? Частичный ответ на этот вопрос удаётся получить для линейных сетей.\n\nСледуя работе [Exact solutions to the nonlinear dynamics of learning in deep linear neural networks](https://arxiv.org/pdf/1312.6120.pdf), рассмотрим линейную сеть с одним скрытым слоем:\n\n$$\nf(x; W_{1:2}) =\nW_2 W_1 x,\n$$\n\nгде $W_1$ и $W_2$ – матрицы $n\\times n$.\n\nПоставим задачу многомерной (метка $y$ – вектор) регрессии с квадратичной функцией потерь: \n\n$$\\mathcal{L}(W_{1:2}) = \\mathbb{E}_{x,y} \\vert\\vert y - f(x; W_{1:2}) \\vert\\vert_2^2 \\to \\min_W$$\n\nШаг градиентного спуска выглядит следующим образом:\n\n$$\n\\dot{W_1\\vphantom{W^T}} =\n\\eta \\mathbb{E}_{x,y} W_2^T (y x^T - W_2 W_1 x x^T),\n\\quad\n\\dot{W_2\\vphantom{W^T}} =\n\\eta \\mathbb{E}_{x,y} (y x^T - W_2 W_1 x x^T) W_1^T,\n$$\n\nгде точка над $W_i$ означает производную по времени (то есть по $t$).\n\nЭто нелинейная система матричных дифференциальных уравнений второго порядка; чтобы проинтегрировать её аналитически, нам придётся сделать ряд предположений.\n\nОпределим ковариационную матрицу входов $\\Sigma_{xx} = \\mathbb{E} x x^T$ и матрицу ковариации меток со входами $\\Sigma_{xy} = \\mathbb{E} y x^T$. Предположим, что данные декоррелированы: $\\Sigma_{xx} = I$; этого можно добиться, заменив входы $x$ на $\\Sigma_{xx}^{-1} x$. Что касается матрицы ковариации меток со входами, рассмотрим её сингулярное разложение:\n\n$$\n\\Sigma_{xy} =\nU_2 S_{2,0} V_0^T =\n\\sum_{r=1}^{n} s_r u_r v_r^T.\n$$\n\nНазовём $s_r$ силой моды с индексом $r$ ковариации между метками и входами.\n\nСделаем замену координат:\n\n$$\n\\overline{W_2} =\nU_2^T W_2,\n\\quad\n\\overline{W_1} =\nW_1 V_0.\n$$\n\nВ новых координатах градиентный спуск принимает вид:\n\n\n$$\n\\dot{\\overline{W}}_1 =\n\\eta \\overline{W_2}^T (S_{2,0} - \\overline{W_2} \\overline{W_1}),\n\\quad\n\\dot{\\overline{W}}_2 =\n\\eta (S_{2,0} - \\overline{W_2} \\overline{W_1}) \\overline{W_1}^T.\n$$\n\n\nПусть $\\overline{W_1} = [a_1, \\ldots, a_n]$ и $\\overline{W_2} = [b_1, \\ldots, b_n]^T$. Тогда в терминах векторов $a$ и $b$\n\n$$\n\\frac{1}{\\eta} \\dot a_{\\alpha} =\ns_\\alpha b_{\\alpha} - \\sum_{\\gamma=1}^n b_\\gamma (b_\\gamma^T a_\\alpha) =\n(s_\\alpha - (b_\\alpha^T a_\\alpha)) b_{\\alpha} - \\sum_{\\gamma\\neq\\alpha} (b_\\gamma^T a_\\alpha) b_\\gamma;\n$$\n\n$$\n\\frac{1}{\\eta} \\dot b_{\\alpha} =\ns_\\alpha a_{\\alpha} - \\sum_{\\gamma=1}^n (a_\\gamma^T b_\\alpha) a_\\gamma = (s_\\alpha - (a_\\alpha^T b_\\alpha)) a_{\\alpha} - \\sum_{\\gamma\\neq\\alpha} (a_\\gamma^T b_\\alpha) a_\\gamma.\n$$ \n\nПолучилась система векторных дифференциальных уравнений порядка $2n$, всё ещё нелинейная. К счастью, при определённом предположении об инициализации эта система распадается на $n$ независимых систем порядка $2$.\n\nПредположим, что существует ортогональная матрица $R = [r_1, \\ldots, r_n]$, такая что при всех $\\alpha$ имеет место равенство\n\n$a_\\alpha(0) = \\tilde a(0) r_\\alpha$ и $b_\\alpha(0) = \\tilde b(0) r_\\alpha$\n\nдля некоторых скалярных величин $\\tilde a(0)$ и $\\tilde b(0)$.\n\nНетрудно заметить, что в этом случае при всех $\\alpha$ и в любой момент времени $t$ имеем $a_\\alpha(t) = \\tilde a(t) r_\\alpha$ и $b_\\alpha(t) = \\tilde b(t) r_\\alpha$ для некоторых скалярных величин $\\tilde a(t)$ и $\\tilde b(t)$ .\n\nТогда для различных $\\alpha$ выражения выше становятся независимыми друг от друга:\n\n$$\n\\frac{d\\tilde a}{dt} =\n\\eta (s - \\tilde a \\tilde b) \\tilde b,\n\\qquad\n\\frac{d\\tilde b}{dt} =\n\\eta (s - \\tilde a \\tilde b) \\tilde a.\n$$\n\nТеперь это система нелинейных дифференциальных уравнений второго порядка.\n\nЕсли $\\tilde a = \\tilde b$ в начальный момент, то это верно и в любой момент времени. Тогда система выше превращается в одно уравнение первого порядка.\n\nВ самом деле, обозначив $u = \\tilde a \\tilde b$, получаем:\n\n$$\n\\dot u = \n2\\eta (s - u) u.\\quad(1)\n$$\n\nЭто уравнение задаёт следующую динамику градиентного спуска для функции потерь $E(u) = \\frac{1}{2} (s - u)^2$ (её глобальный минимум – это $u = s$).\n\nПеред тем, как интегрировать уравнение (1), напомним, как из $u$ перейти обратно к исходным $W_1$ и $W_2$. Имеем для $W_1$:\n\n$$\nW_1 = \\bar W_1 V_0^T,\n\\qquad\n\\bar W_1 = [\\tilde a r_1, \\ldots, \\tilde a r_n],\n\\qquad\n\\tilde a = \\sqrt{u}.\n$$\n\nАналогично для $W_2$:\n\n$$\nW_2 = U_2 \\bar W_2,\n\\qquad\n\\bar W_2 = [\\tilde b r_1, \\ldots, \\tilde b r_n]^T,\n\\qquad\n\\tilde b = \\sqrt{u}.\n$$\n\nТеперь проинтегрируем уравнение (1) в предположении, что $u(0) = u_0$ и $u(t) = u_f$ для выбранного $t$:\n\n$$\nt\n= \\frac{1}{\\eta} \\int_{u_0}^{u_f} \\frac{du}{2u (s - u)} \\, du\n= \\frac{1}{2 s \\eta} \\int_{u_0}^{u_f} \\left(\\frac{du}{u} + \\frac{du}{s-u}\\right) \\, du\n=\n$$\n\n$$\n= \\frac{1}{2 s \\eta} \\left(\\ln\\left(\\frac{u_f}{u_0}\\right) - \\ln\\left(\\frac{u_f-s}{u_0-s}\\right)\\right)\n= \\frac{1}{2 s \\eta} \\ln\\left(\\frac{u_f (u_0-s)}{u_0 (u_f-s)}\\right).\n$$\n\n\nРассмотрим время, необходимое, чтобы выучить фиксированную долю силы данной моды $u_f = \\xi s$, где $\\xi \\in (0,1)$, стартуя из точки из окрестности нуля $u_0 = \\epsilon$. Оно равняется\n\n$$\nt^{(\\xi)} \n= \\frac{1}{2 s \\eta} \\ln\\left(\\frac{\\xi}{1-\\xi} \\frac{s-\\epsilon}{\\epsilon}\\right) \n= \\frac{1}{2 s \\eta} (\\ln(s/\\epsilon - 1) - \\ln(\\xi^{-1} - 1)).\n% \\sim \\frac{1}{2 s \\eta} \\ln(s/\\epsilon) \\; \\text{при $\\epsilon \\to 0$}.\n$$\n\nВидим, что чем сильнее мода (то есть чем больше $s$), тем быстрее она сходится.\n\nРассмотрим две моды с силами $s_1$ и $s_2$, такие что $s_1 > s_2$. Насколько вторая (более слабая) мода выучится к моменту, когда первая уже выучится на долю $\\xi$? Из уравнения выше имеем:\n\n$$\n\\frac{u_f (u_0-s)}{u_0 (u_f-s)} = e^{2 s \\eta t};\n$$\n\n$$\n1 - \\frac{s}{u_f} = \\left(1 - \\frac{s}{u_0}\\right) e^{-2 s \\eta t}.\n$$\n\nПодставляя $s = s_2$ и $t = t_1^{(\\xi)}$, получаем:\n\n$$\n1 - \\frac{s_2}{u_f} \n= \\left(1 - \\frac{s_2}{\\epsilon}\\right) e^{-2 s_2 \\eta t_1^{(\\xi)}}\n= \\left(1 - \\frac{s_2}{\\epsilon}\\right) e^{-\\frac{s_2}{s_1} (\\ln(s/\\epsilon - 1) - \\ln(\\xi^{-1} - 1))}\n\\sim\\\\\\sim -\\frac{s_2}{\\epsilon} \\left(\\frac{s_1}{\\epsilon}\\right)^{-\\frac{s_2}{s_1}} \\left(\\frac{\\xi}{1-\\xi}\\right)^{-\\frac{s_2}{s_1}}\n= -s_2 s_1^{-\\frac{s_2}{s_1}} \\left(\\frac{\\xi}{1-\\xi}\\right)^{-\\frac{s_2}{s_1}} \\epsilon^{\\frac{s_2}{s_1} - 1}.\n$$\n\nПоскольку $s_2 < s_1$, это выражение стремится к минус бесконечности при $\\epsilon \\to 0$, из чего следует, что $u_f$ стремится к нулю.\n\nЭто означает, что если веса в инициализации лежат в окрестности нуля, то к моменту, когда данная мода выучивается на любую фиксированную долю $\\xi \\in (0,1)$, более слабые моды не успевают выучиться вообще. Таким образом, в любой момент времени $t$ матрица $W_2(t) W_1(t)$ является наилучшим малоранговым приближением заданного ранга матрицы корреляций $\\Sigma_{yx}$, причём чем больше $t$, тем больше ранг. Можно сказать, что **градиентный спуск с фиксированным числом шагов «предпочитает» решения малого ранга**.\n\nВ выводе выше, мы использовали ряд предположений, в частности, что вектора $a_{1:n}$, образующие матрицу $\\overline{W_1}$, ортогональны в инициализации. Эмпирически те же выводы оказываются верными и без этого предположения, см. графики в оригинальной работе [Exact solutions to the nonlinear dynamics of learning in deep linear neural networks](https://arxiv.org/pdf/1312.6120.pdf). Можно ли их обосновать строго математически? В работах [Towards resolving the implicit bias of gradient descent for matrix factorization](https://arxiv.org/pdf/2012.09839.pdf) и [Deep Linear Networks Dynamics](https://arxiv.org/pdf/2106.15933v1.pdf) доказывается, что самая сильная мода выучивается в первую очередь. Тем не менее, на момент написания этого текста остаётся недоказанным, что все моды выучиваются последовательно от сильных к слабым. К сожалению, implicit bias градиентного спуска для нелинейных сетей пока остаётся почти неизученным.",
        "handbook": "Учебник по машинному обучению",
        "title": "Implicit bias",
        "description": "Implicit bias"
    },
    {
        "path": "/handbook/ml/article/optimizaciya-v-ml",
        "content": "## Введение\n\nЗачастую задачи машинного обучения формулируются таким образом, что «веса» модели, которую мы строим, возникают, как решение оптимизационной задачи. В качестве VIP-примера рассмотрим задачу линейной регрессии:\n\n$$\n    \\Vert y - Xw \\Vert_2^2 \\to \\min_w,\n$$\n\nПо сути, мы получили чистейшую задачу квадратичной оптимизации. В чем особенность конкретно этой задачи? Она _выпуклая_. \n\n{% cut \"Для интересующихся определением.\" %}\n\nФункция $f \\colon \\mathbb{R}^d \\to \\mathbb{R}$ является (нестрого) выпуклой (вниз), если для любых $x_1,x_2 \\in \\mathbb{R}^d$ верно, что \n\n$$\n    \\forall t \\in [0,1] : f(tx_1 + (1-t)x_2) \\leq t f(x_1) + (1-t) f(x_2).\n$$\n\nЧтобы запомнить, в какую сторону неравенство, всегда полезно рисовать следующую картинку с графическим определением выпуклой функции.\n\n![21_1_3a9cb89468.webp](https://yastatic.net/s3/education-portal/media/21_1_3a9cb89468_befecd19f9.webp)\n\nЭквивалентное определение, если функция достаточно гладкая – гессиан неотрицательно определен в любой точке, то есть в каждой точке функция хорошо приближается параболоидом ветвями вверх. Отсюда по критерию минимальности второго порядка автоматически следует, что всякая точка локального оптимума является точкой локального минимума, то есть локальных максимумов и сёдел в выпуклом мире попросту не существует.\n\n{% endcut %}\n\nВажное свойство выпуклых функций – локальный минимум автоматически является глобальным (но не обязательно единственным!). Это позволяет избегать уродливых ситуаций, которые с теоретической точки зрения могут встретиться в невыпуклом случае, например, вот такой:\n\n**Теорема** (_No free lunch theorem_) Пусть $A$ – алгоритм оптимизации, использующий локальную информацию (все производные в точке). Тогда существует такая невыпуклая функция $f \\colon [0,1]^d \\to [0,1]$, что для нахождения глобального минимума на квадрате $[0,1]^d$ с точностью $\\frac{1}{m}$ требуется совершить хотя бы $m^d$ шагов.\n\n{% cut \"Для интересующихся доказательствами.\" %}\n\nБудем строить наш контрпример, пользуясь принципом сопротивляющегося оракула (или рассуждениями с противником, кому как привычнее называть).\n\nРазделим нашу область на подкубики размера $1/m \\times \\ldots \\times 1/m$. Зададим функцию следующим образом – она будет тождественно равна $1$ на всех кубиках, кроме одного, в середине которого будет точка с значением $0$ (мы не специфицируем, как значение будет гладко «снижаться» до $0$; можно построить кусочно-линейную функцию, а потом сгладить её). \n\nА именно поставим ноль в тот кубик, который наш алгоритм оптимизации $A$ посетит последним. Так как кубиков у нас $m^d$, то алгоритм должен всегда совершить как минимум $m^d$ шагов, попробовав все кубики. Итого у нас следующая картинка ($m=3, d=2$):\n\n![21_2_8d876235dc.webp](https://yastatic.net/s3/education-portal/media/21_2_8d876235dc_ba5da709f5.webp)\n\nОтметим дополнительно, что полученный контрпример можно сделать какой угодно гладкости (но не аналитическим).\n\n{% endcut %}\n\nМы видим, что в общем случае без выпуклости нас ожидает полное разочарование. Ничего лучше перебора по сетке придумать в принципе невозможно. В выпуклом случае же существуют алгоритмы, которые находят глобальный минимум за разумное время.\n\nВстречаются ли в жизни функции невыпуклые? Повсеместно! Например, функция потерь при обучении нейронных сетей, как правило, не является выпуклой. Но отсюда не следует, что любой алгоритм их оптимизации будет обязательно неэффективным: ведь «контрпример» из теоремы довольно специфичен. И, как мы увидим, оптимизировать невыпуклые функции очень даже возможно.\n\nНайти глобальный минимум невыпуклой функции – очень трудная задача, но зачастую нам хватает локального, который является, в частности, стационарной точкой: такой, в которой производная равна нулю. Все теоретические результаты в случае невыпуклых задач, как правило, касаются поиска таких точек, и алгоритмы тоже направлены на их отыскание.\n\nЭтим объясняется и то, что большинство алгоритмов оптимизации, придуманных для выпуклого случая, дословно перешли в невыпуклый. Теоретическая причина в следующем: в выпуклом случае поиск стационарной точки и поиск минимума – _буквально_ одна и та же задача, поэтому то, что хорошо ищет минимум в выпуклом случае, ожидаемо будет хорошо искать стационарные точки в невыпуклом. Практическая же причина в том, что оптимизаторы в библиотеках никогда не спрашивают, выпуклую ли им функцию подают на вход, а просто работают и работают хорошо.\n\nВнимательный читатель мог возразить на моменте подмены задачи: подождите-ка, мы ведь хотим сделать функцию как можно меньше, а не стационарную точку искать какую-то непонятную. Доказать в невыпуклом случае тут, к сожалению, ничего невозможно, но на практике мы снова используем алгоритмы изначально для выпуклой оптимизации. Почему?\n\nПричина номер **1**: сойтись в локальный минимум лучше, чем никуда. Об этом речь уже шла.\n\nПричина номер **2**: в окрестности локального минимума функция становится выпуклой, и там мы сможем быстро сойтись.\n\nПричина номер **3**: иногда невыпуклая функция является в некотором смысле «зашумленной» версией выпуклой или похожей на выпуклую. Например, посмотрите на эту картинку (функция Леви):\n\n![21_3_4bf658e519.webp](https://yastatic.net/s3/education-portal/media/21_3_4bf658e519_40da367c0e.webp)\n\nУ этой функции огромное количество локальных минимумов, но «глобально» она кажется выпуклой. Что-то отдаленно похожее наблюдается и [в случае нейронных сетей](https://losslandscape.com/). Нашей задачей становится не скатиться в маленький локальный минимум, который всегда рядом с нами, а в большую-большую ложбину, где значение функции минимально и в некотором смысле стабильно.\n\nПричина номер **4**: оказывается, что градиентные методы [весьма часто](http://proceedings.mlr.press/v49/lee16.html) сходятся именно к локальным минимумам.\n\nСразу отметим важную разницу между выпуклой и невыпуклой задачами: в выпуклом случае работа алгоритма оптимизации не очень существенно зависит от начальной точки, поскольку мы всегда скатимся в точку оптимума. В невыпуклом же случае правильно выбранная точка старта – это уже половина успеха.\n\nТеперь перейдём к разбору важнейших алгоритмов оптимизации.\n\n## Градиентный спуск (GD)\n\nОпишем самый простой метод, который только можно придумать – градиентный спуск. Для того, чтобы его определить, вспомним заклинание из любого курса матанализа: «градиент – это направление наискорейшего локального возрастания функции», тогда антиградиент – это направление наискорейшего локального убывания.\n\n{% cut \"Для интересующихся формализмом.\" %}\n\nВоспользуемся формулой Тейлора для $\\Vert h \\Vert = 1$ (направления спуска): \n\n$$\n    f(x + \\alpha h) = f(x) + \\alpha \\langle \\nabla f(x), h \\rangle + o(\\alpha).\n$$\n    \nМы хотим уменьшить значение функции, то есть\n\n$$\n    f(x) + \\alpha \\langle \\nabla f(x), h \\rangle + o(\\alpha) < f(x).\n$$\n\nПри $\\alpha \\to 0$ имеем $\\langle \\nabla f(x), \\Delta x \\rangle \\leq 0$. Более того, мы хотим наискорешйшего убывания, поэтому это скалярное произведение хочется минимизировать. Сделаем это при помощи неравенства Коши-Буняковского:\n\n$$\n    \\langle \\nabla f(x), h \\rangle \\geq - \\Vert \\nabla f(x) \\Vert_2 \\Vert h \\Vert_2 = \\Vert \\nabla f(x) \\Vert_2. \n$$\n    \nРавенство в неравенстве Коши-Буняковского достигается при пропорциональности аргументов, то есть \n\n$$\n    h = - \\frac{\\nabla f(x)}{\\Vert \\nabla f(x) \\Vert_2}.\n$$\n\n{% endcut %}\n\n\nТогда пусть $x_0$ – начальная точка градиентного спуска. Тогда каждую следующую точку мы выбираем следующим образом:\n\n$$\n    x_{k+1} = x_k - \\alpha \\nabla f(x_k),\n$$\n\nгде $\\alpha$ – это размер шага (он же learning rate). Общий алгоритм градиентного спуска пишется крайне просто и элегантно:\n\n```python\nx = normal(0, 1)                # можно пробовать и другие виды инициализации\nrepeat S times:                 # другой вариант: while abs(err) > tolerance\n   h = grad_f(x)                # вычисляем направление спуска\n   x -= alpha * h               # обновляем значение в точке\n```\n\nЭту схему в приложении к линейной регрессии можно найти в [параграфе про линейные модели](https://academy.yandex.ru/handbook/ml/article/linejnye-modeli#pochemu-modeli-linejnye). \n\nПосле всего этого начинаются тонкости:\n\n* А как вычислять градиент?\n* А как выбрать размер шага? \n* А есть ли какие-то теоретические оценки сходимости?\n\nНачнем разбирать вопросы постепенно. Для вычисления градиентов современный человек может использовать инструменты автоматического дифференцирования. Идейно, это вариация на тему алгоритма [обратного распространения ошибки (backpropagation)](https://academy.yandex.ru/handbook/ml/article/metod-obratnogo-rasprostraneniya-oshibki), ведь как правило человек задает функции, составленные из элементарных при помощи умножений/делений/сложений/композиций. Такой метод реализован во всех общих фреймворках для нейронных сетей (Tensorflow, PyTorch, Jax). \n\nНо, вообще говоря, возникает некоторая тонкость. Например, расмотрим задачу линейной регрессии. Запишем её следующим образом:\n\n$$\n    f(w) = \\frac{1}{N} \\sum_{i=1}^N (w^\\top x_i - y_i)^2.\n$$\n\nВидим, что слагаемых суммарно $N$ – размер выборки. При $N$ порядка $10^6$ и $d$ (это количество признаков) порядка $10^4$ вычисление градиента за $O(Nd)$ становится жутким мучением. Но если от $d$ избавиться без дополнительных предположений (например, о разреженности) нельзя, то с зависимостью от $N$ в каком-то смысле удастся разделаться при помощи метода стохастического градиентного спуска.\n\nХранение градиентов тоже доставит нам проблемы. У градиента столько же компонент, сколько параметров у модели, и если мы имеем дело с глубокой нейросетью, это даст значительные затраты дополнительной памяти. Хуже того, метод обратного распространения ошибки устроен так, что нам приходится помнить все промежуточные представления для вычисления градиентов. Поэтому вычислить градиент целиком невозможно ни для какой нормальной нейросети, и от этой беды тоже приходится спасаться с помощью стохастического градиентного спуска.\n\nТеперь перейдем к размеру шага. Теория говорит о том, что если функция гладкая, то можно брать достаточно маленький размер шага, где под достаточно маленьким подразумевается $\\alpha \\leq \\frac1L$, где $L$ – некоторая константа, которая зависит от гладкости задачи (так называемая константа Липшица). Вычисление этой константы может быть задачей сложнее, чем изначальная задача оптимизации, поэтому этот вариант нам не годится. Более того, эта оценка крайне пессимистична – мы ведь хотим размер шага как можно больше, чтобы уменьшить функцию как можно больше, а тут мы будем изменять все очень мало.\n\nСуществует так называемый **метод наискорейшего спуска**: выбираем размер шага так, чтобы как можно сильнее уменьшить функцию:\n\n $$\n    \\alpha_k = \\arg\\min_{\\alpha \\geq 0} f(x_k - \\alpha \\nabla f(x_k)).\n $$\n\nОдномерная оптимизация является не сильно сложной задачей, поэтому теоретически мы можем её совершать (например, методом бинарного/тернарного поиска или золотого сечения), можно этот шаг также совершать неточно. Но сразу стоит заметить, что это можно делать, только если функция $f$ вычислима более-менее точно за разумное время, в случае линейной регрессии это уже не так (не говоря уже о нейронных сетях).\n\nТакже есть всевозможные правила Армихо/Гольдштейна/Вульфа и прочее и прочее, разработанные в давние 60-е, и для их проверки требуется снова вычислять значения функции в точке. Желающие могут посмотреть на эти условия [на википедии](https://ru.wikipedia.org/wiki/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F_%D0%92%D0%BE%D0%BB%D1%8C%D1%84%D0%B5). Про более хитрые вариации выбора шагов мы поговорим позже, но сразу стоит сказать, что эта задача довольно сложная.\n\nПо поводу теории: сначала скажем что-то про _выпуклый_ случай.\n\nВ максимально общем выпуклом случае без дополнительных предположений оценки для градиентного спуска крайне и крайне пессимистичные: чтобы достичь качества $\\varepsilon$, то есть\n\n$$\\vert f(x_k) - f(x^*) \\vert\\leq \\varepsilon $$\n\nдостаточно сделать $O(R^2/\\varepsilon^2)$ шагов, где $R^2$ — это расстояние от $x_0$ до $x^*$. Выглядит очень плохо: ведь чтобы достичь точности $10^{-2}$, необходимо сделать порядка $10^4$ шагов градиентного спуска. Но на практике такого не происходит, потому что на самом деле верны разные предположения, дающие более приятные свойства. Для контраста, укажем оценку в случае гладкой и сильно выпуклой в точке оптимума функции: за $k$ шагов будет достигнута точность\n\n$$\n    O\\left( \\min\\left\\{R^2 \\exp\n    \\left(-\\frac{k}{4\\kappa}\\right), \\frac{R^2}{k} \\right\\}\\right),\n$$\n\nгде $\\kappa$ – это так называемое число обусловленности задачи. По сути, это число измеряет, насколько линии уровня функции вытянуты в окрестности оптимума.\n\nМорали две:\n* Скорость сходимости градиентного спуска сильно зависит от обусловленности задачи;\n* Также она зависит от выбора хорошей точки старта, ведь везде входит расстояние от точки старта до оптимума.\n\nВ качестве ссылки на доказательство укажем на [работу Себастиана Стича](https://arxiv.org/abs/1907.04232v2), где оно довольно простое и общее.\n\nВ невыпуклом же случае все куда хуже с точки зрения теории: требуется порядка $O(1/\\varepsilon^2)$ шагов в худшем случае даже для гладкой функции, где $\\varepsilon$ – желаемая точность уменьшения нормы градиента.\n\n## Стохастический градиентный спуск (SGD)\n\nТеперь мы попробуем сэкономить в случае регрессии и подобных ей задач. Будем рассматривать функционалы вида\n\n$$\n    f(x) = \\sum_{i=1}^N \\mathcal{L}(x, y_i),\n$$\n\nгде сумма проходится по всем объектам выборки (которых может быть очень много).\nТеперь сделаем следующий трюк: заметим, что это усреднение – это по сути взятие матожидания. Таким образом, мы говорим, что наша функция выглядит как\n\n$$\n    f(x) = \\mathbb{E}[\\mathcal{L}(x, \\xi)],\n$$\n\nгде $\\xi$ равномерно распределена по обучающей выборке. Задачи такого вида возникают не только в машинном обучении; иногда встречаются и просто задачи _стохастического программирования_, где происходит минимизация матожидания по неизвестному (или слишком сложному) распределению.\n\nДля функционалов такого вида мы также можем посчитать градиент, он будет выглядеть довольно ожидаемо: \n\n$$\n    \\nabla f(x) = \\mathbb{E} \\nabla \\mathcal{L}(x, \\xi).\n$$\n\nБудем считать, что вычисление матожидания напрямую невозможно. \n\nНовый взгляд из статистики дает возможность воспользоваться классическим трюком: давайте подменим матожидание на его несмещенную Монте-Карло оценку. Получается то, что можно назвать _стохастическим градиентом_:\n\n$$\n    \\tilde \\nabla f(x) = \\frac{1}{B} \\sum_{i=1}^B \\nabla \\mathcal{L}(x, \\xi_i).\n$$\n\nГоворя инженерным языком, мы подменили вычисление градиента по всей выборке вычислением по случайной подвыборке. Подвыборку $\\xi_1,\\ldots,\\xi_B$ часто называют (_мини_)_батчем_, а число $B$ – размером батча.\n\nПо-хорошему, наука предписывает нам каждый раз независимо генерировать батчи, но это трудно с вычислительной точки зрения. Вместо этого воспользуемся следующим приёмом: сначала перемешаем нашу выборку (чтобы внести дополнительную случайность), а затем будем рассматривать последовательно блоки по $B$ элементов выборки. Когда мы просмотрели всю выборку – перемешиваем еще раз и повторяем проход. Очередной прогон по обучающей выборке называется _эпохой_. И, хотя, казалось бы, независимо генерировать батчи лучше, чем перемешивать лишь между эпохами, есть несколько результатов, демонстрирующих обратное: [одна работа](https://arxiv.org/abs/1806.10077) и [вторая (более новая)](https://arxiv.org/abs/2006.06946); главное условие успеха – правильно изменяющийся размер шага.\n\nПолучаем следующий алгоритм, называемый **стохастическим градиентным спуском** (**stochastic gradient descent**, **SGD**):\n\n```python\nx = normal(0, 1)                    # инициализация\nrepeat E times:                     # цикл по количеству эпох\n   for i = 0; i <= N; i += B:\n        batch = data[i:i+B]\n        h = grad_loss(batch).mean() # вычисляем оценку градиента как среднее по батчу\n        x -= alpha * h\n```\n\nДополнительное удобство такого подхода – возможность работы с внешней памятью, ведь выборка может быть настолько большой, что она помещается только на жёсткий диск. Сразу отметим, что в таком случае $B$ стоит выбирать достаточно большим: обращение к данным с диска всегда медленнее, чем к данным из оперативной памяти, так что лучше бы сразу забирать оттуда побольше.\n\nПоскольку стохастические градиенты являются лишь оценками истинных градиентов, SGD может быть довольно шумным:\n\n![21_4_5cc6153d0c.webp](https://yastatic.net/s3/education-portal/media/21_4_5cc6153d0c_81e5a8cdd7.webp)\n\nПоэтому если вы обучаете глубокую нейросеть и у вас в память влезает лишь батч размером с 2-4 картинки, модель, возможно, ничего хорошего не сможет выучить. Аппроксимация градиента и поведение SGD может стать лучше с ростом размера батча $B$ – и обычно его действительно хочется подрастить, но парадоксальным образом слишком большие батчи могут порой испортить дело (об этом дальше в этом параграфе!).\n\n### Теоретический анализ\n\nТеперь перейдем к теоретической стороне вопроса. Сходимость SGD обеспечивается несмещенностью стохастического градиента. Несмотря на то, что во время итераций копится шум, суммарно он зачастую оказывается довольно мал.\n\nТеперь приведем оценки. Сначала, по традиции, в выпуклом случае. Для выпуклой функции потерь за $k$ шагов будет достигнута точность порядка\n\n$$\n    O\\left( \\min\\left\\{R^2 \\exp\n    \\left(-\\frac{k}{4\\kappa} \\right)+ \\frac{\\sigma^2}{\\mu k}, \\frac{R^2}{k} + \\frac{\\sigma^2 R}{\\sqrt{k}} \\right\\}\\right),\n$$\n\nгде $\\sigma^2$ – это дисперсия стохградиента, а $\\mu$ – константа сильной выпуклости, показывающая, насколько функция является «не плоской» в окрестности точки оптимума. Доказательство в том же [препринте С. Стича](https://arxiv.org/abs/1907.04232v2). \n\nМораль в следующем: дисперсия стохастического градиента, вычисленного по батчу размера $B$ равна $\\sigma_0^2/B$, где $\\sigma_0^2$ – это дисперсия одного градиента. То есть увеличение размера батча помогает и с теоретической точки зрения.\n\nВ невыпуклом случае оценка сходимости SGD просто катастрофически плохая: требуется $O(1/\\varepsilon^4)$ шагов для того, чтобы сделать норму градиента меньше $\\varepsilon$. В теории есть всевозможные дополнительные способы снижения дисперсии с лучшими теоретическими оценками (Stochastic Variance Reduced Gradient (SVRGD), Spider, etc), но на практике они активно не используются.\n\n\n## Использование дополнительной информации о функции\n\n### Методы второго порядка\n\n_[Основной раздел.](https://academy.yandex.ru/handbook/ml/article/metody-vtorogo-poryadka)_\n\nПостараемся усовершенствовать метод стохастического градиентного спуска. Сначала заметим, что мы используем явно не всю информацию об оптимизируемой функции. \n\nВернемся к нашему VIP-примеру линейной регресии с $\\ell_2$ регуляризацией:\n\n$$\n    \\Vert y - Xw \\Vert_2^2 + \\lambda \\Vert w \\Vert_2^2 \\to \\min_w.\n$$\n\nЭта функция достаточно гладкая, и может быть неплохой идеей использовать её старшие производные для ускорения сходимости алгоритма. В наиболее чистом виде этой философии следует метод Ньютона и подобные ему; о них вы можете прочитать [в соответствующем разделе](https://academy.yandex.ru/handbook/ml/article/metody-vtorogo-poryadka). Отметим, что все такие методы, как правило, довольно дорогие (исключая L-BFGS), и при большом размере задачи и выборки ничего лучше вариаций SGD не придумали.\n\n### Проксимальные методы\n\n_[Основной раздел.](https://academy.yandex.ru/handbook/ml/article/proksimalnye-metody)_\n\nК сожалению, не всегда функции такие красивые и гладкие. Для примера рассмотрим Lasso-регресию:\n\n$$\n    \\Vert y - Xw \\Vert_2^2 + \\lambda \\Vert w \\Vert_1 \\to \\min_w.\n$$\n\nВторое, не гладкое слагаемое резко ломает все свойства этой задачи: теоретически оценки для градиентного спуска становятся _гораздо_ хуже (и на практике тоже). С другой стороны, регуляризационное слагаемое устроено очень просто, и эту дополнительную структурную особенность можно и нужно эксплуатировать. Методы решения задачи вида\n\n$$\n    f(x) + h(x) \\to \\min_x,\n$$\n\nгде $h$ – простая функция (в некотором смысле), а $f$ – гладкая, называются методами _композитной оптимизации_. Глубже погрузиться в них можно в [соответствующем разделе](https://academy.yandex.ru/handbook/ml/article/proksimalnye-metody), посвященном проксимальным методам.\n\n## Использование информации о предыдущих шагах\n\nСледующая претензия к методу градиентного спуска – мы не используем информацию о предыдущих шагах, хотя, кажется, там может храниться что-то полезное.\n\n### Метод инерции, momentum\n\nНачнем с физической аналогии. Представим себе мячик, который катится с горы. В данном случае гора – это график функции потерь в пространстве параметров нашей модели, а мячик – её текущее значение. Реальный мячик не застрянет перед небольшой кочкой, так как у него есть некоторая масса и уже накопленный импульс – некоторое время он способен двигаться даже вверх по склону. Аналогичный прием может быть использован и в градиентной оптимизации. В англоязычной литературе он называется **Momentum**.\n\n![21_5_5006624408.webp](https://yastatic.net/s3/education-portal/media/21_5_5006624408_4e4eebb1ec.webp)\n\nС математической точки зрения, мы добавляем к градиентному шагу еще одно слагаемое:\n\n$$\n    x_{k+1} = x_k - \\alpha_k \\nabla f(x_k) + \\color{red}{\\beta_k (x_k - x_{k-1})}.\n$$\n\nСразу заметим, что мы немного усугубили ситуацию с подбором шага, ведь теперь нужно подбирать не только $\\alpha_k$, но и $\\beta_k$. Для обычного, не стохастического градиентного спуска мы можем адаптировать метод наискорейшего и получить **метод тяжелого шарика**:\n\n$$\n    (\\alpha_k, \\beta_k) = \\arg\\min_{\\alpha,\\beta} f(x_k - \\alpha \\nabla f(x_k) + \\beta (x_k - x_{k-1})).\n$$\n\nНо, увы, для SGD это работать не будет.\n\nВыгода в невыпуклом случае от метода инерции довольно понятна – мы будем пропускать паразитные локальные минимумы и седла и продолжать движение вниз. Но выгода есть также и в выпуклом случае. Рассмотрим плохо обусловленную квадратичную задачу, для которой линии уровня оптимизируемой функции будут очень вытянутыми эллипсами, и запустим на SGD с инерционным слагаемым и без него. Направление градиента будет иметь существенную вертикальную компоненту, а добавление инерции как раз «погасит» паразитное направление. Получаем следующую картинку:\n\n![21_6_aa12e12568.webp](https://yastatic.net/s3/education-portal/media/21_6_aa12e12568_74c75bb6a7.webp)\n\nТакже удобно бывает представить метод моментума в виде двух параллельных итерационных процессов:\n\n$$\\begin{align}\n    v_{k+1} &= \\beta_k v_k - \\alpha_k \\nabla f(x_k)\\\\\n    x_{k+1} &= x_k + v_{k+1}.\n\\end{align}\n$$\n\n\n### Accelerated Gradient Descent (Nesterov Momentum)\n\nРассмотрим некоторую дополнительную модификацию, которая была предложена в качестве оптимального метода первого порядка для решения выпуклых оптимизационных задач.\n\nМожно доказать, что в сильно выпуклом и гладком случае найти минимум с точностью $\\varepsilon$ нельзя быстрее, чем за \n\n$$\n    \\Omega\\left( R^2\\exp\\left(-\\frac{k}{\\sqrt{\\kappa}}\\right) \\right)\n$$\n\nитераций, где $\\kappa$ – число обусловленности задачи. Напомним, что для обычного градиентного спуска в экспоненте у нас был не корень из $\\kappa$, а просто $\\kappa$, то есть, градиентный спуск справляется с плохой обусловленностью задачи хуже, чем мог бы.\n\nВ 1983 году Ю.Нестеровым был предложен алгоритм, имеющий оптимальную по порядку оценку. Для этого модифицируем немного моментум и будем считать градиент не в текущей точке, а как бы в точке, в которую мы бы пошли, следуя импульсу:\n\n$$\\begin{align}\n    v_{k+1} &= \\beta_k v_k - \\alpha_k \\nabla f(\\color{red}{x_k + \\beta_k v_k})\\\\\n    x_{k+1} &= x_k + v_{k+1}\n\\end{align}\n$$\n\nСравним с обычным momentum:\n\n![21_7_8744ece0bb.webp](https://yastatic.net/s3/education-portal/media/21_7_8744ece0bb_19560f458f.webp)\n\n\n_Комментарий: иногда упоминается, что Nesterov Momentum «заглядывает в будущее» и исправляет ошибки на данном шаге оптимизации. Конечно, никто не заглядывает в будущее в буквальном смысле._\n\nВ работе Нестерова были предложены конкретные (и довольно магические) константы для импульса, которые получаются из некоторой еще более магической последовательности. Мы приводить их не будем, поскольку мы в первую очередь заинтересованы невыпуклым случаем.\n\nNesterov Momentum позволяет значительно повысить устойчивость и скорость сходимости в некоторых случаях. Но, конечно, он не является серебряной пулей в задачах оптимизации, хотя в выпуклом мире и является теоретически неулучшаемым.\n\nТакже отметим, что ускоренный метод может напрямую примениться к проксимальному градиентному спуску. В частности, применение ускоренного метода к проксимальному алгоритму решения $\\ell_1$ регрессии (ISTA) называется FISTA (Fast ISTA).\n\n**Общие выводы:**\n\n* Добавление momentum к градиентному спуску позволяет повысить его устойчивость и избегать маленьких локальных минимумов/максимумов;\n* В выпуклом случае добавление моментного слагаемого позволяет доказуемо улучшить асимптотику и уменьшить зависимость от плохой обусловленности задачи.\n* Идея ускорения применяется к любым около-градиентным методам, в том числе и к проксимальным, позволяя получить, например, ускоренный метод для $\\ell_1$-регрессии.\n\n## Адаптивный подбор размера шага\n\nВыше мы попытались эксплуатировать свойства градиентного спуска. Теперь же пришел момент взяться за больной вопрос: как подбирать размер шага? Он максимально остро встаёт в случае SGD: ведь посчитать значение функции потерь в точке очень дорого, так что методы в духе наискорейшего спуска нам не помогут!\n\nНужно действовать несколько хитрее.\n\n### Adagrad\n\nРассмотрим первый алгоритм, который является адаптацией стохастического градиентного спуска. Впервые он предложен в [статье в JMLR 2011 года](http://jmlr.org/papers/v12/duchi11a.html), но она написана в очень широкой общности, так что читать её достаточно сложно.\n\nЗафиксируем $\\alpha$ – исходный learning rate. Затем напишем следующую формулу обновления:\n\n$$\\begin{align}\n    G_{k+1} &= G_k + (\\nabla f(x_k))^2 \\\\\n    x_{k+1} &= x_k - \\frac{\\alpha}{\\sqrt{G_{k+1} + \\varepsilon}} \\nabla f(x_k).\n\\end{align}\n$$\n\nВозведение в квадрат и деления векторов покомпонентные. По сути, мы добавляем некоторую квазиньютоновость и начинаем динамически подбирать размер шага для каждой координаты по отдельности. Наш размера шага для фиксированной координаты – это какая-то изначальная константа $\\alpha$ (learning rate), деленная на корень из суммы квадратов координат градиентов плюс дополнительный параметр сглаживания $\\varepsilon$, предотвращающий деление на ноль. Добавка $\\varepsilon$ на практике оставляется дефолтными `1e-8` и не изменяется.\n\nИдея следующая: если мы вышли на плато по какой-то координате и соответствующая компонента градиента начала затухать, то нам нельзя уменьшать размер шага слишком сильно, поскольку мы рискуем на этом плато остаться, но в то же время уменьшать надо, потому что это плато может содержать оптимум. Если же градиент долгое время довольно большой, то это может быть знаком, что нам нужно уменьшить размер шага, чтобы не пропустить оптимум. Поэтому мы стараемся компенсировать слишком большие или слишком маленькие координаты градиента.\n\nНо довольно часто получается так, что размер шага уменьшается слишком быстро и для решения этой проблемы придумали другой алгоритм.\n\n### RMSProp\n\nМодифицируем слегка предыдущую идею: будем не просто складывать нормы градиентов, а усреднять их в _скользящем режиме_:\n\n$$\\begin{align}\n    G_{k+1} &= \\gamma G_k + (1 - \\gamma)(\\nabla f(x_k))^2 \\\\\n    x_{k+1} &= x_k - \\frac{\\alpha}{\\sqrt{G_{k+1} + \\varepsilon}} \\nabla f(x_k).\n\\end{align}\n$$\n\nТакой выбор позволяет все еще учитывать историю градиентов, но при этом размер шага уменьшается не так быстро.\n\n**Общие выводы:**\n\n* Благодаря адаптивному подбору шага в современных оптимизаторах не нужно подбирать последовательность $\\alpha_k$ размеров всех шагов, а достаточно выбрать всего одно число – learning rate $\\alpha$, всё остальное сделает за вас сам алгоритм. Но learning rate все еще нужно выбирать крайне аккуратно: алгоритм может либо преждевременно выйти на плато, либо вовсе разойтись. Пример приведен на иллюстрации ниже.\n\n![21_8_58c11d1982.webp](https://yastatic.net/s3/education-portal/media/21_8_58c11d1982_67a298fcb7.webp)\n\n\n## Объединяем все вместе...\n\n### Adam\nТеперь покажем гвоздь нашей программы: алгоритм Adam, который считается решением по умолчанию и практически серебряной пулей в задачах стохастической оптимизации. \n\nНазвание Adam = ADAptive Momentum намекает на то, что мы объединим идеи двух последних разделов в один алгоритм. Приведем его алгоритм, он будет немного отличаться от [оригинальной статьи](https://arxiv.org/pdf/1412.6980) отсутствием коррекций смещения (bias correction), но идея останется той же самой:\n\n$$\\begin{align}\n    v_{k+1} &= \\beta_1 v_k + (1 - \\beta_1) \\nabla f(x_k) \\\\\n    G_{k+1} &= \\beta_2 G_k + (1 - \\beta_2)(\\nabla f(x_k))^2 \\\\\n    x_{k+1} &= x_k - \\frac{\\alpha}{\\sqrt{G_{k+1} + \\varepsilon}} v_{k+1}.\n\\end{align}\n$$\n\nКак правило, в этом алгоритме подбирают лишь один гиперпараметр $\\alpha$ – learning rate. Остальные же: $\\beta_1$, $\\beta_2$ и $\\varepsilon$ – оставляют стандартными и равными `0.9`, `0.99` и `1e-8` соответственно. Подбор $\\alpha$ составляет главное искусство. \n\nЗачастую, при начале работы с реальными данными начинают со значения learning rate равного 3e-4. История данного значения достаточно забавна: в 2016 году Андрей Карпатый (Andrej Karpathy) опубликовал шутливый [пост в Twitter](https://twitter.com/karpathy/status/801621764144971776).\n\n![21_9_f4ea80ad49.webp](https://yastatic.net/s3/education-portal/media/21_9_f4ea80ad49_f2d43c4d2a.webp)\n\nПосле чего сообщество подхватило эту идею (до такой степени, что иногда число `3e-4` называют Karpathy constant). \n\nОбращаем ваше внимание, что при работе с учебными данными зачастую полезно выбирать более высокий (на 1-2 порядка) начальный learning rate (например, при классификации MNIST, Fashion MNIST, CIFAR или при обучении языковой модели на примере поэзии выбранного поэта).\n\nТакже стоит помнить, что Adam требует хранения как параметров модели, так и градиентов, накопленного импульса и нормировочных констант (cache). Т.е. достижение более быстрой (с точки зрения количества итераций/объема рассмотренных данных) сходимости требует больших объемов памяти. Кроме того, если вы решите продолжить обучение модели, остановленное на некоторой точке, необходимо восстановить из чекпоинта не только веса модели, но и накопленные параметры Adam. В противном случае оптимизатор начнёт сбор всех своих статистик с нуля, что может сильно сказаться на качестве дообучения. То же самое касается вообще всех описанных выше методов, так как каждый из них накапливает какие-то статистики во время обучения.\n\n_Интересный факт_: [Adam расходится на одномерном контрпримере](https://arxiv.org/pdf/1904.09237), что совершенно не мешает использовать его для обучения нейронных сетей. Этот факт отлично демонстрирует, насколько расходятся теория и практика в машинном обучении. В той же работе предложено исправление этого недоразумения, но его активно не применяют и продолжают пользоваться «неправильным» Adamом потому что он быстрее сходится на практике.\n\n### AdamW\n\nА теперь давайте добавим $\\ell_2$-регуляризацию неявным образом, напрямую в оптимизатор и минуя адаптивный размер шага: \n\n$$\\begin{align}\n    v_{k+1} &= \\beta_1 v_k + (1 - \\beta_1) \\nabla f(x_k) \\\\\n    G_{k+1} &= \\beta_2 G_k + (1 - \\beta_2)(\\nabla f(x_k))^2 \\\\\n    x_{k+1} &= x_k - \\left( \\frac{\\alpha}{\\sqrt{G_{k+1} + \\varepsilon}} v_{k+1} \\color{red}{ + \\lambda x_{k}} \\right).\n\\end{align}\n$$\n\nЭто сделано для того, чтобы эффект $\\ell_2$-регуляризации не затухал со временем и обобщающая способность модели была выше. Оставим ссылку на одну [заметку](https://towardsdatascience.com/why-adamw-matters-736223f31b5d) про этот эффект. Отметим, впрочем, что этот алгоритм особо не используется.\n\n\n## Практические аспекты\n\n### Расписания\n\nЧасто learning rate понижают итеративно: каждые условные 5 эпох (LRScheduler в Pytorch) или же при выходе функции потерь на плато. При этом лосс нередко ведет себя следующим схематичным образом:\n\n![21_10_c00d6ba357.webp](https://yastatic.net/s3/education-portal/media/21_10_c00d6ba357_274a5a4ab3.webp)\n\nПомимо этого используют другие варианты «расписаний» для learning rate. Из часто применяемых неочевидных лайфхаков: сначала сделать warmup, то есть увеличивать learning rate, а затем начать постепенно понижать. Использовалось в известной [статье про трансформеры](https://papers.nips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf). В ней предложили следующую формулу:\n\n$$\n    lr = d^{-0.5}_{\\rm{model}} \\cdot \\min(step\\_ num^{-0.5}, step\\_ num \\cdot warmup\\_ steps^{-1.5}).\n$$\n\nПо сути, первые $warmup\\_ steps$ шагов происходит линейный рост размера шага, а затем он начинает уменьшаться как $1/\\sqrt{t}$, где $t$ — число итераций.\n\nЕсть и вариант с косинусом из [отдельной библиотеки для трансформеров](https://huggingface.co/transformers/main_classes/optimizer_schedules.html).\n\n![21_11_2b8059a205.webp](https://yastatic.net/s3/education-portal/media/21_11_2b8059a205_50aa041e53.webp)\n\nВ этой же библиотеке можно также почерпнуть идею рестартов: с какого-то момента мы снова включаем warmup, увеличивая размер шага.\n\n### Большие батчи\n\nПредставим ситуацию, что мы хотим обучить свою нейронную сеть на нескольких GPU. Одно из решений выглядит следующим образом: загружаем на каждую видеокарту нейронную сеть и свой отдельный батч, вычисляем стохастические градиенты, а затем усредняем их по всем видеокартам и делаем шаг. Что плохого может быть в этом?\n\nПо факту, эта схема в некотором смысле эквивалентна работе с одним очень большим батчем. Хорошо же, нет разве?\n\nНа самом деле существует так называемый generalization gap: использование большого размера батча может приводить к худшей обобщающей способности итоговой модели. О причине этого эффекта можно поспекулировать, базируясь на текущих знаниях о ландшафтах функций потерь [при обучении нейронных сетей](https://losslandscape.com/).\n\nБольший размер батча приводит к тому, что оптимизатор лучше «видит» ландшафт функции потерь для конкретной выборки и может скатиться в маленькие «узкие» паразитные локальные минимумы, которые не имеют обобщающий способности — при небольшом шевелении этого ландшафта (distributional shift c тренировочной на тестовую выборку) значение функции потерь резко подскакивает. В свою очередь, широкие локальные минимумы дают модель с лучшей обобщающей способностью. Эту идею можно увидеть на следующей картинке:\n\n![21_12_1c967fa6bc.webp](https://yastatic.net/s3/education-portal/media/21_12_1c967fa6bc_cf78d362ce.webp)\n\nИными словами, большие батчи могут приводить к переобучению, но это можно исправить правильным динамическим подбором learning rate, как будет продемонстрировано далее. Сразу отметим, что совсем маленькие батчи – это тоже плохо, с ними ничего не получится выучить, так как каждая итерация SGD знает слишком мало о ландшафте функции потерь.\n\n#### LARS\n\nМы рассмотрим нестандартный оптимизатор для обучения нейронных сетей, которого нет в Pytorch по умолчанию, но который много где используется: [Layer-wise Adaptive Rate Scaling (LARS)](https://arxiv.org/abs/1708.03888). Он позволяет эффективно использовать большие размеры батчей, что очень важно при вычислении на нескольких GPU. \n\nОсновная идея заключена в названии – нужно подбирать размер шага не один для всей сети или каждого нейрона, а отдельный для _каждого слоя_ по правилу, похожему на RMSProp. По сравнению с оригинальным RMSProp подбор learning rate для каждого слоя дает большую стабильность обучения.\n\nТеперь рассмотрим формулу пересчета: пусть $w_l$ – это веса слоя $l$, $l < L$. Параметры алгоритма: базовый learning rate $\\eta$ (на который запускается расписание), коэффициент инерции $m$, коэффециент затухания весов $\\beta$ (как в AdamW).\n\n```python\nfor l in range(L):                                              # Цикл по слоям\n    g_l = stochgrad(w_prev)[l]                                  # Вычисляем стохградиент из батча для текущего слоя\n    lr = eta * norm(w[l]) / (norm(g_l) + beta * norm(w[l]))     # Вычислеяем learning rate для текущего слоя\n    v[l] = m * v[l] + lr * (g_l + beta * w[l])                  # Обновляем momentum\n    w[l] -= v[l]                                                # Делаем градиентный шаг по всему слою сразу\nw_prev = w                                                      # Обновляем веса\n```\n\n#### LAMB\n\nЭтот оптимизатор введен в статье [Large Batch Optimization For Deep Learning](https://arxiv.org/abs/1904.00962) и является идейным продолжателем LARS, более приближенным к Adam, чем к обычному RMSProp. Его параметры – это параметры Adam $\\eta, \\beta_1, \\beta_2, \\varepsilon$, которые берутся как в Adam, а также параметр $\\lambda$, который отвечает за затухание весов ($\\beta$ в LARS). \n\n```python\nfor l in range(L):                                              # Цикл по слоям\n    g_l = stochgrad(w_prev)[l]                                  # Вычисляем стохградиент из батча для текущего слоя\n    m[l] = beta_1 * m[l] + (1 - beta_1) * g_l                   # Вычисляем моментум\n    v[l] = beta_2 * v[l] + (1 - beta_2) * g_l                   # Вычисляем новый размер шага\n    m[l] /= (1 - beta_1**t)                                     # Шаг для уменьшения смещения из Adam\n    v[l] /= (1 - beta_2**t)\n    r[l] = m[l] / sqrt(v[l] + eps)                              # Нормируем моментум как предписывает Adam\n    lr = eta * norm(w[l]) / norm(r[l] + llambda * w[l])         # Как в LARS\n    w[l] = w[l] - lr *  (r[l] + llambda * w[l])                 # Делаем шаг по моментуму\nw_prev = w                                                      # Обновляем веса\n```\n\n### Усреднение \n\nТеперь снова заглянем в теорию: на самом деле, все хорошие теоретические оценки для SGD проявляются, когда берётся усреднение по точкам.\n\nЭтот эффект при обучении нейронных сетей был исследован в статье про [алгоритм SWA](https://arxiv.org/abs/1803.05407). Суть очень проста: давайте усреднять веса модели по каждой $c$-й итерации; можно считать, что по эпохам. В итоге, веса финальной модели являются усреднением весов моделей, имевших место в конце каждой эпохи.\n\nВ результате такого усреднения сильно повышается обобщающая способность модели: мы чаще попадаем в те самые широкие локальные минимумы, о которых мы говорили в разделе про большие батчи. Вдохновляющая картинка из статьи прилагается:\n\n![21_13_4ffd39e8b7.webp](https://yastatic.net/s3/education-portal/media/21_13_4ffd39e8b7_63f2f47fe5.webp)\n\nНа второй и третьей картинке изображено сравнение SGD и SWA при обучении нейронной сети (Preactivation ResNet-164 on CIFAR-100) при одной и той же инициализации.\n\nНа первой же картинке изображено, как идеологически должен работать SWA. Также мы видим тут демонстрацию эффекта концентрации меры: после обучения стохастический градиентный спуск становится случайным блужданием по области в окрестности локального минимума. Если, например, предположить, что итоговая точка – это нормальное распределение с центром в реальном минимуме в размерности $d > 10^6$, то все эти точки с большой вероятности будут находиться в окрестности сферы радиуса $\\sqrt{d}$. Интуитивную демонстрацию многомерного нормального распределения можно увидеть на следующей картинке из книги Р.Вершинина \"High-Dimensional Probability\" (слева в размерности 2, справа в большой размерности):\n\n![21_14_c0f6658635.webp](https://yastatic.net/s3/education-portal/media/21_14_c0f6658635_4fc6bb36db.webp)\n\nПоэтому, чтобы вычислить центральную точку этой гауссианы, усреднение просто необходимо, по такому же принципу работает и SWA.\n\n### Предобуславливание\n\nТеперь мы снова обратимся к теории: скорость сходимости градиентного спуска (даже ускоренного) очень сильно зависит от числа обусловленности задачи. Разумной идеей будет попытаться использовать какие-то сведения о задаче и улучшить этот показатель, тем самым ускорив сходимость.\n\nВ теории, здесь могут помочь техники [предобуславливания](https://en.wikipedia.org/wiki/Preconditioner). Но, к сожалению, попытки наивно воплотить эту идею приводят к чему-то, похожему на метод Ньютона, в котором нужно хранить большую-большую матрицу для обучения больших моделей. Способ обойти эту проблему рассмотрели в статье о методе [Shampoo](https://arxiv.org/abs/1802.09568), который использует то, что веса нейронной сети зачастую удобно представлять как матрицу или даже многомерный тензор. Таким образом, Shampoo можно рассматривать как многомерный аналог AdaGrad.",
        "handbook": "Учебник по машинному обучению",
        "title": "Оптимизация в ML",
        "description": "Как найти оптимум функции потерь: от градиентного спуска до Adam"
    },
    {
        "path": "/handbook/ml/article/proksimalnye-metody",
        "content": "В этом разделе мы поговорим о том, как оптимизировать негладкие функции в ситуациях, когда «плохую» составляющую удаётся локализовать и она сравнительно несложная.\n\n## Проксимальная минимизация\n\nДля того, чтобы подступиться к проксимальным методам, посмотрим на градиентный спуск с другой стороны. Для простоты рассмотрим константный размер шага $\\alpha$. Перепишем шаг градиентного спуска следующим образом:\n\n$$\n    \\frac{x_{k+1} - x_k}{\\alpha} = - \\nabla f(x_k).\n$$\n\nПосмотрим на это уравнение по-другому. Рассмотрим функцию $x(t)$, равную $x_k$ при $(k-1)\\alpha < t \\leq \\alpha k$ ($t$ мы будем воспринимать, как некоторый временной параметр). Тогда при $t = \\alpha k$:\n\n$$\n    \\frac{x(t + \\alpha) - x(t)}{\\alpha} = - \\nabla f(x(t)).\n$$\n\nТеперь слева не что иное, как аппроксимация производной! Если мы устремим $\\alpha$ к нулю, то получится так называемое **уравнение градиентного потока**:\n\n$$\n    \\dot{x} = -\\nabla f(x).\n$$\n\nЭта динамика в случае выпуклой функции $f$ сходится к точке минимума $x^*$ из любой начальной точки при $t \\to +\\infty$. Сравнение между динамикой градиентного спуска и градиентного потока можно увидеть на следующем изображении:\n\n![Proksimalnye_metody_267da99b75.webp](https://yastatic.net/s3/education-portal/media/Proksimalnye_metody_267da99b75_90aeece918.webp)\n\nПервый состоит из дискретных шагов, второй же представляет из себя непрерывный процесс.\n\nНетрудно осознать физический смысл динамики $\\dot{x} = -\\nabla f(x)$: маленькое тело скатывается по склону графика функции так, что в любой момент её скорость совпадает с антиградиентом, то есть оно катится по направлению наискорейшего спуска.\n\nТеперь представим, что мы сейчас занимается не машинным обучением, а численными методами. Перед нами есть обыкновенное дифференциальное уравнение (ОДУ), и его надо решить. Одним из численных методов решения ОДУ (более стабильным, чем обычная схема Эйлера) является обратная схема Эйлера (backward Euler scheme):\n\n$$\n    \\frac{x_{k+1} - x_k}{\\alpha_k} = -\\nabla f(x_{\\color{red}{k+1}}).\n$$\n\nВ обратной схеме Эйлера мы делаем градиентный спуск, только градиент смотрим не в текущей точке (как было бы в обычной схеме Эйлера), а _буквально_ в будущей. Занятная идея, только вот напрямую выразить $x_{k+1}$ из этого уравнения не получится. Нужно поступить чуть хитрее. Заметим, что\n\n$$\\frac{(x_{k+1} - x_k)_i}{\\alpha_k} = \\left.\\frac{1}{2\\alpha_k} (x - x_k)^2_i \\right\\vert_{x_{k+1}}$$\n \nЭто позволяет нам сказать, что весь вектор $\\frac{x_{k+1} - x_k}{\\alpha_k}$ является градиентом функции $g(u) = \\frac{1}{2\\alpha_k} \\Vert u - x_{k} \\Vert^2$, посчитанном в точке $x_{k+1}$. Тогда получаем, что $x_{k+1}$ удовлетворяет следующему условию:\n\n$$\n    \\nabla\\left( g(u) + f(u) \\right)(x_{k+1}) = 0.\n$$\n\nЕсли функция $f(x)$ выпуклая, то $f(x) + g(x)$ тоже выпуклая, и её стационарная точка будет точкой минимума. Стало быть, $x_{k+1}$ можно высчитывать по формуле \n\n$$\n    x_{k+1} = \\arg\\min_{u}\\left\\{ f(u) + \\frac{1}{2\\alpha_k}\\Vert u - x_{k} \\Vert^2   \\right\\}.\n$$\n\nОпределим **прокс-оператор** следующим образом:\n\n$$\n    \\mathrm{prox}_{f}(x)  = \\arg\\min\\left\\{ f(u) + \\frac{1}{2}\\Vert u - x \\Vert^2   \\right\\}.\n$$\n\nТогда, поскольку умножение на $\\alpha_k > 0$ внутри арг-минимума не влияет на саму точку минимума, получаем следующую итеративную схему:\n\n$$\n    x_{k+1} = \\arg\\min\\left\\{ \\alpha_k \\left(f(u) + \\frac{1}{2\\alpha_k}\\Vert u - x \\Vert^2   \\right)\\right\\} = \n$$\n\n$$\n    \\arg\\min\\left\\{ \\alpha_k f(u) + \\frac{1}{2}\\Vert u - x \\Vert^2  \\right\\}= \\mathrm{prox}_{\\alpha_k f}(x_k).\n$$\n\nИтеративный процесс $x_{k+1} = \\mathrm{prox}_{\\alpha_k f}(x_k)$ называется **методом проксимальной минимизации**. Вы можете спросить себя: зачем он нужен? Ведь теперь на каждом шаге мы должны решать задачу оптимизации:\n\n$$\n    \\min_{u} f(u) + \\frac{1}{2\\alpha_k}\\Vert u - x_k \\Vert^2\n$$\n\nЕсли $f$ выпуклая, нам есть, что ответить: наличие второго слагаемого гарантирует сильную выпуклость задачи, то есть она решается достаточно эффективно. Но если $f$ не является выпуклой, то мы ничего не достигли этой модификацией.\n\n### Композитная оптимизация, проксимальный градиентный метод (PGM)\n\nЧтобы понять, зачем нам понадобилась проксимальная оптимизация, рассмотрим оптимизацию функций вида \n\n$$\n    \\min_{x} \\{ f(x) = g(x) + h(x)\\},\n$$\n\nгде $g(x)$ – это гладкая функция, а $h(x)$ – это функция, для которой прокс-оператор считается аналитически. Воспользуемся следующим трюком: по $g$ мы совершим градиентный шаг, а по $h$ – проксимальный. Получаем следующую итеративную процедуру:\n\n$$\n    x_{k+1} = \\mathrm{prox}_{\\alpha_k h} (x_k - \\alpha_k \\nabla g(x_k));\n$$\n\nЭта процедура определяет так называемый проксимальный градиентный метод (Proximal Gradient Method, PGM), который может использоваться, например, для решения задачи регрессии с $\\ell_1$-регуляризацией.\n\n### ISTA (Iterative Shrinkage-Thresholding Algorithm)\n\nТеперь решим конкретную задачу $\\ell_1$-регрессии. Она выглядит следующим образом:\n\n$$\n    \\Vert y - Xw \\Vert_2^2 + \\lambda \\Vert w \\Vert_1 \\to \\min_w.\n$$\n\nМы хотим применить PGM к этой задаче, для этого нужно научиться вычислять прокс-оператор для $\\ell_1$-нормы. Проделаем эту операцию:\n\n$$\n    \\mathrm{prox}_{\\alpha \\Vert \\cdot \\Vert_1}(x) = \\arg\\min_{u} \\left\\{  \\Vert u \\Vert_1 + \\frac{1}{2 \\alpha} \\Vert u - x \\Vert_2^2 \\right\\} = \n$$\n\n$$\n    = \\arg\\min_{u} \\left\\{ \\sum_{i=1}^d \\vert u_i \\vert +  \\frac{(u_i - x_i)^2}{2\\alpha}  \\right\\}.\n$$\n\nЗаметим, что каждое слагаемое зависит _только от одной координаты_. Это значит, что каждую координату мы можем прооптимизировать отдельно и получить $d$ одномерных задач минимизации вида \n\n$$\n    \\arg\\min_{u_i} \\left\\{ \\vert u_i \\vert + \\frac{(u_i - x_i)^2}{2\\alpha} \\right\\}.\n$$\n\nРешение такой одномерной задачи записывается в виде функции _soft thresholding_:\n\n$$\n    \\mathrm{prox}_{\\alpha \\Vert \\cdot \\Vert_1}(x)_i = \\begin{cases}\n        x_i - \\alpha &, x_i \\geq \\alpha \\\\\n        0 & \\vert x_i \\vert \\leq \\alpha \\\\\n        x_i + \\alpha & x_i \\leq - \\alpha\n    \\end{cases}\n$$\n\nТогда мы получаем следующий алгоритм для $\\ell_1$-регрессии, которые называются Iterative Shrinkage-Thresholding Algorithm (ISTA):\n\n```python\nw = normal(0, 1)                                            # инициализация\nrepeat S times:                                             # другой вариант: while abs(err) > tolerance\n    f = X.dot(w)                                            # посчитать предсказание\n    delta = f - y                                           # посчитать отклонение предсказания\n    grad = 2 * X.T.dot(delta) / n                           # посчитать градиент\n    w_prime = w - alpha * grad                              # считаем веса, которые отправим в прокс\n    for i in range(d):\n        w[i] = soft_threshold(w_prime[i], alpha * llambda)  # вычисляем прокс\n```\n\nЗаметим одну крутую особенность этого алгоритма -- мы явно видим, что решение получается разреженное, ведь какие-то координаты будут явно зануляться при применении soft threshold! Причем чем больше размер и шага, и параметра регуляризации, тем больше прореживается координат.\n\nКонкретно этот метод не применяется на практике, но используются его вариации. Например, [статья](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41159.pdf), которая указана в параграфе про [линейные модели](https://academy.yandex.ru/handbook/ml/article/linejnye-modeli) о том, как работало предсказание CTR в google в 2012 году, также базируется на вычислении soft threshold как прокс-оператора.\n\n\n### Общие выводы\n\nПодытожим все вышесказанное:\n\n1. Проксимальные методы – теоретически интересная идея для выпуклой оптимизации, которая должна давать более численно стабильные алгоритмы.\n2. Проксимальные методы позволяют достаточно эффективно решать задачи композитной оптимизации, в частности, $\\ell_1$-регуляризованную задачу регрессии. Более того, используемые на практике решения задачи $\\ell_1$-регуляризованной регрессии так или иначе базируются на идее ISTA. \n3. Также есть попытки использовать проксимальные методы для более сложных моделей. Например, [статья о применении их в нейросетях](https://arxiv.org/abs/1706.04638).\n\nКроме того, имеются применения проксимальных методов для построения распределенных алгоритмов. Все подробности можно найти в [монографии Neal Parikh и Stephen Boyd](https://web.stanford.edu/~boyd/papers/prox_algs.html), мы же только привели применение этих идей в машинном обучении.",
        "handbook": "Учебник по машинному обучению",
        "title": "Проксимальные методы",
        "description": "Как оптимизировать функции потерь с $L_1$-регуляризацией"
    },
    {
        "path": "/handbook/ml/article/metody-vtorogo-poryadka",
        "content": "В этом разделе мы сконцентрируемся сначала на методах, которые используют информацию о гессиане функции, а затем рассмотрим, как, сохраняя высокоуровневую идею метода Ньютона, обойтись без гессиана.\n\n## Метод Ньютона\n\nИтак, наша задача – безусловная оптимизация гладкой функции \n\n$$\n    f(x) \\to \\min_{x \\in \\mathbb{R}^d}.\n$$\n\nКак и при оптимизации методом градиентного спуска, мы будем искать направление уменьшения функционала. Но в этот раз мы будем использовать не линейное приближение, а квадратичное:\n\n$$\n    f(x + \\Delta x) \\approx f(x) + \\langle \\nabla f(x), \\Delta x \\rangle + \\frac{1}{2}\\langle \\Delta x, B(x) \\Delta x \\rangle.\n$$\n\nФормула Тейлора говорит нам брать $B(x) = \\nabla^2 f(x)$. Приравняв к нулю градиент этой квадратичной аппроксимации, мы получаем направление спуска для метода Ньютона:\n\n$$\n    \\Delta x = [B(x)]^{-1} \\nabla f(x).\n$$\n\nОбозначим $B_k = B(x_k), H_k = B_k^{-1}$. В таком случае мы можем записать итеративный алгоритм спуска:\n\n$$\n    x_{k+1} = x_{k} - \\alpha_k \\cdot H_k \\nabla f(x_k).\n$$\n\nВ литературе методом Ньютона называется такой метод при $\\alpha_k = 1$, при другом размере шаге $\\alpha_k \\in (0, 1)$ этот метод называют **дэмпированным** (damped) методом Ньютона. \n\nОбсудим, в чем главная особенность метода Ньютона и в чем заключается выигрыш по сравнению с классическим градиентным спуском. Таких особенностей две.\n\n### Скорость сходимости метода Ньютона\n\nПервая связана со скоростью его сходимости. А именно – в окрестности решения он сходится _квадратично_.\n\n**Теорема**. Пусть функция $f$ имеет достаточно гладкий гессиан и сильно выпукла в точке оптимума $x^*$. Тогда $\\exists r > 0$, что для всякого $x_0 : \\Vert x_0 - x^*\\Vert \\leq r$ для метода Ньютона с $\\alpha_k = 1$ верно $\\Vert x_{k+1} - x^* \\Vert \\leq c \\Vert x_k - x^* \\Vert^2$ для константы $c$ зависящей только от $f$.\n\n{% cut \"Набросок доказательства для интересующихся.\" %}\n\nНемного поясним терминологию. Под достаточно гладким гессианом мы подразумеваем то, что он должен быть _липшицевым_ и дифференцируемым, из чего следует, что\n    \n$$\n    \\Vert \\nabla^2 f(x) - \\nabla^2 f(y) \\Vert \\leq L \\Vert x - y \\Vert,\n$$\n\nа также\n\n$$ \n    \\Vert \\left[\\nabla^3 f(x)\\right] (x - y, x - y, \\cdot) \\Vert \\leq L \\Vert x - y\\Vert^2,\n$$\n\nгде $\\left[\\nabla^3 f(x)\\right] (x - y, x - y, \\cdot)$ – результат подстановки $(x - y)$ в качестве двух первых аргументов в трилинейную форму $\\left[\\nabla^3 f(x)\\right]$. Под сильной выпуклостью мы подразумеваем здесь $\\mu$-сильную выпуклость, которую здесь строго определять излишне (подробнее см. [в этой статье](https://en.m.wikipedia.org/wiki/Convex_function)), но из которой следует, что гессиан отделён от нуля:\n\n$$\\lambda_{\\min}(\\nabla^2 f(x)) \\geq \\mu$$\n\nРазложим градиент по формуле Тейлора в точке $x_k$ с остаточным членом в форме Лагранжа:\n\n$$\n    0 = \\nabla f(x^*) = \\nabla f(x_k) + \\nabla^2 f(x_k) (x^* - x_k) + \\frac{1}{2} \\nabla^3 f(\\xi_k) [x^* - x_k]^2.\n$$\n\nУмножим с обеих сторон на обратный гессиан и получаем:\n\n$$\n    x_k - [\\nabla^2 f(x_k)]^{-1} \\nabla f(x_k) - x^* = \\frac{1}{2} [\\nabla^2 f(x_k)]^{-1}\\nabla^3 f(\\xi_k) [x^* - x_k]^2.\n$$\n\nВоспользуемся формулой шага $x_{k+1} = x_k - [\\nabla^2 f(x_k)]^{-1} \\nabla f(x_k)$, тогда в левой части равенства у нас $x_{k+1} - x^*$. Посчитаем норму и воспользуемся гладкостью:\n\n$$\n    \\Vert x_{k+1} - x^* \\Vert \\leq \\frac{L}{2}  \\Vert [\\nabla^2 f(x_k)]^{-1} \\Vert  \\Vert x^* - x_k \\Vert^2.\n$$\n\nТеперь воспользуемся сильной выпуклостью в точке оптимума. Поскольку мы предполагаем, что точка старта достаточно близко к точке оптимума, то по гладкости можем считать, что в точке $x_k$ у нас есть хотя бы $\\mu/2$-сильная выпуклость. Тогда получаем:\n\n$$\n    \\Vert x_{k+1} - x^* \\Vert \\leq \\frac{L}{4\\mu} \\Vert x_k - x^* \\Vert^2.\n$$\n\n{% endcut %}\n\n### Метод Ньютона и плохо обусловленные задачи\n\nВторое приятное свойство заключается в устойчивости метода Ньютона к плохой обусловленности задачи (в отличие от метода градиентного спуска). Разберёмся, что это значит. Когда мы говорим о плохой обусловленности задачи, мы имеем в виду, что гессиан в точке оптимума плохо обусловлен, то есть отношение максимального и минимального собственных чисел является большим числом. Геометрически это значит, что линии уровня функции вблизи оптимума похожи на очень вытянутые эллипсоиды; мы уже обсуждали, что в такой ситуации градиентный спуск может работать медленно. А как справится метод Ньютона? Оказывается, намного лучше. И связано это с его инвариантностью к линейным преобразованиям.\n\nА именно, рассмотрим функцию $\\hat f(y) = f(Ay)$ для некоторой невырожденной матрицы $A$. Обозначим $x = Ay$. Посмотрим, как связаны градиент и гессиан новой функции с градиентом и гессианом старой. Воспользуемся производной сложной функции:\n\n$$\n    \\nabla_y \\hat f = A^\\top_x \\nabla f,\n$$\n\n$$\n    \\nabla^2_y \\hat f = A^\\top \\nabla^2_x f A\n$$\n\nРассмотрим теперь траекторию $x_0, x_1, \\ldots, x_K$ метода Ньютона, запущенного из точки $x_0$ для поиска минимума функции $f$, и траекторию $y_0, y_1, \\ldots,y_K$ метода Ньютона, запущенного для поиска минимума функции $\\hat f$. Если $x_0 = A y_0$, то для всех $k$ будет верно $x_k = A y_k$, то есть траектории получаются одна из другой при помощи этого линейного преобразования, другими словами, траектории исходной и новой функции подобны.\n\n\n{% cut \"Для интересующихся доказательствами.\" %}\n    \nДокажем по индукции. Для $k=0$ это дано по условию. Теперь докажем шаг индукции:\n\n$$\n    y_{k+1} = y_{k} - \\alpha_k [ \\nabla^2_{y_k} \\hat f]^{-1} \\nabla_{y_k} \\hat f = \n$$\n\n$$\n    y_k - \\alpha_k (A^{-1} [\\nabla^2_{A y_k} f] A^{-\\top}) (A^{\\top} \\nabla_{A y_k} f).\n$$\n\nПо предположению индукции $x_k = A y_k$, тогда получаем:\n\n$$\n    y_{k+1} = A^{-1} ( x_k - \\alpha [\\nabla^2 \\hat f(x_k)] \\nabla f(x_k) ) = A^{-1} x_{k+1} \\Rightarrow x_{k+1} = A y_{k+1}.\n$$  \n\n{% endcut %}\n\nВернёмся теперь к плохо обусловленной задаче минимизации функции $f$. Рассмотрим линейное преобразование $A = (\\nabla^2_{x^*} f)^{-1/2}$ и функцию $\\hat f(x) = f(Ax)$. Тогда для функции $\\hat f$ число обусловленности гессиана в точке оптимума равно в точность единице (проверьте это!), а траектории для этой новой, хорошо обусловленной функции, и старой, плохо обусловленной, подобны. В частности, метод Ньютона не будет, как градиентный спуск, долго метаться где-то на задворках вытянутой эллиптической «ямки» вокруг оптимума, а быстро ринется к центру.\n\nМожно сказать, что метод Ньютона правильно улавливает кривизну линий уровня функции и это позволяет ему быстрее сходиться к оптимуму. Эту идею стоит запомнить, она появляется в некоторых вдохновлённых методами второго порядка модификациях SGD.\n\nТакже еще можно заметить, что свойства, которые мы требуем от функции в теореме о квадратичной сходимости, вообще говоря, не сохраняются при линейных преобразованиях: могут поменяться константы липшицевости и сильной выпуклости. Это простое замечание побудило исследователей ввести класс самосогласованных функций, более широкий и линейно инвариантный, для которого метод Ньютона также сходится. Подробнее об этом можно узнать в [разделе 9.6 книги S. Boyd & L. Vandenberghe, Convex Optimization](https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf).\n\n### Слабости метода Ньютона\n\nОт хорошего переходим к плохому: к слабостям метода Ньютона. Во-первых, мы имеем квадратичную скорость сходимости только в _окрестности_ оптимума. А если мы стартуем из произвольно удалённой точки, то нам, как и в случае градиентного спуска, требуется подбор шага $\\alpha_k$ при помощи линейного поиска (что нам вряд ли по карману). Если подбирать шаг не хочется, можно прибегнуть к интересному теоретическому методу получения гарантий на глобальную сходимость – добавлению кубической регуляризации.\n\n{% cut \"Немного деталей для пытливых\" %}\n\nВ случае кубической регуляризации мы хотим обеспечить не просто аппроксимацию, но и оценку сверху:\n\n$$\n    f(x + \\Delta x) \\leq f(x) + \\langle \\nabla f(x), \\Delta x \\rangle + \\frac{1}{2}\\langle \\Delta x, \\nabla^2 f(x) \\Delta x \\rangle + \\frac{M}{6} \\Vert \\Delta x \\Vert^3_2.\n$$\n\nПо сути, мы задаем кубическую модель, которую мы можем уже оптимзировать по $\\Delta x$. Тогда мы получаем следующую итеративную процедуру _проксимального вида_:\n\n$$\n    x_{k+1} = \\arg\\min_{y} \\biggl\\{ f(x_k) + \\langle \\nabla f(x_k), y - x_k \\rangle + \\frac{1}{2}\\langle y-x_k, \\nabla^2 f(x_k) (y - x_k) \\rangle + \\frac{M}{6} \\Vert y - x_k \\Vert^3_2\n    \\biggl\\}\n$$\n\nВ таком случае можно использовать, например, постоянный размер шага и иметь гарантии на сходимость. Этот метод в последнее время стал пользоваться популярностью в теоретических исследованиях, в том числе в распределенной оптимизации. \n\nТакже можно задаться простым вопросом: а можем ли мы пользоваться подобным разложением с регуляризацией для большего числа членов разложения по формуле Тейлора? На самом деле да, только коэффициент $M$ нужно подбирать чуть более специфично. Такие методы называются _тензорными методами_. \n\n{% endcut %}\n\nДругая проблема кроется в формуле пересчета следующей итерации: _вычисление и обращение гессиана_. Конечно, вместо обращения гессиана можно честно решать систему линейных уравнений, но асимптотика остается прежней: $O(d^3)$, а от затрат памяти на хранение матрицы $O(d^2)$ вообще некуда деться. А это значит, что, например, решать линейную регрессию с ~10000 признаками методом Ньютона попросту невозможно. \n\nЕсть и третья, малозаметная проблема: дословно метод Ньютона не работает для невыпуклых задач, поскольку $\\nabla^2 f(x)$ не будет положительно опредленной и $\\Delta x$ перестанет быть направлением спуска. Для решения этой проблемы можно немного «подпортить» нашу аппроксимацию и рассмотреть матрицу вида $B_k = \\nabla^2 f(x_k) + \\Delta_k$, такую что $B_k$ станет положительно определенной, и уже её подставлять в нашу квадратичную модель. Идея подмены гессиана на что-то более подходящее – это главная идея квазиньютоновских методов, обсуждаемых далее.\n\nИтак, общие выводы:\n* Метод Ньютона – теоретически оптимальный метод, который автоматически улавливает кривизну функции в окрестности оптимума.\n* Для размерности $d > 1000$ он уже не является эффективным, поскольку требует вычисления и хранения гессиана, а также решения системы линейных уравнений с его участием (что может быть в общем случае очень дорого).\n\n## Квазиньютоновские методы\n\nЧтобы придумать, как бороться с проблемами метода Ньютона, нужно посмотреть на него с другой стороны, а для этого мы обратимся ненадолго к решению задачи нахождения нуля векторной функции.\n\n### Метод касательной\n\nИтак, рассмотрим совершенно новую задачу. Пусть дана функция $g \\colon \\mathbb{R}^n \\to \\mathbb{R}^n$ и нужно найти её ноль, то есть такое $x^*$, что $g(x^*) = 0$. Связь с оптимизацией (_по крайней мере в выпуклом случае_) довольно проста: если взять $g(x) = \\nabla f(x)$, то корень уравнения $g(x) = 0$ и будет точкой оптимума.\n\nСначала рассмотрим одномерный случай $d=1$. Как найти ноль функции с помощью итеративной процедуры? Логично поступить следующим образом: проводим касательную $y = g'(x_n)(x - x_n) + g(x_n)$ к графику функции и находим точку $x_{n+1}$, в которой линейная аппроксимация обнуляется:\n\n$$0 = g'(x_n)(x_{n+1} - x_n) + g(x_n),$$\n\nоткуда получаем формулу пересчета\n\n$$\n    x_{n+1} = x_n - \\frac{g(x_n)}{g'(x_n)}.\n$$\n\n \n![23_1_241d0fc91a.webp](https://yastatic.net/s3/education-portal/media/23_1_241d0fc91a_b91154211d.webp)\n\nИзвестно, что этот метод обладает квадратичной скоростью сходимости в одномерном мире, что очень перекликается с методом Ньютона для оптимизации – и не просто так.\n\nЕсли рассмотреть многомерный случай, то вычисление производной заменяется на вычисление якобиана векторнозначной функции $g$. В случае $g = \\nabla f$ наш якобиан становится гессианом и получаем в точности обычный метод Ньютона для оптимизации:\n\n$$\n    x_{n+1} = x_n - \\left[\\nabla^2_{x_n} f\\right]^{-1} \\nabla_{x_n} f.\n$$\n\n### Метод секущей и общая схема квазиньютоновских методов\n\n\nПусть мы хотим найти такую точку $x^*$, что $g(x^*) = 0$. В одномерном случае мы можем подменить вычисление $g'(x_n)$ вычислением её приближения $g(x_n) - g(x_{n-1}) / (x_n - x_{n-1})$. Откуда получаем формулу пересчета:\n\n$$\n    x_{n+1} = x_{n} - \\frac{x_n - x_{n-1}}{g(x_n) - g(x_{n-1})} g(x_n)\n$$\n\nГрафически, этот метод выглядит следующим образом:\n\n![23_2_f753f18d7e.webp](https://yastatic.net/s3/education-portal/media/23_2_f753f18d7e_d22215a18e.webp)\n\nСкорость сходимости этого метода несколько ниже, чем у метода Ньютона (линейная, а не квадратичная), но зато мы теперь не должны вычислять производную! В текущем виде, используя просто подмену градиента на его конечно-разностную аппроксимацию, не очевидно, как обобщить этот метод на произвольную размерность. Но, если посмотреть на название метода и на картинку, как он работает, мы видим, что мы по сути проводим через два предыдущих приближения секущую, а затем выбираем ноль этой секущей в качестве следующей точки. В многомерном случае мы можем выписать соответствующее ей уравнение $y = B_k(x - x^k) + g(x^{k})$, где $B_k$ – матрица размера $d \\times d$, которая должна удовлетворять так называемому _уравнению секущей_ (secant equation):\n\n$$\n    B_k(x^k - x^{k-1}) = g(x^k) - g(x^{k-1}).\n$$\n\nТеперь, чтобы выбрать следующую точку, нужно найти ноль секущей, то есть\n\n$$\n    B_k(x^{k+1} - x^{k}) + g(x^k) = 0 \\iff  x^{k+1} = x^k - B_k^{-1} g(x^k).\n$$\n\nА теперь рассмотрим $g(x) = \\nabla f(x)$ и добавим в итеративную схему выше размер шага. Тогда мы получаем общую итеративную схему квазиньютоновских методов:\n\n$$\n    x^{k+1} = x^k - \\alpha_k B_k^{-1} \\nabla f(x^k).\n$$\n\nПри этом необходимо выбирать такие $B_k$, чтобы они \n\n(а) были симметричными и положительно определенными и \n\n(б) удовлетворяли уравнению секущей\n\n$$B_k(x^{k} - x^{k-1}) = \\nabla f(x^k) - \\nabla f(x^{k-1})$$\n\nПервое требование восходит к двум соображениям. Первое – $B_k$ должно приближать гессиан, а он в идеале в окрестности точки минимума как раз является симметричным и положительно определенным. Второе соображение проще: в противном случае $d_k = -B_k^{-1} \\nabla f(x^k)$ попросту не будет направлением спуска. Несмотря на эти два свойства, выбор по прежнему остается достаточно широким, откуда возникает большое разнообразие квазиньютоновских методов. Мы рассмотрим один классический и широко известный метод BFGS (Broyden, Fletcher, Goldfarb, Shanno).\n\n### BFGS \n\nСначала заметим, что в самом алгоритме в первую очередь используется обратная матрица к $B_k$, которую мы обозначим $H_k = B_k^{-1}$. Тогда выбирать $B_k$ – это тоже самое, что выбирать $H_k$. Введем еще два стандартных обозначения, чтобы можно было проще записывать все последующие формулы: $s_k = x_{k+1} - x_{k} = \\alpha_k d_{k}$ и $y_k = \\nabla f(x^{k+1}) - \\nabla f(x^k)$. В их терминах уравнение секущей для $H_k$ выглядит максимально просто: $H_{k} y_{k-1} = s_{k-1}$.\n\nТеперь введем некоторое искусственное требование, которое гарантирует единственность $H_{k+1}$ – выберем ближайшую подходящую матрицу к $H_k$, удовлетворяющую описанным выше условиям:\n\n$$\n    H_{k+1} = \\text{argmin}_H\\left\\{\\left.\\frac12\\Vert H - H_k \\Vert\\right| Н = H^\\top, \\ \\ H y_k = s_k\\right\\}\n$$\n\nВообще говоря, при выборе разных норм $\\Vert \\cdot \\Vert$ мы будем получать разные квазиньютоновские алгоритмы. Рассмотрим один достаточно общий класс норм (аналог взвешенных $\\ell_2$ норм в матричном мире):\n\n$$\n    \\Vert A \\Vert := \\Vert W^{1/2} A W^{1/2} \\Vert_F,\n$$\n\nгде $\\Vert \\cdot \\Vert_F$ – это Фробениусова норма\n\n$$\\Vert C \\Vert_F^2 = \\langle C, C\\rangle_F = \\text{tr}(C^\\top C) = \\sum_{i,j} C_{ij}^2,$$\n\nа $W$ – некоторая симметричная и положительно определенная матрица весов, которую мы выберем таким образом, что она будет сама по себе удовлетворять уравнению секущей $Ws_k = y_k$. \n\nСразу уточним, что матрица весов в таком случае меняется на каждой итерации и, по сути, на каждой итерации мы имеем разные задачи оптимизации, само же предположение задает дополнительную похожесть на обратный гессиан, поскольку можно взять в качестве весов усредненый гессиан\n\n$$W = \\bar G_k = [\\int_0^1 \\nabla^2 f(x_k + \\tau \\alpha_k p_k) d\\tau]$$\n\nРешив описанную выше оптимизационную задачу, мы получаем матрицу $H_{k+1}$, не зависящую явным образом от матрицы весов:\n\nЭта формула как раз является ключевой в алгоритме BFGS. Чтобы заметить одно крайне важное свойство этой формулы, раскроем скобки:\n\n$$\n    H_{k+1} = H_k - \\rho_k (H_k y_k s_k^{\\top} + s_k y_k^\\top H_k) + \\rho_k^2 (s_k y_k^\\top H_k y_k s_k^\\top)  + \\rho_k s_k s_k^\\top.\n$$\n\nОтсюда мы видим, что нам в этой формуле достаточно умножать матрицу на вектор и складывать матрицы, что можно делать за $O(d^2)$ операций! То есть мы победили один из самых страшных минусов метода Ньютона. Воспользовавшись тем, что $ y_k^\\top H_k y_k $ и $1/\\rho_k = y_k^\\top s_k = s_k^\\top y_k$ – числа, перепишем формулу в более computational friendly стиле:\n\n$$\n    H_{k+1} = H_k + \\rho_k^2 (1/\\rho_k + y_k^\\top H_k y_k)(s_k s_k^\\top) - \\rho_k (H_k y_k s_k^{\\top} + s_k y_k^\\top H_k).\n$$\n\nОбщие выводы:\n* Итерации BFGS вычислительно проще итераций метода Ньютона и не требуют вычисления гессиана;\n* По скорости сходимости BFGS уступает методу Ньютона, но все равно является достаточно быстрым;\n* По прежнему требуется $O(d^2)$ памяти, что по-прежнему вызывает проблемы при большой размерности ($10^4-10^5$).\n* Время выполнения итерации $O(d^2)$ гораздо лучше, чем $O(d^3)$ метода Ньютона, но всё ещё оставляет желать лучшего.\n\nКазалось бы, избавиться от $O(d^2)$ нельзя принципиально, ведь нужно как-то взаимодействовать с матрицей $H_k$ размера $O(d^2)$, а она не факт что разреженная. Но и в этом случае можно добиться улучшения до линейной сложности (как у градиентных методов!).\n\n### L-BFGS\n\nПри взаимодействии с матрицами существует два основных способа хранить их дешевле, чем «по-честному». Первый способ – пользоваться разреженностью матрицы, а второй – низкоранговыми разложениями или чем-то близким. Поскольку сейчас мы не хотим добавлять предположений на задачу, которую мы решаем, то единственный выход – это пользоваться структурой $H_k$, возникающей в BFGS.\n\nЕсли внимательно взглянуть на формулы обновления, то их можно переписать в следующем виде:\n\n$$\n    H_{k+1} = V(s_k, y_k)^\\top H_k V(s_k, y_k) + U(s_k, y_k),\n$$\n$$\n    V(s_k, y_k) = I - \\rho_k y_k s_k^\\top, \\ \\ \\ U(s_k,y_k) = \\rho_k s_k s_k^\\top\n$$\n\nДля того, чтобы перейти от $H_k$ к $H_{k+1}$, можно хранить не матрицу $H_{k}$, а набор пар из k пар $(s_i, y_i)_{i=1,\\ldots,k}$ и начальное приближение $H_0$ (например, $H_0 = \\gamma I$ для некоторого $\\gamma > 0$), чтобы «восстановить» $H_k$. Пользуясь такой структурой, мы можем хранить матрицу $H_{k+1}$ при помощи лишь $(k+1) \\cdot 2d + 1$ чисел, а не $d^2$. К сожалению, такая структура имеет довольно простую проблему: при $k > d/2$ затраты памяти становятся только выше. \n\nВозникает простая идея – а давайте хранить только последние $m = \\text{const}$ обновлений! Таким образом, мы получаем алгоритм L-BFGS, который имеет уже линейные $O(md)$ затраты памяти и, что немаловажно, такие же линейные затраты $O(md)$ на итерацию, ведь умножение матриц $V$ и $U$ на вектор может осуществляться за линейное время.\n\nОбщие выводы:\n* L-BFGS обладает линеной сложностью итерации, линейными требованиями по дополнительной памяти и к тому же требует вычислять только градиенты!\n* Производительность сильно зависит от константы $m$, отвечающей за точность аппроксимации гессиана;\n* Как и все методы из этого раздела, требует точного, а не стохастического вычисления градиентов.\n\n## Практические аспекты \n\nИз всех перечисленных в этом разделе методов важнее всего отметить L-BFGS как самый практичный. Он реализован в любой* библиотеке, которая имеет дело с оптимизацией чего-либо и может быть эффективным, если удаётся вычислить градиенты (и значения функций для линейного поиска размера шага). К сожалению, это получается не всегда: при больших размерах датасета вычисление честного градиента и значения для функционалов вида суммы\n\n$$\n    L(X,Y) = \\sum_{i=1}^N L(x_i, y_i)\n$$\n\nне представляется возможным за разумное время. В таком случае мы вынуждены вернуться в мир стохастического градиентного спуска. Общая идея более тонкого учёта геометрии линий уровня функции потерь, в чём-то напоминающая происходящее в методе Ньютона, находит применение и в ряде вариаций SGD, но, конечно, порождает совершенно другие методы.\n\nЧто же касается самого метода Ньютона, его можно несколько оптимизировать, если смириться с тем, что всё вычисляется неточно. Во-первых, обратную матрицу к гессиану матрицу на самом деле не нужно ни хранить, ни даже вычислять. Давайте разберёмся, почему. Умножить $(\\nabla^2f)^{-1}$ на вектор $v$ – это то же самое, что решить систему с левой частью $\\nabla^2f$ и правой частью $v$, а для решения систем уравнений существуют эффективные итеративные методы, не меняющие левой части системы, а требующие лишь уметь умножать её на разные векторы. При этом умножать гессиан на вектор можно при помощи автоматического дифференцирования. Кроме того, можно на кажом шаге неточно решать систему, получая таким образом неточный метод Ньютона. Теория предписывает решать систему все точнее с ростом номера итерации, но на практике нередко используют фиксированное и небольшое число шагов итеративных методов решения систем линейных уравнений.",
        "handbook": "Учебник по машинному обучению",
        "title": "Методы второго порядка",
        "description": "От метода Ньютона до LBFGS"
    },
    {
        "path": "/handbook/ml/article/shodimost-sgd",
        "content": "Стохастический Градиентный Спуск (SGD) имеет достаточно простую запись:\n\n$$\nx_{k+1} = x_k - \\alpha_k g_k.\n$$\n\nЗдесь $g_k$ &mdash; это некоторая аппроксимация градиента целевой функции $\\nabla f(x_k)$ в точке $x_k$, называемая стохастическим градиентом (или просто стох. градиентом), $\\alpha_k > 0$ &mdash; это размер шага (stepsize, learning rate) на итерации $k$. Для простоты мы будем считать, что $\\alpha_k = \\alpha > 0$ для всех $k \\geq 0$. Обычно предполагается, что стох. градиент является несмещённой оценкой $\\nabla f(x_k)$ при фиксированном $x_k$: $\\mathbb{E}\\left(g_k \\mid x_k\\right) = \\nabla f(x_k)$. \n\n## Доказательство сходимости\n\nЗададимся следующим вопросом: с какой скоростью и в каком смысле SGD сходится к решению и сходится ли? Во-первых, как и во многих работах по стохастической оптимизации, нас будет интересовать сходимость метода в среднем, т.е. оценки на $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_\\ast\\vert\\vert^2\\right)$ или $\\mathbb{E}\\left(f(x_k) - f(x_\\ast)\\right)$, где $x_\\ast$ &mdash; решение задачи (для простоты будем считать, что оно единственное). \n\nВо-вторых, чтобы SGD сходился в указанном смысле, необходимо ввести дополнительные предположения. Действительно, например, если дисперсия стох. градиента не ограничена $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert g_k - \\nabla f(x_k)\\vert\\vert^2 \\mid x_k\\right) = \\infty$, то $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_\\ast\\vert\\vert^2\\right) = \\infty$ и никаких разумных гарантий доказать не удаётся. Поэтому дополнительно к несмещённости часто предполагается, что дисперсия равномерно ограничена: предположим, что существует такое число $\\sigma \\ge 0$, что для всех $k \\ge 0$ выполнено\n\n$$\n\\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k - \\nabla f(x_k)\\vert\\vert^2\\right| x_k\\right) \\leq \\sigma^2.\n$$\n\nДанное предположение выполнено, например, для задачи логистической регрессии (поскольку в данной задаче норма градиентов слагаемых ограничена), но в то же время является весьма обременительным. Его можно заменить на более реалистичные предположения, что мы немного затронем далее. Однако при данном предположении анализ SGD является очень простым и полезным для дальнейших обобщений и рассуждений.\n\nДля простоты везде далее мы будем считать, что функция $f$ является **$L$-гладкой** и **$\\mu$-сильно выпуклой**, т.е. для всех $x, y \\in \\mathbb{R}^d$ выполнены неравенства\n\n$$\n    \\vert\\vert\\nabla f(x) - \\nabla f(y)\\vert\\vert \\leq L\\vert\\vert x-y\\vert\\vert,\n$$\n\n$$\n    f(y) \\geq f(x) + \\langle\\nabla f(x), y- x \\rangle + \\frac{\\mu}{2}\\vert\\vert y - x\\vert\\vert^2.\n$$\n\n**Теорема**. Предположим, что $f$ является $L$-гладкой и $\\mu$-сильно выпуклой, стох. градиент $g_k$ имеет ограниченную дисперсию, и размер шага удовлетворяет $0 < \\alpha \\leq 1/L$. Тогда для всех $k \\geq 0$ выполняется неравенство\n\n$$\n        \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2\\right) \\leq (1 - \\alpha\\mu)^k\\vert\\vert x_0 - x_{\\ast}\\vert\\vert^2 + \\frac{\\alpha\\sigma^2}{\\mu}.\n$$\n\n**Доказательство.** Используя выражение для $x_{k+1}$, мы выводим\n\n$$\n\\vert\\vert x_{k+1} - x_\\ast \\vert\\vert^2 = \\vert\\vert x_k - x_{\\ast} - \\alpha g_k\\vert\\vert^2\\\\\n= \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha \\langle x_k - x_{\\ast}, g_k \\rangle + \\alpha^2 \\vert\\vert g_k\\vert\\vert^2\n$$\n\nДалее мы берём условное матожидание $\\mathbb{E}\\left(\\cdot\\mid x_k\\right)$ от левой и правой частей и получаем:\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right| x_k\\right) = \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha\\mathbb{E}\\left( \\langle x_k - x_{\\ast}, g_k \\rangle \\mid x_k\\right) + \\alpha^2 \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right)\\\\\n    = \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha\\left\\langle x_k - x_{\\ast}, \\mathbb{E}\\left(g_k \\mid x_k\\right) \\right\\rangle + \\alpha^2 \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right)\\\\\n    = \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha\\langle x_k - x_{\\ast}, \\nabla f(x_k)\\rangle + \\alpha^2 \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right).\n$$\n\nСледующий шаг в доказательстве состоит в оценке второго момента $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2 \\mid x_k\\right)$. Используя предположение об ограниченности дисперсии стох. градиента, мы выводим:\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right) = \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert\\nabla f(x_k) + g_k - \\nabla f(x_k)\\vert\\vert^2\\right| x_k\\right)\\\\\n    = \\vert\\vert\\nabla f(x_k)\\vert\\vert^2 + \\mathbb{E}\\left(\\langle \\nabla f(x_k), g_k - \\nabla f(x_k) \\rangle \\mid x_k\\right) + \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k - \\nabla f(x_k)\\vert\\vert^2 \\right| x_k\\right)\\\\\n    = \\vert\\vert\\nabla f(x_k)\\vert\\vert^2 + \\left\\langle \\nabla f(x_k), \\mathbb{E}\\left(g_k - \\nabla f(x_k) \\mid x_k\\right)\\right\\rangle  + \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k - \\nabla f(x_k)\\vert\\vert^2 \\right| x_k\\right)\\\\\n    = \\vert\\vert\\nabla f(x_k)\\vert\\vert^2 + \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k - \\nabla f(x_k)\\vert\\vert^2 \\right| x_k\\right)\\\\\n    \\leq \\vert\\vert\\nabla f(x_k)\\vert\\vert^2 + \\sigma^2\n$$\n\nЧтобы оценить сверху $\\vert\\vert\\nabla f(x_k)\\vert\\vert^2$, мы используем следующий факт, справедливый для любой выпуклой $L$-гладкой функции $f$ (см. книгу Ю. Е. Нестерова \"Методы выпуклой оптимизации\", 2010):\n\n$$\n    \\vert\\vert\\nabla f(x) - \\nabla f(y)\\vert\\vert^2 \\leq 2L\\left(f(x) - f(y) - \\langle \\nabla f(y), x- y \\rangle\\right).\n$$\n\nБеря в этом неравенстве $x = x_k$, $y = x_\\ast$ и используя $\\nabla f(x_\\ast) = 0$, получаем\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right) \\leq 2L\\left(f(x_k) - f(x_\\ast)\\right) + \\sigma^2.\n$$\n\nДалее мы подставляем эту оценку в выражение для $\\mathbb{E}\\left(\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2 \\mid x_k\\right)$:\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right| x_k\\right) \\leq \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha\\langle x_k - x_{\\ast}, \\nabla f(x_k)\\rangle + 2\\alpha^2L\\left(f(x_k) - f(x_\\ast)\\right) + \\alpha^2\\sigma^2.\n$$\n\nОстаётся оценить скалярное произведение в правой части неравенства. Это можно сделать, воспользовавшись сильной выпуклостью функции $f$: из\n\n$$\n    f(x_\\ast) \\geq f(x_k) + \\langle\\nabla f(x_k), x_\\ast - x_k \\rangle + \\frac{\\mu}{2}\\vert\\vert x_\\ast - x_k\\vert\\vert^2\n$$\n\nследует\n\n$$\n    \\langle\\nabla f(x_k), x_k - x_\\ast \\rangle \\geq f(x_k) - f(x_\\ast) + \\frac{\\mu}{2}\\vert\\vert x_k - x_\\ast\\vert\\vert^2.\n$$\n\nИспользуя это неравенство в выведенной ранее верхней оценке на $\\mathbb{E}\\left(\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\mid x_k\\right)$, мы приходим к следующему неравенству:\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right| x_k\\right) \\leq (1-\\alpha\\mu)\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 -2\\alpha(1 - \\alpha L)\\left(f(x_k) - f(x_\\ast)\\right) + \\alpha^2\\sigma^2\\\\\n    \\leq (1-\\alpha\\mu)\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 + \\alpha^2\\sigma^2,\n$$\n\nгде в последнем неравенстве мы воспользовались неотрицательностью $2\\alpha(1 - \\alpha L)\\left(f(x_k) - f(x_\\ast)\\right)$, что следует из $0 < \\alpha \\leq 1/L$ и $f(x_k) \\geq f(x_\\ast)$. Чтобы получить результат, заявленный в теореме, нужно взять полное мат. ожидание от левой и правой частей полученного неравенства (воспользовавшись при этом крайне полезным свойством условного мат. ожидания &mdash; tower property: $\\mathbb{E}\\left(\\mathbb{E}\\left(\\cdot\\mid x^k\\right)\\right) = \\mathbb{E}\\left(\\cdot\\right)$)\n\n$$\n    \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right) \\leq (1-\\alpha\\mu)\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2\\right) + \\alpha^2\\sigma^2,\n$$\n\nа затем, применяя это неравенство для $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2\\right)$, $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_{k-1} - x_{\\ast}\\vert\\vert^2\\right)$, $\\ldots$ , $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_1 - x_{\\ast}\\vert\\vert^2\\right)$, получим\n\n$$\n\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right) \\leq (1-\\alpha\\mu)^{k+1}\\vert\\vert x_0 - x_{\\ast}\\vert\\vert^2 + \\alpha^2\\sigma^2\\sum\\limits_{t=0}^k (1-\\alpha\\mu)^t\\\\\n\\leq (1-\\alpha\\mu)^{k+1}\\vert\\vert x_0 - x_{\\ast}\\vert\\vert^2 + \\alpha^2\\sigma^2\\sum\\limits_{t=0}^\\infty (1-\\alpha\\mu)^t\\\\\n= (1 - \\alpha\\mu)^{k+1}\\vert\\vert x_0 - x_{\\ast}\\vert\\vert^2 + \\frac{\\alpha\\sigma^2}{\\mu},\n$$\n\nчто и требовалось доказать.\n\nДанный результат утверждает, что SGD с потоянным шагом сходится линейно к окрестности решения, радиус которой пропорционален $\\tfrac{\\sqrt{\\alpha} \\sigma}{\\sqrt{\\mu}}$. Отметим, что чем больше размер шага $\\alpha$, тем быстрее SGD достигает некоторой окрестности решения, в которой продолжает осциллировать. Однако чем больше размер шага, тем больше эта окрестность. Соответственно, чтобы найти более точное решение, необходимо уменьшать размер шага в SGD. Этот феномен хорошо проиллюстрирован [здесь](https://fa.bianp.net/teaching/2018/COMP-652/stochastic_gradient.html).\n\nТеорема выше доказана при достаточно обременительных предположениях: мы предположили, что функция является сильно выпуклой, $L$-гладкой и стох. градиент имеет равномерно ограниченную дисперсию. В практически интересных задачах данные условия (в данном виде) выполняются крайне редко. Тем не менее, выводы, которые мы сделали из доказанной теоремы, справедливы для многих задач, не удовлетворяющих введённым предположениям (во многом потому, что указанные свойства важны лишь на некотором компакте вокруг решения задачи, что в свою очередь не так и обременительно).\n\nБолее того, если мы сделаем немного другое предположение о стохастических градиентах, то сможем покрыть некоторые случаи, когда дисперсия не является равномерно ограниченной на всём пространстве. Предположим теперь, что $g_k = \\nabla f_{\\xi_k}(x_k)$, где $\\xi_k$ просэмплировано из некоторого распределения $\\cal D$ независимо от предыдущих итераций, $f(x) = \\mathbb{E}_{\\xi\\sim \\cal D}\\left(f_{\\xi}(x)\\right)$ и $f_{\\xi}(x)$ является выпуклой и $L_{\\xi}$-гладкой для всех $\\xi$ (данное предположение тоже можно ослабить, но для простоты изложения остановимся именно на такой формулировке). Будем называть данные условия предположением о выпуклых гладких стохастчиеских реализациях. Они выполнены, например, для задач линейно регрессии и логистической регрессии.\n\nВ таком случае, для точек, сгенерированных SGD, справедливо, что SGD с потоянным шагом сходится линейно к окрестности решения, радиус которой пропорционален $\\tfrac{\\sqrt{\\alpha} \\sigma}{\\sqrt{\\mu}}$. Отметим, что чем больше размер шага $\\alpha$, тем быстрее SGD достигает некоторой окрестности решения, в которой продолжает осциллировать. Однако чем больше размер шага, тем больше эта окрестность. Соответственно, чтобы найти более точное решение, необходимо уменьшать размер шага в SGD. Этот феномен хорошо проиллюстрирован [здесь](https://fa.bianp.net/teaching/2018/COMP-652/stochastic_gradient.html).\n\n**Теорема**. Предположим, что $f$ является $L$-гладкой и $\\mu$-сильно выпуклой, стохастчиеские реализации являются выпуклыми и гладкими, и размер шага удовлетворяет $0 < \\alpha \\leq 1/2L_{\\max}$, где $L_{\\max} = \\max_{\\xi\\sim \\cal D} L_{\\xi}$. Тогда для всех $k \\geq 0$ выполняется неравенство\n\n$$\n    \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2\\right) \\leq (1 - \\alpha\\mu)^k\\vert\\vert x_0 - x_{\\ast}\\vert\\vert^2 + \\frac{2\\alpha\\sigma_\\ast^2}{\\mu},\n$$\n\nгде $\\sigma_\\ast^2 = \\mathbb{E}_{\\xi\\sim \\cal D}\\vert\\vert\\nabla f_{\\xi}(x_\\ast)\\vert\\vert^2$.\n\n**Доказательство**. Аналогично предыдущей доказательству предыдущей теоремы, получаем\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right| x_k\\right) = \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha\\langle x_k - x_{\\ast}, \\nabla f(x_k)\\rangle + \\alpha^2 \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right).\n$$\n\nПоскольку $f_{\\xi}(x)$ является выпуклой и $L_\\xi$-гладкой, имеем (см. книгу Ю. Е. Нестерова \"Методы выпуклой оптимизации\", 2010):\n\n$$\n    \\vert\\vert\\nabla f_{\\xi}(x) - \\nabla f_{\\xi}(y)\\vert\\vert^2 \\leq 2L_{\\xi}\\left(f_{\\xi}(x) - f_{\\xi}(y) - \\langle \\nabla f_{\\xi}(y), x - y \\rangle\\right).\n$$\n\nПрименяя это неравенство для $x = x_k$, $y = x_{\\ast}$, получаем\n\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right| x_k\\right) = \\mathbb{E}_{\\xi_k \\sim \\mathcal{D}}\\left(\\vert\\vert\\nabla f_{\\xi_k}(x_k) - \\nabla f_{\\xi_k}(x_\\ast) + \\nabla f_{\\xi_k}(x_\\ast)\\vert\\vert^2\\right)\\\\\n    \\leq 2\\mathbb{E}_{\\xi_k \\sim \\mathcal{D}}\\left(\\vert\\vert\\nabla f_{\\xi_k}(x_k) - \\nabla f_{\\xi_k}(x_\\ast)\\vert\\vert^2\\right) + 2\\mathbb{E}_{\\xi_k \\sim \\mathcal{D}}\\left(\\vert\\vert\\nabla f_{\\xi_k}(x_\\ast)\\vert\\vert^2\\right)\\\\\n    \\leq \\mathbb{E}_{\\xi_k \\sim \\mathcal{D}}\\left(4L_{\\xi_k}\\left(f_{\\xi_k}(x_k) - f_{\\xi_k}(x_\\ast) - \\langle \\nabla f_{\\xi_k}(x_\\ast), x_k - x_\\ast \\rangle\\right)\\right) + 2\\mathbb{E}_{\\xi \\sim \\mathcal{D}}\\left(\\vert\\vert\\nabla f_{\\xi_k}(x_\\ast)\\vert\\vert^2\\right)\\\\\n    \\leq 4L_{\\max} \\left(f(x_k) - f(x_\\ast) - \\langle \\nabla f(x_\\ast), x_k - x_\\ast\\rangle\\right) + 2\\sigma_{\\ast}^2 \\\\\n    = 4L_{\\max} \\left(f(x_k) - f(x_\\ast)\\right) + 2\\sigma_{\\ast}^2,\n$$\n\n\nгде во втором переходе мы воспользовались стандартным фактом: $\\vert\\vert a+b\\vert\\vert^2 \\leq \\vert\\vert a\\vert\\vert^2 + \\vert\\vert b\\vert\\vert^2$ для любых $a, b \\in \\mathbb{R}^n$. Подставим полученное неравенство в выражение для $\\mathbb{E}\\left(\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2 \\mid x_k\\right)$, доказанное ранее:\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right| x_k\\right) = \\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 - 2\\alpha\\langle x_k - x_{\\ast}, \\nabla f(x_k)\\rangle + 4L_{\\max}\\alpha^2 \\left(f(x_k) - f(x_\\ast)\\right) + 2\\alpha^2\\sigma_{\\ast}^2.\n$$\n\nОстаётся оценить скалярное произведение в правой части неравенства. Это можно сделать, воспользовавшись сильной выпуклостью функции $f$: из\n\n$$\n    f(x_\\ast) \\geq f(x_k) + \\langle\\nabla f(x_k), x_\\ast - x_k \\rangle + \\frac{\\mu}{2}\\vert\\vert x_\\ast - x_k\\vert\\vert^2\n$$\n\nследует\n\n$$\n    \\langle\\nabla f(x_k), x_k - x_\\ast \\rangle \\geq f(x_k) - f(x_\\ast) + \\frac{\\mu}{2}\\vert\\vert x_k - x_\\ast\\vert\\vert^2.\n$$\n\nИспользуя это неравенство в выведенной ранее верхней оценке на $\\mathbb{E}\\left(\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2 \\mid x_k\\right)$, мы приходим к следующему неравенству:\n\n$$\n    \\mathbb{E}\\left(\\left.\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_\\ast\\vert\\vert^2\\right| x_k\\right) \\leq (1-\\alpha\\mu)\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 -2\\alpha(1 - 2\\alpha L_{\\max})\\left(f(x_k) - f(x_\\ast)\\right) + 2\\alpha^2\\sigma^2\\\\\n    \\leq (1-\\alpha\\mu)\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2 + 2\\alpha^2\\sigma_{\\ast}^2,\n$$\n\nгде в последнем неравенстве мы воспользовались неотрицательностью $2\\alpha(1 - 2\\alpha L_{\\max})\\left(f(x_k) - f(x_\\ast)\\right)$, что следует из $0 < \\alpha \\leq 1/2L_{\\max}$ и $f(x_k) \\geq f(x_\\ast)$. Действуя по аналогии с доказательством предыдущей теоремы, получаем требуемый результат.\n\nВыводы, которые можно сделать из данной теоремы, очень похожи на те, что мы уже сделали из прошлой теоремы. Главные отличия заключаются в том, что $L_{\\max}$ может быть гораздо больше $L$, т.е. максимальный допустимый размер шага $\\alpha$ в данной теореме может быть гораздо меньше, чем в предыдущей. Однако размер окрестности теперь зависит от дисперсии стох. градиента в решении $\\sigma_\\ast^2$, что может быть значительно меньше $\\sigma^2$.\n\nРассмотрим важный частный случай &mdash; задачи минимизации суммы функций:\n\n$$\n\\min\\limits_{x \\in \\mathbb{R}^d}\\left\\{f(x) = \\frac{1}{n}\\sum\\limits_{i=1}^n f_i(x)\\right\\}.\n$$\n\nОбычно $f_i(x)$ имеет смысл функции потерь на $i$-м объекте датасета. Предположим, что $f_i(x)$ &mdash; выпуклая и $L_i$-гладкая функция. Тогда выполняется предположение о выпуклых гладких стохастчиеских реализациях: действительно, достаточно задать $\\xi$ как случайное число из $\\{1,2,\\ldots,n\\}$, имеющее равномерное распределение. Тогда справедлив результат предыдущей теоремы с $L_{\\max} = \\max_{i\\in 1,\\ldots,n)}L_i$ и $\\sigma_\\ast^2 = \\tfrac{1}{n}\\sum_{i=1}^n \\vert\\vert\\nabla f_i(x_\\ast)\\vert\\vert^2$.\n\nДля любого $K \\ge 0$ можно выбрать шаг в SGD следующим образом:\n\n$$\n    \\text{если } K \\leq \\frac{2L_{\\max}}{\\mu},  \\gamma_k = \\frac{1}{2L_{\\max}},\\\\\n    \\text{если } K > \\frac{2L_{\\max}}{\\mu} \\text{ и } k < k_0,  \\gamma_k = \\frac{1}{2L_{\\max}},\\\\\n    \\text{если } K > \\frac{2L_{\\max}}{\\mu} \\text{ и } k \\geq k_0,  \\gamma_k = \\frac{1}{4L_{\\max} + \\mu(k-k_0)},\n$$\n\nгде $k_0 = \\lceil K/2 \\rceil$. Тогда из доказанного выше результата следует (см. Лемму 3 из [статьи С. Стиха](https://arxiv.org/pdf/1907.04232.pdf)), что после $K$ итераций\n\n$$\n    \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_K - x_\\ast\\vert\\vert^2\\right) = \\cal O\\left(\\frac{L_{\\max} \\vert\\vert x_0 - x_\\ast\\vert\\vert^2}{\\mu}\\exp\\left(-\\frac{\\mu}{L_{\\max}}K\\right) + \\frac{\\sigma_{\\ast}^2}{\\mu^2 K}\\right).\n$$\n\nТаким образом, чтобы гарантировать $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_K - x_\\ast\\vert\\vert^2\\right) \\leq \\varepsilon$, SGD требуется\n\n$$\n  \\cal O\\left(\\frac{L_{\\max} }{\\mu}\\log\\left(\\frac{L_{\\max} \\vert\\vert x_0 - x_\\ast\\vert\\vert^2}{\\mu\\varepsilon}\\right) + \\frac{\\sigma_{\\ast}^2}{\\mu^2 \\varepsilon}\\right)\n$$\n\nитераций/подсчётов градиентов слагаемых. Чтобы гарантировать то же самое, градиентному спуску (GD) необходимо сделать\n\n$$\n  \\cal O\\left(n\\frac{L}{\\mu}\\log\\left(\\frac{\\vert\\vert x_0 - x_\\ast\\vert\\vert^2}{\\varepsilon}\\right)\\right)\n$$\n\nподсчётов градиентов слагаемых, поскольку каждая итерация GD требует $n$ подсчётов градиентов слагаемых (нужно вычислять полный градиент $\\nabla f(x) = \\tfrac{1}{n}\\sum_{i=1}^n \\nabla f_i(x)$). Можно показать, что $L \\leq L_{\\max} \\leq nL$, поэтому в худшем случае полученная оценка для SGD заведомо хуже, чем для GD. Однако в случае, когда $L_{\\max} = \\cal O(L)$, однозначного вывода сделать нельзя: при большом $\\varepsilon$ может доминировать первое слагаемое в оценке сложности SGD, поэтому в таком случае SGD будет доказуемо быстрее, чем GD (если пренебречь логарифмическими множителями). \n\nИными словами, чтобы достичь не очень большой точности решения, выгоднее использовать SGD, чем GD. В ряде ситуаций небольшой точности вполне достаточно, но так происходит не всегда. Поэтому возникает ествественный вопрос: можно ли так модифицировать SGD, чтобы полученный метод сходился линейно асимптотически к точному решению (а не к окрестности как SGD), но при этом стоимость его итераций была сопоставима со стоимостью итераций SGD? Оказывается, что да и соответствующие методы называются методами редукции дисперсии.\n\n## Методы редукции дисперсии\n\nПеред тем, как мы начнём говорить о методах редукции дисперсии, хотелось бы раскрыть подробнее причину того, что SGD не сходится линейно асимптотически к точному решению. Мы рассмотрели анализ SGD в двух предположениях, и в обоих случаях нам требовалось вывести некоторую верхнюю оценку на второй момент стох. градиента, т.е. на $\\mathbb{E}\\left(\\vert\\vert g_k\\vert\\vert^2 \\mid x_k\\right)$. В обоих случаях эта оценка содержала некоторый константный член ($\\sigma^2$ или $2\\sigma_\\ast^2$ &mdash; зависит от рассматриваемого предположения), который потом возникал и в финальной оценке на $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_\\ast\\vert\\vert^2\\right)$, препятствуя тем самым линейно сходимости метода. Конечно, это рассуждение существенно опирается на конкретный способ анализа метода, а потому не является строгим объяснением, почему SGD не сходится линейно.\n\nОднако важно отметить, что оценка на $\\mathbb{E}\\left(\\vert\\vert g_k\\vert\\vert^2 \\mid x_k\\right)$ достаточно точно отражает поведение метода вблизи решения: даше если точка $x_k$ оказалась по какой-то причине близка к решению $x_\\ast$ (или даже просто совпала с решением), то $\\mathbb{E}\\left(\\vert\\vert g_k\\vert\\vert^2 \\mid x_k\\right)$ и, в частности, $\\mathbb{E}\\left(\\vert\\vert g_k - \\nabla f(x_k)\\vert\\vert^2 \\mid x_k\\right)$ будут порядка $\\sigma^2$ или $\\sigma_{\\ast}^2$. Следовательно, при следующем шаге метод с большой вероятностью отдалится от/выйдет из решения, поскольку $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_{k+1} - x_k\\vert\\vert^2\\right) = \\alpha^2\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right) \\sim \\alpha^2\\sigma^2$ или $\\alpha^2\\sigma_{\\ast}^2$.\n\n\nИз приведённых выше рассуждений видно, что дисперсия стох. градиента мешает методу сходится линейно к точному решению. Поэтому хотелось бы как-то поменять правило вычисления стох. градиента, чтобы выполнялись 3 важных свойства: (1) новый стох. градиент должен быть не сильно дороже в плане вычислений, чем подсчёт стох. градиента в SGD (градиента слагаемого), (2) новый стох. градиент должен быть несмещённой оценкой полного градиента $\\nabla f(x_k)$, и (3) дисперсия нового стох. градиента должна уменьшаться в процессе работы метода. Например, можно рассмотреть следующий стох. градиент:\n\n$$\ng_k = \\nabla f_{j_k}(x_k) + s_k, \n$$\n\nгде $j_k$ выбирается случайно равновероятно из множества $\\{1, 2, \\ldots, n\\}$ и $\\mathbb{E}\\left(s_k\\mid x_k\\right) = 0$. В таком случае, будет выполнено свойство (2) из списка выше. Чтобы достичь желаемой цели, необходимо как-то специфицировать выбор случайного вектора $s_k$. Исторически одним из первых способов выбора $s_k$ был $s_k = -\\nabla f_{j_k}(w_k) + \\nabla f(w_k)$, где точка $w_k$ обновляется раз в $m \\sim n$ итераций:\n\n$$\n    w_{k+1} = \\begin{cases} w_k, & \\text{if } k+1 \\mod m \\neq 0,\\\\ x_{k+1}, & \\text{if } k+1 \\mod m = 0. \\end{cases}\n$$\n\nДанный метод называется Stochastic Variance Reduced Gradient (SVRG). Данный методы был предложен и проанализирован в [NeurIPS статье Джонсона и Жанга в 2013 году](https://proceedings.neurips.cc/paper/2013/hash/ac1dd209cbcc5e5d1c6e28598e8cbbe8-Abstract.html). Теперь же убедимся, что метод удовлетворяет всем трём отмеченным свойствам. Начнём с несмещённости:\n\n$$\n    g_k = \\nabla f_{j_k}(x_k) - \\nabla f_{j_k}(w_k) + \\nabla f(w_k),\n$$\n\n$$\n    \\mathbb{E}\\left(g_k\\mid x_k\\right) = \\frac{1}{n}\\sum\\limits_{i=1}^n \\left(\\nabla f_{i}(x_k) - \\nabla f_{i}(w_k) + \\nabla f(w_k)\\right) = \\nabla f(x_k).\n$$\n\nДалее, вычисление $g_k$ подразумевает 2 подсчёта градентов слагаемых при $k \\mod m \\neq 0$ и $n+2$ подсчёта градентов слагаемых при $k \\mod m \\neq 0$. Таким образом, за $m$ последователльных итераций SVRG происходит вычисление $2(m-1) + n + 2 = 2m + n$ градиентов слагаемых, в то время как SGD требуется $m$ подсчётов градиентов слагаемых. Если $m = n$ (стандартный выбор параметра $m$), то $n$ итераций SVRG лишь в 3 раза дороже, чем $n$ итераций SGD. Иными словами, в среднем итерация SVRG не сильно дороже итерации SGD.\n\nНаконец, если мы предположим, что метод сходится $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_\\ast\\vert\\vert^2\\right) \\to 0$ (а он действительно сходится, см., например, доказательство вот [тут](http://proceedings.mlr.press/v108/gorbunov20a/gorbunov20a-supp.pdf)), то получим, что $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert w_k - x_\\ast\\vert\\vert^2\\right) \\to 0$, а значит $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - w_k\\vert\\vert^2\\right) \\to 0$ и $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert\\nabla f(w_k)\\vert\\vert^2\\right) \\to 0$. Но тогда в силу Липшицевости градиентов $f_i$ для всех $i=1,\\ldots,n$ имеем:\n\n$$\n    \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert g_k\\vert\\vert^2\\right) = \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert\\nabla f_{j_k}(x_k) - \\nabla f_{j_k}(w_k) + \\nabla f(w_k)\\vert\\vert^2\\right)\\\\\n    \\leq 2\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert\\nabla f_{j_k}(x_k) - \\nabla f_{j_k}(w_k)\\vert\\vert^2\\right) + 2\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert\\nabla f(w_k)\\vert\\vert^2\\right)\\\\\n    \\leq 2L_{\\max} \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - w_k\\vert\\vert^2\\right) + 2\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert\\nabla f(w_k)\\vert\\vert^2\\right) \\to 0,\n$$\n\nа значит, дисперсия $g_k$ стремится к нулю.\n\nПриведённые выше рассуждения не являются формальным доказательством сходимости метода, но частично объясняют, почему метод сходится и, самое главное, объясняют интуицию позади формул, задающих метод. Строгое доказательство можно прочитать вот [тут](http://proceedings.mlr.press/v108/gorbunov20a/gorbunov20a-supp.pdf). Мы же здесь приведём результат о сходимости немного другого метода &mdash; Loopless Stochastic Variance Reduced Gradient (L-SVRG), который был предложен в [2015 году](https://proceedings.neurips.cc/paper/2015/hash/effc299a1addb07e7089f9b269c31f2f-Abstract.html) и переоткрыт в [2019 году](http://proceedings.mlr.press/v117/kovalev20a/kovalev20a.pdf). Основное отличие от SVRG состоит в том, что точка $w_k$ теперь обновляется на каждой итерации с некоторой маленькой вероятностью $p \\sim 1/n$:\n\n$$\n    w_{k+1} = \\begin{cases} w_k, & \\text{с вероятностью } 1-p,\\\\ x_{k}, & \\text{с вероятностью } p. \\end{cases}\n$$\n\nИными словами, L-SVRG имеет случайную длину цикла, в котором $w_k$ не обновляется. Вся интуиция и все наблюдения приведённые для SVRG выше, справедливы и для L-SVRG. \n\nМожно доказать следующий результат.\n\n**Теорема**. Предположим, что $f$ является $L$-гладкой, $\\mu$-сильно выпуклой и имеет вид суммы, функции $f_i$ являются выпуклыми и $L_i$-гладкими для всех $i=1,\\ldots, n$, и размер шага удовлетворяет $0 < \\alpha \\leq 1/6L_{\\max}$, где $L_{\\max} = \\max_{i\\in 1,\\ldots,n} L_{i}$. Тогда для всех $k \\geq 0$ для итераций L-SVRG выполняется неравенство\n\n$$\n        \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2\\right) \\leq \\left(1 - \\min\\left\\{\\alpha\\mu, \\frac{p}{2}\\right\\}\\right)^kV_0,\n$$\n\nгде $V_0 = \\vert\\vert x_0 - x_\\ast\\vert\\vert^2 + \\tfrac{4\\alpha^2}{p}\\sigma_0^2$, $\\sigma_0^2 = \\tfrac{1}{n}\\sum_{i=1}^n \\vert\\vert\\nabla f_i(x_0) - \\nabla f_i(x_\\ast)\\vert\\vert$.\n\n\n**Замечание**. В частности, если $\\alpha = 1/6L_{\\max}$ и $p = 1/n$, то \n\n$$\n    \\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_{\\ast}\\vert\\vert^2\\right) \\leq \\left(1 - \\min\\left\\{\\frac{\\mu}{6L_{\\max}}, \\frac{1}{2n}\\right\\}\\right)^kV_0.\n$$\n\nСледовательно, чтобы гарантировать $\\mathbb{E}\\left(\\vphantom{\\frac14}\\vert\\vert x_k - x_\\ast\\vert\\vert^2\\right) \\leq \\varepsilon$, L-SVRG требуется\n\n$$\n  \\cal O\\left(\\left(n + \\frac{L_{\\max} }{\\mu}\\right)\\log\\left(\\frac{V_0}{\\varepsilon}\\right)\\right)\n$$\n\nитераций/подсчётов градиентов слагаемых (в среднем). Напомним, что чтобы гарантировать то же самое, градиентному спуску (GD) необходимо сделать\n\n$$\n  \\cal O\\left(n\\frac{L}{\\mu}\\log\\left(\\frac{L \\vert\\vert x_0 - x_\\ast\\vert\\vert^2}{\\mu\\varepsilon}\\right)\\right)\n$$\n\nподсчётов градиентов слагаемых, поскольку каждая итерация GD требует $n$ подсчётов градиентов слагаемых (нужно вычислять полный градиент $\\nabla f(x) = \\tfrac{1}{n}\\sum_{i=1}^n \\nabla f_i(x)$). Можно показать, что $L \\leq L_{\\max} \\leq nL$, поэтому в худшем случае полученная оценка для L-SVRG не лучше, чем для GD. Однако в случае, когда $L_{\\max} = \\cal O(L)$, L-SVRG имеет сложность значительно лучше, чем GD (если пренебречь логарифмическими множителями).\n\nВ заключение этого раздела, хотелось бы отметить, что существуют и другие методы редукции дисперсии. Одним из самых популярных среди них является [SAGA](https://proceedings.neurips.cc/paper/2014/hash/ede7e2b6d13a41ddf9f4bdef84fdc737-Abstract.html). В отличие от SVRG/L-SVRG, в методе SAGA хранится набор градиентов $\\nabla f_1(w_k^1), \\nabla f_2(w_k^2), \\ldots, \\nabla f_n(w_k^n)$. Здесь точка $w_k^i$ обозначает точку, в которой в последний раз был подсчитан градиент функции $i$ до итерации $k$. Формально это можно записать следующим образом:\n\n$$\n    w_0^1 = w_0^2 = \\ldots = w_0^n,\n$$\n\n$$\n    g_k = \\nabla f_{j_k}(x_k) - \\nabla f_{j_k}(w_k^{j_k}) + \\frac{1}{n}\\sum\\limits_{i=1}^n \\nabla f_{i}(w_k^{i}),\n$$\n\n$$\n    w_{k+1}^{j_k} = x_k, \\quad w_{k+1}^i = w_k^i \\text{ для всех } i \\neq j_k,\n$$\n\n$$\n    x_{k+1} = x_k - \\alpha g_k.\n$$\nОсновное преимущество SAGA состоит в том, что не требуется вычислять полный градиент всей суммы по ходу работы метода, однако в начале требуется посчитать градиенты всех слагаемых (отмечаем здесь, что эта операция может быть гораздо дороже по времени, чем вычисление полного градиента) и, более того, требуется хранить $n$ векторов, что может быть недопустимо для больших датасетов. В плане теоретических гарантий SAGA и L-SVRG не отличимы.\n\nНиже приведён график с траекториями SGD (с постоянным шагом), L-SVRG и SAGA при решении задачи логистической регрессии. Как можно видеть из графика, SGD достаточно быстро достигает не очень высокой точности и начинает осциллировать вокруг решения. В то же время, L-SVRG и SAGA достигают той же точности медленнее, но зато не осциллируют вокруг решения, а продолжают сходится (причём линейно).\n\n\n**Сравнение работы SGD, L-SVRG и SAGA при решении задачи логистической регрессии на датасете gisette из библиотеки [LIBVSM](https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html).**\n\n![Shodimost_SGD_2c9e0b99e3.webp](https://yastatic.net/s3/education-portal/media/Shodimost_SGD_2c9e0b99e3_49bbc13459.webp)",
        "handbook": "Учебник по машинному обучению",
        "title": "Сходимость SGD",
        "description": "Почему он всё-таки сходится"
    },
    {
        "path": "/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya",
        "content": "## О чём раздел про онлайн-обучение, кому и зачем его читать?\n\nВо многих случаях обучение ML-модели ― это однократный процесс, после которого она не меняется и только используется для предсказания. А что, если к нам постоянно поступает новая информация и мы должны её учитывать? Тогда модель должна уметь обновляться при поступлении нового объекта или батча объектов. Грубо говоря, этим и занимается онлайн-оптимизация. Можно заметить, что обновление модели на батче объектов проходит и в процессе стохастической оптимизации, ― и это сходство не случайно.\n\nОказывается, что все известные вам методы стохастической оптимизации первого порядка ― такие как SGD, AdaGrad, Adam, AMSgrad и другие ― являются в первую очередь алгоритмами онлайн-обучения. Чтобы в этом убедиться, достаточно открыть эти статьи и увидеть, для какой задачи выводятся гарантии на сходимость. Постановка задачи онлайн-обучения является одновременно математически простой и очень общей, соединяя три больших темы:\n1. «Классическое» онлайн обучение.\n2. Стохастическую оптимизацию на фиксированном датасете. Мы покажем, что любой алгоритм онлайн обучения можно переформулировать, как алгоритм стохастической оптимизации; при этом из гарантий на сходимость, полученных для онлайн обучения, автоматически будет следовать сходимость на фиксированном датасете.\n3. Adversarial обучение.\n\nДанный текст является в первую очередь систематизирующим. Мы постараемся достичь следующих целей:\n1. Подведем единую математическую базу, необходимую для вдумчивого чтения статей по оптимизации. Это будет полезно **ML-теоретикам**.\n2. Покажем, как исторически развивались методы оптимизации, как из одного метода получался другой, какие проблемы они решали и ― главное ― актуальны ли эти проблемы сейчас.\n3. Разберём все «именные» методы оптимизации на набор базовых концепций и покажем, как вы можете самостоятельно их сочетать, создавая оптимальный метод для решения своей задачи. Спойлер: базовых концепций *намного* меньше, чем наименований методов. Эти знания будут полезны **ML-инженерам**.\n4. Пройдемся по относительно нишевым темам, таким как разреженные методы регуляризации $L_1$ и $L_{1/2}$, и рассмотрим наилучшие методы оптимизации для них. Такие методы невозможно получить в стандартной постановке стохастической оптимизации. Эти знания будут полезны **ML-инженерам**, занимающимся рекомендательными системами.\n\nВ параграфе «Введение в онлайн-обучение», которую вы читаете сейчас, вы познакомитесь с общей постановкой задачи онлайн-обучения, а также с семейством алгоритмов Follow the Regularized Leader (FTRL), которое включает в себя все методы первого порядка. Кроме того, вы узнаете, как сводить задачи стохастической оптимизации к задачам онлайн-обучения и увидите, что этот переход позволяет строить более эффективные методы стохастической оптимизации, особенно для разреженных регуляризаторов вроде $L_1$.\n\nВ параграфе «[Адаптивный FTRL](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl)» вы узнаете, как улучшить сходимость алгоритмов стохастической оптимизации с помощью регуляризаторов и каковы гарантии сходимости для регуляризованных задач. Это позволит вывести AdaGrad как наилучший адаптивный метод для онлайн-оптимизации.\n\nВ параграфе «[Регуляризация в онлайн-обучении](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii)» мы снова поговорим о регуляризации, но на этот раз речь пойдёт о регуляризаторах, которые накладывают на решение определённые органичения, например, разреженность. Вы сможете с новой стороны взглянуть на разреживающие свойства $L_1$-регуляризаторов. Кроме того, мы получим не достижимые с помощью обычных SGD/AdaGrad результаты для разреженных $L_1$ и $L_{1/2}$ регуляризаторов.\n\nВ параграфе «[Стохастическая оптимизация в Deep Learning](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning)» мы перейдём к методам оптимизации в глубоких нейросетях. Вас ждёт краткий исторический обзор и мотивация появления двух важных модификаций AdaGrad ― Adam и RMSprop. Мы покажем, что эти методы ломаются вокруг критических точек, и поговорим о том, как починить это и достичь более точной сходимости (этого эффекта можно достичь либо прямой модификацией алгоритмов (AMSgrad и RAdam), либо косвенно с помощью Learning Rate Scheduler'ов). \n\nВ конце параграфа мы соберём воедино все рассмотренные концепции и покажем, как можно комбинировать лучшее из разных методов оптимизации в один новый метод.\n\n## Оглавление\n\n{% cut \"<a href=\"https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya\">Часть 1. Введение</a>\" %}\n\n   - [Постановка задачи](https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya#postanovka-zadachi)\n   - [Выпуклая онлайн-оптимизация](https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya#vypuklaya-onlajn-optimizacziya)\n   - [Follow the Leader](https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya#follow-the-leader)\n   - [Follow The Regularized Leader (FTRL)](https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya#follow-the-regularized-leader)\n   - [Линеаризация и вычислительно эффективный FTRL](https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya#linearizacziya-i-vychislitelno-effektivnyj-ftrl)\n   - [Субдифференциал и субградиентные методы](https://academy.yandex.ru/handbook/ml/article/onlajn-obuchenie-i-stohasticheskaya-optimizaciya#subdifferenczial-i-subgradientnye-metody)\n\n{% endcut %}\n\n{% cut \"<a href=\"https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl\">Часть 2. Адаптивные методы оптимизации</a>\" %}\n\n   - [Аддитивные регуляризаторы](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#additivnye-regulyarizatory)\n   - [Классы алгоритмов FTRL](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#klassy-algoritmov-ftrl)\n   - [Гарантии сходимости для алгоритмов FTRL](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#garantii-shodimosti-dlya-algoritmov-ftrl)\n   - [Построение эффективного адаптивного FTRL](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#postroenie-effektivnogo-adaptivnogo-ftrl)\n      - [$O(1)$ learning rate](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#constant-learning-rate-ftrl)\n      - [$O(\\frac{1}{\\sqrt{t}})$ learning rate](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#ftrl-s-learning-rate-scheduling)\n      - [Data-Adaptive learning rate.](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#data-adaptive-ftrl)\n      - [AdaGrad ― оптимальный data-adaptive метод](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#ada-grad-nailuchshij-adaptivnyj-metod)\n\n{% endcut %}\n\n{% cut \"<a href=\"https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii\">Часть 3. Продвинутые методы регуляризации</a>\" %}\n\n   - [Идея неразложения регуляризаторов в субградиентную оценку](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#ideya-nerazlozheniya-regulyarizatorov-v-subgradientnuyu-oczenku)\n      - [Связь между Composite-Objective FTRL и Proximal Gradient Descent. Lazy vs Greedy представления](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#svyaz-mezhdu-composite-objective-ftrl-i-proximal-gradient-descent-lazy-vs-greedy-predstavleniya)\n   - [$L_1$-регуляризация](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#l-1-regulyarizacziya)\n      - [Отбор параметров разреженных моделей](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#otbor-parametrov-razrezhennyh-modelej)\n      - [Linear Incremental $L_1$. Аналог $L_1$ в Greedy методах](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#linear-incremental-lambda-1-t-t-lambda-1)\n      - [Global $L_1$. Лучший метод $L_1$ для онлайн обучения]()\n   - [$L_2$ регуляризация](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#l-2-regulyarizacziya)\n      - [Weight Decay. Decoupled Weight Decay](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#weight-decay)\n   - [Проекция на выпуклое множество $\\chi$](https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#i-chi-w-proekcziya-na-vypukloe-mnozhestvo-chi)\n\n{% endcut %}\n   \n{% cut \"<a href=\"https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning\">Часть 4. Методы оптимизации в Deep Learning</a>\" %}\n\n   - [RMSprop и Adam](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#skolzyashhee-srednee-v-znamenatele-ada-grad-metody-rm-sprop-i-adam)\n      - [Мотивация их создания](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#motivacziya)\n      - [RMSprop](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#rms-prop)\n      - [Adam](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#adam)\n      - [Мотивация для bias correction]()\n      - [Почему Adam ошибочно считают лучшим методом стохастической оптимизации]()\n   - [Как сломать адаптивные методы RMSprop и Adam со скользящим средним](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#kak-slomat-adaptivnye-metody-so-skolzyashhim-srednim)\n   - [Чиним RMSprop и Adam](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#chinim-rm-sprop-i-adam)\n      - [Метод AMSgrad](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#am-sgrad)\n         - [Реализация без дополнительной памяти](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#realizacziya-bez-dopolnitelnoj-pamyati)\n         - [Добавление Bias Correction](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#dobavlenie-bias-correction)\n      - [Learning Rate Scheduling](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#learning-rate-scheduling)\n         - [Влияние learning rate decay на сходимость](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#vliyanie-learning-rate-decay-na-shodimost)\n         - [Практические рекомендации](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#prakticheskie-rekomendaczii)\n         - [Learning rate scheduling vs AdaGrad](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#learning-rate-scheduling-vs-ada-grad)\n   - [SGD vs Adam. Методы AdamW/SGDW. Улучшение методов с помощью проксимального $L_2$](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#sgd-vs-adam)\n   - [Momentum](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#momentum)\n      - [Nesterov Momentum](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#nesterov-momentum)\n      - [Adan](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#adan)\n\n{% endcut %}\n\n{% cut \"<a href=\"https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#sobiraem-vse-idei-voedino\">Часть 5. Заключение</a>\" %}\n\n   - [Таблицы формул. Примеры комбинирования идей](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#primer-tabliczy-s-obshhimi-formulami)\n\n{% endcut %}\n\n## Постановка задачи\n\n**Литература**. Отсюда и далее, пока явно не скажем о переходе на другие источники информации, используется материал из книги Shai Shalev-Shwartz [ Online Learning and Online\nConvex Optimization](https://www.cs.huji.ac.il/w~shais/papers/OLsurvey.pdf)\n\nОнлайн-обучение ― это процесс предсказания ответов на последовательность вопросов с учётом знания (возможно, неполного) о предыдущих правильных ответах.\n\nПредставим себе следующую игру (назовём её **игра (1)**). На каждом раунде игры $t$ мы:\n1. Получаем $x_t$ ― частичную информацию о текущем «вопросе»;\n2. Выбираем модель $w_t$, которой будем делать прогноз;\n3. Прогнозируем $p_t(w_t, x_t)$;\n4. Получаем истинный ответ $y_t$;\n5. Получаем обратную связь-лосс $l(p_t, y_t)$. Лоссы обычно имеют семантику функции ошибки: больше ― хуже, меньше ― лучше.\n\nЦель *любого* алгоритма онлайн обучения ― минимизация суммарной ошибки прогнозов $Loss(T) = \\sum\\limits_{t=1}^Tl(p_t, y_t)$ для любого количества раундов $T$.\n\nПока рассмотрим интуитивный пример: линейная регрессия (обозначения взяты из [параграфа про линейные модели](https://academy.yandex.ru/handbook/ml/article/linejnye-modeli)). Пусть у нас уже сыграны раунды $1,\\ldots,t-1$ и есть выборка данных $x_1,\\ldots,x_{t-1}$ и ответов $y_1,\\ldots,y_{t-1}$.\n1. Получаем новый $x_t$. В данном случае просто получаем и пока не используем;\n2. Выбираем модель $w_t$, которая наилучшим образом объясняет всю предыдущую имеющуюся выборку $x_{1..t}$ (алгоритм обучения можем выбирать любой, какой нам нравится);\n3. Прогнозируем $p_t = <w_t, x_t>$;\n4. Получаем правильный ответ $y_t$;\n5. Считаем loss $(y_t - p_t)^2$;\n\nДействуя таким образом, мы делаем интуитивное предположение, что ответы $y_t$ как-то зависят от наших $x_t$ и что эту зависимость мы можем выучить из предыдущей выборки, улучшив прогноз на новых объектах.\n\n### Предположения\n\nТеория онлайн обучения выгодно отличается от классической теории статистического обучения довольно расслабленными и гораздо более простыми (с точки зрения математических формулировок) условиями. Мы **не делаем** предположений о некой статистической зависимости между $x_t$, $y_t$. Зависимость может быть детерминированной, стохастической или даже adversarial:\n1. Детерминированная: в самом начала игры делается выбор детерминированной зависимости $x_t \\rightarrow y_t$\n2. Стохастическая: $x_t$ может быть реализациями случайной величины, зависящей от $y_t$\n3. Adversarial: мы играем против активного противника, который может на каждом раунде игры по своему усмотрению менять зависимость $x_t \\rightarrow y_t$ и/или подбирать $l(p_t, y_t)$, имея на руках *в том числе текущий ответ $y_t$, не доступный алгоритму онлайн-обучения*\n\nAdversarial постановка включает в себя все остальные как частные случаи, так что сразу будем строить теорию для наиболее общего случая.\n\n### Поведение алгоритма на шаге T\nНачнем с введения метрики качества алгоритма на некотором раунде игры $T$, а затем расширим ее на все раунды игры.\n\nЕсли у противника нет никаких ограничений, то противник всегда выигрывает. Поскольку $l(p_t, y_t)$ выбирается **после** нашего прогноза, он может выбрать любую функцию с сколь угодно большим штрафом.\n\nЧтобы такого не случалось, мы предположим, что все ответы на шаге $T$ должны быть сгенерированы некоторым отображением $h^*: X\\rightarrow Y, h^* \\in H$, где $H$ ― пространство возможных решений, **известное и онлайн-алгоритму, и противнику**.\n\nС учетом введенного ограничения на поведение противника, введем понятие *regret*:\n\n$$Regret_T(h) = \\sum\\limits_{t=1}^T l(p_t, y_t) - \\sum\\limits_{t=1}^Tl(h(x_t), y_t)$$\n\nRegret ― это метрика того, насколько онлайн алгоритм работает хуже, чем некоторая фиксированная модель-бейзлайн h (regret переводится как «сожаление»: насколько мы пожалели о том, что взяли онлайн алгоритм, а не модель h). Поскольку мы работаем в adversarial случае, то логично сравнивать наш онлайн алгоритм с сильнейшим возможным противником, а именно: противник всегда выбирает не «некоторую», а **наилучшую модель-бейзлайн** $h^* \\in H$:\n\n$$maxRegret(T) = \\max\\limits_{h^* \\in H}\\left[ \\sum\\limits_{t=1}^T l(p_t, y_t) - \\sum\\limits_{t=1}^Tl(h^*(x_t), y_t)\\right]$$\n\n### Поведение алгоритма на всей последовательности раундов игры\n\nВспомним, что вообще-то мы играем игру с бесконечным числом раундов. В таком случае, естественно будет анализировать поведение ряда $maxRegret(T), T \\in \\mathbb{N}, T \\rightarrow \\infty$. Здесь хочется еще раз подчеркнуть, в чем заключается adversarial поведение: на каждом шаге t maxRegret будет иметь **свою** наилучшую модель $h^*_t$ в бейзлайне:\n\n$$maxRegret(\\color{#348FEA}{T_1}) = \\max\\limits_{h^* \\in H} \\sum\\limits_{t=1}^{\\color{#348FEA}{T_1}} l(p_t, y_t) - \\sum\\limits_{t=1}^{\\color{#348FEA}{T_1}}l(h^*(x_t), y_t) = \\sum\\limits_{t=1}^{\\color{#348FEA}{T_1}} l(p_t, y_t) - \\sum\\limits_{t=1}^{\\color{#348FEA}{T_1}}l(h^*_{\\color{#348FEA}{T_1}}(x_t), y_t)$$\n\n$$maxRegret(\\color{#E06A27}{T_2}) = \\max\\limits_{h^* \\in H} \\sum\\limits_{t=1}^{\\color{#E06A27}{T_2}} l(p_t, y_t) - \\sum\\limits_{t=1}^{\\color{#E06A27}{T_2}}l(h^*(x_t), y_t) = \\sum\\limits_{t=1}^{\\color{#E06A27}{T_2}} l(p_t, y_t) - \\sum\\limits_{t=1}^{\\color{#E06A27}{T_2}}l(h^*_{\\color{#E06A27}{T_2}}(x_t), y_t)$$\n\n### Качество онлайн алгоритма на протяжении всей игры\n\nКогда мы говорим про adversarial setting и игру с противником, мы хотим не просто как-то минимизировать кумулятивный $Loss(T) = \\sum\\limits_{t=1}^Tl(p_t, y_t)$, но еще и хотим быть *не хуже нашего противника*. Потребуем, чтобы\n\n$$\\lim\\limits_{T \\rightarrow \\infty} \\frac{1}{T}maxRegret(T) = 0$$\n\nТакое условие означает, что regret должен расти медленнее чем линейно (в таком случае говорят, что алгоритм имеет *сублинейный regret*).\n\nСублинейности бывают разные. Так, $Regret_T$ может быть ограничен сверху рядом с асимптотикой $\\sqrt{T}$ или же рядом с асимптотикой $\\log{T}$\n\nАсимптотика $\\log{T}$, очевидно, приводит к намного лучшей сходимости. Но достичь этого не всегда возможно. *Стандартной* асимптотикой regret в большинстве используемых на практике алгоритмов является $\\sqrt{T}$, для этой асимптотики условия на задачу наименее жесткие. Все рассматриваемые нами ниже алгоритмы будут иметь асимптотику $\\sqrt{T}$ и отличаться в основном константами в оценках (но, конечно, отличия в константах при оценке Regret часто приводят к существенно разному поведению на практике). Любые более мощные асимптотики требуют условий, которые крайне редко выполняются в практических задачах\n\n### Online to batch conversion\n\nВ данном обзоре мы будем анализировать методы, которые гораздо чаще используются для оптимизации в классической постановке: есть фиксированный датасет $(x_i, y_i)_{i=1}^N$, модель $p_w(x)$ с обучаемыми параметрами $w$ и функция потерь $f$, задача ― найти минимум функции\n\n$$\\frac1N \\sum\\limits_{i=1}^N f(p_w(x_i), y_i)$$\n\nЕсли представить, что все наши $f(p_w(x_i), y_i)$ ― независимые одинаково распределенные случайные величины, то можно считать, что на самом деле мы оптимизируем\n\n$$\\frac1N \\sum\\limits_{i=1}^N f(p_w(x_i), y_i) \\approx \\mathbb{E}_{(x,y)}f(p_w(x), y)$$\n\nТакую постановку задачи часто называть батчевой (англ. batch). Это означает, что мы можем использовать два класса методов оптимизации:\n* методы, которые на каждом шаге смотрят сразу на всю выборку (например, градиентный спуск или метод Ньютона);\n* методы, которые на каждом шаге смотрят на случайное подмножество данных в надежде, что, итерируясь по таким подмножествам, мы сможем соптимизировать матожидание $\\mathbb{E}f(w)$ (например, SGD). Такие методы называют стохастическими.\n\nСуществует специальный класс методов анализа сходимости, называемый online to batch conversion. Они позволяют адаптировать алгоритм онлайн-обучения к постановке задачи стохастической оптимизации на фиксированном датасете; при этом оценка на regret транслируется в асимптотику сходимости стохастической оптимизации. Математически строгий вывод этих методов обычно довольно громоздкий и не дарит более глубокого понимания идей в современных стохастических методах, это чисто технические выкладки, поэтому мы здесь ограничимся интуитивным описанием. Строгий вывод можно найти, например, в упомянутой выше книге Shai Shalev-Schwartz.\n\nПроцесс стохастической оптимизации на фиксированном датасете можно представить в виде задачи онлайн обучения, если вытянуть все эпохи (проходы по датасетам) в единую последовательность. Мы получим задачу онлайн обучения, в которой $(x_t, y_t)$ сэмплируются из фиксированного множества $(x_1,y_1),\\ldots,(x_N,y_N)$. Строго говоря, тут сэмлпирование двухстадийное:\n1. Берем исходное множество функций\n2. Сэмплируем из него без возвращения, пока множество не станет пустым\n3. Как только оно стало пустым ― заново заполняем его\n\nТаким образом, деление на \"эпохи\" отчетливо видно и в вытянутой последовательности.\n\nЛегко видеть, что эта задача является корректной задачей онлайн обучения. Тут мы активно пользуемся тем, что постановка задачи онлайн обучения математически простая и очень общая. Из корректности данной задачи следует, что все алгоритмы онлайн обучения будут иметь на такой последовательности сублинейный regret.\n\nСледующим шагом давайте взглянем на regret **в момент смены эпохи**. Обозначим за $M$―число эпох, тогда:\n\n$$maxRegret(T) = \\max\\limits_{h^* \\in H}\\left[ \\sum\\limits_{t=1}^T l(p_t, y_t) - \\sum\\limits_{t=1}^Tl(h^*(x_t), y_t)\\right] = \\max\\limits_{h^* \\in H}\\left[ \\sum\\limits_{m=1}^M \\sum\\limits_{i=1}^N l(p_{m,i}, y_i) - \\sum\\limits_{m=1}^M \\sum\\limits_{i=1}^N l(h^*(x_i), y_i)\\right] = \\max\\limits_{h^* \\in H}\\left[ \\sum\\limits_{m=1}^M \\sum\\limits_{i=1}^N l(p_{m,i}, y_i) - M\\sum\\limits_{i=1}^N l(h^*(x_i), y_i) \\right]$$\n\nИз сходимости последовательности следует сходимость любой ее подпоследовательности, а значит, последовательность regret'ов в моменты смены эпох тоже ведет себя сублинейно:\n\n$$\\frac{1}{MN}\\max\\limits_{h^* \\in H}\\left[ \\sum\\limits_{m=1}^M \\sum\\limits_{i=1}^N l(p_{m,i}, y_i) - M\\sum\\limits_{i=1}^N l(h^*(x_i), y_i) \\right] \\rightarrow 0$$\n\n$$\\max\\limits_{h^* \\in H}\\left[ \\frac{1}{MN}\\sum\\limits_{m=1}^M \\sum\\limits_{i=1}^N l(p_{m,i}, y_i) - \\frac1N\\sum\\limits_{i=1}^N l(h^*(x_i), y_i) \\right] \\rightarrow 0$$\n\n$$\\frac{1}{MN}\\sum\\limits_{m=1}^M \\sum\\limits_{i=1}^N l(p_{m,i}, y_i) - \\min\\limits_{h^* \\in H}\\left[ \\frac1N\\sum\\limits_{i=1}^N l(h^*(x_i), y_i) \\right] \\rightarrow 0$$\n\nПоследнее слагаемое уже выглядит практически как постановка задачи стохастической оптимизации на фиксированном датасете! Интуиция на данный момент подсказывает нам, что разрыв между решениями, даваемыми онлайн обучением, и точным решением задачи батч-оптимизации, будет постепенно сокращаться.\n\nВ этот момент интуицию можно выключать―остаются только строгие технические выкладки по ссылкам выше.\n\n## Выпуклая онлайн-оптимизация\n\nВыпуклая оптимизация играет центральную роль в анализе алгоритмов онлайн-обучения и позволяет получать эффективные алгоритмы. Вот примеры задач, в которых она хорошо работает:\n1. Линейная оптимизация;\n2. Expert Advice problem;\n3. Линейная/логистическая регрессия.\n\nДля задач, возникающих в глубинном обучении, мы поступим согласно рекомендациям ведущих ученых: возьмем теоретически обоснованный алгоритм выпуклой оптимизации, воткнем в нейросеть и помолимся, чтобы он сохранил свои хорошие свойства. С методами первого порядка, как правило, работает (а здесь мы будем рассматривать только такие методы)\n\nВведём в нашу игру предположение о выпуклости, а заодно попробуем сделать вычисления менее громоздкими. Для этого определим упрощённую **игру (2)**:\n1. Выбираем параметрическую модель $w_t$;\n2. Получаем извне **выпуклую** функцию потерь $f_t(w)$;\n3. Считаем $f_t$ в точке $w_t$ и получаем наш loss $f_t(w_t)$.\n\nПервое упрощение состоит в том, что прогноз $h_t$ и бейзлайн $h^*_t$ мы теперь берём не из абстрактного функционального множества $H$, а из некоторого параметризованного семейства. Говоря «модель $w_t$», мы имеем в виду «модель, заданная параметрами $w_t$». Скажем, для линейной регрессии это может быть вектор весов и bias. Regret будет записываться следующим образом:\n\n$$maxRegret_T = \\sum\\limits_{t=1}^T f_t(w_t) - \\sum\\limits_{t=1}^T f_t(w_T^*)$$\n\nВторое упрощение в том, что мы не думаем о признаках $x_t$ и таргетах $y_t$. Вся эта информация спрятана в определение функции $f_t(w)$. Например, для линейной регрессии $f_t(w) = (x_t^Tw - y_t)^2$. При этом теперь у нас нет частичной информации о текущем раунде игры **перед** выбором новой модели $w_t$: ведь мы сначала выбираем $w_t$ и лишь потом получаем $f_t(w)$.\n\n**Обратите внимание**: если вы попробуете себе представить онлайн алгоритм на практике, то, как правило, частичная информация о функции $f_t(w)$ перед выбором $w_t$ вам **доступна**. Например, рассмотрим рекомендательную систему с онлайн-дообучаемой ранжирующей моделью:\n1. Пользователь пришел, мы сразу пошли в базу данных за его историей покупок и получили признаковое описание (возможно частичное) $x_t$;\n2. С учётом этого признакового описания мы выбираем модель $w_t$ и с её помощью оцениваем релевантность товаров этому пользователю;\n3. Смотрим, что купил пользователь и купил ли, это даёт нам $f_t(w_t)$.\n\nТем не менее, в этом параграфе мы будем считать, что частичной информации нет, потому что хотим разрабатывать наиболее общий фреймворк, а не ad-hoc алгоритмы, использующие конкретный вид этой частичной информации. Если даже для какой-то узкой проблемы можно сформулировать специфический алгоритм, учитывающий частичную информацию, с высокой вероятностью он не будет работать значимо лучше стандартного решения. Если знаете контрпримеры ― напишите, добавим сюда для полноты.\n\n## Follow the Leader\n\nПредположим, что мы провели $t$ шагов игры (2) и теперь выбираем модель $w_{t+1}$ (как условились, без информации о $f_{t+1}(w)$). Наиболее естественным выбором будет алгоритм, минимизирующий ошибку на всех предыдущих раундах\n\n$$w_{t+1} = arg\\min\\limits_w \\sum\\limits_{s=1}^{t}f_s(w)$$\n\nТакой алгоритм называется **Follow The Leader (FTL)**, потому что мы идем вплотную за наилучшим возможным алгоритмом-бейзлайном в regret (лидером), который учитывает ещё и информацию с $(t+1)$-го шага:\n\n$$w*_{t+1} = arg\\min\\limits_w \\sum\\limits_{s=1}^{\\color{#E06A27}{t+1}}f_s(w)$$\n\nК сожалению, для алгоритма в таком виде есть важные примеры выпуклых задач, когда он не работает. Допустим, наши функции потерь линейны $f_t(w) = g_t^Tw$. Вам может показаться, что линейная функция не особенно похожа на функцию потерь, но, забегая вперед, именно такие функции потерь встретятся дальше при изучении градиентных онлайн-алгоритмов ($g_t = \\nabla f_t(w_t)$).\n\nРассмотрим одномерную задачу $f_t(w) = g_tw_t$, $g_t \\in \\mathbb{R}$, $w_t \\in[-1;1]$. Пусть\n\n$$g_t = \\begin{cases}\n      -0.5 & t=1 \\\\\n      1 & t\\%2 = 0 \\\\\n      -1 & t\\%2 = 1\n   \\end{cases}$$\n\nАлгоритм FTL выглядит так:\n\n$$w_{T+1} = arg\\min\\limits_w\\sum\\limits_{t=1}^T g_tw = arg\\min\\limits_w w\\Big(\\sum\\limits_{t=1}^T g_t\\Big)$$\n\nТакие осциллирующие суммы коэффициентов будут заставлять FTL выбирать наихудшее возможное решение в каждом раунде. Функция потерь в каждом раунде будет равна $0.5$, а кумулятивная функция потерь примет вид $\\sum\\limits_{t=1}^T0.5 = 0.5T$. При этом кумулятивная функция потерь константного решения $w^*=0$ будет равна 0. Получаем линейный regret $0.5T$ относительно бейзлайна $w_T^* = w^* = 0$, алгоритм не сходится.\n\n## Follow The Regularized Leader\n\nЧтобы стабилизировать алгоритм, мы добавим регуляризаторы, и назовем получившийся алгоритм **Follow The Regularized Leader (FTRL)**:\n\n$$w_T = arg\\min\\limits_w\\Big[ \\sum\\limits_{t=1}^T f_t(w) + R(w)\\Big]$$\n\n**Упражнение**. Проверьте, что в примере из предыдущего параграфа добавление регуляризатора стабилизирует осцилляцию решения $w$.\n\nДобавка $R(w)$ должна быть выпуклой и неотрицательной. При этом различный выбор $R(w)$ будет приводить к различным алгоритмам и различным оценкам на regret.\n\nПервое, что приходит в голову ― это $L_2$ регуляризатор $R(w) = \\vert\\vert w\\vert\\vert_2^2$. Он даёт алгоритм\n\n$$w_T = arg\\min\\limits_w\\Big[ \\sum\\limits_{t=1}^T f_t(w) +\\frac{1}{2\\lambda}\\vert\\vert w\\vert\\vert_2^2\\Big]$$\n\n## Adaptive FTRL\n\nСледующая идея―*сделать регуляризатор зависящим от данных (то есть от $f_t$) и своим на каждом раунде T*:\n\n$$w_T = arg\\min\\limits_w\\Big[ \\sum\\limits_{t=1}^T f_t(w) + R_T(w)\\Big]$$\n\nЗабегая вперед―все современные градиентные алгоритмы Adam, RMSProp, AdaGrad и т.д. попадают в это семейство data-dependent регуляризаторов и работают **значительно** эффективнее любых алгоритмов с константными регуляризаторами $R(w)$.\n\n**Обратите внимание**: регуляризаторы являются частью алгоритма FTRL, они **не входят** в формулу для regret, которая по-прежнему имеет вид\n\n$$Regret_T(w^*) = \\sum\\limits_{t=1}^T f_t(w_t) - \\sum\\limits_{t=1}^T f_t(w^*)$$\n\nТаким образом, мы не изменили постановку решаемой нами задачи, изменили лишь метод ее решения.\n\n**Обратите внимание**: введение регуляризаторов влияет *только* на онлайн-алгоритм и выбор $w_t$. Бейзлайны $w_T^*$ выбираются как и раньше:\n\n$$w_T^* = arg\\min\\limits_w \\sum\\limits_{t=1}^Tf_t(w)$$\n\n## Линеаризация и вычислительно эффективный FTRL\n\nРассмотрим пример с логистической регрессией $f_t(w) = \\log(1 + e^{-y_tw_t^Tx_t})$ и  константным $L_2$ регуляризатором:\n\n$$\\sum\\limits_{t=1}^T \\log(1 + e^{-y_tw_t^Tx_t}) + \\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2\\longrightarrow\\min\\limits_w$$\n\nКлассический пример использования онлайн логистической регрессии ― [предсказание CTR в рекламе]( https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41159.pdf). Миллионы запросов в секунду => миллионы решений этой оптимизационной задачи в секунду (если разбивать на батчи ― тысячи, но сути это не меняет). Успех онлайн-алгоритма в таких задачах определяется его вычислительной эффективностью, как по памяти, так и по скорости. Увы, с этим у нашего алгоритма не всё так хорошо:\n\n* Скорость: аналитически задача не решается => FAIL\n* Память: нужно хранить все предыдущие запросы $x_t$, $t\\in{1..T}$ => FAIL\n\nЗдесь нам на помощь приходит линеаризация задачи. Если фунции $f_t(w)$ выпуклые (вниз) и гладкие (на негладкие посмотрим позже), то они удовлетворяют основному свойству выпуклых функций\n\n$$f(w) \\geq f(w_t) + [\\nabla f(w_t)]^T(w - w_t)$$\n\nРазложим все функции $f_t(w)$ в точках $w_t$:\n\n$$f_t(w) \\geq f_t(w_t) + [\\nabla f(w_t)]^T(w - w_t)$$\n\n$$f_t(w_t) - f_t(w) \\leq [\\nabla f(w_t)]^T(w - w_t)$$\n\nПросуммируем от 1 до $T$\n\n$$\\sum\\limits_{t=1}^T \\Big(f_t(w_t) - f_t(w)\\Big) \\leq \\sum\\limits_{t=1}^T \\Big([\\nabla f_t(w_t)]^Tw_t - [\\nabla f_t(w_t)]^Tw^T\\Big)$$\n\nТеперь обозначим $g_t = \\nabla f_t(w_t)$ и рассмотрим выпуклую *линейную* задачу онлайн обучения с функцией потерь $\\widetilde{f}_t(w) = g_t^Tw$. Regret для нее выглядит как\n\n$$LinearizedRegret_T(w^*) = \\sum\\limits_{t=1}^T g_t^Tw_t - \\sum\\limits_{t=1}^T g_t^Tw^*$$\n\nНеравенство выше позволяет нам оценить regret исходной задачи через regret линеаризованной:\n\n$$Regret_T(w^*) \\leq LinearizedRegret_T(w^*)$$\n\n\nМинимизируя правую часть неравенства, мы, безусловно, будем минимизировать и левую, так что мы можем выбирать $w_t$ алгоритмом, решающим линеаризованную задачу, и получать хорошо сходящийся метод для исходной задачи.\n\nПосмотрим, будет ли линеаризованный алгоритм вычислительно эффективнее. Посмотрим на линеаризацию задачи с data-depedent регуляризатором:\n\n$$w_T = arg\\min\\limits_w\\Big[ \\sum\\limits_{t=1}^T \\nabla [f_t(w_t)]^Tw + R_T(w)\\Big]$$\n\nЛинейные задачи имеют аналитическое решение для широкого спектра $R_T(w)$. Собственно, это и есть основное, что нужно помнить на практике ― выбирать регуляризатор так, чтобы эта задача решалась аналитически. Мы рассмотрим простейший случай $R_T(w) = R(w) = \\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2$:\n\n$$w_T = arg\\min\\limits_w\\Big[ \\sum\\limits_{t=1}^T \\nabla f_t(w_t)^Tw + \\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2\\Big]$$\n\nСправа дифференцируемая функция, так что мы можем найти $w_T$, приравняв к нулю градиент:\n\n$$w_T = -\\eta\\sum\\limits_{t=1}^T \\nabla f_t(w_t) = -\\eta z_T,$$\n\nгде $z_T = \\sum\\limits_{t=1}^T \\nabla f_t(w_t)$ ― это сумма векторов, которую не нужно пересчитывать заново на каждом шаге, а можно инкрементально обновлять. Благодаря этому нам больше не нужно помнить все предыдущие объекты выборки, достаточно хранить лишь некоторую статистику.\n\nГотово, мы построили наш первый вычислительно эффективный алгоритм онлайн обучения! В дальнейшем мы займемся тем, чтобы найти *наилучший* вычислительно эффективный алгоритм.\n\n**Обратите внимание**: теперь вы понимете, почему пример с линейной функцией потерь был так важен: линейные функции соответствуют линеаризованному regret. При этом, как мы уже выяснили, без регуляризатора такие линеаризованные задачи нестабильны.\n\n**Обратите внимание**: если переписать немного формулу для $w_T$, мы получим:\n\n$$w_T = -\\eta\\sum\\limits_{t=1}^T \\nabla f_t(w_t) = w_{T-1} - \\eta \\nabla f_t(w_t)$$\n\nТаким образом, формулы FTRL c константным регуляризатором *эквивалентны формулам обычного стохастического градиентного спуска*. Забегая вперед, скажем, что различия в формулах градиентного спуска и FTRL будут *только* в разделе Composite objective FTRL. В этих отличиях и будет заключаться преимущество FTRL перед привычным SGD.\n\n**Обратите внимание**: концепции FTRL и gradient descent в литературе часто называют *lazy* (ленивая) и *greedy* (жадная) соответственно.\n\nGradient descent жадный, потому что алгоритм для обновления $w_{t+1}$ использует только текущий $w_t$ и текущий градиент $g_t$. Всё, что было на предыдущих шагах, алгоритм забывает.\n\nFTRL ленивый, потому что алгоритм в явном виде сохраняет всю информацию с начала обучения и рассчитывает $w_{t+1}$, исходя из всей истории $g_1,\\ldots,g_t$, и только после этого применяет все регуляризаторы. Подробнее мы расскажем об этом в разделе «Сравнение Composite Objective FTRL-Proximal и Adaptive Gradient Descent».\n\n## Субдифференциал и субградиентные методы\n\nВыше мы рассматривали гладкие функции $f_t(w)$. Гладкость ― сильное ограничение, и оно на самом деле необязательно, можно ослабить условие, если использовать субградиенты.\n\nКогда мы переходили от исходной задачи к линеаризованной, мы использовали основное свойство гладких выпуклых функций\n\n$$f(w) \\geq f(w_t) + [\\nabla f(w_t)]^T(w - w_t), \\quad \\forall w_t$$\n\nГладкость обеспечивает существование $\\nabla f(w_t)$ для всех $w_t$. Но нам ведь не нужно, чтобы существовал именно *градиент* функции. Нам достаточно, чтобы существовал *какой-то* вектор $g_t$, для которого выполнено неравенство\n\n$$f(w) \\geq f(w_t) + g^T(w - w_t)$$\n\nИ в этом помогают следующие два понятия.\n\n**Субдифференциалом** функции $f(w)$ в точке $w_t$ называется множество\n\n$$\\partial_{w_t} f(w) = \\left\\{ g_t \\mid f(w) \\geq f(w_t) + f^T(w - w_t),\\forall w\\right\\}$$\n\n**Субградиентом** функции $f(w)$ в точке $w_t$ называется любой элемент множества $\\partial f(w_t)$.\n\nПотребуем, чтобы для любой точки был непустой субдифференциал, и дело в шляпе, можно вместо $\\nabla f_t(w)$ везде подставлять субградиент $g_t$ и обобщить все выкладки выше на негладкий случай.\n\n**Примеры**. Для гладких функций субдифференциал состоит из одной точки: градиента функции, а субградиент равен градиенту. В качестве примера функции с нетривиальным субградиентом рассмотрим функцию $f(x) = \\vert x \\vert$, где $x$ ― скаляр. Субградиент в точке $0$ ― это можество\n\n$$\\partial_0|x| = \\left\\{ \\lambda\\mid |x| \\geq \\alpha x \\right\\}$$\n\nЛегко видеть, что $\\partial_0\\vert x\\vert $ ― это отрезок $[-1, 1]$.\n\n**Замечание**. На практике субдифференциал используют не так часто. Оптимизационные задачи с популярными негладкими регуляризаторами $L_1$ решают «в лоб», без перехода к субградиентной оценке, например, с помощью [проксимальных методов](https://ysda_trove.gitlab.io/ml-handbook/chapters/optimization/proximal).\n\n**Обратите внимание**. В литературе очень часто используется термин Online Mirror Descent. Mirror descent ― это оптимизационная процедура вида\n\n$$w_{t+1} = arg\\min\\limits_w \\left[\\vphantom{\\frac12}g_t^Tw + \\lambda \\psi(w) + \\vert\\vert w-w_t\\vert\\vert_2^2\\right],$$\n\nв которой $\\psi$ ― дополнительный негладкий регуляризатор (например, тот же $L_1$), который мы как раз таки не заменяем на субградиентную оценку, а вместо этого оптимизируем всё «в лоб». Заметьте, что эти формулы *идентичны* формулам [Proximal Gradient Descent](https://ysda_trove.gitlab.io/ml-handbook/chapters/optimization/proximal). Если у нас нет регуляризатора $\\psi$, то формулы эквивалентны обычному gradient descent.\n\nКак вы увидите дальше, Mirror Descent ― это частный случай общего фреймворка, который мы описываем.\n\n### Субградиентные методы оптимизации.\n\nПочти все градиентные методы оптимизации обобщаются на негладкие функции. Модифицируется необходимое и достаточное условие минимума для выпуклых функций: точка $w^*$ является минимумом, если субдифференциал содержит ноль: $0 \\in \\partial f(w^*)$. Очевидно, это прямое обобщение условия для гладких функций, где субдифференциал состоит только из градиента функции.",
        "handbook": "Учебник по машинному обучению",
        "title": "Введение в онлайн-обучение",
        "description": null
    },
    {
        "path": "/handbook/ml/article/adaptivnyj-ftrl",
        "content": "В данном разделе мы рассмотрим широкое семейство алгоритмов, позволяющее делать улучшения в способах введения регуляризации, которые невозможно добиться в классическом градиентном спуске.\n\n### Полезные ссылки\nВсе написанное ниже (за исключением вывода AdaGrad) — сокращенный пересказ обзора H. Brendan McMahan [A Survey of Algorithms and Analysis for Adaptive Online Learning](https://www.jmlr.org/papers/volume18/14-428/14-428.pdf). Везде, где мы обозначаем Lemma 4, Theorem 10 и т.д. — мы ссылаемся на соответствующие теоремы из этой статьи. То же самое с доказательствами: если мы что-то опускаем, подробности можно найти в обзоре\n\nИнтуитивный вывод AdaGrad взят из статьи [Adaptive Subgradient Methods for Online Learning and Stochastic Optimization](https://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf) . Вместо оригинальных оценок на метод Regularized Dual Averaging, требующих дополнительных понятий вроде двойственности по Фенхелю, мы использовали аналогичную оценку из обзора выше, сохранив все рассуждения автора. Опять же — строгое доказательство оценок на regret для AdaGrad есть в этом обзоре.\n\n## Синтаксический сахар\n\nВ выкладках очень часто используются суммы, и без сокращенных обозначений читать их невозможно. В литературе про онлайн-обучение приняты вот такие сокращения:\n\n* $\\color{#348FEA}{r_{0:t}(w)} = \\sum\\limits_{s=0}^tr_s(w)$;\n* Особо отметим обозначение $\\color{#348FEA}{r_{0:t}(w_t)} = \\sum\\limits_{s=0}^tr_s(w_t)$, т.е. точка $w_t$ *фиксирована и не меняется с индексацией в сумме*;\n* $\\color{#348FEA}{h_{0:t}(w)} = f_{1:t}(w) + r_{0:t}(w)$ (обычно это будет сумма функции потерь и регуляризатора);\n* $\\color{#348FEA}{g_t}$ — субградиент функции $f_t(w)$ в точке $w_t$.\n\n\n## Аддитивные регуляризаторы\n\nВ новых обозначениях описанные выше алгоритмы примут вид:\n* Adaptive FTRL: $w_T = arg\\min\\limits_w \\Big[f_{1:t}(w) + R_T(w)\\Big]$\n* Adaptive Linearized FTRL: $w_T = arg\\min\\limits_w \\Big[\\nabla f_{1:t}(w_t)^Tw + R_T(w)\\Big]$\n\nОпишем условия, накладываемые нами на алгоритм. В обзоре они называются Setting 1.\n\n### Setting 1\n\nОт функций $R_T(w)$ мы потребуем, чтобы они представлялись в виде:\n\n$$R_T(w) = \\sum\\limits_{t=0}^Tr_t(w) =  r_{0:T}(w)$$\n\nСлагаемые должны удовлетворять следующим условиям:\n\n1. Все $r_t(w)$ выпуклы (вниз);\n2. $r_t(w) \\geq 0$;\n3. $w_0 = arg\\min\\limits_w r_0(w)$.\n\nТакже наложим следующие требования на $h_{1:t} = f_{1:t}(w) + r_{0:t}(w)$:\n1. Область определения $h_{1:t}$ — непустое множество. Это требование может показаться странным, но при желании можно придумать пример $h_{1:t}$ с пустой областью определения: достаточно взять несколько регуляризаторов-проекций $I_{\\chi}(w)$ на непересекающиеся выпуклые множества (подробнее о таких регуляризаторах мы расскажем в одном из следующих разделов);\n2. Субдифференциал $\\partial_{w_t} f_t(w)$ в точке $w_t$ непуст.\n\n## Классы алгоритмов FTRL\n\nБудем рассматривать аддитивные регуляризаторы $r_t(w)$ из двух семейств в зависимости от того, где у них минимум:\n\n* **FTRL-Centered**: $arg\\min\\limits_w r_t(w) = w_0$;\n* **FTRL-Proximal**: $arg\\min\\limits_w r_t(w) = w_t$;\n* **Composite Objective**: смешение первых двух семейств.\n\n**Обратите внимание**: название Proximal напрямую связано с проксимальным градиентным спуском (ссылка на учебник с проксимальными методами). В обоих случаях мы накладываем регуляризатор в текущей точке $w_t$.\n\n**Обратите внимание**: для Proximal регуляризаторов зачастую требуют выполнения более сильного условия: $r_t(w_t) = 0$. Это не такое уж и серьёзное ограничение: все разумные Proximal регуляризаторы (например,  $\\vert\\vert w - w_t\\vert\\vert^2$) ему удовлетворяют.\n\n**Обратите внимание**: у обоих семейств есть значимые высокоцитируемые статьи\n* FTRL-Centered: метод [Regularized Dual Averaging](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/xiao10JMLR.pdf). Статья получила премию Test of Time Award на NeurIPS 2021, так как огромное количество последующих громких результатов (тот же AdaGrad) напрямую основывались на этих результатах. В названии Dual Averaging под dual average имеется в виду $\\frac1t g_{1:t}$, то есть среднее по градиентам. Кардинально других техник оценок regret там нет, обзор McMahan строго улучшает все доступные там результаты.\n* FTRL-Proximal: самая известная статья от гугла [Ad Click Prediction](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41159.pdf). Известна она скорее потому, что там выписаны формулы и объяснено, как правильно реализовывать метод для large-scale задач с результатами применения различных дополнительных инженерных идей. Это хороший *инженерный обзор*, а не математическая статья.\n\nРассмотрим отдельно каждую из разновидностей алгоритмов\n\n### FTRL-Centered\n\nЗадача оптимизации имеет вид\n\n$$w_{t+1} = arg\\min\\limits_{w} h_{0:t} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + r_{0:t}(w)\\Big],$$\n\nгде $r_t(w)$ таковы, что\n\n$$arg\\min\\limits_w r_t(w) = w_0$$\n\n**Пример**: Рассмотрим SGD с фиксированным learning rate и стартом в точке $0$. Положим\n\n$$r_1(w) = \\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2$$\n\n$$r_t(w) = 0, \\quad t > 0$$\n\n$$w_0 = 0$$\n\n$$w_{t+1} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + \\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2\\Big].$$\n\nКак мы уже знаем, итеративное обновление весов будет иметь вид\n\n$$w_{t+1} = w_t - \\eta g_t.$$\n\n### FTRL-Proximal\n\nЗадача имеет похожий вид\n\n$$w_{t+1} = arg\\min\\limits_{w} h_{0:t} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + r_{0:t}(w)\\Big],$$\n\nно $r_t(w)$ выбираются так, чтобы\n\n$$arg\\min\\limits_w r_t(w) = w_t$$\n\n**Пример**: Рассмотрим SGD с убывающим learning rate:\n\n$$\\eta_t = \\frac{\\alpha}{\\sqrt{t}}$$\n\n$$\\sigma_t = \\frac{1}{\\eta_t} - \\frac{1}{\\eta_{t-1}}$$\n\nПодробный вывод связи $\\sigma_t$ и $\\eta_t$ мы приведём в одном из следующих разделов, а сейчас просто приведём результат:\n\n$$r_t(w) = \\sigma_t\\vert\\vert w - w_t\\vert\\vert_w^2$$\n\n$$w_{t+1} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + \\sum\\limits_{s=1}^t\\sigma_s \\vert\\vert w - w_s\\vert\\vert_w^2\\Big]$$\n\n$$w_{t+1} = w_t - \\eta_t g_t = w_t - \\frac{\\alpha}{\\sqrt{t}} g_t$$\n\n**Обратите внимание**: как правило, на практике Proximal методы работают лучше. Интуитивно, центрирование в недавних точках вместо\n\n### Composite-Objective FTRL\n\nРассмотрим смесь центрированных и проксимальных регуляризаторов:\n\n$$w_{t+1} = arg\\min\\limits_{w} h_{0:t} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + \\psi_{0:t}(w) + r_{0:t}(w)\\Big],$$\n\nгде $r_t(w)$ и $\\psi_t(w)$ таковы, что\n\n$$arg\\min\\limits_w r_t(w) = w_t$$\n\n$$arg\\min\\limits_w \\psi_t(w) = w_0$$\n\n**Пример**: FTRL-Proximal с L1 и L2 регуляризацией\n\n$$w_{t+1} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + \\lambda_{1,t}\\vert\\vert w\\vert\\vert_1 + \\lambda_{2,t}\\vert\\vert w\\vert\\vert_w^2 + \\sum\\limits_{s=1}^t\\sigma_s \\vert\\vert w - w_s\\vert\\vert_2^2\\Big]$$\n\n**Обратите внимание**: как правило, центрированные регуляризаторы в довесок к проксимальным вводят уже не для «дополнительной стабилизации» алгоритма, а для наложения ограничений на решение $w$.\n\n**Обратите внимание**: наиболее правильные и хорошо работающие на практике способы подбора коэффициентов $\\lambda_{1,t}$ и $\\lambda_{2,t}$ мы приведём в параграфе про учет дополнительной $L_1$ и $L_2$ регуляризации.\n\n## Гарантии сходимости для алгоритмов FTRL\n\nВ этом разделе мы обсудим теоретические оценки на скорость сходимости алгоритма FTRL или, что то же самое, на скорость убывания maxRegret.\n\nНапомним формулу:\n\n$$maxRegret(T) = \\max\\limits_{w^*}\\left[ \\sum\\limits_{t=1}^Tf_t(w_t) - f_{1:T}(w^*)\\right]$$\n\nЧтобы делать оценки на maxRegret, нужно пытаться оценить асимптотику ряда, каждое слагаемое которого — это решение сложной оптимизационной задачи $\\min\\limits_w f_{1:t}(w)$ с произвольными функциями $f_t(w)$. Работать с такой сущностью крайне сложно. Наша основная цель — сделать верхнюю оценку на regret, в которой не будет этого члена.(???)\n\n#### Strong FTRL Lemma (Lemma 4)\n\n1. Пусть $f_t(w)$ — последовательность произвольных (не обязательно) функций;\n2. Пусть $r_t(w)$ — последовательность выпуклых неотрицательных регуляризаторов;\n3. Пусть также $w_{t+1} = arg \\min\\limits_w h_{0:t}(w)$ всегда определен (относительно слабые условия 1-2 требуют от нас это явно проговорить);\nТогда алгоритм, выбирающий $w_{t+1}$ по правилу (3), удовлетворяет неравенству\n\n$$Regret_T(w^*) \\leq r_{0:T}(w^*) + \\sum\\limits_{t=1}^T \\left[h_{0:t}(w_t) - h_{0:t}(w_{t+1}) - r_t(w_t)\\vphantom{\\frac12}\\right]$$\n\nИз чего состоит эта лемма?\n\n1. Слагаемое $r_{0:T}(w^*)$ — это суммарная регуляризация в точке $w^*$. Совсем избавиться от вхождения $w^*$ не получится, но мы можем выбирать регуляризатор так, чтобы оценить сверху $r_{0:T}(w^*)$ было не очень сложно.\n\n2. Каждое слагаемое суммы $\\sum\\limits_{t=1}^T \\left[h_{0:t}(w_t) - h_{0:t}(w_{t+1})\\vphantom{\\frac12}\\right] $ отражает, насколько улучшается $t$-й лосс $h_{0:t}$ при замене $w_t$ на $w_{t+1} = arg \\min\\limits_w h_{0:t}(w)$. Поведение разностей $h_{0:t}(w_t) - h_{0:t}(w_{t+1})$ характеризует стабильность алгоритма. Мы ожидаем, что при больших $t$ у хорошо сходящегося алгоритма на очередном шаге $w_t$ будет достаточно близок к оптимуму $w_{t+1}$, то есть вся сумма будет меняться всё медленнее, и её получится разумно оценить. Пример ситуации, когда это не так, мы уже видели, когда рассматривали FTL без регуляризации для линейной функции потерь (там всё было максимально нестабильно и расходилось). К счастью, введение регуляризации обычно помогает добиться стабильности.\n\nОбе компоненты неразрывно связаны. Добавляя регуляризацию, мы увеличиваем первую компоненту, но улучшает стабильность алгоритма, чем уменьшаем вторую, и наоборот.\n\n**Обратите внимание**: в условиях леммы допускаются невыпуклые $f_t(w)$, и это позволяет применять её в весьма общей ситуации. Впрочем, все наши последующие выкладки все-таки будут опираться на выпуклость $f_t(w)$.\n\n{% cut \"Доказательство Strong FTRL Lemma\" %}\n\nПреобразуем выражение для regret:\n\n$$regret(T) = \\sum\\limits_{t=1}^Tf_t(w_t) - f_{1:T}(w^*) =$$\n\n$$= \\sum\\limits_{t=0}^Th_t(w_t) - h_{0:T}(w^*) - \\sum_{t=0}^Tr_t(w_t) + r_{0:T}(w^*) = (\\ast)$$\n\nВспомним, что\n\n$$w_{t+1} = arg \\min\\limits_w h_{0:t}(w),$$\n\nоткуда\n\n$$ h_{0:t}(w^*) \\geq h_{0:t}(w_{t+1}).$$\n\nПоэтому выражение выше мы можем оценить как\n\n$$(\\ast)\\leq \\sum\\limits_{t=0}^Th_t(w_t) - h_{0:T}(w_{t+1}) - \\sum_{t=0}^Tr_t(w_t) + r_{0:T}(w^*) = (\\ast\\ast)$$\n\nТеперь займёмся первыми двумя компонентами\n\n$$\\sum\\limits_{t=0}^Th_t(w_t) - h_{0:T}(w_{t+1}) = $$\n\n$$= h_0(w_0) + \\color{#E06A27}{\\sum\\limits_{t=1}^T}\\left[h_{0:t}(w_t) \\color{#E06A27}{- h_{0:t-1}(w_t)} \\vphantom{\\frac12}\\right] \\color{#E06A27}{- h_{0:T}(w_{T+1})}$$\n\nПосмотрим повнимательнее на рыжие слагаемые:\n\n$$\\sum\\limits_{t=1}^T h_{0:t-1}(w_t) + h_{0:T}(w_{T+1}) = \\color{#348FEA}{\\sum\\limits_{t=1}^T \\sum\\limits_{i=0}^{t-1}h_i(w_t)} + \\sum\\limits_{i=0}^T h_i(w_{T+1}) =$$\n\n$$= \\left|\\vphantom{\\frac12}\\color{#348FEA}{s = t - 1}\\right|\n= \\color{#348FEA}{\\sum\\limits_{s=0}^{T-1} \\sum\\limits_{i=0}^{s}h_i(w_{s+1})} + \\sum\\limits_{i=0}^T h_i(w_{T+1}) = $$\n\n$$=\\sum\\limits_{t=0}^{T}\\sum\\limits_{i=0}^{t}h_i(w_{t+1}) = \\sum\\limits_{t=0}^Th_{0:t}(w_{t+1}) =\n$$\n\n$$= h_0(w_1) + \\sum\\limits_{t=1}^Th_{0:t}(w_{t+1})$$\n\nПодставим это:\n\n$$(\\ast\\ast) = h_0(w_0) + \\sum\\limits_{t=1}^Th_{0:t}(w_t) - h_0(w_1) - \\sum\\limits_{t=1}^Th_{0:t}(w_{t+1}) - \\sum_{t=0}^Tr_t(w_t) + r_{0:T}(w^*) \\leq$$\n\n$$\\leq h_0(w_0) + r_{0:T}(w^*) + \\sum\\limits_{t=1}^T \\left[h_{0:t}(w_t) - h_{0:t}(w_{t+1}) - r_t(w_t)\\vphantom{\\frac12}\\right].$$\n\nЗдесь мы снова воспользовались тем, что $h_0(w_1) = r_0(w_1)\\geq 0$, а также сократили $h_0(w_0) = r_0(w_0)$.\n\nЛемма доказана.\n\n{% endcut %}\n\n### Теоретические оценки на Regret (regret bounds)\n\nНиже мы представим теоремы 1,2 и 10 из [обзора McMahan](https://www.jmlr.org/papers/volume18/14-428/14-428.pdf). Они дают оценки на regret в немного разных исходных предположениях и для разных типов регуляризаторов; асимптотика regret в каждом из случаев $O(\\sqrt{T})$, хотя константы будут различными. О важности констант в сходимости мы поговорим в одной из следующих параграфов, когда будем разбирать метод AdaGrad. В самом конце параграфа мы обсудим, какие оценки получаются для линеаризованного regret. А в следующем параграфе мы займёмся выводом конкретных алгоритмов FTRL для разных видов регуляризаторов.\n\nМы не будем полностью пересказывать обзор (если вам стало интересно, рекомендуем прочитать его самостоятельно) и докажем в качестве примера теорему 2, а для остальных приведём лишь формулировки.\n\n#### Напоминание из выпуклого анализа\n\n**Определение** Выпуклая функция $\\psi(x)$ называется **$\\sigma$-сильно выпуклой** по отношению к некоторой норме $\\vert\\vert \\cdot\\vert\\vert $, если выполнено\n\n$$\\forall g \\in \\partial \\psi(y) \\quad \\psi(x) \\geq \\psi(y) + g^T(x-y) + \\frac{\\sigma}{2}\\vert\\vert x-y\\vert\\vert^2$$\n\n**Определение** **Двойственной нормой** $\\vert\\vert \\cdot\\vert\\vert_*$ по отношению к норме $\\vert\\vert \\cdot\\vert\\vert $ называется\n\n$$\\vert\\vert x\\vert\\vert_* = \\sup\\limits_{y:\\vert\\vert y\\vert\\vert  \\leq 1} x^Ty$$\n\n{% cut \"Физический смысл\" %}\n\nЭта норма у нас возникнет в контексте работы с градиентами. С одной стороны, конечно, градиент $g_t = \\nabla_{w_t}f_t$ — это вектор, но по сути он играет роль линейной функции $w\\mapsto g_t^Tw$, и кажется логичным определять для него норму именно как для линейной функции, то есть как для элемента **двойственного пространства**, состоящего из ограниченных линейных функций на исходном пространстве. \n  \nКак можно определить норму отображения? Самый, пожалуй, естественный вариант — это рассмотреть **операторую норму** относительно $\\vert\\vert \\cdot\\vert\\vert $:\n\n$$\\vert\\vert x\\vert\\vert_* = \\sup\\limits_{y\\leq 0} \\frac{|x^Ty|}{\\vert\\vert y\\vert\\vert},$$\n\nЭто формула верна, если пространство, в котором живут $x$ и $y$ ненулевое (впрочем, нулевое мы вряд ли рассматриваем). Можно показать, что это выражение равно $\\sup\\limits_{y:\\vert\\vert y\\vert\\vert  \\leq 1} x^Ty$.\n\nПостроенная норма называется **двойственной** к норме $\\vert\\vert\\cdot\\vert\\vert$ на исходном пространстве.\n\n{% endcut %}\n\nБолее подробно о $\\sigma$-сильной выпуклости и двойственных нормах вы можете почитать, например, в книге [Boyd, 2004, Convex Optimization](https://web.stanford.edu/~boyd/cvxbook/).\n\n#### Теорема 1. General FTRL Bound\n\nПусть\n* Обновление параметров происходит по правилу \n\n$$w_{t+1} = arg\\min\\limits_{w} h_{0:t} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + r_{0:t}(w)\\Big];$$\n\n* Выполнены все условия Setting 1;\n* Регуляризатор $r_t(w)$ выбирается так, чтобы выражение $h_{0:t}(w) + f_{t+1}(w) = r_{0:t}(w) + f_{1:t+1}(w)$ было 1-сильно выпукло по отношению к некоторой норме $\\vert\\vert \\cdot\\vert\\vert_{t}$ (возможно, своей на каждом шаге).\n\nТогда\n\n$$Regret_T(w^*) \\leq r_{0:T-1}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{(t-1),*}^2,$$\n\nгде $\\vert\\vert \\cdot\\vert\\vert_{(t-1),*}$ — норма, двойственная к норме $\\vert\\vert \\cdot\\vert\\vert_{(t-1)}$.\n\n#### Теорема 2. FTRL-Proximal Bound\n\nПусть\n* Обновление параметров происходит по правилу\n\n$$w_{t+1} = arg\\min\\limits_{w} h_{0:t} = arg\\min\\limits_{w}\\Big[ g_{1:t}^Tw + r_{0:t}(w)\\Big];$$\n\n* Выполнены все условия Setting 1;\n* Все регуляризаторы $r_t(w)$ лежат в семействе FTRL-Proximal, причём $r_t(w_t) = 0$ для всех $t$;\n* $r_t(w)$ выбирается так, чтобы выражение $h_{0:t}(w) = r_{0:t}(w) + f_{1:t}(w)$ было 1-сильно выпукло по отношению к некоторой норме $\\vert\\vert \\cdot\\vert\\vert_t$ (возможно, своей на каждом шаге).\n\nТогда\n\n$$Regret_T(w^*) \\leq r_{0:T}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{t,*}^2,$$\n\nгде $\\vert\\vert \\cdot\\vert\\vert_{t,*}$ — норма, двойственная к норме $\\vert\\vert \\cdot\\vert\\vert_{t}$.\n\n#### Теорема 10. Composite Objective FTRL-Proximal Bound\n\nПусть\n* Обновление параметров происходит по правилу\n\n$$w_{t+1} = arg\\min\\limits_{w} h_{0:t} = arg\\min\\limits_{w} \\Big[g_{1:t}^Tw + \\alpha_{1:t}\\Psi(w) + r_{0:t}(w)\\Big];$$\n\n* Выполнены все условия Settning 1;\n* $\\hat{h}_t(w) = f_t(w) + \\alpha_t\\Psi(w) + r_t(w)$;\n* $\\alpha_t$ — неубывающая последовательность;\n* $\\Psi(w)$ — Centered регуляризатор с минимумом в точке $w_0$;\n* $r_t(w)$ — Proximal регуляризаторы;\n* $r_t(w)$ выбирается так, чтобы выражение $\\hat{h_{0:t}}(w) = r_{0:t}(w) + \\alpha_{1:t}\\Psi(w) + f_{1:t}(w)$ было 1-сильно выпукло по отношению к некоторой норме $\\vert\\vert \\cdot\\vert\\vert_t$ (возможно, своей на каждом шаге).\n\nТогда\n\n* Если мы рассматриваем regret относительно $\\hat{f}_t(w) = f_t(w) + \\alpha_t\\Psi(w)$, то\n\n$$Regret_T(w^*) \\leq r_{0:T}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{t,*}^2;$$\n\n* Если мы рассматриваем regret относительно $f_t(w)$, то\n\n$$Regret_T(w^*) \\leq r_{0:T}(w^*) + \\alpha_{1:t}\\Psi(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{t,*}^2,$$\n\nгде $\\vert\\vert \\cdot\\vert\\vert_{(t),*}$ — норма, двойственная к норме $\\vert\\vert \\cdot\\vert\\vert_{t}$.\n\n**Обратите внимание**. Оценки Proximal и General отличаются индексацией: до $t$ или до $t-1$ соответственно. Это чисто техническое различие, однако именно из-за него с Proximal регуляризаторами удобнее работать как в теоретических выкладках, так и при выведении практических методов.\n\n**Обратите внимание**. На $f_t(w)$ мы не хотим накладывать ограничения сильной выпуклости, но сильную выпуклость функции $h_{0:t}(w) = f_{1:t}(w) + r_{0:t}(w)$ можно обеспечить за счет выбора сильно выпуклых регуляризаторов. В самом деле, сумма выпуклой и сильно выпуклой функций сильно выпукла. Если\n\n$$f_t(w) \\geq f_t(w_t) + (w - w_t)^T\\nabla f_t(w_t)$$\n\nи\n\n$$r_t(w) \\geq r_t(w_t) + (w - w_t)^T\\nabla r_t(w_t) + \\frac{1}{2}\\vert\\vert w - w_t\\vert\\vert^2,$$\n\nто\n\n$$f_t(w) + r_t(w) \\geq f_t(w_t) + r_t(w_t) + (w - w_t)^T(\\nabla f_t(w_t) + \\nabla r_t(w_t)) + \\frac{1}{2}\\vert\\vert w - w_t\\vert\\vert^2.$$\n\n**Обратите внимание**. Норма $\\vert\\vert w\\vert\\vert_{t,*}^2$ является сопряженной к норме, относительно которой 1-сильно выпукла функция $h_{0:t}(w) = f_{1:t}(w) + r_{0:t}(w)$. Это значит, что норму мы будем выбирать по **сумме** регуляризаторов $r_{0:t}(w)$, а не просто по $r_t(w)$.\n\n#### Доказательство на примере теоремы 2\n\nНам понадобится следующая чисто техническая лемма, доказательство которой мы опустим. Желающие могут прочитать Appendix B в [обзоре](https://www.jmlr.org/papers/volume18/14-428/14-428.pdf). \n\n**Lemma 7**. Пусть\n\n* $\\phi_1$ — выпуклая функция $\\mathbb{R}^n \\rightarrow \\mathbb{R} \\cup \\{\\infty\\}$, для которой существует $x_1 = arg\\min\\limits_x \\phi_1(x)$;\n* $\\psi$ — выпуклая функция;\n* $\\phi_2(x) = \\phi_1(x) + \\psi(x)$ — выпуклая функция, для которой существует $x_2 = arg\\min\\limits_x \\phi_2(x)$ и которая, кроме того, 1-сильно выпукла по норме $\\vert\\vert \\cdot\\vert\\vert $.\n\nТогда, для любого элемента $b$ субдифференциала $\\partial_{x_1} \\psi$ имеет место неравенство\n\n$$\\vert\\vert x_1 - x_2\\vert\\vert  \\leq \\vert\\vert b\\vert\\vert_*$$\n\nи для любого $x'$ имеет место неравенство\n\n$$\\phi_2(x_1) - \\phi_2(x') \\leq \\frac{1}{2}\\vert\\vert b\\vert\\vert_*.$$\n\n**Доказательство теоремы 2**\n\nРассмотрим соседние раунды $w_t$ и $w_{t+1}$. Имеем\n\n$$w_{t} = arg\\min\\limits_w h_{0:t-1} = arg\\min\\limits_w\\left[f_{1:t-1} + r_{0:t-1}\\right]$$\n\nОбозначим $\\phi_1(w) = f_{1:t-1}(w) + r_{0:t}(w) = h_{0:t-1}(w) + r_t(w) = h_{0:t}(w) - f_t(w)$. Поскольку $w_t$ одновременно минимизирует и $r_t(w)$ (т.к. это proximal регуляризатор), и $h_{0:t-1}$, имеем\n\n$$w_t = arg\\min\\limits_w \\Big[h_{0:t-1} + r_t(w)\\Big] = arg\\min\\limits_w \\phi_1(w).$$\n\nДалее,\n\n$$w_{t+1} = arg\\min\\limits_w h_{0:t} = arg\\min\\limits_w \\Big[\\phi_1(w) + f_t(w)\\Big]$$\n\nВыпишем оценку из Strong FTRL Lemma и постараемся оценить отмеченные рыжим слагаемые\n\n$$\\sum\\limits_{t=1}^Tf_t(w_t) - f_{1:T}(w^*) \\leq r_{0:T}(w^*) + \\color{#E06A27}{\\sum\\limits_{t=1}^Th_{0:t}(w_t) - h_{0:t}(w_{t+1}) - r_t(w_t)}$$\n\nТак как по условию теоремы $r_t(w_t) = 0$, мы можем убрать это слагаемое:\n\n$$h_{0:t}(w_t) - h_{0:t}(w_{t+1}) - r_t(w_t) = \\color{#C81D6B}{h_{0:t}(w_t)} - \\color{#348FEA}{h_{0:t}(w_{t+1})} = $$\n\n$$= \\color{#C81D6B}{\\phi_1(w_t) + f_t(w_t)} - \\color{#348FEA}{(\\phi_1(w_{t+1}) + f_t(w_{t+1}))}$$\n\nОбозначим $\\phi_2(w) = \\phi_1(w) + f_t(w)$. Применив Лемму 7, получаем\n\n$$\\phi_1(w_t) + f_t(w_t) - \\phi_1(w_{t+1}) - f_t(w_{t+1}) \\leq \\frac{1}{2}\\vert\\vert g_t\\vert\\vert_{t,*}^2$$\n\n### О связи оценок на regret для обычного и линеаризованного FTRL\n\nВспомним, что для линеаризованного FTRL имеет место неравенство:\n\n$$Regret_T(w) \\leq LinearizedRegret_T(w).$$\n\nУвы, верхняя оценка на левую часть неравенства не помогает оценить правую. Поэтому рассмотрим линеаризованный алгоритм более подробно. Он работает с последовательностью функций $\\hat{f}_t(w) = g_t^Tw$, где $g_t \\in \\partial_{w_t} f_t$. Субдифференциал $\\hat{f}_t$ состоит из одного вектора (градиента это функции)\n\n$$\\hat{g}_t = \\frac{\\partial \\hat{f}_t(w)}{\\partial w} = g_t$$\n\nПрименим приведённые выше оценки на regret для исходного и для линеаризованного алгоритма:\n\n$$Regret_T(w^*) \\leq r_{0:T}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{t,*}^2$$\n\n$$LinearizedRegret_T(w^*) \\leq r_{0:T}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert \\hat{g}_t\\vert\\vert_{t,*}^2 = r_{0:T}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{t,*}^2$$\n\nЛегко убедиться, что **оценки regret для обычного и линеаризованного FTRL совпадают** и выполнено соотношение\n\n$$Regret_T(w^*) \\leq LinearizedRegret_T(w^*) \\leq TheoremRegret_T(w^*).$$\n\nТаким образом, для линеаризованного варианта любого алгоритма FTRL не нужно доказывать собственные оценки. А поскольку линеаризованный FTRL намного эффективнее, в дальнейшем мы всегда будем сразу переходить от исходного алгоритма к линеаризованному.\n\n## Построение эффективного адаптивного FTRL\n\nТеперь, когда мы получили теоретические оценки на качество работы адаптивного FTRL, настала пора рассмотреть несколько конкретных примеров алгоритмов из этого класса.\n\n### Семейство квадратичных регуляризаторов $r_t(w)$\n\nВо всех дальнейших выкладках мы сразу ограничим себя семейством квадратичных регуляризаторов:\n1. Для FTRL-Centered алгоритмов: $r_t(w) = w^TD_tw = \\vert\\vert w\\vert\\vert_{D_t}^2$,\n2. Для FTRL-Proximal алгоритмов: $r_t(w) = (w - w_t)^TD_t(w - w_t) = \\vert\\vert w - w_t\\vert\\vert_{D_t}^2$,\n\nгде $D_t$ — некоторая симметричная положительно определённая матрица (возможно, своя для каждого шага).\n\nПомимо того, что они удобны и привычны, таки регуляризаторы позволяют достаточно просто выписывать оценки на regret. Чтобы в этом убедиться, вспомним, какие нетривиальные сущности возникают в теоремах:\n\n* на каждом шаге нам нужно выбрать норму $\\vert\\vert \\cdot\\vert\\vert_{t}$, по отношение к которой выражение $h_{0:t}(w) + f_{t+1}(w) = r_{0:t}(w) + f_{1:t+1}(w)$ было бы 1-сильно выпуклым;\n* во всех оценках участвует $r_{0:T}(w^*)$ (или $r_{0:T-1}(w^*)$), и его хорошо бы уметь оценивать сверху;\n* также в оценках фигурирует норма, двойственная к $\\vert\\vert \\cdot\\vert\\vert_{t}$, и её нужно уметь выводить.\n\nДавайте разберёмся с каждым из пунктов и поймём, почему для квадратичных регуляризаторов всё довольно хорошо.\n\n**Выбор нормы $\\vert\\vert\\cdot\\vert\\vert_{t}$**\n\nТут всё просто:\n\n1. Регуляризатор $\\vert\\vert w\\vert\\vert_D$ является 1-сильно выпуклым относительно нормы $\\vert\\vert w\\vert\\vert_D$ (т.е. относительно себя же);\n2. Регуляризатор $\\vert\\vert w - w_t\\vert\\vert_D$ является 1-сильно выпуклым относительно *той же самой нормы* $\\vert\\vert w\\vert\\vert_D$.\n\nНам, впрочем, нужна 1-сильная выпуклость всей суммы $r_{0:t}(w)$, но легко убедиться, что $r_{0:t}$ 1-сильно выпукло относительно суммарной нормы $\\vert\\vert \\cdot\\vert\\vert_{D_{0:t}}^2$. Поскольку $D_{0:t}$ — тоже симметричная положительно определенная матрица, мы остаёмся в том же классе норм Махаланобиса.\n\n**Двойственная норма $r_{0:t}(w)$**\n\nОказывается, что\n\n$$\\vert\\vert w\\vert\\vert_{D,*} = \\vert\\vert w\\vert\\vert_{D^{-1}}$$\n\n{% cut \"Доказательство\" %}\n\nПо определению\n\n$$\\vert\\vert x\\vert\\vert_{D,*} = sup \\{ x^Ty: y^TDy \\leq 1 \\}$$\n\nДля начала заметим, что ограничение-неравенство можно заменить на ограничение-равенство. А именно, если $\\vert\\vert y\\vert\\vert_D < 1$, то, взяв $\\alpha > 1: \\vert\\vert \\alpha y\\vert\\vert_D = 1$, мы получим $\\vert\\alpha x^Ty\\vert > \\vert x^Ty\\vert$. Значит, супремум можно искать на границе.\n\nДалее, заметим, что мы работаем с конечномерными пространствами (вряд ли у вектора весов бесконечное число компонент), поэтому единичный шар $\\vert\\vert y\\vert\\vert_D = 1$ является компактом и, стало быть, супремум на нём достигается. Таким образом, мы можем решать привычную задачу оптимизации с ограничениями и применить для неё метод множителей Лагранжа.\n\nВыпишем функцию Лагранжа:\n\n$$L(y, \\lambda) = x^Ty - \\lambda(y^TDy - 1)$$\n\nПродифференцируем её и приравняем градиент к нулю:\n\n\n$$\\nabla_y L(y, \\lambda) = x - 2\\lambda y(D + D^T) = 0$$\n\n\nТак как матрица $D$ симметрична, имеем $D + D^T = 2D$ и, следовательно,\n\n$$y = \\frac{1}{\\lambda}D^{-1}x$$\n\nПодставим его в граничное условие-равенство и выразим $\\lambda$:\n\n$$1 = y^TDy = \\left(-\\frac{1}{\\lambda}D^{-1}x\\right)^TD\\left(-\\frac{1}{\\lambda}D^{-1}x\\right) =\\frac{1}{\\lambda^2}x^TD^{-T}DD^{-1}x$$\n\nОтсюда\n\n$$x^TD^{-T}x = \\lambda^2$$\n\nТранспонировав обе части, получаем\n\n$$x^TD^{-1}x = \\lambda^2$$\n\n$$\\lambda = \\sqrt{x^TD^{-1}x}$$\n\nПодставим найденное $\\lambda$ обратно в выражение $y = \\frac{1}{\\lambda}D^{-1}x$:\n\n$$y = \\frac{D^{-1}x}{\\sqrt{x^TD^{-1}x}},$$\n\nа полученное решение подставим в исходную функцию $x^Ty$:\n\n$$x^Ty = \\frac{x^TD^{-1}x}{\\sqrt{x^TD^{-1}x}} = \\sqrt{x^TD^{-1}x} = \\vert\\vert x\\vert\\vert_{D^{-1}}.$$\n\n{% endcut %}\n\n**Ограничение сверху для $r_{0:t}(w^*)$**\n\nСтрого говоря, здесь никаких гарантий нет, и, например, очень плохая инициализация может всё сильно испортить. На практике, впрочем, всё работает нормально, но авторы статей не могут себе позволить надеяться на благосклонность судьбы. Поэтому в статьях часто встречается следующий костыль. Для вывода оценок на regret вводится регуляризатор $r_0(w) = I_{R}(w)$, где \n\n$$\nI_{R}(w) = \\begin{cases}\n      \\infty & \\vert\\vert w \\vert\\vert > R \\\\\n      0 & \\vert\\vert w \\vert\\vert \\leq R\n   \\end{cases}\n$$\n   \nэто проекция на шар. Тогда можно доказать, что $\\vert\\vert w^* \\vert\\vert \\leq R$.\n\n\n### Семейство логарифмических регуляризаторов\n\nДля ряда частных задач вроде expert advice problem и оптимизаций по вероятностным распределениям используется также семейство энтропийных регуляризаторов\n\n$$r_t(w) = \\sum\\limits_{i=1}^Nw_i\\log{w_i}$$\n\nБолее подробно о нём можно почитать в [обзоре Shai-Shalev Schwartz](https://www.cs.huji.ac.il/w~shais/papers/OLsurvey.pdf), пример 2.5.\n\n### Constant learning rate FTRL\n\nПростейший пример — это константный регуляризатор \n\n$$\nr_s(w) = \\begin{cases}\n\\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2,\\ s=0,\\\\ \n0,\\ s > 0\n\\end{cases}\n$$\n\nЛегко показать, что $\\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2 = \\vert\\vert w\\vert\\vert_{\\frac{1}{2\\eta}I}^2$.\n\nСоответствующий итерационный процесс оптимизации имеет вид\n\n$$w_{t+1} = arg\\min\\limits_w\\Big[ g_{1:t}^Tw + \\frac{1}{2\\eta}\\vert\\vert w\\vert\\vert_2^2\\Big]$$\n\nКак мы уже наблюдали ранее, этот метод эквивалентен методу стохастического градиентного спуска с константным learning rate. А именно, шаг обновления весов можно сформулировать двумя способами:\n\n* на языке FTRL: $w_{t+1} = -\\eta g_{1:t}^T$;\n\n* на языке градиентного спуска: $w_{t+1} = w_t - \\eta g_t$.\n\n**Оценка на Regret** (3.1 Constant Learning Rate Online Gradient Descent). Пусть\n* $\\vert\\vert g_t\\vert\\vert  \\leq G$;\n* $\\vert\\vert w^*\\vert\\vert  \\leq R$.\n\nТогда, если взять $\\eta = \\frac{R}{G\\sqrt{T'}}$, то для любого $T' \\leq T$\n\n$$Regret_T(w^*) \\leq RG\\sqrt{T'}$$\n\nВ целом, такая стратегия регуляризации не самая оптимальная. Интуитивно, наш регуляризатор фиксирован вне зависимости от того, сколько мы уже сыграли раундов, и со временем может перестать компенсировать член $g_{1:t}^Tw$, и тогда стабильность алгоритма может падать.\n\n### FTRL с learning rate scheduling\n\nЧтобы исправить нестабильность алгоритма, возьмём $L_2$-регуляризатор, не равный нулю на каждом шаге.\n\nПроцесс оптимизации примет вид:\n\n* Для FTRL-Proximal: $w_{t+1} = arg\\min\\limits_w \\Big[ g_{1:t}^Tw + \\sum\\limits_{s=0}^t\\frac{\\sigma_s}{2}\\vert\\vert w-w_s\\vert\\vert_2^2 \\Big]$;\n* Для FTRL-Centered: $w_{t+1} = arg\\min\\limits_w \\Big[ g_{1:t}^Tw + \\sum\\limits_{s=0}^t\\frac{\\sigma_s}{2}\\vert\\vert w\\vert\\vert_2^2 \\Big]$.\n\nПосмотрим, какое обличье примет алгоритм FTRL-Proximal, если его изложить на языке градиентного спуска. Для этого продифференцируем и приравниваем нулю выражение, которое мы минимизируем:\n\n$$0 = g_{1:t} + \\sum\\limits_{s=0}^t\\sigma_s (w - w_s)$$\n\n$$\\sum\\limits_{s=0}^t\\sigma_s w_s - g_{1:t} = \\sigma_{0:t} w$$\n\n$$w_{t+1} = \\frac{1}{\\sigma_{0:t}} \\sum\\limits_{s=0}^t\\sigma_s w_s -\\frac{1}{\\sigma_{0:t}} g_{1:t}$$\n\nПопробуем получить рекуррентную формулу для выражения $w_{t+1}$ через $w_t$:\n\n$$w_{t+1} = \\frac{1}{\\sigma_{0:t}} \\Big(\\sum\\limits_{s=0}^t\\sigma_s w_s - g_{1:t}\\Big)$$\n\n$$w_t = \\frac{1}{\\sigma_{0:t-1}} \\color{#E06A27}{\\Big(\\sum\\limits_{s=0}^{t-1}\\sigma_s w_s - g_{1:t-1}\\Big)}$$\n\n$$w_{t+1} = \\frac{1}{\\sigma_{0:t}} \\Big(\\color{#E06A27}{\\sum\\limits_{s=0}^{t-1}\\sigma_s w_s} + \\sigma_t w_t - \\color{#E06A27}{g_{1:t-1}} - g_t \\Big)$$\n\n$$w_{t+1} = \\frac{1}{\\sigma_{0:t}} \\Big(\\sigma_{0:t-1} w_t + \\sigma_t w_t - g_t\\Big) = \\frac{1}{\\sigma_{0:t}} \\Big( \\sigma_{0:t} w_t - g_t\\Big) = w_t - \\frac{1}{\\sigma_{0:t}}g_t$$\n\nЕсли теперь положить $\\eta_t = \\frac{1}{\\sigma_{0:t}}$, мы получаем формулу градиентного спуска:\n\n$$w_{t+1} = w_t - \\eta_t g_t$$\n\nТаким образом, *темп обучения градиентного спуска равен обратной сумме коэффициентов регуляризации ftrl*. Точно так же можно выразить\n\n$$\\sigma_t = \\frac{1}{\\eta_t} - \\frac{1}{\\eta_{t-1}}$$\n\nВ качестве классической непокоординатной последовательности learning rate обычно берут\n\n$$\\eta_t = \\frac{\\alpha}{\\sqrt{t}}$$\n\n$$\\sigma_t = \\frac{\\sqrt{t + 1} - \\sqrt{t}}{\\alpha}$$\n\n**Оценка на Regret** (3.2, Dual Averaging) Пусть\n* $\\vert\\vert g_t\\vert\\vert  \\leq G$,\n* $\\vert\\vert w^*\\vert\\vert  \\leq R$.\n\nТогда, если выбрать $\\eta_t = \\frac{R}{\\sqrt{2}G\\sqrt{t+1}}$, то\n\n$$Regret_T(w^*) \\leq \\sqrt{2}RG\\sqrt{T}$$\n\nКак и в случае с константным learning rate, константа $\\frac{R}{\\sqrt{2}G}$ в $\\eta_t$ на практике никому не известна, так что ее подменяют на $\\alpha$ и перебирают руками с learning rate, равным $\\frac{\\alpha}{\\sqrt{t+1}}$.\n\n### Data-Adaptive FTRL\n\nДо сих пор мы рассматривали в качестве нормы $\\vert\\vert \\cdot\\vert\\vert $ стандартное скалярное произведение, в которое различные компоненты вектора весов (которые, грубо говоря, соответствуют различным признакам) вносят равный вклад. Такой подход может быть слишком наивным для «боевых» задач, где геометрия оптимизации имеет форму, например, вытянутого эллипса.\n\nНетрудно обобщить предыдущие рассуждения на случай произвольного скалярного произведения\n\n$$w_{t+1} = arg\\min\\limits_w\\Big[ g_{1:t}^Tw + \\frac{1}{2}\\sum\\limits_{s=0}^T\\vert\\vert w - w_s\\vert\\vert_{D_s}^2\\Big]$$\n\nКоэффициенты $\\sigma_s$ в этом выражении теперь спрятались в $D_s$. Найдем точку минимума:\n\n$$0 = g_{1:t} + \\frac{1}{2}\\sum\\limits_{s=0}^t(w - w_s)(D_s + D_s^T) = g_{1:t} + \\sum\\limits_{s=0}^t(w - w_s)D_s$$\n\n$$\\Big(\\sum\\limits_{s=0}^tD_s\\Big)w = \\sum\\limits_{s=0}^tD_sw_s - g_{1:t}$$\n\nНо сразу возникают проблемы:\n\n* Нужно хранить $\\sum\\limits_{s=0}^tD_s$, в общем случае это квадрат по памяти от числа параметров. Ни в какой реальной задаче мы не сможем себе этого позволить;\n* На каждой итерации метода нужно решать гигантскую систему линейных уравнений для поиска $w$. Есть все шансы состариться, так и не успев увидеть решение задачи оптимизации.\n\nУпростим себе жизнь и предположим, что все матрицы $D_s$ диагональны. Тогда $\\sum\\limits_{s=1}^tD_s$ можно хранить в виде вектора диагональных элементов того же размера, что и $w$, а система на каждой итерации будет решаться за линию.\n\n### AdaGrad: наилучший адаптивный метод\n\nРазрешив себе брать нормы $\\vert\\vert\\cdot\\vert\\vert_{D_s}$ с диагональными матрицами $D_s$, мы сделали алгоритм более гибким, но при этом приобрели дополнительные степени свободы (выбор диагональных элементов). Попробуем ответить на два вопроса:\n\n* Можно ли матрицы $D_s$ не угадывать, а настраивать по доступной на очередном шаге информации?\n* Как выбирать матрицы $D_s$ так, чтобы минимизировать оценки на regret?\n\nВ процессе поисков ответов на них мы придём к известному методу оптимизации **AdaGrad**.\n\nПомня, что $\\vert\\vert .\\vert\\vert_{D,*} = \\vert\\vert .\\vert\\vert_{D^{-1}}$, выпишем общий вид оценки на regret:\n\n$$Regret_T(w^*) \\leq r_{0:T-1}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g\\vert\\vert_{(t),*}^2 = \\sum\\limits_{t=1}^T \\vert\\vert w^* - w_t\\vert\\vert_{D_t}^2 + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{(D_{0:T})^{-1}}^2$$\n\nЧтобы упростить выкладки, введем новую симметричную положительно определенную матрицу $S_T = D_{0:T}^{-1}$ и перепишем формулы\n\n$$Regret_T(w^*) \\leq r_{0:T-1}(w^*) + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g\\vert\\vert_{t-1,*}^2 = \\sum\\limits_{t=1}^T \\vert\\vert w^* - w_t\\vert\\vert_{D_t}^2 + \\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{S_T}^2$$\n\nС членом $\\sum\\limits_{t=1}^T \\vert\\vert w^* - w_t\\vert\\vert_{D_t}^2$ явно будет очень сложно работать: чтобы им пользоваться, нужно иметь на руках оптимальное решение $w_t^*$ для всей предыдущей выборки. Более перспективным выглядит слагаемое $\\frac{1}{2}\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{S_T}^2$: вычислять их одно удовольствие. Идея метода **AdaGrad** как раз в том, чтобы не пытаться работать с первым членом и минимизировать второй, надеясь, что итоговые оценки на regret при этом тоже улучшатся.\n\nДля начала выведем диагональный AdaGrad как более простой случай. Если все $D_t$ диагональны, то матрица $S_T = D_{1:T}^{-1}$ тоже диагональна и представляется набором диагональных элементов $\\frac{1}{s_i}$ (уберем индекс $T$ для сокращения выкладок, так как мы рассматриваем фиксированный раунд).\n\nРаспишем второе слагаемое в regret\n\n$$\\sum\\limits_{t=1}^T\\vert\\vert g_t\\vert\\vert_{S_T}^2 = \\sum\\limits_{t=1}^T\\sum\\limits_{i=1}^N\\frac{g_{t,i}^2}{s_i}$$\n\nПопробуем минимизировать его\n\n$$\n\\begin{cases}\\sum\\limits_{t=1}^T\\sum\\limits_{i=1}^N \\frac{g_{t,i}^2}{s_i} \\longrightarrow \\inf\\limits_s\\\\\ns_i \\geq 0\n\\end{cases}\n$$\n\nУсловие $s_i \\geq 0$ возникает из неотрицательной определенности матрицы $S_T$. Решеним такой задачи, очевидно, является $s_i \\rightarrow +\\infty$. Однако в этом случае член $\\sum\\limits_{t=1}^T \\vert\\vert w^* - w_t\\vert\\vert_{D_t}^2$ из оценки на regret станет, наоборот, бесконечно большим, и нужен какой-то компромисс. Введем довольно слабое ограничение на положительные коэффициенты\n\n$$\n\\begin{cases}\\sum\\limits_{t=1}^T\\sum\\limits_{i=1}^N \\frac{g_{t,i}^2}{s_i} \\longrightarrow \\inf\\limits_s\\\\\ns_i \\geq 0,\\\\\n\\sum\\limits_{i=1}^Ns_i \\leq c\n\\end{cases}\n$$\n\nи найдём оптимум с помощью метода множителей Лагранжа. Функция Лагранжа имеет вид\n\n$$L(s,\\lambda,\\theta) = \\sum\\limits_{t=1}^T\\sum\\limits_{i=1}^N \\frac{g_{t,i}^2}{s_i} + \\lambda^Ts + \\theta\\left(\\sum\\limits_{i=1}^Ns_i - c\\right)$$\n\nОтметим, что здесь $\\lambda$ — это вектор, а $\\theta$ — число.\n\nПриравняем к нулю частные производные:\n\n$$0=\\frac{\\partial L(s,\\lambda,\\theta)}{\\partial s_i} = -\\frac1{s_i}\\sum\\limits_{t=1}^T g_{t,i}^2 + \\lambda_i + \\theta$$\n\nВспомним про условия дополняющей нежесткости, требующие, чтобы $\\lambda_i s_i = 0$. Так как $s_i$ мы нулю приравнять здесь не можем, получаем, что $\\lambda_i = 0$:\n\n$$\\frac1{s_i}\\sum\\limits_{t=1}^T g_{t,i}^2 - \\theta = 0$$\n\n$$s_i = \\theta^{-\\frac{1}{2}}\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}$$\n\nТеперь вспомним про условие $\\sum\\limits_{i=1}^Ns_i \\leq c$. Можно показать, что оптимум достигается на границе (то есть когда неравенство превращается в равенство). Тогда\n\n$$c = \\sum\\limits_{i=1}^Ns_i  = \\theta^{-\\frac{1}{2}}\\sum\\limits_{i=1}^N\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}$$\n\n$$\\theta^{-\\frac{1}{2}} = \\frac{c}{\\sum\\limits_{i=1}^N\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}}$$\n\n$$s_i =  \\frac{c\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}}{\\sum\\limits_{i=1}^N\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}}$$\n\nВернемся к оценке на regret. Чему равно $c$ мы не знаем, поэтому мы просто констатируем, что оптимальные коэффициенты $s_i$ пропорциональны $\\sqrt{\\sum\\limits_{s=1}^tg^2_{s,i}}$:\n\n$$s_i = \\frac1{\\alpha}\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}$$\n\nТеперь $S_T$ — диагональная матрица с диагональными элементами $\\frac1{s_i}$. Следовательно, $D_{0:T} = (S_T)^{-1}$ - тоже диагональная матрица с диагональными элементами $s_i$:\n\n$$D_{0:T,i} = \\frac1{\\alpha}{\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}} = \\sum\\limits_{t=1}^T \\left(\\frac1{\\alpha}{\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}} - \\frac1{\\alpha}{\\sqrt{\\sum\\limits_{t=1}^{T-1} g_{t,i}^2}}\\right) + 0, \\quad D_0 = 0,$$\n\nи легко убедиться, что\n\n$$D_{t,i} = \\frac1{\\alpha}{\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}} - \\frac1{\\alpha}{\\sqrt{\\sum\\limits_{t=1}^T g_{t,i}^2}}$$\n\nТеперь вспомним, что эти формулы в точности повторяют то, что мы получили выше для соотношения $\\sigma_t = \\frac{1}{\\eta_t} - \\frac{1}{\\eta_{t-1}}$, только вместо общего коэффициента $\\eta_t$ у нас теперь покоординатные коэффициенты $\\eta_{t,i}$:\n\n$$\\eta_{t,i} = \\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^t g_{s,i}^2}}$$\n\nПолучаем формулы для метода AdaGrad в градиентной постановке:\n\n$$w_{t+1,i} = w_{t,i} - \\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^t g_{s,i}^2}}g_{t,i},$$\n\nгде коэффициент $\\alpha$ приобретает значение learning rate.\n\n**Оценка на Regret** (3.4, FTRL-Proximal with Diagonal Matrix Learning Rates)\n\nЕсли использовать AdaGrad с покоординатными learning rate, то\n\n$$Regret_T(w^*) \\leq 2 \\sqrt{2} R \\sqrt{\\sum\\limits_{t=1}^Tg_t^2}$$\n\nОтметим, что это оценка отличается от предыдущей тем, что вместо $G\\sqrt{T}$ используется $\\sqrt{\\sum\\limits_{t=1}^Tg_t^2}$. Таким образом, если у градиента на какой-то из позиций стоит что-то большое, это повлияет лишь на одно из слагаемых под корнем вместо того, чтобы умножиться на $\\sqrt{T}$.\n\n**Эффективный размер шага**. Предположим, что градиенты ограничены по норме $\\vert\\vert g\\vert\\vert_2 \\leq R$. Перепишем наши формулы в виде\n\n$$\\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^T g_{s,i}^2}} = \\frac{\\alpha}{\\sqrt{T}\\cdot\\sqrt{\\frac{1}{T}\\sum\\limits_{s=1}^T g_{s,i}^2}} \\leq \\frac{\\alpha}{R\\sqrt{T}}$$\n\nИз этих формул следует, что в среднем learning rate в AdaGrad убывает как $\\eta_t = O\\left(\\frac{1}{\\sqrt{T}}\\right)$, то есть так же, как в предыдущем методе. Отличие состоит лишь в более правильной покоординатной нормировке, которая улучшает сходимость.",
        "handbook": "Учебник по машинному обучению",
        "title": "Адаптивный FTRL",
        "description": null
    },
    {
        "path": "/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii",
        "content": "В этом параграфе мы поговорим о регуляризации, но использовать мы её будем не для стабилизации обучения, а для того, чтобы *накладывать ограничение на получаемое нами решение*. Чтобы отличать их от стабилизирующих слагаемых, для таких регуляризаторов будем использовать обозначение $\\psi_t(w)$\n\nВ теории от регуляризатора требуется только выпуклость, но на практике широко используются лишь три вида:\n\n* $L_1 = \\vert\\vert w\\vert\\vert_1$ и его собрат $L_{1/2}$;\n* $L_2 = \\vert\\vert w\\vert\\vert_2^2$;\n* Проекция на выпуклое множество $\\chi$: \n\n$$\n\\psi(w) = I_{\\chi}(w) = \\begin{cases}\n      \\infty & w \\not\\in \\chi \\\\\n      0 & w \\in \\chi\n   \\end{cases}\n$$\n\nКлассическим способом введения регуляризации является прибавление к оптимизируемому функционалу:\n\n$$\\hat{f}_t(w) = f_t(w) + \\psi_t(w)$$\n\nс последующим применением любых методов оптимизации «из коробки». Яркий пример — $L_2$ регуляризация:\n\n$$\\hat{f}_t(w) = f_t(w) + \\frac{1}{2\\lambda_2}\\vert\\vert w\\vert\\vert_2^2,$$\n\nкоторая не портит гладкости функционала.\n\n## Идея неразложения регуляризаторов в субградиентную оценку\n\nВспомним вывод linearized FTRL. В ходе линеаризации мы заменяли все функции $\\hat{f}_t(w)$ на их субградиентную оценку в точке $w_t$. Для регуляризованного функционала $\\hat{f}_t(w) = f_t(w) + \\psi_t(w)$ получалась бы такая оценка:\n\n$$\\hat{f}_t(w) \\geq \\hat{f}_t(w_t) + (g_t + \\partial\\psi_t)^T (w - w_t),$$\n\nгде через $\\partial\\psi_t$ мы обозначили для краткости субградиент $\\psi_t$ в точке $w_t$. Теперь субградиентную оценку можно подставить в метод FTRL:\n\n$$w_{t+1} = arg\\min\\limits_w \\Big[(g_{1:t} + \\partial\\psi_{1:t})^Tw + \\sum\\limits_{s=1}^t\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2\\Big]$$\n\nИдея неразложения состоит в следующем: заменим на субградиентную оценку только $f_t(w)$, а регуляризатор будем подбирать так, чтобы задача FTRL решалась аналитически. Интуитивно, оценка\n\n$$\\hat{f}_t(w) = f_t(w) + \\psi_t(w) \\geq f_t(w_t) + g_t^T(w - w_t) + \\psi_t(w)$$\n\nдолжна быть точнее оценки\n\n$$\\hat{f}_t(w) = f_t(w) + \\psi_t(w) \\geq f_t(w_t) + \\psi_t(w_t) + (g_t + \\partial\\psi_t)^T (w - w_t)$$\n\nа значит, и метод оптимизации будет точнее и эффективнее.\n\nЭта идея очень важна для построения регуляризованных алгоритмов онлайн-обучения.\n\nДавайте выпишем, как будут выглядеть с учётом этой идеи регуляризованные алгоритмы. \n\n**Composite Objective FTRL**\n\n$$w_{t+1} = arg\\min\\limits_w \\Big[g_{1:t}^Tw + \\psi_{1:t}(w) + \\sum\\limits_{s=1}^t\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2\\Big]$$\n\n**Online Mirror Descent, Proximal Gradient Descent, (F)ISTA**\n\n$$w_{t+1} = arg\\min\\limits_w \\Big[g_t^Tw + \\psi_t(w) + \\vert\\vert w - w_t\\vert\\vert_{\\sigma_t}^2 \\Big]$$\n\nНапомним, что три названия в заголовке соответствуют трём способам восприятия этой формулы:\n\n* Online Mirror Descent — метод онлайн-обучения;\n* Proximal Gradient Descent — метод (стохастической) батч-оптимизации. В стохастическом случае он неотличим от Mirror Descent;\n* (F)ISTA — по сути, это название аналитического решения указанного уравнения для $L_1$-регуляризации.\n\n### Связь между Composite-Objective FTRL и Proximal Gradient Descent. Lazy vs Greedy представления\n\nВ этом подразделе мы будем проводить рассуждения на примере $L_1$-регуляритора.  для других регуляризаторов выкладки будут аналогичными.\n\nВыпишем Proximal (он же Mirror) Gradient Descent с $L_1$-регуляризацией:\n\n$$w_{t+1} = arg\\min\\limits_w g_t^Tw + \\lambda_1\\vert\\vert w\\vert\\vert_1 + \\frac{1}{2\\eta_t}\\vert\\vert w - w_t\\vert\\vert_2^2$$\n\nНеобходимым условием минимума явняется равенство нулю градиента (а в данном случае субградиента) всего выражения:\n\n$$0 = g_t + \\hat{g}_t + \\frac{1}{\\eta_t}(w_{t+1} - w_t)$$\n\nгде $\\hat{g}_t$ - субградиент регуляризатора $\\lambda_1\\vert\\vert w\\vert\\vert_1$ в точке $w_{t}$. Отсюда получаем\n\n$$w_{t+1} = w_{t} - \\eta_t (g_t + \\hat{g}^T)$$\n\nЕсли же переписать формулы в духе FTRL, мы получим\n\n$$w_{t+1} = arg\\min\\limits_{w} g_{1:t}^Tw + \\hat{g}_{1:{t-1}}^Tw + \\lambda \\vert\\vert w\\vert\\vert_1 + \\frac{1}{2}\\sum\\limits_{s=0}^t\\vert\\vert w-w_s\\vert\\vert_{\\sigma_s}^2$$\n\nПолучился метод, который оптимизирует $L_1$-регуляризатор в явном виде только на текущей итерации $t$, а для остальных использует субоптимальные субградиентные оценки. Заметим, что тем же выражением можно ограничить сверху и функционал:\n\n$$w_{t+1} = arg\\min\\limits_{w} g_{1:t}^Tw + t\\lambda \\vert\\vert w\\vert\\vert_1 + \\frac{1}{2}\\sum\\limits_{s=0}^t\\vert\\vert w-w_s\\vert\\vert_{\\sigma_s}^2$$\n\nМы получили метод FTRL с incremental $L_1$ — более сильным и стабильным вариантом регуляризации, чем Mirror Descent. Подробнее его анализом мы займемся в параграфе про продвинутую $L_1$-регуляризацию.\n\n## $L_1$-регуляризация\n\n### Отбор параметров разреженных моделей\n\nПредположим, что мы хотим обучить модель минимального размера и при этом как можно лучшего качества. В этом нам поможет отбор параметров. А именно, давайте постараемся оставить только те из них, которые оказывают наиболее влияние на лосс $f_{1:T}(w)$.\n\n**Определение**. Будем называть параметр $w_i$ **разреженным**, если он не используется (пропускается) при предсказании некоторых $f_t(w)$. «Некоторых» может означать как десятую часть, так и $0.99999$ прогнозов $f_t(w)$, главное — что такие объекты просто есть. Частым мы будем называть параметр, у которого частота пропусков низкая (например, $10\\%$ пропусков), а редким — тот, у которого она высокая (второй случай).\n\n**Пример**. Рассмотрим модель разреженной линейной регрессии $f_t(w) = (w^Tx_t - y_t)^2$. Обычно она применяется в ситуациях, когда элементы вектора признаков $x_{t,i}$ — это $0$ или $1$ (например, «встретилось ли $i$-е слово в $t$-м документе»), причем на практике доля единиц обычно бывает очень маленькой. Поэтому существенная часть параметров $w_i$ при прогнозе на шаге $t$ будет умножаться на нули и, таким образом, не будет использоваться.\n\n**Обратите внимание**: как правило, в литературе по онлайн-обучению говорят о разреженных *параметрах*, а не признаках. Впрочем, подавляющее большинство моделей на разреженных признаках устроены так, что каждому такому признаку сопоставляется некий набор параметров, поэтому определения «разреженный признак» и «разреженные параметры» взаимозаменяемы. В линейной модели, как в примере выше, каждому признаку $x_i$ сопоставляется параметр $w_i$. В более сложных моделях признаку $x_i$ может сопоставляться вектор параметров $w_i$ — эмбеддинг этого признака.\n\nДавайте теперь поймём, что означает фраза «признак влияет на лосс $f_{1:T}(w)$». Оказывать влияние можно двумя способами:\n\n1. Качеством. Если параметр $w_i$ редкий, но очень хорошо прогнозирует свой небольшой набор объектов, его стоит оставить. За счет того, что мы оставим достаточное количество таких параметров, мы можем покрыть большое число объектов. Такие параметры называются **memorization parameters** (они как будто запоминают «свои» объекты).\n2. Количеством. Если параметр $w_i$ часто встречается, то он в любом случае должен остаться в модели и помогать с суммарным качеством прогноза.\n\nУбирать мы хотим только слабые и редкие параметры. Таких, как правило, больше $99\\%$.\n\n**Обратите внимание**: мы не хотим убирать *слабые, но часто встречающиеся параметры*. Тому есть две причины:\n\n1. Места они много не занимают, а количества данных в large scale задачах достаточно, чтобы правильно выучить эти параметры. Они будут вносить свой, пусть и небольшой, вклад в общее качество;\n2. Частые параметры хорошо запоминают среднее поведение на всех данных, а разреженные — поведение на конкретных объектах. Если наша цель — оставить как можно меньше параметров, то выгоднее хорошо выучить среднее поведение на всех данных, а отклонения от среднего запомнить с помощью memorization parameters. Если в модели есть только супер-разреженные параметры, то из-за огромной вариативности в их возможных комбинациях в данных каждому параметру придется доучивать среднее поведение. Подробнее на этой проблеме мы остановимся в конце параграфа.\n\n### Инициализация разреженных параметров\n\nВ обучении разреженных моделей все параметры, на которые накладывается $L_1$-регуляризация, инициализируются нулями. С точки зрения здравого смысла такая инициализация довольно естественна, однако есть и более формальное обоснование;\n\n1. Если параметры инициализируются нулями, то мы по мере обучения смотрим на градиенты этих параметров и в зависимости от градиентов принимаем решение, нужен нам параметр для прогноза или не нужен. Все параметры стартуют в равных условиях, и модель понемногу выходит из состояния «абсолютная разреженность», выучивая что-то содержательное.\n2. Если же параметры инициализируются случайно, то нам надо сначала доучить все параметры до какого-то более или менее разумного значения, а потом уже пытаться понять, нужен ли он нам. Момент, когда модель начинает эффективно разреживаться, тем самым очень сильно отдалается.\n\n### Composite-objective FTRL с $L_1$-регуляризацией\n\nНапомним формулировку задачи:\n\n$$w_{t+1} = arg\\min\\limits_w g_{1:t}^Tw + \\lambda_{1,t}\\vert\\vert w\\vert\\vert_1 + \\frac{1}{2}\\sum\\limits_{s=1}^T\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2$$\n\nРешение можно выписать в явном виде. Для этого введём следующие обозначения:\n\n* $z_t$ будет аккумулировать сумму градиентов, $z_0 = 0$,\n* $n_t$ будет аккумулировать сумму поэлементных квадратов градиентов, $n_0 = 0$,\n* $\\alpha$ — это learning rate.\n\nСледующие формулы выписаны отдельно для каждой координаты. В них $i$ — индекс параметра модели, $t$ — номер итерации.\n\n$$\\sigma_{t,i} = \\frac{1}{\\eta_{t,i}} - \\frac{1}{\\eta_{t-1,i}} = \\frac{1}{\\alpha}\\Big(\\sqrt{n_{t,i} + g_{t,i}^2} - \\sqrt{n_{t,i}}\\Big)$$\n\n$$z_{t+1,i} = z_{t,i}  + g_{t,i} - \\sigma_{t,i}w_{t,i}$$\n\n$$n_{t+1,i} = n_{t,i} + g_{t,i}^2$$\n\n$$w_{t+1,i} = \\begin{cases}\n      0 & \\vert z_{t+1,i}\\vert  \\leq \\lambda_{1,t}\\\\\n      -\\frac{\\alpha}{\\sqrt{n_{t+1,i}} + \\alpha\\lambda_{2,t}} \\Big(z_{t+1,i} - sgn(z_{t+1,i})\\lambda_{1,t} \\Big) & \\vert z_{t+1,i}\\vert  > \\lambda_{1,t}\n   \\end{cases}\\qquad(\\ast)$$\n\nВывод этих формул хорошо расписан в [конспекте курса Д. А. Кропотова](http://www.machinelearning.ru/wiki/images/5/5b/MOMO12_sparse_methods.pdf).\n\n#### Анализ аналитического решения\n\nПри регуляризаторе $\\vert\\vert w\\vert\\vert_1$ в оптимизируемом функционале стоят коэффициенты $\\lambda_{1,t}$, которые могут как-то зависеть от $t$. Обычно рассматривают три вида зависимости:\n\n1. Fixed: $\\lambda_{1,t} = \\lambda$.\n2. Squared incremental: $\\lambda_{1,t} = \\sqrt{t}\\lambda$\n3. Linear incremental: $\\lambda_{1,t} = t\\lambda$\n\nИх также можно комбинировать, получая коэффициенты регуляризации\n\n$$\\lambda_{1,t} = \\lambda_{1,global} + \\sqrt{t}\\lambda_{1,sqrt} + t\\lambda_{1,incremental}$$\n\nНапомним, что все веса $w_{i}$ мы инициализируем нулями. По формулам $(\\ast)$ из нуля на шаге $t$ выводятся веса $w_i$, для которых\n\n$$\\vert g_{1:t,i} - \\sum\\limits\\sigma_sw_{s,i}\\vert  > \\lambda_{1,t}.$$\n\nТаким образом, **начальное условие выхода параметров из нуля** имеет вид\n\n$$\\vert g_{1:t,i}\\vert  > \\lambda_{1,t}.$$\n\nПопробуем понять физический смысл этого неравенства.\n\n**Напоминание**. Говорят, что функция $f(w)$ имеет **липшиц-непрерывный** градиент с константой $L$, если\n\n$$\\vert\\vert \\nabla f(x) - \\nabla f(y)\\vert\\vert_2^2 \\leq \\frac{L}{2} \\vert\\vert x - y\\vert\\vert_2^2$$\n\nПредположим, что это выполняется (ниже мы покажем, что это не слишком обременительное ограничение). Тогда, подставив в качестве $y$ точку оптимума функции $f_t(w)$ (не путайте с глобальным $w_T^*$ из regret!), мы получим\n\n$$\\vert\\vert \\nabla f(x)\\vert\\vert_2^2 \\leq \\frac{L}{2}\\vert\\vert x - x_*\\vert\\vert_2^2$$\n\nЭто означает, что для достаточно хорошей функции **норма градиента является оценкой снизу на расстояние до точки оптимума в пространстве параметров**. Чем больше норма градиента, тем дальше мы от оптимальных параметров $w$.\n\nВернемся к выражению $\\vert g_{1:t,i}\\vert  > \\lambda_{1,t}$. Здесь мы имеем дело (а) отдельно с каждой из координат и (б) с нормой суммы градиентов (а не с суммой норм). Хорошая новость: утверждение выше верно и для функций одной переменной, то есть $\\vert g_{s,i}\\vert$, грубо говоря, показывает, насколько мы далеки от оптимума по $i$-й координате. Знак $g_{s,i}$ говорит о том, в какую сторону мы будем сдвигаться по $i$-й координате $w$ на $s$-м шаге. Если сдвиги были в основном в одну сторону, то $g_{1:t,i}$ будет больше, а если они всё время в разную сторону, то отдельные слагаемые могут скомпенсировать друг друга, и $g_{1:t,i}$ может быть малым.\n\nОтметим ещё, что абсолютная величина компоненты $g_{1:t,i}$ на первых итерациях может отражать прогнозирующую силу параметра $w_i$: в самом деле, неверное значение важного для предсказания параметра может вести к большим ошибкам, что будет давать большие градиенты.\n\nПосмотрим теперь, как будет вести себя разреженная модель в зависимости от вида $\\lambda_{1,t}$.\n\n### Linear incremental ($\\lambda_{1,t} = t\\lambda_1$)\n\nУсловие выхода $w_i$ из нуля принимает вид\n\n$$\\vert g_{1:t,i}\\vert  > t\\lambda_1,$$\n\nчто равносильно\n\n$$\\left| \\frac{1}{t}g_{1:t,i}\\right|  > \\lambda_1$$\n\nОграничение на среднее значение компоненты градиента означает, что для выхода из нуля параметр $w_i$ должен иметь определённую прогнозирующую силу. Это противоречит нашему требованию о том, чтобы частые маломощные параметры все равно присутствовали в модели и выучивали среднее поведение.\n\n**Обратите внимание**. Выше мы показали, что проксимальный градиентный спуск с обычным $L_1$\n\n$$w_{t+1} = arg\\min\\limits_w g_t^Tw + \\lambda_1 \\vert\\vert w\\vert\\vert_1 + \\frac{1}{\\eta_t}\\vert\\vert w - w_t\\vert\\vert_2^2$$\n\nв некотором смысле эквивалентен Composite-Objective FTRL с инкрементальным $L_1$. Таким образом, обычная $L_1$-регуляризация в классическом градиентном спуске эквивалентна именно инкрементальному $L_1$, который, как мы выяснили, субоптимален. Ниже мы рассмотрим специфический для FTRL вариант $L_1$-регуляризации, который лишен этих недостатков.\n\n### Фиксированный ($\\lambda_{1,t} = t\\lambda_1$)\n\nЭто самый мощный и полезный на практике режим.\n\nЗдесь мы не нормируем на $\\frac{1}{t}$ (то есть не берём среднее), и это означает, что выйти из нуля может и слабый, но частый параметр, который за много итераций накопит достаточно большую сумму частных производных.\n\nСвойства фильтрации с фиксированным регуляризатором в точности совпадают с продуктовыми требованиями:\n\n1. Редкий параметр с мощной прогнозирующей силой на старте будет иметь большие по модулю градиенты одного знака, и он выйдет из нуля;\n2. Редкий параметр с малой прогнозной силой не выйдет из нуля;\n3. Частые параметры в любом случае выйдут из нуля.\n\n### Squared incremental: ($\\lambda_{1,t} = \\sqrt{t}\\lambda$)\n\nВ [этой статье](http://www.opt-ml.org/papers/OPT2016_paper_24.pdf) было теоретически обосновано, что если параметр частый, но нерелевантный и абсолютно шумный, то дисперсия $\\vert g_{1:t}\\vert$ будет иметь асимптотику $O(\\sqrt{t})$. Из этого следует, что, если сделать регуляризацию порядка $\\sqrt{t}$, мы лишим такой случайный шум почти любых шансов выйти из нуля.\n\nК сожалению, ни в игрушечных примерах вроде Avazu, ни в продакшен задачах улучшений качества прогноза или степени разреживания модели без потери качества достичь не удалось. Возможно, вам повезет больше.\n\n### Полезность частых параметров для разреживания модели\n\nРассмотрим две линейных модели\n\n$$f_t(w) = w^Tx_t + b,\\quad g_t(w) = w^Tx_t,$$\n\nв которых все параметры $w_i$ разреженные. Давайте считать, что в первой модели есть константный (и совсем даже не разреженный) признак $x_b = 1$, которому и соответствует параметр $b$.\n\nТеперь в каждой из моделей наложим на $w$ регуляризацию $L_1$ и сравним, что получится:\n\n1. В модели $f_t$ параметрам $w_i$ нужно запомнить «отклонение» от среднего $b$;\n2. В модели $g_t$ параметрам $w_i$ нужно запомнить абсолютное значение предсказания.\n\nНетрудно понятно, что при наличии bias нормы градиентов в первой модели в среднем будут намного меньше, потому что мы на каждом шаге оптимизации будем стартовать с точки, которая в среднем ближе к точке оптимума (bias и есть наше среднее). Поэтому меньше весов смогут преодолеть порог по модулю суммы градиентов и выйти из нуля. Таким образом, несмотря на одинаковый оптимум без регуляризации, при введении $L_1$-регуляризации модель с bias будет обладать более хорошим соотношением разреженность/качество прогноза.\n\nЭта логика легко обобщается на более сложные случаи, когда вместо bias у нас есть неразреженные контентные признаки. Вывод такой: модели, в которых есть только очень разреженные параметры, обладают гораздо худшим соотношением разреженность/качество, чем модели, в которых есть и контентные, и разреженные параметры.\n\nУбедиться в этих эффектах мы сможем в разделе с практикой на линейных моделях.\n\n## $L_2$ регуляризация\n\n\n### Weight decay\n\nРассмотрим обыкновенный SGD.\n\n$$w_{t+1} = w_t - \\alpha g_t$$\n\n**Weight decay** состоит во введение штрафа на размер текущих весов:\n\n$$w_{t+1} = (1 - \\lambda)w_t - \\alpha g_t,\\quad 0 \\leq \\lambda < 1$$\n\nВнимательные читатели уже заметили, что в случае с SGD это эквивалентно введению $L_2$-регуляризации. Давайте разберёмся, как это сделать правильно.\n\n### Decoupled weight decay\n\nПопробуем заменить $f_t(w)$ на\n\n$$\\hat{f}_t(w) = f_t(w) + \\lambda_2 \\vert\\vert w\\vert\\vert_2^2$$\n\nи запустить любой адаптивный метод, например, AdaGrad. Если мы беспечно заменим на градиентную оценку всю функцию $\\hat{f}_t(w)$ (забыв, что с регуляризатором этого делать не стоит), то алгоритм примет вид\n\n$$w_{t+1} = w_t - \\hat{\\eta}_tg_t,$$\n\nгде\n\n$$\\hat{\\eta}_t = \\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^t (g_s + \\lambda_2 w_s)^2 }}$$\n\nВ этих формулах нехороши две вещи:\n\n1. Коэффициенты $\\alpha$ и $\\lambda_2$ нетривиальным образом взаимодействуют. Это крайне неудобно при переборе гиперпараметров: изменение learning rate $\\alpha$ должно влечь за собой переподбор коэффициента регуляризации $\\lambda_2$ по полной сетке;\n2. В квадратах градиентов мы хотим видеть только адаптивность к кривизне самой функции $f_t$, но теперь там ещё добавка $\\lambda_2w_s$.\n\nЭта проблема была впервые замечена в [Decoupled weight decay regularization](https://arxiv.org/pdf/1711.05101.pdf). Авторы также рассматривали влияние на momentum, к этому мы вернёмся в параграфе про AdamW.\n\nАвторы статьи предлагают модифицировать метод AdaGrad следующим образом:\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^t g_s^2}} g_t - \\lambda_2 w_t$$\n\nСразу отметим сходство с исходными формулами weight decay — его и добивались авторы.\n\n### Decoupled weight decay — это адаптивный $L_2$\n\nЛегко видеть, что формула\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^t g_s^2}} g_t - \\lambda_2 w_t$$\n\nописывает обыкновенный покоординатный градиентный спуск с некоторым линеаризованным $L_2$-регуляризатором. Давайте «проинтегрируем» это выражение обратно до аргминимума, из которого бы получились такие формулы обновления весов:\n\n$$w_{t+1} = arg\\min\\limits_w \\Big[ g_t^Tw + \\frac{\\lambda_2}{\\eta_t}\\color{#E06A27}{w_t^T}w + \\frac{1}{2\\eta_t}\\vert\\vert w - w_t\\vert\\vert_2^2 \\Big]$$\n\nПолучается, что decoupled weight decay — это адаптивный $L_2$-centered регуляризатор. Его можно усовершенствовать, вспомним наше важное правило не заменять регуляризатор на субградиентную оценку. Перейдём к задаче\n\n$$w_{t+1} = arg\\min\\limits_w \\Big[ g_t^Tw + \\frac{\\lambda_2}{2\\eta_t}\\vert\\vert w\\vert\\vert_2^2 + \\frac{1}{2\\eta_t}\\vert\\vert w - w_t\\vert\\vert_2^2 \\Big]$$\n\nОна отличается от предыдущей заменой $\\color{#E06A27}{w_t^T}w$ на $\\color{#348FEA}{w^T}w = \\vert\\vert w\\vert\\vert^2$. Её решение имеет вид\n\n$$w_{t+1} = \\color{#C81D6B}{\\frac{1}{1 + \\lambda_2}}\\Big(w_t - \\eta_t g_t \\Big)$$\n\nПоскольку мы меньше огрубляем оптимизируемый функционал, обучение может стать немного стабильнее.\n\nОбратите внимание, что в оптимизационной задаче у нас теперь стоит не просто $\\lambda_2$, а $\\frac{\\lambda_2}{2\\eta_t}$.\n\n### Decoupled $L_2$-регуляризация в Composite-Objective FTRL\n\nТеперь посмотрим, как decoupled weight decay будте работать с Composite-Objective FTRL. Линеаризованная задача имеет вид:\n\n$$w_{t+1} = arg\\min\\limits_w \\left[g_{1:t}^Tw + \\frac{\\lambda_2}{2}\\vert\\vert w\\vert\\vert_{\\sigma_{1:s}}^2 + \\frac{1}{2}\\sum\\limits_{s=1}^t\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2\\right]$$\n\nПерепишем её:\n\n$$w_{t+1} = arg\\min\\limits_w \\left[g_{1:t}^Tw + \\frac{1}{2}\\sum\\limits_{s=1}^t\\Big(\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2 + \\lambda_2\\vert\\vert w\\vert\\vert_{\\sigma_s}^2 \\Big)\\right]$$\n\nНетрудно показать, что решение имеет вид\n\n$$z_{t+1} = z_t + g_t - \\sigma_t\\odot w_t,$$\n\n$$w_{t+1} = -\\color{#C81D6B}{\\frac{1}{1 + \\lambda_2}} \\frac{1}{\\eta_t}z_t.$$\n\nДля $z_t$ можно написать и явную формулу: $z_{t} = g_{1:t} - \\sum_{s=1}^t\\sigma_s\\odot w_s$.\n\n**Замечание**. Чтобы оценить Regret такого метода, мы не сможем механически воспользоваться оценкой для AdaGrad: ведь она базированась на оценке на Regret, выведенной либо для целиком Proximal, либо для целиком Centered $L_2$-регуляризаторов. Composite objective из теоремы 10 тут не годится, так как Centered регуляризатор в этом случае не поедет в оценку норм градиентов, а мы в текущем представлении рассматриваем Proximal и Centered как равноправные члены. Интуитивно, мы должны применить Lemma 7 к обоим регуляризаторам и получить точно такую же оценку с такой же двойственной нормой (напомним, что centered и proximal регуляризаторы имеют одинаковую двойственную норму). Двойственная норма такая же -> формулы оптимального метода AdaGrad будут такие же. Мы оставляем это читателям в качестве упражнения.\n\n## $I_{\\chi}(w)$: проекция на выпуклое множество $\\chi$\n\n**Напоминание**: множество $\\chi$ называется **выпуклым**, если\n\n$$\\forall x,y\\in \\chi,\\ \\forall\\alpha \\in [0; 1]: \\quad \\alpha x + (1-\\alpha)y \\in \\chi$$\n\nПроекцией на это множество называют функцию\n\n$$I_{\\chi}(w) = \\begin{cases}\n      \\infty & w \\not\\in \\chi \\\\\n      0 & w \\in \\chi\n   \\end{cases}$$\n\nДокажем, что $I_{\\chi}(w)$ — выпуклый регуляризатор. Для этого нам нужно проверить неравенство\n\n$$\\alpha I(x) + (1-\\alpha)I(y) \\geq I(\\alpha x + (1 - \\alpha) y).$$\n\nЕдинственный шанс, когда это может быть нарушено — это $I(\\alpha x + (1 - \\alpha) y) = \\infty$, $I(x) = 0$, $I(y) = 0$. Это значит, что $x,y\\in \\chi$, а $\\alpha x + (1 - \\alpha) y \\notin \\chi$, что противоречит выпуклости $\\chi$.\n\nВернемся к формулам FTRL. Здесь ситуация сильно проще — от накидывания любых последовательностей $\\alpha_{1:T}$ на регуляризатор ничего не изменится, так что его всегда оставляют просто as is\n\n$$w_{t+1} = arg\\min\\limits_w g_{1:t}^Tw + I_{\\chi}(w) + \\frac{1}{2}\\sum\\limits_{s=1}^T\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2$$\n\nАналитические решения для каждого вида $\\chi$ нужно искать отдельно. Примерно все решения получаются путем выноса $I_{\\chi}(w)$ из оптимизируемого функционала и превращения его в ограничение, после чего можно применить метод множителей Лагранжа.\n\n### Проекция на шар ${x: \\vert\\vert x\\vert\\vert  \\leq c}$\n\nРешим аналитически задачу проекции на шар\n\n$$ \\begin{cases}\ng_{1:t}^Tw + \\frac{1}{2}\\sum\\limits_{s=1}^T\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2\\longrightarrow\\min_w,\\\\\n\\vert\\vert w\\vert\\vert_2 \\leq c.\n\\end{cases}$$\n\nФункция Лагранжа будет иметь вид\n\n$$L(w, \\lambda) = g_{1:t}^Tw + \\frac{1}{2}\\sum\\limits_{s=1}^T\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2 + \\lambda(\\vert\\vert w\\vert\\vert_2 - c),$$\n\nа её градиент равен\n\n$$\\nabla_wL(w, \\lambda) = g_{1:t}^T + \\sum\\limits_{s=1}^T(w - w_s)\\odot\\sigma_s + \\lambda \\frac{w}{\\vert\\vert w\\vert\\vert_2},$$\n\nгде $\\sigma_s$ - вектор, а $\\odot$ — поэлементное умножение векторов. Приравнивая к нулю градиент, получаем\n\n$$z_t + \\sigma_{1:s}\\odot w + \\lambda \\frac{w}{\\vert\\vert w\\vert\\vert_2} = 0,$$\n\nгде мы, как обычно, обозначили $z_{t} = g_{1:t} - \\sum_{s=1}^t\\sigma_s\\odot w_s$.\n\nПроанализируем условие дополняющей нежесткости $\\lambda(\\vert\\vert w\\vert\\vert -c) = 0$. Если $\\lambda = 0$, то решение $w$ уже находится внутри шара и имеет вид\n\n$$w = \\frac{-z_t}{\\sigma_{1:s}}$$\n\nПри практической реализации мы просто сначала посчитаем это выражение и проверим, не попадаем ли мы в шар. Если попадаем — отлично, если нет — то дальше говорим, что $\\vert\\vert w\\vert\\vert  = c$ и решаем продолжаем решение\n\n$$z_t + \\sigma_{1:s}*w + \\lambda \\frac{w}{с} = 0$$\n\n$$w = \\frac{-z_t}{\\sigma_{1:s} + \\frac{\\lambda}{c}}$$\n\nТеперь подставим это в $\\vert\\vert w\\vert\\vert  = c$ и получим\n\n$$\\vert\\vert w\\vert\\vert  = \\frac{\\vert\\vert z_t\\vert\\vert }{\\sigma_{1:s} + \\frac{\\lambda}{c}} = c$$\n\n$$\\lambda = \\vert\\vert z_t\\vert\\vert  - \\sigma_{1:s}c$$\n\n$$w = c\\frac{-z_t}{\\vert\\vert z_t\\vert\\vert }$$\n\nПолучаем, что если мы находимся внутри шара, то мы действуем согласно обыкновенному adaptive алгоритму со всеми хорошими свойствами, иначе — проекция побеждает.\n\nАналогично $L_1$ регуляризации, здесь тоже есть различия между lazy и greedy представлением этого регуляризатора. Однако, в классических DL задачах эти методы встречаются не слишком часто и здесь сложно привести какой-нибудь значимый успех, который мог бы улучшить качество в важной задача. Навскидку мы можем вспомнить разве что Adversatial White-Box learning, в котором можно было бы это попробовать.",
        "handbook": "Учебник по машинному обучению",
        "title": "Регуляризация в онлайн-обучении",
        "description": null
    },
    {
        "path": "/handbook/ml/article/metody-optimizacii-v-deep-learning",
        "content": "## Напоминания\n\n**Определение** Критической точкой гладкой функции $f_t(w)$ называется точка $w^*$, для которой\n\n$$\\nabla f_t(w^*) = 0\n$$\n\nВ выпуклой оптимизации такая точка обязательно будет точкой глобального минимума. В невыпуклой оптимизации все сильно сложнее:\n\n1. Бывает много локальных минимумов\n2. Бывают седловые точки\n\nЛокальный минимум — это критическая точка $w^*$, в которой Гессиан $H(w^*) = \\nabla^2 f_t(w^*)$ положительно определён. Отметим, что часто в методах глобальной оптимизации рассматривается так называемая «локальная выпуклость», для которой требуется, чтобы функция $f_t(w)$ была выпуклой внутри некоторого шара радиуса $\\epsilon$ с центром в точке $w^*$. Критические точки, в которых гессиан не является знакоопределённым, называются седловыми.\n\n**Пример**: функция $f(x_1, x_2) = x_1^2 - x_2^2$ имеет седловую точку $\\{0, 0\\}$. Гессиан в точке 0\n\n$$H(0, 0) = \\begin{pmatrix}\n2 & 0\\\\\n0 & -2\n\\end{pmatrix}\n$$\n\n**Обратите внимание**: во многих современных статьях про сходимость методов оптимизации первого порядка на невыпуклых функциях ([пример](https://arxiv.org/pdf/2003.02395.pdf)) в качестве критерия сходимости рассматривают сходимость по норме градиента: $\\vert\\vert \\nabla f(w)\\vert\\vert_2^2 < \\epsilon$ при некотором заранее фиксированном $\\epsilon$.\n\nВ выпуклой оптимизации этот критерий сходимости эквивалентен двум другим:\n\n- сходимости по расстоянию до оптимума в пространстве параметров: $\\vert\\vert w - w^*\\vert\\vert_2^2 < \\epsilon$;\n- сходимости по расстоянию до оптимума по значениям функции $f(w) - f(w^*) < \\epsilon$.\n\nВ невыпуклой оптимизации всё не так просто и поиск глобального минимума является в общем случае NP-трудной задачей. Критерий $\\vert\\vert \\nabla f(w)\\vert\\vert_2^2 < \\epsilon$ даёт возможность исследовать сходимость к любой критической точке, но если речь об обучении нейронных сетях, то остается лишь надеяться, что эта критическая точка будет хорошим локальным минимумом.\n\n## Скользящее среднее в знаменателе AdaGrad. Методы RMSprop и Adam\n\n### Мотивация\n\nВ далекие 2012-2014е в мире было не так много опыта по построению хороших нейросетевых архитектур. «Канонические» методы оптимизации нейросетей RMSprop и Adam появлялись во времена, когда ещё не придумали основополагающих вещей вроде:\n\n- [Residual connection](https://arxiv.org/pdf/1512.03385.pdf) и [Dense connection](https://arxiv.org/pdf/1608.06993.pdf) (статьи опубликованы в 2015/2016 соответственно, во всех экспериментах используется SGD, в статье и в ссылках не упоминаются методы Adam/RMSprop), плохо решались проблемы взрывов/затуханий градиентов и т.д.\n- [Batch Normalization](https://arxiv.org/abs/1502.03167) и [Layer Normalization](https://arxiv.org/abs/1607.06450) (2015/2016 соответственно)\n\nТакже люди не умели правильно инициализировать нейросети гигантской глубины. статьи вроде [1000\\+ layer fully connected](https://arxiv.org/abs/1711.04735) и [10000\\+ layer CNN](https://arxiv.org/pdf/1806.05393.pdf) позже. Кстати, этот цикл статей хочется особо отметить за интересную технику анализа распространения сигнала по нейронной сети.\n\nВ общем, в те времена царило архитектурное средневековье со всеми родовыми проблемами нейронных сетей:\n\n1. Взрывы градиентов;\n2. Затухания градиентов;\n3. Взрывы-затухания сигнала на прямом проходе;\n4. Плохие начальные инициализации, нестабильный старт обучения.\n\nПри попытках применять метод AdaGrad особо остро стояли проблемы 1 и 4. AdaGrad аккумулирует всю прошедшую историю $\\frac{1}{\\sqrt{g_{1:t}^2}}$ без затухания. Если в какой-то момент возникает одна из указанных проблем, знаменатель резко возрастает и больше не выправляется.\n\nЧтобы побороть проблемы 1-4, решили поработать над оптимизатором и сделать так, чтобы история в AdaGrad аккумулировалась с затуханием и метод оптимизации мог со временем забыть плохие точки. Самый популярный и простой в реализации метод — экспоненциальное скользящее среднее.\n\n### RMSProp\n\nСамая первая и самая простая модификация метода AdaGrad — метод RMSprop — вместо суммы использует экспоненциальное скользящее среднее в знаменателе:\n\n$$v_0 = 0\n$$\n\n$$v_t = \\beta v_{t-1} + (1 - \\beta) g_t^2\n$$\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{v_t}}g_t\n$$\n\nМетоду RMSprop не было посвящено ни одной специализированной статьи, равно как и не было никаких доказательств его сходимости даже для выпуклых задач.\n\n### Adam\n\nАвторы Adam в статье [Adam: A Method For Stochastic Optimization](https://arxiv.org/pdf/1412.6980.pdf) вводят два новшества по сравнению с RMSprop. Во-первых, это Momentum. Во вторых — Bias correction term. Напомним, как работает этот метод.\n\n$$v_0 = 0, m_0 = 0\n$$\n\n$$m_t = \\beta_1 m_{t-1} + (1 - \\beta_1)g_t\n$$\n\n$$v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\n$$\n\nПрименяем bias correction\n\n$$\\hat{m}_t = \\frac{1}{1 - \\beta_1^t}m_t\n$$\n\n$$\\hat{v}_t = \\frac{1}{1 - \\beta_2^t}v_2\n$$\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{\\hat{v}_t}}\\hat{m}_t\n$$\n\nСразу перепишем $v_t$ и $m_t$ в нерекурсивной форме с зависимостью только от $g$:\n\n$$\\hat{v}_t = \\frac{1}{1 - \\beta_2^t}(1-\\beta_2)\\sum\\limits_{s=1}^t \\beta_2^{t-s} g_s^2\n$$\n\n$$\\hat{m}_t = \\frac{1}{1 - \\beta_1^t}(1-\\beta_1)\\sum\\limits_{s=1}^t \\beta_1^{t-s} g_s\n$$\n\n#### Мотивация для bias correction\n\nАвторы статьи пишут, что для правильной работы метода $m_t$ и $v_t$ должны быть несмещенными оценками $\\mathbb{E}[g]$ и $\\mathbb{E}[g^2]$ соответственно. Допустим, все $g_t$ — независимые одинаково распредёленные случайные величины. Это довольно сильное предположение, но иначе не получатся красивые формулы. Рассмотрим на примере $v_t$:\n\n$$\\mathbb{E}[v_t] = \\mathbb{E}\\Big[(1-\\beta_2)\\sum\\limits_{s=1}^t \\beta_2^{t-s} g_s^2\\Big] = (1-\\beta_2)\\sum\\limits_{s=1}^t \\beta_2^{t-s}\\mathbb{E}[g_s^2] =\n$$\n\n$$= \\Big((1-\\beta_2)\\sum\\limits_{s=1}^t \\beta_2^{t-s}\\Big)\\mathbb{E}[g^2] = (1 - \\beta_2^t)\\mathbb{E}[g^2]\n$$\n\nОтсюда очевидно, что исходные $v_t$ и $m_t$ смещены на множитель $(1 - \\beta_2^t)$, поэтому авторы Adam делят на него $\\hat{m}_t$ и $\\hat{v}_t$. Так как $\\lim\\limits_{t\\rightarrow \\infty} (1 - \\beta_2^t) = 1$ при $0 \\leq \\beta_2 < 1$, эффект смещения сильнее всего заметен в начале итерационного процесса. Например, при классическом $\\beta_2 = 0.999$ мы получаем смещение в 0.001 раз.\n\nВ начале обучения bias correction призван уменьшить слишком большие шаги оптимизатора.\n\n#### Доказательство сходимости метода\n\nВ оригинальной статье приводится теорема с доказательством сублинейного Regret. Доказательство содержало ошибку, в новой работе 2018 года было доказано, что для любого набора гиперпараметров Adam существует *выпуклая* задача, на которой он не сходится. Проблемы со сходимостью, впрочем, не являются специфичными для выпуклых задач: в нейронных сетях Adam тоже может вести себя странно, и об этом мы поговорим ниже в разделе «Как сломать адаптивные методы».\n\nРазбирать доказательство исходной статьи мы не будем, зато обратим внимание на пару неприятных фактов о различиях между «продаваемой» частью статьи и бекендом с экспериментами и доказательствами теорем.\n\n#### Почему Adam стали считать лучшим методом стохастической оптимизации?\n\nПосле успешного введения метода Adam в эксплуатацию в нейросети его окрестили «method of choice» в задачах стохастической оптимизации. Это было на 100% обусловлено его успехом в обучении нейронных сетей с нестабильными архитектурами.\n\nСтруктура статьи выглядит следующим образом:\n\n1. Выделенный в большую красивую видную рамочку алгоритм с дефолтными настройками вроде $\\alpha = 0.001$;\n2. Формулировка теоремы в разделе про доказательства;\n3. Эксперименты на нейросетях и выпуклых задачах.\n\nВ пункте 1 описан алгоритм, который все нынче знают, как Adam. Мало кто знает, что в доказательствах сходимости и в экспериментах на выпуклых задачах использовался немного другой алгоритм: вместо константного $\\alpha$ авторы статьи взяли $\\alpha_t = \\frac{\\alpha}{\\sqrt{t}}$. Сравним эти learning rate с AdaGrad:\n\n#|\n||\n\nМетод\n\n|\n\nФормулы\n\n||\n||\n\nAdaGrad\n\n|\n\n$\\frac{1}{\\sqrt{\\sum\\limits_{s=1}^t g_s^2}}$\n\n||\n||\n\nAdam\n\n|\n\n$\\frac{1 - \\beta^t}{\\sqrt{t}\\sqrt{(1-\\beta)}\\sqrt{\\sum\\limits_{s=1}^t \\beta^{t-s} g_s^2}}$\n\n||\n|#\n\nАвторы в экспериментах на логистической регрессии **убили основное свойство Adam — неубывающие learning rate**. Вспомним, как в разделе про [вывод AdaGrad](https://academy.yandex.ru/handbook/ml/article/adaptivnyj-ftrl#ada-grad-nailuchshij-adaptivnyj-metod) мы анализировали порядок убывания learning rate — он был $\\eta_t = O(\\frac{1}{\\sqrt{t}})$. Отсюда следует, что у такого Adam learning rate убывают так же, как в AdaGrad. Словом, будьте внимательны при чтении статей: смотрите не только в описание алгоритмов, но и в их реализацию.\n\nНастоящий Adam, который в pytorch и tensorflow реализован без множителя $\\frac1{\\sqrt{t}}$, в выпуклой задаче разреженной логистической регрессии обычно работает намного хуже AdaGrad. Это справедливо как для чисто линейных моделей, так и для комбинированных [Wide & Deep](https://arxiv.org/abs/1606.07792) архитектур, из-за чего в одной и той же нейросети приходится использовать разные методы оптимизации для разных параметров.\n\n### Промежуточный итог по Adam/RMSProp\n\nТут нужно запомнить три идеи:\n\n1. Momentum\n2. Скользящее среднее в learning rate\n3. Bias correction\n\nНа практике, часто почему-то рассматривают методы RMSprop и Adam как нечто отлитое в граните и не пытаются брать от них лучшее. Например, методу RMSprop обычно идет на пользу добавление bias correction от adam. Так что полезно помнить идеи, стоящие за методами оптимизации, и уметь их комбинировать.\n\n## Как сломать адаптивные методы со скользящим средним\n\n### Как и когда ломаются адаптивные методы\n\nВсе диагональные адаптивные методы так или иначе используют покоординатный learning rate $\\eta_{t,i} = \\frac{\\alpha_t}{\\sqrt{v_{t,i}}}$. Методы отличаются лишь формулировкой $v_{t,i}$ и $\\alpha_t$:\n\n#|\n||\n\nМетод\n\n|\n\nРекуррентные формулы $v_{t,i}$\n\n|\n\nРазвернутые формулы $v_{t,i}$\n\n|\n\n$\\alpha_t$\n\n||\n||\n\nAdaGrad\n\n|\n\n$v_{t-1,i} + g^2_{t,i}$\n\n|\n\n$v_{t,i} = \\sum\\limits_{s=1}^tg^2_{s,i}$\n\n|\n\n$\\alpha$\n\n||\n||\n\nRMSprop\n\n|\n\n$\\beta v_{t-1,i} + (1 - \\beta) g^2_{t,i}$\n\n|\n\n$(1-\\beta)\\sum\\limits_{s=1}^t \\beta^{t-s} g_s^2$\n\n|\n\n$\\alpha$\n\n||\n||\n\nAdam\n\n|\n\n$\\beta v_{t-1,i} + (1 - \\beta) g^2_{t,i}$\n\n|\n\n$(1-\\beta)\\sum\\limits_{s=1}^t \\beta^{t-s} g_s^2$\n\n|\n\n$\\alpha\\sqrt{1 - \\beta^t}$\n\n||\n|#\n\nВсе эти методы имеют единый вид формул FTRL, аналогичный формулам FTRL-AdaGrad:\n\n$$w_{t+1} = arg\\min\\limits_w g_{1:t}^Tw + \\sum\\limits_{s=1}^t\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2\n$$\n\n$$\\eta_{s,i} = \\frac{\\alpha_s}{\\sqrt{v_{s,i}}}\n$$\n\n$$\\sigma_{s,i} = \\frac{\\sqrt{v_{s,i}}}{\\alpha_s} - \\frac{\\sqrt{v_{s-1,i}}}{\\alpha_{s-1}}\n$$\n\nВспомним теоретические ограничения на $r_t(w)$:\n\n- $r_t(w)$ — выпуклый;\n- $r_t(w) \\geq 0$.\n\nАдаптивные методы с регуляризаторами $r_t(w) = \\vert\\vert w\\vert\\vert_{\\sigma_t}^2$ будут удовлетворять этим условиям, если все $\\sigma_{s,i} \\geq 0$. В этом месте и локаются методы со скользящим средним: никто не обещал, что последовательность $v_t$ будет монотонно неубывать. Если же\n\n$$\\frac{\\sqrt{v_{s,i}}}{\\alpha_s} < \\frac{\\sqrt{v_{s-1,i}}}{\\alpha_{s-1}},\\qquad(\\ast)\n$$\n\nто метод может ломаться\n\n**Обратите внимание**. Momentum в методе Adam никак не повлияет на справедливость наших рассуждений, поскольку в формулах для адаптивных learning rate он не используется. Адаптивные методы с такими learning rate сломаются и с momentum, и без него.\n\n**Обратите внимание**. Bias correction в методе Adam уменьшает learning rate в начале обучения, заставляя метод делать меньшие шаги.\n\nВсе рекуррентные формулы из таблицы можно переписать в виде\n\n$$v_{t} = C_1v_{t-1} + C_2g_t^2\n$$\n\nТогда неравенство $(\\ast)$ можно записать в виде\n\n$$\\frac{\\sqrt{C_1v_{t-1} + C_2g_t^2}}{\\alpha_t} < \\frac{\\sqrt{v_{t-1}}}{\\alpha_{t-1}}\n$$\n\n$$g_t^2 < \\frac{\\alpha_t^2}{C_1}v_{t-1}\\left(\\frac{1}{\\alpha_{t-1}^2} - \\frac{C_1}{\\alpha_t^2}\\right)\n$$\n\nЗдесь мы можем подвести общую черту и сказать, что методы Adam и RMSprop дают $\\sigma_{s,i} < 0$, когда $g_t^2$ становится меньше предыдущей накопленной истории с точностью до некоторой константы.\n\nА когда такое бывает? Уменьшение $g_t^2$, как правило, означает приближение к критическим точкам. Добавление квадратичных регуляризаторов с отрицательным коэффициентом приводит к тому, что метод оптимизации **штрафует за близость к критическим точкам, заставляя убегать от них**. Это приводит к тому, что метод не может нормально сойтись к локальным минимумам (в выпуклых задачах — просто к минимумам, что намного более критично).\n\nОтметим, что по разным координатам $\\sigma_{s,i}$ могут вести себя по-разному. Таким образом, можно получить ситуацию, когда мы поощряем близость по одним координатам и штрафуем за близость по другим.\n\n### Вывод условий поломок для конкретных методов\n\n#### AdaGrad\n\nAdaGrad невозможно сломать таким способом: для него гарантируется, что $\\sigma_t \\geq \\sigma_{t-1}$.\n\n#### RMSprop\n\n$$v_{t,i} = \\beta v_{t-1,i} + (1-\\beta)g_{t,i}^2\n$$\n\nПодставим в условие $(\\ast)$, сразу сократив константный $\\alpha_t = \\alpha$:\n\n$$\\beta v_{t-1,i} + (1-\\beta)g_{t,i}^2 < v_{t-1,i}\n$$\n\n$$g_{t,i}^2 < v_{t-1,i}\n$$\n\n#### Adam\n\nЧисто технически, при выведении формул можно подумать, что Adam страдает от указанных эффектов гораздо сильнее RMSprop, но на самом деле это не так.\n\nПереобозначим $\\beta_2$ из статьи про Adam как просто $\\beta$ для общности обозначений.\n\nРаспишем неравенство $(\\ast)$ для метода Adam:\n\n$$\\frac{\\beta v_{t-1} + (1 - \\beta) g^2_t}{1 - \\beta^t} < \\frac{v_{t-1}}{1 - \\beta^{t-1}}\n$$\n\n$$\\frac{1 - \\beta}{1 - \\beta^t}g^2_t < v_{t-1}\\Big(\\frac{1}{1 - \\beta^{t-1}} - \\frac{\\beta}{1 - \\beta^t}\\Big)\n$$\n\n$$\\frac{1 - \\beta}{1 - \\beta^t}g^2_t < v_{t-1}\\frac{1 - \\beta^t - \\beta + \\beta^t}{(1 - \\beta^{t-1})(1 - \\beta^t)}\n$$\n\n$$g_t^2 < \\frac{1}{1 - \\beta^{t-1}} v_{t-1}\n$$\n\nВ отличие от RMSprop, у нас появился дополнительный множитель $\\frac{1}{1 - \\beta^{t-1}} > 1$. С одной стороны, можно подумать, что метод строго хуже. Однако, этот множитель сильно больше нуля только во время первых шагов оптимизации, тогда как рассматриваемая нами проблема играет роль только на поздних стадиях оптимизации при приближении к критическим точкам. А к тому моменту, этот множитель будет практически равен единице и мы получим формулы выше от RMSprop.\n\nПоэтому, на самом деле, методы в одинаковой степени страдают от этих эффектов, но bias correction добавляет стабильности в начале.\n\n### Интерпретации\n\n#### Избегание локальных минимумов или седловых точек\n\nЕсли представить, что нейросеть — очень плохая и жутко невыпуклая задача, то можно рассматривать подобное поведение как «защиту» от промежуточных плохих критических точек, позволяющую нам «убегать» от них.\n\nДанная интерпретация, к сожалению, имеет множество недостатков:\n\n1. Никто не обещал, что новая критическая точка будет лучше старой и что мы, прыгая таким образом, будем улучшать качество модели.\n2. Не каждый локальный минимум плохой. Если текущая критическая точка — хороший локальный минимум с хорошей обобщающей способностью, то мы просто нормально не сойдемся к нему и не достигнем хорошего качества модели.\n3. Общественность уже идентифицировала такое поведение как проблему и решила ее в более поздних популярных оптимизаторах (см.раздел про [AMSgrad](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#am-sgrad)).\n4. Большинство современных рекомендаций по обучению больших неонлайновых моделей вроде GPT или картиночных моделей содержат в себе learning rate scheduler'ы как обязательный для успеха ингредиент. Эти рекомендации нивелируют проблему отрицательных регуляризаторов.\n5. Все learning rate scheduler'ы заставляют learning rate убывать, что позволяет достигать лучших результатов, чем с помощью обычных Adam и RMSprop.\n6. В параграфе про FTL мы узнали, что градиентный метод без регуляризации отвратительно работает даже на выпуклых задачах, а если мы начнём вводить отрицательную регуляризацию, да еще и на сложных невыпуклых задачах, то все может стать еще хуже.\n\nВ целом, мировой опыт говорит, что полагаться на подобные интерпретации при тюнинге модели не стоит.\n\n#### Нестабильность в выпуклых задачах\n\nИтак, методы RMSprop и Adam плохо работают для выпуклых задач, особенно для разреженных задач, и могут приводить к субоптимальным решениям на train. Тем не менее, есть искушение заявить, что «это такая регуляризация в классическом смысле: не слишком хорошо сходимся к оптимальной точке, не слишком сильно переобучаемся под датасет и можем лучше работать на тесте». Это искушение особенно опасно потому, что подобные эффекты действительно могут иметь место, особенно в классической (не онлайновой) постановке задачи. Любая регуляризация направлена на то, чтобы сдвинуть оптимум решения исходной некорректно поставленной задачи в надежде, что точка оптимума измененной задачи будет обладать лучшей обобщающей способностью на тесте. В частности, такой эффект может иметь ранняя остановка методов оптимизации до их сходимости к точке оптимума.\n\nОднако здесь есть одно очень важное «но». Если введение регуляризации в некорректно поставленную задачу — это полностью осмысленный и контролируемый гиперпараметрами процесс, то хаотично разваливающийся вокруг точки оптимума метод оптимизации — нет. Подумайте: вдруг ваша задача фактически не является некорректно поставленной? Вдруг у вас огромный и очень репрезентативный датасет, благодаря чему оптимум на train всегда отлично работает в проде? В этом случае кривой метод оптимизации способен подпортить качество вашей модели.\n\n#### Нестабильность в разреженных задачах\n\nВ задачах с разреженными параметрами ситуацию $g_{t,i}^2 < v_{t-1,i}$ получить еще легче. Допустим, у нас есть некоторый параметр $w_i$, который встречается в 0.1% объектов выборки. В такой ситуации между появлениями этого объекта в выборке и очередным расчетом градиентов для него проходит значительное время. За это значительное время модель дообучалась, и за счет других, менее разреженных параметров могла научиться лучше прогнозировать очередной объект с этим параметром $w_i$. Тогда $\\vert\\vert g_{t,i}\\vert\\vert_2$ уменьшается и, следовательно, больше шансов попасть в плохую ситуацию.\n\nНиже мы рассмотрим метод AMSgrad и наперёд скажем, что для оптимизации разреженных параметров Adam/RMSprop добавление AMSgrad очень часто дает прибавку в качестве.\n\n#### Зависимость нестабильности в регуляризаторе от learning rate $\\alpha$\n\nНа первый взгляд, парадоксальным кажется следующий факт: чем меньше learning rate, тем в бОльшую сторону может отклониться отрицательный регуляризатор:\n\n$$\\sigma_t = \\frac{\\sqrt{v_t} - \\sqrt{v_{t-1}}}{\\alpha}\n$$\n\nОднако в «жадных» формулах все с точностью до наоборот:\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{v_t}}g_t\n$$\n\nИз жадных формул очевидно, что уменьшение $\\alpha$ ведет к уменьшению шага и, как следствие, увеличению стабильности алгоритма.\n\nЧтобы разрешить парадокс, надо вспомнить, что в FTRL решающее значение имеет не один отдельный регуляризатор, а *сумма* $\\sigma_{0:t}$. В начале процесса оптимизации $v_0 = 0$, первый регуляризатор точно не сломается. Чем меньше learning rate, тем меньшие шаги мы делаем от начальной точки и, следовательно, *тем меньше должна отличаться норма градиентов*.\n\nЕсли от шага к шагу норма градиента меняется не слишком сильно, то мы накопим огромную кумулятивную регуляризацию $\\sigma_{0:t}$ к моменту, когда регуляризатор решит отклониться в отрицательную сторону. При бОльшем learning rate мы шагаем быстрее, и точки, когда ломается регуляризатор, достигаем тоже быстрее, накопив гораздо меньшую сумму $\\sigma_{0:t}$. Если теперь для очередной точки мы получили отрицательный регуляризатор, то насколько сильно он может всё поломать?\n\nОкей, допустим, мы шагнули к критической точке. А насколько сильно может расколбасить *одна* плохая точка в регуляризаторе? Так, чтобы он перекрыл всю предыдущую сумму $\\sigma_{0:t}$? Если градиенты ограничены по норме, то катастрофы, очевидно, не будет. Ограниченность градиентов по норме мы, с одной стороны, гарантировать не можем, с другой — проблемам взрыва/затухания градиентов в архитектурах уделяется столько внимания, что на практике это условие зачастую выполняется.\n\n## Чиним RMSprop и Adam\n\n### Мотивация\n\nВремя шло, люди учились строить хорошо обучаемые архитектуры. Стали даже появляться революционные идеи вроде [ReZero](https://arxiv.org/pdf/2003.04887.pdf) (не путать с аниме) с полным отказом от batchnorm/layernorm нормализаций в глубоких сетях и с улучшением качества работы и скорости сходимости. Ситуация со стабильностью обучения нейросетей кардинально изменилась.\n\nНесмотря на улучшение стабильности обучения, люди стали замечать, что при длительном процессе оптимизации Adam начинает сбоить. Авторы метода AMSgrad в статье [On the Convergence of Adam and Beyond](https://openreview.net/pdf?id=ryQu7f-RZ) были одними из первых, кто провел почти аналогичный нашему анализ и добавили в Adam костыль, который обеспечивает выполнение условия $v_{t} \\geqslant v_{t-1}$ и исключает отрицательные регуляризаторы.\n\n**Обратите внимание**: в разделее про [Learning Rate Scheduling vs AdaGrad](https://academy.yandex.ru/handbook/ml/article/metody-optimizacii-v-deep-learning#learning-rate-scheduling-vs-ada-grad) мы поговорим о «цикличности истории» развития методов оптимизации в deep learning.\n\n### AMSgrad\n\nАвторы статьи [On the Convergence of Adam and Beyond](https://openreview.net/pdf?id=ryQu7f-RZ) анализируют последовательность\n\n$$\\Gamma_{t+1} = \\Big(\\frac{\\sqrt{v_{t+1}}}{\\alpha_{t+1}} - \\frac{\\sqrt{v_t}}{\\alpha_t} \\Big)\n$$\n\nи говорят, что отрицательные значения в ней вызывают проблемы с процессом оптимизации. Их анализ в целом аналогичен приведённому выше, поэтому мы не будем его здесь дублировать.\n\nАвторы статьи не стали предлагать новых схем learning rate и просто модифицировали старую: выполнение $v_t >= v_{t-1}$ обеспечивается «в лоб» при помощи $\\hat{v}_t = \\max\\{v_t, \\hat{v}_{t-1}\\}, \\hat{v}_0 = 0$.\n\nИтоговое правило апдейта без momentum и без bias correction (оригинальный Algorithm 2 из статьи bias correction не использует):\n\n$$v_t = \\beta v_{t-1} + (1 - \\beta) g_t^2\n$$\n\n$$\\hat{v}_t = \\max\\{v_t, \\hat{v}_{t-1}\\}\n$$\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{\\hat{v}_t}}g_t\n$$\n\nЕсли нужен метод с momentum, то можно просто заменить $g_t$ в последней формуле на $m_t$\n\n$$m_t = \\gamma m_{t-1} + (1 - \\gamma) g_t\n$$\n\n$$w_{t+1} = w_t - \\frac{\\alpha}{\\sqrt{\\hat{v}_t}}m_t\n$$\n\n#### Реализация без дополнительной памяти\n\nОригинальные формулы из статьи $\\hat{v}_t = \\max\\{v_t, \\hat{v}_{t-1}\\}$ предполагают, что для расчета $\\hat{v}_t$ мы держим два параметра: $v_{t-1}$ и $\\hat{v}_{t-1}$. RMSprop и Adam хранят только один параметр $v_{t-1}$. Таким образом, включение метода требует дополнительных расходов памяти (х1.5 относительно RMSprop и x1.33 относительно Adam). Выше при разборе методов RMSprop/Adam мы сказали, что на практике AMSgrad помогает разреженным параметрам. Для разреженных моделей потребление памяти — краеугольный камень, поэтому простое включение дефолтной реализации amsgrad из статьи может быть болезненным и, к сожалению, не оправданным.\n\nНа практике же эвристика вида $v_t = \\max\\{v_t, v_{t-1}\\}$ для разреженных параметров обычно работает так же хорошо и не требует дополнительной памяти. Никаких теоретических гарантий для нее нет, но на практике она работает.\n\n#### Добавление bias correction\n\nОригинальная статья (и следующие букве оригинала стандартные реализации алгоритма, например, в PyTorch) предполагает убирание bias correction. Эксперименты на разреженных данных показывают, что убирание bias correction вредит сходимости, это полезная вещь.\n\nС практической точки зрения, есть два способа реализовать bias correction в AMSgrad:\n\n1. Post-correction: $\\hat{v}_t = \\frac{1}{1 - \\beta^t}\\max\\{v_t, \\hat{v}_{t-1}\\}$,\n2. Pre-correction: $\\hat{v}_t = \\max\\{\\frac{1}{1 - \\beta^t}v_t, \\frac{1}{1 - \\beta^{t-1}}\\hat{v}_{t-1}\\}$.\n\nС точки зрения корректности метода AMSgrad, правильный вариант — pre-correction, так как он не ломает максимум. А вот эксперименты показывают, что добавление pre-correction ничего не даёт, а вот post-correction действительно помогает в том смысле, что AMSgrad \\+ post-bias correction лучше, чем просто RMSProp/Adam с bias correction.\n\n#### Соединяем эвристику \\+ bias correction\n\nИтоговые формулы можно использовать такие:\n\n$$\\hat{v} = \\frac{1}{1 - \\beta^t}\\max\\left\\{v_t, \\frac{1}{1-\\beta^{t-1}}v_{t-1}\\right\\}\n$$\n\n### Learning Rate Scheduling\n\nДругим способом улучшения сходимости методов RMSprop/Adam/SGD является learning rate scheduling (расписание learning rate, шедулер). Learning rate scheduler — это мета-алгоритм: они берёт любой стандартный метод оптимизации с константным параметром learning rate $\\alpha$ и предписывает схему изменения $\\alpha_t$ на каждом шаге $t$, или на каждой эпохе, или на любом другом заданном периоде.\n\nПоскольку мы работаем с одним параметром $\\alpha$, мы можем с ним делать всего две вещи: увеличивать или уменьшать. Эти два варианта имеют свои названия:\n\n1. Learning rate decay — уменьшение learning rate с течением времени с целью нивелировать осцилляцию RMSprop/Adam около критических точек.\n2. (Warm)Restart — обычно резкое увеличение learning rate. Warm — потому что мы уже сошлись в какую-то хорошую точку и сбрасываем только состояние оптимизатора в ней, но не переинициализируем сами параметры. WarmRestart может заключаться не только в увеличении $\\alpha$, но и, например, в дополнительном сбросе состояния оптимизатора (обнуление momentum или $v_{t}$), хотя автор статьи такой подход встречали достаточно редко\n\nСуществует огромное количество вариантов расписания, каждый со своим графиком изменения $\\alpha_t$ и со своим любовно подобранным множеством задач, на которых данный метод показывает себя лучше других. Приводить здесь их список особого смысла нет, лучше просто откройте [документацию любого фреймворка](https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate) и наслаждайтесь разнообразием вариантов.\n\nМы же обсудим влияние learning rate decay на осцилляцию вокруг критических точек и дадим практические рекомендации по подбору расписаний.\n\n#### Влияние learning rate decay на сходимость\n\nДля выпуклых задач в разделе про схемы убывания learning rate для FTRL-методов (константный регуляризатор, $\\frac{1}{sqrt{t}}$ и AdaGrad) мы буквально на оценках на regret видели, что это важный аспект для асимптотики сходимости.\n\nВ выпуклом случае, при приближении к минимуму мы должны оптимизировать решение с куда большей точностью. Норма градиентов при приближении к минимуму тоже уменьшаются, поэтому даже с константным $O(1)$ learning rate шаги будут становиться меньше, но — как показывают и теоретические оценки на regret, и многочисленные их валидации в статьях — этого недостаточно. Уменьшение learning rate с правильной асимптотикой уменьшения дает куда более хорошие результаты. Для глубинного обучения и оптимизации к каким-то локальным минимумам эта логика тоже применима.\n\nВозвращаясь к методам Adam/RMSprop — напомним, что у них асимптотика learning rate $O(1)$. Им в любом случае пойдет на пользу уменьшение learning rate, даже если не брать во внимание их проблемы вокруг критических точек и взять метод AMSgrad, который от этих проблем не страдает.\n\nОтсюда же очевидно, что проблемы adam/rmsprop начинают стрелять гораздо меньше. Learning rate уменьшается =\\> от критической точки мы в плохих ситуациях шагаем на гораздо меньшее расстояние =\\> область, вокруг которой мы будем «прыгать», сужается =\\> мы худо-бедно, но сходимся.\n\n#### Практические рекомендации\n\nКак мы уже отмечали выше, шедулеров существует поистине фантастическое количество, гораздо больше, чем базовых оптимизаторов, к которым они применяются. Без структуризации подхода к ним работать становится сложно.\n\nМы хотели бы дать вам следующие рекомендации:\n\n1. Выучите свою модель без learning rate scheduling со стандартными методами оптимизации и посмотрите, как ведёт себя loss для различных learning rate. Обязательно переберите learning rate на этом шаге.\n2. Начинать внедрение расписаний рекомендуем с шедулеров, которые только уменьшают learning rate. Классические варианты — ReduceOnPlateou или linear decay. Правильный подбор learning rate и темпа его уменьшения очень важны в любой задаче стохастической оптимизации.\n3. Только после того, как вы хорошенько потюните learning rate decay, можно смотреть в сторону WarmRestart. Иногда рестарты могут помочь. Автор статьи занимается в основном рекомендательными моделями и там эту технику практически никто не применяет.\n\n#### Learning rate scheduling vs AdaGrad\n\nУ методов SGD/RMSprop/Adam последовательность $\\eta_t \\sim O(1)$ не является асимптотически убывающей, и для того, чтобы это скомпенсировать, используется расписание learning rate. А вот у AdaGrad с $\\eta_t$ и так всё в порядке.\n\nДавайте восстановим хронологию событий:\n\n1. Метод AdaGrad пытаются применять к нейросетям в 2012\\+ годах, но тогда архитектуры были нестабильны, градиенты взрывались и навсегда портили знаменатель AdaGrad, сильно уменьшая learning rate.\n2. Появляются методы RMSprop/[Adam](https://arxiv.org/abs/1412.6980) (2013/2014) со скользящим средним в знаменателе, которые могут оправиться от взрыва градиента.\n3. Развитие архитектур нейронных сетей не стоит на месте, появляются разные виды [residual connection](https://arxiv.org/abs/1512.03385) (2015), [LayerNorm](https://arxiv.org/abs/1607.06450)/[BatchNorm](https://arxiv.org/abs/1502.03167) (2015-2016), крутые методы [начальной инициализации](https://arxiv.org/abs/1711.04735) — огромное количество способов улучшения стабильности обучения.\n4. С развитием архитектур люди замечают, что RMSProp/Adam умеют застревать на одном уровне значений функции потерь, и начинают применять техники для уменьшения learning rate.\n5. В дальнейших работах метод AdaGrad часто рассматривается наравне с Adam/RSMprop и дает очень похожее, либо даже лучшее качество (см, например, статью про [Shampoo](https://arxiv.org/pdf/1802.09568.pdf)). А дело в том, что архитектуры уже очень хорошо инициализируются и правильно проектируются так, чтобы не было взрывов/затуханий градиентов ни на какой стадии оптимизации.\n\nРазвитие методов оптимизации в deep learning сделало небольшой круг, и мы рекомендуем об этом помнить. Порой люди могут одновременно рассуждать о бесценной пользе learning rate decay (особенно с линейным убыванием как $\\frac1t$) и корить AdaGrad за бесконечное аккумулирование квадратов градиентов (которые убывают как $\\frac1{\\sqrt{t}}$). Так что если у вас вдруг хорошо заработал шедулер с $\\alpha_t \\sim O(\\frac{1}{\\sqrt{t}})$ — возможно, обычный AdaGrad будет лучше?\n\n### SGD vs Adam\n\nВ последнее время в литературе часто появляются заявления, что решения, полученные адаптивными методами в нейросетях, обладают худшей обобщающей способностью. Сразу хотим отметить, что большинство этих статей исследуют эти эффекты только на задачах Computer Vision на одних и тех же датасетах MNIST/CIFAR/ImageNet. В реальной жизни куда большее разнообразие постановок задач и датасетов, что сразу заставляет сомневаться в воспроизводимости этих эффектов. Рекомендация тут одна, как и всегда — досконально сами все проверяйте.\n\n#### AdamW, SGDW\n\nДанные методы предложены авторами в статье [Decoupled Weight Decay Regularization](https://arxiv.org/abs/1711.05101), которую мы подробно разобрали в разделее про продвинутую <a href='https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#l-2-regulyarizacziya'>$L_2$ регуляризацию</a>. Методы AdamW и SGDW — это просто модификации методов Adam и SGD с momentum, которые используют линеаризованный decoupled $L_2$.\n\nАвторы статьи изучали проблему, почему в их экспериментах SGD обобщает лучше Adam (но учится дольше и требует более аккуратной настройки). Они пришли к выводу, что дело не в магии SGD, а в том, что $L_2$-регуляризация у этих двух методов работает по-разному. Добавив decoupling, авторы сумели показать, что decoupled Adam обгоняет SGD.\n\nЭти эффекты, повторимся, были уже рассмотрены ранее в разделее про продвинутую <a href='https://academy.yandex.ru/handbook/ml/article/regulyarizaciya-v-onlajn-obuchenii#l-2-regulyarizacziya'>$L_2$ регуляризацию</a>. Единственное, что мы не обсудили тогда — это momentum. В постановке Proximal Gradient Descent градиент заменяется на momentum\n\n$$w_{t+1} = \\color{red}{g_t}^Tw + \\frac{\\lambda_2}{\\eta_t}w_t + \\frac{1}{2\\eta_t}\\vert\\vert w - w_s\\vert\\vert_2^2\n$$\n\n$$m_t = \\gamma m_{t-1} + (1 - \\gamma) g_t\n$$\n\n$$w_{t+1} = \\color{red}{m_t}^Tw + \\frac{\\lambda_2}{\\eta_t}w_t + \\frac{1}{2\\eta_t}\\vert\\vert w - w_s\\vert\\vert_2^2\n$$\n\n$$w_{t+1} = w_t - \\eta_t m_t - \\lambda_2 w_t\n$$\n\nПокоординатные $\\eta_t$ могут рассчитываться любыми методами: AdaGrad, RMSprop или Adam, не принципиально.\n\nНа всякий случай напомним, что мы вывели потенциально более правильные формулы\n\n$$w_{t+1} = m_t^Tw + \\frac{\\lambda_2}{2\\eta_t}\\vert\\vert w\\vert\\vert_w^2 + \\frac{1}{2\\eta_t}\\vert\\vert w - w_s\\vert\\vert_2^2\n$$\n\n$$w_{t+1} = \\frac{1}{1 + \\lambda_2}\\Big(w_t - \\eta_t m_t\\Big)\n$$\n\nМетод SGDW получается из формул выше, если убрать покоординатность $\\eta_t$\n\nК сожалению, здесь мы не почерпнули новых идей, так как выяснили, что это просто очередная инкарнация Proximal методов оптимизации.\n\n#### RAdam\n\nЭтот метод заключается в том, чтобы стартовать с адаптивного метода Adam и в некоторый момент переключиться на SGD. «Некоторый момент» — это, интуитивно, момент стабилизации всех статистик в Adam, когда мы выжали все из ускоренного старта адаптивных методов и хотим получше сойтись к хорошему оптимуму в найденной им окрестности.\n\nОтметим, что позднее переключение на SGD с неубывающими learning rate автоматически починит проблемы расходимости Adam ровно там, где они чаще всего и возникают: при хорошем приближении к локальным минимумам.\n\nМы не будем здесь подробно рассматривать их анализ, вы можете сами познакомиться с ним в статье [On The Variance Of The Adaptive Learning Rate And Beyond](https://arxiv.org/pdf/1908.03265.pdf)\n\n## Online RMSprop\n\nОсобняком стоит метод, описанный в статье [Variants of RMSProp and Adagrad with Logarithmic Regret Bounds](http://proceedings.mlr.press/v70/mukkamala17a/mukkamala17a.pdf). Авторы не придумывали очередной хотфикс, а аккуратно заново выводили формулы. Также важно, что данный метод является строгим обобщением метода AdaGrad.\n\nВ работе есть два нововведения:\n\n1. Переформулировка метода RMSprop так, чтобы:\\\n   — Осталось экспоненциальное скользящее среднее;\\\n   — Не было проблемы с отрицательными регуляризаторами и взрывающимися learning rate;\\\n   — Метод AdaGrad являлся частным случаем нового метода;\\\n   — Чтобы все эмпирически хорошо работало в т.ч. на глубоких моделях\n2. Формулировка новых алгоритмов оптимизации SC-AdaGrad и SC-RMSprop для сильно выпуклых функций с логарифмическими гарантиями на regret. SC в названии — Strongly Convex.\n\nПока рассмотрим только первый пункт. Авторы вводят следующий общий метод:\n\n$$v_t = \\beta_t v_{t-1} + (1 - \\beta_t) g_t^2\n$$\n\n$$\\epsilon_t = \\frac{\\epsilon}{\\sqrt{t}}\n$$\n\n$$\\alpha_t = \\frac{\\alpha}{\\sqrt{t}}\n$$\n\n$$w_{t+1} = w_t - \\frac{\\alpha_t}{\\sqrt{v_t} + \\epsilon_t}g_t\n$$\n\nНововведение здесь в том, что вместо фиксированного $\\beta$ мы будем рассматривать последовательность $\\beta_t$. Авторы доказывают сублинейный regret для любых последовательностей, удовлетворяющих\n\n$$1 - \\frac{1}{t} \\leq \\beta_t \\leq 1 - \\frac{\\gamma}{t}\n$$\n\n$$0 < \\gamma \\leq 1\n$$\n\n### AdaGrad как частный случай\n\nДокажем, что метод Adagrad — это метод OnlineRMSprop с $\\gamma = 1$. Аналогично выводам momentum в FTRL, перепишем рекуррентное выражение для $v_{t+1}$:\n\n$$v_t = \\sum\\limits_{s=1}^t(1 - \\beta_s)\\prod\\limits_{k=s+1}^t\\beta_k g_k^2\n$$\n\nПодставив $\\beta = 1 - \\frac{1}{t}$, получим\n\n$$v_t = \\sum\\limits_{s=1}^t(1 - \\beta_s)\\Big(\\prod\\limits_{k=s+1}^t\\beta_k\\Big) g_s^2 = \\sum\\limits_{s=1}^t\\frac{1}{s}g_s^2\\prod\\limits_{k=s+1}^t\\frac{t - 1}{t} =\n$$\n\n$$= \\sum\\limits_{s=1}^t\\frac{1}{s}g_s^2\\prod\\limits_{k=s+1}^t\\frac{k - 1}{k} = \\sum\\limits_{s=1}^t\\frac{1}{s}g_s^2\\frac{s}{t} = \\frac{1}{t}\\sum\\limits_{s=1}^tg_s^2\n$$\n\nДалее, подставляя это в формулу $\\eta_t = \\frac{\\alpha_t}{\\sqrt{v_t}}$, получаем\n\n$$\\eta_t = \\frac{\\frac{\\alpha}{\\sqrt{t}}}{\\sqrt{\\frac{1}{t}\\sum\\limits_{s=1}^tg_s^2}} = \\frac{\\alpha}{\\sqrt{\\sum\\limits_{s=1}^tg_s^2}}\n$$\n\n### Анализ OnlineRMSprop с $\\gamma < 1$ в стиле FTRL. Пригодность для выпуклых задач\n\nДокажем, что OnlineRMSprop не может сломать регуляризаторы в regret. Для этого преобразуем неравенство\n\n$$\\frac{\\sqrt{v_t}}{\\alpha_t} < \\frac{\\sqrt{v_{t-1}}}{\\alpha_{t-1}}\n$$\n\n$$tv_t < (t-1)v_{t-1}\n$$\n\n$$t(\\beta_t v_{t-1} + (1 - \\beta_t)g_t^2) < (t-1)v_{t-1}\n$$\n\n$$t((1 - \\frac{\\gamma}{t})v_{t-1} + \\frac{\\gamma}{t}g_t^2) < (t-1)v_{t-1}\n$$\n\n$$\\frac{\\gamma}{t}g_t^2 < v_{t-1}(t - 1 - t(1 - \\frac{\\gamma}{t}))\n$$\n\n$$\\frac{\\gamma}{t}g_t^2 < v_{t-1}(\\gamma - 1)\n$$\n\nИз условия $0 < \\gamma \\leq 1$ получаем, что правая часть неравенства неположительна, а левая неотрицательно. Значит, последнее неравенство невозможно, то есть все $\\sigma_t \\geq 0$. Таким образом, регуляризаторы не сломаются, сходимость будет иметь место и данный метод можно использовать в выпуклых задачах. Строгое доказательство сходимости и оценки на Regret можно прочитать в исходной статье.\n\n### Эффективный learning rate\n\nКак и ранее в методе AdaGrad, допустим, что $\\vert\\vert g\\vert\\vert_2 < R$. Тогда\n\n$$\\eta_t = \\frac{\\alpha}{\\sqrt{t}\\sqrt{\\sum\\limits_{j=1}^t(1-\\beta_j)\\prod\\limits_{k=j+1}^t\\beta_kg_j^2}} \\leq \\frac{\\alpha}{R\\sqrt{t}\\sqrt{\\sum\\limits_{j=1}^t(1-\\beta_j)\\prod\\limits_{k=j+1}^t\\beta_k}}\n$$\n\nПри $1 - \\frac{1}{t} \\leq \\beta_t \\leq 1 - \\frac{\\gamma}{t}$ выполнено\n\n$$\\lim\\limits_{t\\rightarrow\\infty} \\sum\\limits_{j=1}^t(1-\\beta_j)\\prod\\limits_{k=j+1}^t\\beta_k = 1\n$$\n\nДокажем, что все элементы предела \\< 1. Из этого, в частности, будет следовать, что learning rate у OnlineRMSprop не меньше, чем learning rate в AdaGrad.\n\nЕсли все все $g_i^2 = 1$, то итерационный процесс OnlineRMSprop превращается в\n\n$$v_t = \\beta_t v_{t-1} + (1 - \\beta_t)\n$$\n\nПредположим, что $v_t \\geq 1$. Тогда:\n\n$$\\beta_t v_{t-1} + (1 - \\beta_t) \\geq 1\n$$\n\n$$(1 - \\frac{\\gamma}{t}) v_{t-1} + \\frac{\\gamma}{t} \\geq 1\n$$\n\n$$v_{t-1} \\geq 1\n$$\n\nПо индукции разворачиваем вплоть до $v_0 = 0$, получаем противоречие.\n\nПолное доказательство предела оставляем читателям. Надо бы чем-нибудь снизу подпереть, что тоже к 1 сходится. Автор сдавал матан почти 10 лет назад и ему было очень неохота откапывать все эти прекрасные пределы, поэтому ответ был получен с помощью wolfram.\n\n**Вывод**: learning rate у OnlineRMSprop убывает со скоростью $\\eta_t = O(\\frac{1}{\\sqrt{t}})$. Мы исправили ошибку предыдущего RMSprop, изменив *только* перевзвешивание, но не асимптотику в $\\eta_t$. Такой RMSprop можно пробовать использовать в выпуклых задачах\n\n## Momentum\n\nПопробуем расписать классический momentum с константным learning rate в стиле FTRL:\n\n$$v_{t + 1} = \\beta v_t + (1 - \\beta) g_{t}\n$$\n\n$$w_{t + 1} = w_t - \\alpha v_{t + 1}\n$$\n\nВсё, что нам нужно сделать — это взять все рекурсивные зависимости от предыдущей итерации и «размотать» их, получив явное выражение.\n\nЗависимость $w_{t+1}$ от $w_t$ переписать довольно просто, мы это уже делали для обычного градиентного спуска:\n\n$$w_{t+1} = -\\alpha\\sum\\limits_{i=1}^tv_i\n$$\n\nТеперь надо размотать $v_t = (1-\\beta)\\sum\\limits_{i=1}^t\\beta^{t-i}g_i$\n\nТеперь будет чуть сложнее. Подставим это и попробуем расписать, как сумму $g_i$ с определенными коэффициентами:\n\n$$w_{t+1} = -\\alpha\\sum\\limits_{i=1}^tv_i = -\\alpha\\sum\\limits_{i=1}^t (1-\\beta)\\sum\\limits_{j=1}^i\\beta^{i-j}g_j\n$$\n\nМножитель $-\\alpha(1-\\beta)$ сразу выносим за сумму и пока забываем.\n\n$$\\sum\\limits_{i=1}^t\\sum\\limits_{j=1}^i\\beta^{i-j}g_j = \\sum\\limits_{i=1}^t\\sum\\limits_{j=1}^t \\mathbb{I}(j\\leq i)\\beta^{i-j}g_j =\n$$\n\n$$= \\sum\\limits_{j=1}^t\\sum\\limits_{i=1}^t\\mathbb{I}(j\\leq i)\\beta^{i-j}g_j = \\sum\\limits_{j=1}^tg_j\\sum\\limits_{i=1}^t\\mathbb{I}(j\\leq i)\\beta^{i-j} =\n$$\n\n$$= \\sum\\limits_{j=1}^tg_j\\sum\\limits_{i=j}^t\\beta^{i-j}\n$$\n\nОтлично, а теперь нам нужно получить последовательность функций. В линеаризованной задаче это фактически эквивалентно получению зависимости $z_{t+1}$ от $z_t$, где, напомним, $z_t$ — это сумма градиентов.\n\n$$z_{t+1} - z_t = \\sum\\limits_{j=1}^{t+1}g_j\\sum\\limits_{i=j}^{t+1}\\beta^{i-j} - \\sum\\limits_{j=1}^tg_j\\sum\\limits_{i=j}^t\\beta^{i-j} = g_{t+1} + \\sum\\limits_{j=1}^{t}g_j\\sum\\limits_{i=j}^{t+1}\\beta^{i-j} - \\sum\\limits_{j=1}^tg_j\\sum\\limits_{i=j}^t\\beta^{i-j} = g_{t+1} + \\sum\\limits_{j=1}^{t}\\beta^{t+1-j}g_j = \\sum\\limits_{j=1}^{t+1}\\beta^{t+1-j}g_j\n$$\n\nТеперь мы можем записать функцию, градиент которой равен $z_{t+1} - z_t$ и онлайн-оптимизация которой эквивалентна процедуре с моментумом:\n\n$$\\hat{f}_t(w) = \\sum\\limits_{j=1}^{t}\\beta^{t-j}f_j(w)\n$$\n\nПолучаем, что для онлайн-обучения мы на самом деле каждую итерацию скармливаем экспоненциально взвешенную последовательность всех предыдущих функций исходной последовательности. В принципе, нечто такое мы и ожидали увидеть. Функции $\\hat{f_t(w)}$, очевидно, выпуклы, так что для данной измененной последовательности функций будет сублинейный regret.\n\n### Nesterov Momentum\n\nРассмотрим классический SGD с momentum, для всех adaptive методов рассуждения аналогичны.\n\n$$m_t = \\gamma m_{t-1} + (1 - \\gamma)g_t\n$$\n\n$$w_{t+1} = w_t - \\alpha m_t\n$$\n\nГрадиент функции $g_t$ посчитан в предыдущей точке $w_t$. Идея nesterov momentum в том, чтобы применить momentum на параметры $w_t$ **до вычисления градиента**:\n\n$$g_t = \\nabla f_t(w_t)\n$$\n\n$$\\hat{g}_t = \\nabla f_t(w_t - m_{t-1})\n$$\n\nУ метода много всяких «интуитивных объяснений», но изначально Nesterov Momentum был выведен сугубо аналитическими методами. Увы, попытки добавлять его в стохастическую оптимизацию «в лоб» обычно улучшением качества не заканчиваются. Анализ того, почему так нельзя и делать и как можно сделать правильно, проводится в работах [Katyusha: The First Direct Acceleration of Stochastic Gradient Methods](https://arxiv.org/pdf/1603.05953.pdf) и [Natasha-2](https://arxiv.org/abs/1708.08694) (мотивация их автора Zeyuan Allen-Zhu для выбора таких наименований доподлинно неизвестна). Katuysha правильным образом использует nesterov momentum для выпуклого случая, Natasha — для невыпуклого. Данные методы используют подход SVRG для улучшения сходимости и ускорение оптимизации происходит **только при приближении к точке оптимума**.\n\n### Adan\n\nДо недавнего времени громких историй успеха для nesterov momentum в глубоком обучении не было. Метод Natasha распространения не нашел. Наконец, авторы статьи [Adan](https://arxiv.org/abs/2208.06677) (2022) нашли способ правильной обработки Nesterov Momentum. Метод показал отличные результаты и обновил SOTA метрики на широком спектре задач.\n\n## Собираем все идеи воедино\n\nАвторы данного обзора очень хотят, чтобы читатель ушел не с знанием набора наименований методов оптимизации, а с знанием набора концепций, которые тот или иной метод реализует, и при случае мог сам подстроить метод под свои нужды. Тюнинг методов оптимизации — один из главных способов улучшения качества модели на фиксированном датасете.\n\n 1. Adaptive learning rate — автоматическое подстраивание метода под геометрию задачи оптимизации. Крайне важный класс методов для выпуклых/невыпуклых задач. Must-have для разреженных моделей. Методы: AdaGrad/RMSprop/Adam.\n 2. Скользящее среднее в adaptive learning rate представлено в методах RMSprop/Adam. Не забывайте про их плохое поведение вокруг критических точек и проблемы со сходимостью на финальных этапах оптимизации.\n 3. BiasCorrection: стабилизация обучения на старте для адаптивных методов со скользящим средним. Большинство экспериментов показывают, что это крайне полезная штука и стоит всегда её использовать. В том числе стоит использовать RMSprop с bias correction, если вам не нужны momentum и Adam.\n 4. AMSgrad: способ починить сходимость RMSprop/Adam. Не забывайте, что стандартные реализации при использовании AMSgrad отключают bias correction, а это на самом деле может навредить, а также о том, что можно реализовать AMSgrad без дополнительной памяти, и всё будет хорошо работать.\n 5. Learning rate decay: убывание learning rate зачастую является очень важной деталью в стохастической оптимизации. Помните, что можно брать как AdaGrad, в котором это есть из коробки со скоростью $O(\\frac{1}{\\sqrt{t}})$ (но архитектура нейросети должна быть хорошей), так и комбинацию RMSProp/Adam \\+ learning rate scheduler.\n 6. WarmRestart: эвристика, резко увеличивающая learning rate после достижения некоторой точки в процессе оптимизации. Практически всегда идет бок о бок с learning rate decay. Где-то помогает\n 7. Проксимальные методы для функций потерь с регуляризаторами: ProximalGD/AdamW/SGDW/FTRL-Proximal. Must-have для $L_1$-регуляризаторов, без проксимальности они вообще не работают.\n 8. FTRL-Proximal: lazy vs greedy представление. Переписываем представление любого метода оптимизации в не-жадный вид. Позволяет по-новому взглянуть на любые регуляризаторы, особенно негладкие. Must-have для $L_1$-регуляризации.\n 9. $L_1$-регуляризация в FTRL-Proximal: Incremental/Fixed/SquareIncremental. Все три имеют разные свойства и разную область применения. Fixed является наилучшим для отбора разреженных признаков/эмбеддингов.\n10. $L_{1/2}$-регуляризатор для отбора эмбеддингов или автоматического подбора размерности. Можно использовать как аналог FSTR. Крайне полезный подход для разреженных нейросетей в рекомендательных системах, для которых рекомендуется использовать адаптивную схему SquareIncremental.\n11. Heavy-ball Momentum: используется для ускорения процесса оптимизации. В выпуклых задачах имеет доказанные оценки на улучшение скорости сходимости, в нейросетях используется как эвристика (зачастую опциональная).\n12. Nesterov momentum: в выпуклом случае гораздо мощнее для batch gradient descent, чем обычный momentum, и это подверждается теоретическими гарантиями. В стохастических методах оптимизации и в онлайн обучении «в лоб» применять нельзя: для выпуклого случая подойдет Katyusha, для нейросетей — Adan.\n\nГлавное, что мы хотим подчеркнуть, — эти идеи друг другу не противоречат и их можно свободно комбинировать друг с другом. Например, можно собрать себе FTRL-Proximal метод с $L_1$-регуляризацией, любым momentum и RMSprop learning rate с AMSgrad. Или любую другую комбинацию. Всегда можно выбрать оптимальный набор под задачу.\n\n### Пример таблицы с общими формулами\n\nЭти формулы используют все подходы выше в едином фреймворке, чтобы наглядно убедиться в том, что все можно друг с другом комбинировать.\n\n**Generic FTRL-Proximal**\n\n$$w_{t+1} = arg\\min\\limits_w \\hat{g}_{1:t}^Tw + \\lambda_{1,t}\\vert\\vert w\\vert\\vert_1 + \\frac{1}{2}\\vert\\vert w\\vert\\vert_{\\lambda_{2,t}}^2 + \\frac{1}{2}\\sum\\limits_{s=1}^t\\vert\\vert w - w_s\\vert\\vert_{\\sigma_s}^2\n$$\n\n$$z_t = g_{1:t} - \\sum\\limits_{s=1}^t\\sigma_s w_s\n$$\n\n$$w_{t+1,i} = \\begin{cases}\n      0 & \\vert z_{t,i}\\vert  \\leq \\lambda_{1,t}\\\\\n      -\\frac{\\sigma_{1:t}}{1 + \\lambda_{2,t}\\sigma_{1:t}} (z_t - sign(z_t)\\lambda_{1,t})& \\vert z_{t,i}\\vert  > \\lambda_{1,t}\n\\end{cases}\n$$\n\n**Generic Mirror (Proximal) Gradient Descent**\n\n$$w_{t+1} = arg\\min\\limits_w \\hat{g}_t^Tw + \\lambda_{1,t}\\vert\\vert w\\vert\\vert_1 + \\frac{1}{2}\\vert\\vert w\\vert\\vert_{\\lambda_{2,t}}^2 + \\frac{1}{2}\\vert\\vert w - w_t\\vert\\vert_{\\frac{1}{\\eta_t}}^2\n$$\n\n$$z_t = \\frac{1}{\\eta_t} w_t - g_t\n$$\n\n$$w_{t+1} = \\begin{cases}\n      0 & \\vert z_t\\vert  \\leq \\lambda_{1,t}\\\\\n      -\\frac{\\eta_t}{1 + \\lambda_{2,t}\\eta_t} (z_t - sign(z_t)\\lambda_{1,t})& \\vert z_t\\vert  > \\lambda_{1,t}\n\\end{cases}\n$$\n\n**Связь**:\n\n$$\\sigma_t = \\frac{1}{\\eta_t} - \\frac{1}{\\eta_{t-1}}\n$$\n\n#|\n||\n\nИдея\n\n|\n\nFTRL (lazy)\n\n|\n\nGradient Descent (greedy)\n\n|\n\nКомментарии\n\n||\n||\n\nMomentum\n\n|\n\n$\\hat{g}_t = m_t = \\gamma m_{t-1} + (1 - \\gamma) g_t$ $m_0 = 0$\n\n|\n\nТо же самое\n\n|\n\nНе влияет на adaptive $v_t$\n\n||\n||\n\nКонстантный learning rate\n\n|\n\n$\\sigma_0 = \\frac{1}{\\alpha}$, $\\sigma_t = 0, t > 0$\n\n|\n\n$\\eta_t = \\alpha$\n\n|\n\n\n||\n||\n\nУбывающий непокоординатный learning rate\n\n|\n\n$\\sigma_t = \\frac{1}{\\alpha_t} - \\frac{1}{\\alpha_{t-1}}$\n\n|\n\n$\\eta_t = \\alpha_t$\n\n|\n\nОбычно берут $\\alpha_t = \\frac{\\alpha}{\\sqrt{t}} = O(\\frac{1}{\\sqrt{t}})$\n\n||\n||\n\nGeneric Adaptive learning rate\n\n|\n\n$\\sigma_t = \\frac{\\sqrt{v_t}}{\\alpha_t} - \\frac{\\sqrt{v_{t-1}}}{\\alpha_{t-1}}$\n\n|\n\n$\\eta_t = \\frac{\\alpha}{\\sqrt{v_t}}$\n\n|\n\n$v_t$ и $\\eta_t$ — векторы, везде ниже умножение $\\eta_tg_t$  означает покоординатное умножение\n\n||\n||\n\nGeneric Adaptive learning rate с scheduler $S(\\alpha, t)$\n\n|\n\n$\\sigma_t = \\frac{\\sqrt{v_t}}{S(\\alpha_t, t)} - \\frac{\\sqrt{v_{t-1}}}{S(\\alpha_{t-1}, t)}$\n\n|\n\n$\\eta_t = \\frac{S(\\alpha_t, t)}{\\sqrt{v_t}}$\n\n|\n\nНапример, в Adam: $\\alpha\\sqrt{1 - \\beta^t} \\rightarrow S(\\alpha, t)\\sqrt{1 - \\beta^t}$\n\n||\n||\n\nAdaptive learning rate: AdaGrad\n\n|\n\n$v_t = \\sum\\limits_{s=1}^t g_s^2$</th><th>$v_t = \\sum\\limits_{s=1}^t g_s^2$\n\n|\n\n$v_t = \\sum\\limits_{s=1}^t g_s^2$\n\n|\n\n$\\eta_t = O(\\frac{1}{\\sqrt{t}})$\n\n||\n||\n\nAdaptive learning rate: RMSprop\n\n|\n\n$v_t = \\beta v_{t-1} + (1 - \\beta) v_t$, $\\alpha_t = \\alpha$\n\n|\n\nТо же самое\n\n|\n\n$\\eta_t = O(1)$, ломается у критических точек\n\n||\n||\n\nAdaptive learning rate: Online RMSprop\n\n|\n\n$v_t = \\beta_t v_{t-1} + (1 - \\beta_t) v_t$, $\\alpha_t = \\frac{\\alpha}{\\sqrt{t}}$, $\\beta_t = 1 - \\frac{\\gamma}{t}$\n\n|\n\nТо же самое\n\n|\n\n$\\eta_t = O(\\frac{1}{\\sqrt{t}})$\n\n||\n||\n\nAdaptive learning rate: Adam\n\n|\n\n$v_t = \\beta v_{t-1} + (1 - \\beta) v_t$, $\\alpha_t = \\alpha\\sqrt{1 - \\beta^t}$\n\n|\n\nТо же самое\n\n|\n\n$\\eta_t = O(1)$, ломается у критических точек\n\n||\n||\n\nAdaptive learning rate: AMSgrad\n\n|\n\n$v_t = \\beta v_{t-1} + (1 - \\beta) v_t$, $\\alpha_t = \\alpha$\n\n|\n\nТо же самое\n\n|\n\n$\\eta_t = O(1)$\n\n||\n||\n\nAdaptive learning rate: RAdam\n\n|\n\nМногобукв\n\n|\n\nМногобукв\n\n|\n\n$\\eta_t = O(1)$\n\n||\n||\n\nКлассическая $L_2$ регуляризация\n\n|\n\n$\\lambda_{2,t} = \\lambda_2$\n\n|\n\n$\\lambda_{2,t} = \\lambda_2$\n\n|\n\n\n||\n||\n\nDecoupled $L_2$ регуляризация\n\n|\n\n$\\lambda_{2,t} = \\frac{\\lambda_2}{\\sigma_{0:t}}$\n\n|\n\n$\\lambda_{2,t} = \\frac{\\lambda_2}{\\eta_t}$\n\n|\n\n\n||\n||\n\nИнкрементальная $L_1$ регуляризация\n\n|\n\n$\\lambda_{1,t} = t\\lambda_1$\n\n|\n\n$\\lambda_{1,t} = \\lambda_1$\n\n|\n\n\n||\n||\n\nФиксированная $L_1$ регуляризация\n\n|\n\n$\\lambda_{1,t} = \\lambda_1$\n\n|\n\nОтсутствует\n\n|\n\n\n||\n|#\n\n",
        "handbook": "Учебник по машинному обучению",
        "title": "Методы оптимизации в Deep Learning",
        "description": null
    },
    {
        "path": "/handbook/ml/article/matrichnoe-differencirovanie",
        "content": "Любая задача машинного обучения — это задача оптимизации, а задачи оптимизации удобнее всего решать градиентными методами (если это возможно, конечно). Поэтому важно уметь находить производные всего, что попадается под руку. Казалось бы, в чём проблема: ведь дифференцирование — простая и понятная штука (чего не скажешь, например, об интегрировании). Зачем же как-то специально учиться дифференцировать матрицы?\n\nДа в принципе-то никаких проблем: в этом параграфе вы не узнаете никаких секретных приёмов или впечатляющих теорем. Но, согласитесь, если исходная функция от вектора $x$ имела вид $f(x) = \\vert\\vert Ax - b\\vert\\vert^2$ (где $A$ — константная матрица, а $b$ — постоянный вектор), то хотелось бы уметь и производную выражать красиво и цельно через буквы $A$, $x$ и $b$, не привлекая отдельные координаты $A_{ij}$, $x_k$ и $b_s$. Это не только эстетически приятно, но и благотворно сказывается на производительности наших вычислений: ведь матричные операции обычно очень эффективно оптимизированы в библиотеках, чего не скажешь о самописных циклах по $i, j, k, s$. И всё, что будет происходить дальше, преследует очень простую цель: научиться вычислять производные в удобном, векторно-матричном виде. А чтобы сделать это и не сойти с ума, мы должны ввести ясную систему обозначений, составляющую ядро техники матричного дифференцирования.\n\n## Основные обозначения\n\nВспомним определение производной для функции $f:\\mathbb{R}^m\\rightarrow\\mathbb{R}^n$. Функция $f(x)$ дифференцируема в точке $x_0$, если\n\n$$f(x_0 + h) = f(x_0) + \\color{#348FEA}{\\left[D_{x_0} f \\right]} (h) + \\bar{\\bar{o}} \\left(\\left| \\left| h\\right|\\right|\\right),\n$$\n\nгде $\\color{#348FEA}{\\big[D_{x_0} f\\big]}$ — **дифференциал** функции $f$: линейное отображение из мира $x$-ов в мир значений $f$. Грубо говоря, он превращает «малое приращение $h=\\Delta x$» в «малое приращение $\\Delta f$» («малые» в том смысле, что на о-малое можно плюнуть):\n\n$$f(x_0 + h) - f(x_0)\\approx\\color{#348FEA}{\\left[D_{x_0} f \\right]} (h)\n$$\n\nОтметим, что дифференциал зависит от точки $x_0$, в которой он берётся: $\\color{#348FEA}{\\left[D_{\\color{red}{x_0}} f \\right]} (h)$. Под $\\vert\\vert h\\vert\\vert$ подразумевается норма вектора $h$, например корень из суммы квадратов координат (обычная евклидова длина).\n\nДавайте рассмотрим несколько примеров и заодно разберёмся, какой вид может принимать выражение $\\color{#348FEA}{\\big[D_{x_0} f\\big]} (h)$ в зависимости от формы $x$. Начнём со случаев, когда $f$ — скалярная функция.\n\n{% cut \"Примеры конкретных форм $\\big[D_{x_0} f\\big] (h)$, когда $f$ — скалярная функция\" %}\n\n1. $f(x)$ — скалярная функция, $x$ — скаляр. Тогда\n\n$$f(x_0 + h) - f (x_0) \\approx f'(x_0) (h)\n$$\n\n$$\\color{#348FEA}{\\left[D_{x_0} f\\right] (h)} = f'(x_0) h = h \\cdot f'(x_0)\n$$\n\nЗдесь $h$ и $f'(x_0)$ — просто числа. В данном случае $\\color{#348FEA}{\\left[D_{x_0} f\\right]}$ — это обычная линейная функция.\n\n2. $f(x)$ — скалярная функция, $x$ — вектор. Тогда\n\n$$f(x_0 + h) - f(x_0) \\approx \\sum\\limits_i \\left.\\frac{\\partial f}{\\partial x_i} \\right|_{x=x_0} h_i,\n$$\n\nто есть\n\n$$\t\\color{#348FEA}{\\left[D_{x_0} f\\right]}(h) = \\left(\\color{#FFC100}{\\nabla_{x_0} f}\\right)^T h = \\langle\\color{#FFC100}{\\nabla_{x_0} f}, h \\rangle, \n$$\n\nгде $\\langle\\bullet, \\bullet\\rangle$ — операция скалярного произведения, а $\\color{#FFC100}{\\nabla_{x_0} f} = \\left(\\frac{\\partial f}{\\partial x_1}, \\ldots, \\frac{\\partial f}{\\partial x_n}\\right)$ — градиент функции $f$.\n\n3. $f(x)$ — скалярная функция, $X$ — матрица. Дифференциал скалярной функции по матричному аргументу определяется следующим образом:\n\n$$\tf(X_0 + H) - f(X_0) \\approx \\sum\\limits_{i,j}\\ \\left.\\frac{\\partial f}{\\partial X_{ij}} \\right|_{X=X_0} H_{ij}\n$$\n\nМожно заметить, что это стандартное определение дифференциала функции многих переменных для случая, когда переменные — элементы матрицы $X$. Заметим также один интересный факт:\n\n$$\t\\sum_{ij} A_{ij} B_{ij} = \\text{tr} A^T B,\n$$\n\nгде $A$ и $B$ — произвольные матрицы одинакового размера. Объединяя оба приведённых выше факта, получаем:\n\n$$\t\\color{#348FEA}{\\left[D_{X_0} f \\right]} (H) \n\t= \\sum \\limits_{ij} \n\t\t\\left.\n\t\t\t\\frac{\\partial f}{\\partial X_{ij}}\n\t\t\\right|_{X = X_0} \n\t\t\\left( \n\t\t\tX - X_0\n\t\t\\right)_{ij}\n\t= \\text{tr}\\, \n\t\t\\left( \\left[\\left. \\frac{\\partial f}{\\partial X_{ij}}\\right|_{X=X_0}\\right]^T H\\right).\n$$\n\nМожно заметить, что здесь, по аналогии с примерами, где $x$ — скаляр и где $x$ — вектор (и $f(x)$ — скалярная функция), получилось на самом деле скалярное произведение градиента функции $f$ по переменным $X_{ij}$ и приращения. Этот градиент мы записали для удобства в виде матрицы с теми же размерами, что матрица $X$.\n\n{% endcut %}\n\nВ примерах выше нам дважды пришлось столкнуться с давним знакомцем из матанализа: **градиентом** скалярной функции (у нескалярных функций градиента не бывает). Напомним, что градиент $\\color{#FFC100}{\\nabla_{x_0} f}$ функции в точке $x_0$ состоит из частных производных этой функции по всем координатам аргумента. При этом его обычно упаковывают в ту же форму, что и сам аргумент: если $x$ — вектор-строка, то и градиент записывается вектор-строкой, а если $x$ — матрица, то и градиент тоже будет матрицей того же размера. Это важно, потому что для осуществления градиентного спуска мы должны уметь прибавлять градиент к точке, в которой он посчитан.\n\nКак мы уже имели возможность убедиться, для градиента скалярной функции $f$ выполнено равенство\n\n$$    \\left[D_{x_0} f \\right] (x-x_0) = \\langle\\color{#FFC100}{\\nabla_{x_0} f}, x-x_0\\rangle,\n$$\n\nгде скалярное произведение — это сумма попарных произведений соответствующих координат (да-да, самое обыкновенное).\n\nПосмотрим теперь, как выглядит дифференцирование для функций, которые на выходе выдают не скаляр, а что-то более сложное.\n\n{% cut \"Примеры $\\big[D_{x_0} f\\big] (h)$, где $f$ — это вектор или матрица\" %}\n\n1. \n\n$$f(x) = \\begin{pmatrix} f(x_1)\\\\ \\vdots\\\\ f(x_m) \\end{pmatrix}\n$$\n\n$x$ — вектор. Тогда\n\n$$f(x_0 + h) - f(x_0) = \n\t\\begin{pmatrix}\n\t\tf(x_{01} + h_1) - f(x_{01})\\\\\n\t\t\\vdots \\\\\n\t\tf(x_{0m} + h_m) - f(x_{0m}) \n\t\\end{pmatrix}\n\\approx \n\t\\begin{pmatrix}\n\t\tf'(x_{01}) h_1\\\\\n\t\t\\vdots  \\\\\n\t\tf'(x_{0m}) h_m\n\t\\end{pmatrix} \n=\n\t\\begin{pmatrix}\n\t\tf'(x_{01}) \\\\\n\t\t\\vdots \\\\\n\t\tf'(x_{0m})\n\t\\end{pmatrix}\n\t\\odot\n\t\th.\n$$\n\nВ последнем выражении происходит покомпонентное умножение:\n\n$$\\color{#348FEA}{\\big[D_{x_0} f\\big]} (h) = f'(x_0) \\odot h = h \\odot f'(x_0)\n$$\n\n2. $f(X) = XW$, где $X$ и $W$ — матрицы. Тогда\n\n$$f(X_0 + H) - f(X_0) = (X_0 + H) W - X_0 W = H W,\n$$\n\nто есть\n\n$$\\color{#348FEA}{\\big[D_{X_0} f\\big]} (H) = H W\n$$\n\n3. $f(W) = XW$, где $X$ и $W$ — матрицы. Тогда\n\n$$f(W_0 + H) - f(W_0) = X(W_0 + H) - XW_0 = X H,\n$$\n\nто есть\n\n$$\\color{#348FEA}{\\big[D_{W_0} f\\big]} (H) = X H\n$$\n\n4. $f(x) = (f_1(x),\\ldots,f_K(x))$ — вектор-строка, $x = (x_1,\\ldots,x_D)$ — вектор-строка. Тогда\n\n$$\\color{#348FEA}{\\big[D_{x_0} f\\big]}(h)\n= \\left(\\sum_j \n\\left. \n\t\\frac{\\partial f_1}{\\partial y_j} \n\t\\right|_{y=x_0}h_j, \\ldots, \\sum_j \\left. \\frac{\\partial f_K}{\\partial y_j} \\right|_{y=x_0}h_j \\right) =\n$$\n\n$$= h \\cdot \n\\begin{pmatrix} \n\t\\left.\n\t\t\\frac{\\partial f_1}{\\partial y_1}\n\t\\right|_{y=x_0} & \\ldots & \n\t\\left.\n\t\t\\frac{\\partial f_k}{\\partial y_1}\n\t\\right|_{y=x_0} \\\\\n\t\\vdots & & \\vdots \\\\\n\t\\left.\n\t\t\\frac{\\partial f_1}{\\partial y_D}\n\t\\right|_{y=x_0} & \\ldots & \n\t\\left.\n\t\t\\frac{\\partial f_k}{\\partial y_D}\n\t\\right|_{y=x_0}\\\\\n\\end{pmatrix}\n= h \\cdot \n\\left.\n\t\\frac{\\partial f}{\\partial y}\\right|_{y = x_0}\n$$\n\nМатрица, выписанная в предпоследней выкладке, — это знакомая вам из курса матанализа матрица Якоби.\n\n{% endcut %}\n\n## Простые примеры и свойства матричного дифференцирования\n\n1. **Производная константы.** Пусть $f(x) = a$. Тогда\n\n   $$f(x_0 + h) - f(x_0) = 0,\n   $$\n   \n   то есть $\\color{#348FEA}{\\big[D_{x_0} f\\big]}$ — это нулевое отображение. А если $f$ — скалярная функция, то и $\\color{#FFC100}{\\nabla_{x_0} f} = 0.$\n\n2. **Производная линейного отображения.** Пусть $f(x)$ — линейное отображение. Тогда\n\n   $$f(x_0 + h) - f(x_0) = f(x_0) + f(h) - f(x_0) = f(h)\n   $$\n   \n   Поскольку справа линейное отображение, то по определению оно и является дифференциалом $\\color{#348FEA}{\\big[D_{x_0} f\\big]}$. Мы уже видели примеры таких ситуаций выше, когда рассматривали отображения умножения на матрицу слева или справа. Если $f$ — (скалярная) линейная функция, то она представляется в виде $\\langle a, v\\rangle$ для некоторого вектора $a$ — он и будет градиентом $f$.\n\n3. **Линейность производной.** Пусть $f(x) = \\lambda u(x) + \\mu v(x)$, где $\\lambda, \\mu$ — скаляры, а $u, v$ — некоторые отображения, тогда\n\n   $$\\color{#348FEA}{\\big[D_{x_0} f\\big]} = \\lambda \\color{#348FEA}{\\big[D_{x_0} u\\big]} + \\mu \\color{#348FEA}{\\big[D_{x_0} v\\big]}\n   $$\n   \n   \n\n{% cut \"Попробуйте доказать сами, прежде чем смотреть доказательство. \" %}\n\n$$f(x_0 + h) - f(x_0) = (\\lambda u(x_0 + h) + \\mu v(x_0 + h)) - (\\lambda u(x_0) + \\mu v(x_0)) =\n$$\n\n$$= \\lambda(u(x_0 + h) - u(x_0)) + \\mu(v(x_0 + h) - v(x_0)) \\approx \n$$\n\n$$\\approx \\lambda \\color{#348FEA}{\\big[D_{x_0} u\\big]}(h) + \\mu \\color{#348FEA}{\\big[D_{x_0} v\\big]}(h)\n$$\n\n{% endcut %}\n\n4. **Производная произведения.** Пусть $f(x) = u(x) v(x)$, где $u, v$ — некоторые отображения, тогда\n\n   $$\\color{#348FEA}{\\big[D_{x_0} f\\big]} = \\color{#348FEA}{\\big[D_{x_0} u\\big]} \\cdot v(x_0) + u(x_0) \\cdot \\color{#348FEA}{\\big[D_{x_0} v\\big]}\n   $$\n   \n   \n\n{% cut \"Попробуйте доказать сами, прежде чем смотреть доказательство.\" %}\n\nОбозначим для краткости $x = x_0 + h$. Тогда\n\n$$u(x)v(x) - u(x_0)v(x_0) = u(x)v(x) - u(x_0)v(x) + u(x_0)v(x) - u(x_0)v(x_0) =\n$$\n\n$$(u(x) - u(x_0))v(x) + u(x_0)(v(x) - v(x_0))\\approx \n$$\n\n$$\\approx \\color{#348FEA}{\\big[D_{x_0} u\\big]}(h) \\cdot v(x) + u(x_0)\\cdot \\color{#348FEA}{\\big[D_{x_0} v\\big]}(h)\n$$\n\nИ всё бы хорошо, да в первом слагаемом $v(x)$ вместо $v(x_0)$. Придётся разложить ещё разок:\n\n$$\\color{#348FEA}{\\big[D_{x_0} u\\big]}(h) \\cdot v(x) \\approx \n$$\n\n$$\\color{#348FEA}{\\big[D_{x_0} u\\big]}(h) \\cdot \\left(v(x_0) + \\color{#348FEA}{\\big[D_{x_0} v\\big]}(h) + o(\\vert\\vert h\\vert\\vert)\\right) =\n$$\n\n$$\\color{#348FEA}{\\big[D_{x_0} u\\big]}(h) \\cdot v(x_0) + \\bar{\\bar{o}}\\left(\\vert\\vert h\\vert\\vert\\right)\n$$\n\n{% endcut %}\n\nЭто же правило сработает и для скалярного произведения:\n\n$$\\color{#348FEA}{\\big[D_{x_0} \\langle u, v\\rangle\\big]} = \\langle\\color{#348FEA}{\\big[D_{x_0} u\\big]}, v\\rangle + \\langle u, \\color{#348FEA}{\\big[D_{x_0} v\\big]}\\rangle$$\n\nВ этом нетрудно убедиться, повторив доказательство или заметив, что в доказательстве мы пользовались лишь дистрибутивностью (= билинейностью) умножения.\n\n\n5. **Производная сложной функции.** Пусть $f(x) = u(v(x))$. Тогда\n\n   $$f(x_0 + h) - f(x_0) = u(v(x_0 + h)) - u(v(x_0)) \\approx \n   $$\n   \n   $$\\approx\\left[D_{v(x_0)} u \\right] (v(x_0 + h) - v(x_0)) \\approx \\left[D_{v(x_0)} u \\right] \\left( \\left[D_{x_0} v\\right] (h)\\right)\n   $$\n   \n   Здесь $D_{v(x_0)} u$ — дифференциал $u$ в точке $v(x_0)$, а $\\left[D_{v(x_0)} u \\right]\\left(\\ldots\\right)$ — это применение отображения $\\left[D_{v(x_0)} u \\right]$ к тому, что в скобках. Итого получаем:\n\n   $$\\left[D_{x_0} \\color{#5002A7}{u} \\circ \\color{#4CB9C0}{v} \\right](h) = \\color{#5002A7}{\\left[D_{v(x_0)} u \\right]} \\left( \\color{#4CB9C0}{\\left[D_{x_0} v\\right]} (h)\\right)\n   $$\n   \n   \n\n6. Важный частный случай: **дифференцирование перестановочно с линейным отображением**. Пусть $f(x) = L(v(x))$, где $L$ — линейное отображение. Тогда $\\left[D_{v(x_0)} L \\right]$ совпадает с самим $L$ и формула упрощается:\n\n   $$\\left[D_{x_0} \\color{#5002A7}{L} \\circ \\color{#4CB9C0}{v} \\right](h) = \\color{#5002A7}{L} \\left( \\color{#4CB9C0}{\\left[D_{x_0} v\\right]} (h)\\right)\n   $$\n   \n   \n\n## Простые примеры вычисления производной\n\n* Вычислим дифференциал и градиент функции $f(x) = \\langle a, x\\rangle$, где $x$ — вектор-столбец, $a$ — постоянный вектор.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение.\" %}\n\nВычислить производную можно непосредственно:\n\n$$f(x_0 + h) - f(x_0) = \\langle a, x_0 + h\\rangle - \\langle a, x_0\\rangle = \\langle a, h\\rangle\n$$\n\nНо можно и воспользоваться формулой дифференциала произведения:\n\n$$\\color{#348FEA}{\\big[D_{x_0} \\langle a, x\\rangle\\big]} (h) = \n$$\n\n$$=\\langle\\color{#348FEA}{\\big[D_{x_0} a\\big]}(h), x\\rangle + \\langle a, \\color{#348FEA}{\\big[D_{x_0} x\\big]}(h)\\rangle\n$$\n\n$$= \\langle 0, x\\rangle + \\langle a, h\\rangle = \\langle a, h\\rangle\n$$\n\nСразу видно, что градиент функции равен $a$.\n\n{% endcut %}\n\n* Вычислим производную и градиент $f(x) = \\langle Ax, x\\rangle$, где $x$ — вектор-столбец, $A$ — постоянная матрица.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение. \" %}\n\nСнова воспользуемся формулой дифференциала произведения:\n\n$$\\color{#348FEA}{\\big[D_{x_0} \\langle Ax, x\\rangle\\big]}(h) = \n$$\n\n$$= \\langle\\color{#348FEA}{\\big[D_{x_0} Ax\\big]}(h), x_0\\rangle + \\langle Ax_0, \\color{#348FEA}{\\big[D_{x_0} x\\big]}(h)\\rangle\n$$\n\n$$= \\langle Ah, x_0\\rangle + \\langle Ax_0, h\\rangle\n$$\n\nЧтобы найти градиент, нам надо это выражение представить в виде $\\langle ?, h\\rangle$. Для этого поменяем местами множители первого произведения и перенесём $A$ в другую сторону ($A$ перенесётся с транспонированием):\n\n$$\\langle A^Tx_0, h\\rangle + \\langle Ax_0, h\\rangle = \n$$\n\n$$= \\langle (A^T + A)x_0, h\\rangle\n$$\n\nПолучается, что градиент в точке $x_0$ равен $(A^T + A)x_0$.\n\n{% endcut %}\n\n* Вычислим производную обратной матрицы: $f(X) = X^{-1}$, где $X$ — квадратная матрица.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение. \" %}\n\nРассмотрим равенство $I = X\\cdot X^{-1} = I$ и продифференцируем его:\n\n$$0 = \\color{#348FEA}{\\big[D_{X_0} \\left( X\\cdot X^{-1}\\right)\\big]}(H) = \n$$\n\n$$= \\color{#348FEA}{\\big[D_{X_0} X\\big]}(H)\\cdot X_0^{-1} + X_0\\cdot \\color{#348FEA}{\\big[D_{X_0} X^{-1}\\big]}(H)\n$$\n\nОтсюда уже легко выражается\n\n$$\\color{#348FEA}{\\big[D_{X_0} X^{-1}\\big]}(H) = -X_0^{-1}\\cdot\\color{#348FEA}{\\big[D_{X_0} X\\big]}(H)\\cdot X_0^{-1}\n$$\n\nОсталось подставить $\\color{#348FEA}{\\big[D_{X_0} X\\big]}(H) = H$, но запомните и предыдущую формулу, она нам пригодится.\n\n{% endcut %}\n\n* Вычислим градиент определителя: $f(X) = \\text{det}(X)$, где $X$ — квадратная матрица.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение. \" %}\n\nВ предыдущих примерах мы изо всех сил старались не писать матричных элементов, но сейчас, увы, придётся. Градиент функции состоит из её частных производных: $\\color{#FFC100}{\\nabla_{x_0} f} = \\left(\\frac{\\partial f}{\\partial{x_{ij}}}\\right)_{i,j}$. Попробуем вычислить $\\frac{\\partial f}{\\partial{x_{ij}}}$. Для этого разложим определитель по $i$-й строке:\n\n$$\\text{det}(X) = \\sum_{k}x_{ik}\\cdot(-1)^{i + k}M_{ik},\n$$\n\nгде $M_{ik}$ — это определитель подматрицы, полученной из исходной выбрасыванием $i$-й строки и $k$-го столбца. Теперь мы видим, что определитель линеен по переменной $x_{ij}$, причём коэффициент при ней равен $\\cdot(-1)^{i + k}M_{ik}$. Таким образом,\n\n$$\\frac{\\partial f}{\\partial{x_{ij}}} = (-1)^{i + k}M_{ik}\n$$\n\nЧтобы записать матрицу, составленную из таких определителей, покороче, вспомним, что\n\n$$X^{-1} = \\frac1{\\text{det}(X)}\\left((-1)^{i+j}M_{\\color{red}{ji}}\\right)_{i,j}\n$$\n\nОбратите внимание на переставленные индексы $i$ и $j$ (отмечены красным). Но всё равно похоже! Получается, что\n\n$$\\color{#FFC100}{\\nabla_{x_0} f} = \\text{det}(X)\\cdot X^{-T},\n$$\n\nгде $X^{-T}$ — это более короткая запись для $(X^{-1})^T$.\n\n{% endcut %}\n\n* Вычислим градиент функции $f(x) = \\vert\\vert Ax - b\\vert\\vert^2$. С этой функцией мы ещё встретимся, когда будем обсуждать задачу линейной регрессии.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение. \" %}\n\nРаспишем квадрат модуля в виде скалярного произведения:\n\n$$\\vert\\vert Ax - b\\vert\\vert^2 = \\langle Ax - b, Ax - b\\rangle\n$$\n\nПрименим формулу дифференциала произведения и воспользуемся симметричностью скалярного произведения:\n\n$$\\color{#348FEA}{\\big[D_{x_0} \\langle Ax - b, Ax - b\\rangle\\big]}(h) = \n$$\n\n$$\\langle \\color{#348FEA}{\\big[D_{x_0} (Ax - b)\\big]}(h), Ax_0 - b\\rangle + \\langle Ax_0 - b, \\color{#348FEA}{\\big[D_{x_0} (Ax - b)\\big]}(h)\\rangle\n$$\n\n$$= 2\\langle Ax_0 - b, \\color{#348FEA}{\\big[D_{x_0} (Ax - b)\\big]}(h)\\rangle =\n$$\n\n$$= 2\\langle Ax_0 - b, Ah\\rangle = \\langle 2A^T(Ax_0 - b), h\\rangle\n$$\n\nПолучаем, что\n\n$$\\color{#FFC100}{\\nabla_{x_0} f} = 2A^T(Ax_0 - b)\n$$\n\n{% endcut %}\n\n## Примеры вычисления производных сложных функций\n\n* Вычислим градиент функции $f(X) = \\text{log}(\\text{det}(X))$.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение. \" %}\n\nВспомним формулу производной сложной функции:\n\n$$\\left[D_{X_0} u \\circ v \\right](H) = \\left[D_{v(X_0)} u \\right] \\left( \\left[D_{X_0} v\\right] (H)\\right)\n$$\n\nи посмотрим, как её тут можно применить. В роли функции $u$ у нас логарифм:\n\n$$u(y) = \\text{log}(u),\\quad \\left[D_{y_0} u\\right](s) = \\frac1y_0\\cdot s,\n$$\n\nа в роли $v$ — определитель:\n\n$$v(X) = \\text{det}(X),\\quad \\left[D_{y_0} v\\right](H) = \\langle \\text{det}(X_0)\\cdot X_0^{-T}, H\\rangle,\n$$\n\nгде под скалярным произведением двух матриц понимается, как обычно,\n\n$$\\langle A, B\\rangle = \\sum_{i,j}a_{ij}b_{ij} = \\text{tr}(A^TB)\n$$\n\nПодставим это всё в формулу произведения сложной функции:\n\n$$\\left[D_{X_0} u \\circ v \\right](H) = \\frac1{\\text{det}(X)}\\cdot\\langle \\text{det}(X)\\cdot X^{-T}, H\\rangle =\n$$\n\n$$= \\langle \\frac1{\\text{det}(X)}\\cdot\\text{det}(X)\\cdot X^{-T}, H\\rangle =\n\\langle X_0^{-T}, H\\rangle$$\n\nОтсюда сразу видим, что\n\n$$\\color{#FFC100}{\\nabla_{X_0} f} = X_0^{-T}\n$$\n\n{% endcut %}\n\n* Вычислим градиент функции $f(X) = \\text{tr}(AX^TX)$.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение.\" %}\n\nВоспользуемся тем, что след — это линейное отображение (и значит, перестановочно с дифференцированием), а также правилом дифференцирования сложной функции:\n\n$$\\left[D_{X_0} f \\right](H) = \\text{tr}\\left(\\left[D_{X_0} AX^TX \\right](H)\\right) =\n$$\n\n$$=\\text{tr}\\left(A\\cdot\\left[D_{X_0} X^T \\right](H)\\cdot X_0 + AX_0^T\\left[D_{X_0} X \\right](H)\\right) =\n$$\n\n$$=\\text{tr}\\left(AH^TX_0 + AX_0^TH\\right)\n$$\n\nЧтобы найти градиент, мы должны представить это выражение в виде $\\langle ?, H\\rangle$, что в случае матриц переписывается, как мы уже хорошо знаем, в виде $\\text{tr}(?^T\\cdot H) = \\text{tr}(?\\cdot H^T)$. Воспользуемся тем, что под знаком следа можно транспонировать и переставлять множители по циклу:\n\n$$\\ldots=\\text{tr}\\left(AH^TX_0\\right) + \\text{tr}\\left(AX_0^TH\\right) =\n$$\n\n$$=\\text{tr}\\left(X_0AH^T\\right) + \\text{tr}\\left(H^TX_0A^T\\right) =\n$$\n\n$$=\\text{tr}\\left(X_0AH^T\\right) + \\text{tr}\\left(X_0A^TH^T\\right) =\n$$\n\n$$=\\text{tr}\\left((X_0A + X_0A^T)H^T\\right)\n$$\n\nСтало быть,\n\n$$\\color{#FFC100}{\\nabla_{X_0} f} = X_0A + X_0A^T\n$$\n\n{% endcut %}\n\n* Вычислим градиент функции $f(X) = \\text{det}\\left(AX^{-1}B\\right)$.\n\n{% cut \"Подумайте, почему мы не можем расписать определитель в виде произведения определителей\" %}\n\nРасписать у нас может не получиться из-за того, что $A$ и $B$ могут быть не квадратными, и тогда у них нет определителей и представить исходный определитель в виде произведения невозможно.\n\nВоспользуемся правилом дифференцирования сложной функции для $u(Y) = \\text{det}(Y)$, $v(X) = AX^{-1}B$. А для этого сначала вспомним, какие дифференциалы у них самих. С функцией $u$ всё просто:\n\n$$\\left[D_{Y_0} u\\right](S) = \\langle \\text{det}(Y_0)Y_0^{-T}, S\\rangle =\n$$\n\n$$= \\text{tr}\\left(\\text{det}(Y_0)Y_0^{-1}S\\right)\n$$\n\nФункция $v$ сама является сложной, но, к счастью, множители $A$ и $B$ выносятся из-под знака дифференциала, а дифференцировать обратную матрицу мы уже умеем:\n\n$$\\left[D_{X_0} v\\right](H) = - AX_0^{-1}HX_0^{-1} B\n$$\n\nС учётом этого получаем:\n\n$$\\left[D_{X_0} f \\right](H) = \\left[D_{v(X_0)} u \\right] \\left( \\left[D_{X_0} v\\right] (H)\\right) =\n$$\n\n$$=\\text{tr}\\left(\\text{det}(AX_0^{-1}B)(AX_0^{-1}B)^{-1}\\left(- AX_0^{-1}HX_0^{-1} B\\right)\\right)\n$$\n\n$$=\\text{tr}\\left(-\\text{det}(AX_0^{-1}B)(AX_0^{-1}B)^{-1}AX_0^{-1}HX_0^{-1} B\\right)\n$$\n\nЧтобы найти градиент, мы должны, как обычно, представить это выражение в виде $\\text{tr}(?^T\\cdot H)$.\n\n$$\\ldots=\\text{tr}\\left(-\\text{det}(AX_0^{-1}B)X_0^{-1} B(AX_0^{-1}B)^{-1}AX_0^{-1}H\\right)\n$$\n\nСтало быть,\n\n$${\\nabla_{X_0} f} = \\left(-\\text{det}(AX_0^{-1}B)X_0^{-1} B(AX_0^{-1}B)^{-1}AX_0^{-1}\\right)^T =\n$$\n\n$$=-\\text{det}(AX_0^{-1}B)X_0^{-T} A^T(AX_0^{-1}B)^{-T}B^TX_0^{-T}\n$$\n\n{% endcut %}\n\n## Вторая производная\n\nРассмотрим теперь не первые два, а первые три члена ряда Тейлора:\n\n$$f(x_0 + h) = f(x_0) + \\color{#348FEA}{\\left[D_{x_0} f \\right]} (h) + \\frac12\\color{#4CB9C0}{\\left[D_{x_0}^2 f \\right]} (h, h) + \\bar{\\bar{o}} \\left(\\left|\\left| h\\right|\\right|^2\\right),\n$$\n\nгде $\\color{#4CB9C0}{\\left[D_{x_0}^2 f \\right]} (h, h)$ — второй дифференциал, квадратичная форма, в которую мы объединили все члены второй степени.\n\n**Вопрос на подумать.** Докажите, что второй дифференциал является дифференциалом первого, то есть\n\n$$\\left[D_{x_0} \\color{#348FEA}{\\left[D_{x_0} f \\right]} (h_1) \\right] (h_2) = \\left[D_{x_0}^2 f \\right] (h_1, h_2)\n$$\n\nЗависит ли выражение справа от порядка $h_1$ и $h_2$?\n\nЭтот факт позволяет вычислять второй дифференциал не с помощью приращений, а повторным дифференцированием производной.\n\nВторая производная может оказаться полезной при реализации методов второго порядка или же для проверки того, является ли критическая точка (то есть точка, в которой градиент обращается в ноль) точкой минимума или точкой максимума. Напомним, что квадратичная форма $q(h)$ называется положительно определённой (соответственно, отрицательно определённой), если $q(h) \\geqslant 0$ (соответственно, $q(h) \\leqslant 0$) для всех $h$, причём $q(h) = 0$ только при $h = 0$.\n\n**Теорема.** Пусть функция $f:\\mathbb{R}^m\\rightarrow\\mathbb{R}$ имеет непрерывные частные производные второго порядка $\\frac{\\partial^2 f}{\\partial x_i\\partial x_j}$ в окрестности точки $x_0$, причём $\\color{#FFC100}{\\nabla_{x_0} f} = 0$. Тогда точка $x_0$ является точкой минимума функции, если квадратичная форма $\\color{#348FEA}{D_{x_0}^2 f}$ положительно определена, и точкой максимума, если она отрицательно определена.\n\nЕсли мы смогли записать матрицу квадратичной формы второго дифференциала, то мы можем проверить её на положительную или отрицательную определённость с помощью [критерия Сильвестра](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B9_%D0%A1%D0%B8%D0%BB%D1%8C%D0%B2%D0%B5%D1%81%D1%82%D1%80%D0%B0).\n\n## Примеры вычисления и использования второй производной\n\n* Рассмотрим задачу минимизации $f(x) = \\vert\\vert Ax - b\\vert\\vert^2$ по переменной $x$, где $A$ — матрица с линейно независимыми столбцами. Выше мы уже нашли градиент этой функции; он был равен $\\color{#FFC100}{\\nabla_{x_0} f} = 2A^T(Ax - b)$. Мы можем заподозрить, что минимум достигается в точке, где градиент обращается в ноль: $x_* = (A^TA)^{-1}A^Tb$. Отметим, что обратная матрица существует, так как $\\text{rk}(A^TA) = \\text{rk}{A}$, а столбцы $A$ по условию линейно независимы и, следовательно, $\\text{rk}(A^TA)$ равен размеру этой матрицы. Но действительно ли эта точка является точкой минимума? Давайте оставим в стороне другие соображения (например, геометрические, о которых мы упомянем в параграфе про [линейные модели](https://education.yandex.ru/handbook/ml/article/linear-models)) и проверим аналитически. Для этого мы должны вычислить второй дифференциал функции $f(x) = \\vert\\vert Ax - b\\vert\\vert^2$.\n\n{% cut \"Попробуйте вычислить сами, прежде чем смотреть решение.\" %}\n\nВспомним, что\n\n$$\\color{#348FEA}{\\big[D_{x_0} \\vert\\vert Ax - b\\vert\\vert^2\\big]}(h_1) = \\langle 2A^T(Ax_0 - b), h_1\\rangle\n$$\n\nПродифференцируем снова. Скалярное произведение — это линейная функция, поэтому можно занести дифференцирование внутрь:\n\n$$\\color{#348FEA}{\\big[D_{x_0} \\langle 2A^T(Ax - b), h_1\\rangle\\big]}(h_2) = \n\\langle \\color{#348FEA}{\\big[D_{x_0} (2A^TAx - 2A^Tb)\\big]}(h_2), h_1\\rangle =$$\n\n$$=\\langle 2A^TAh_2, h_1\\rangle = 2h_2^T A^TA h_1\n$$\n\n{% endcut %}\n\nМы нашли квадратичную форму второго дифференциала; она, оказывается, не зависит от точки (впрочем, логично: исходная функция была второй степени по $x$, так что вторая производная должна быть константой). Чтобы показать, что $x_*$ действительно является точкой минимума, достаточно проверить, что эта квадратичная форма положительно определена.\n\n{% cut \"Попробуйте сделать это сами, прежде чем смотреть решение.\" %}\n\nХорошо знакомый с линейной алгеброй читатель сразу скажет, что матрица $A^TA$ положительно определена для матрицы $A$ с линейно независимыми столбцами. Но всё же давайте докажем это явно. Имеем $h^TA^TAh = (Ah)^TAh = \\vert\\vert Ah\\vert\\vert^2 \\geqslant 0$. Это выражение равно нулю тогда и только тогда, когда $Ah = 0$. Последнее является однородной системой уравнений на $h$, ранг которой равен числу переменных, так что она имеет лишь нулевое решение $h = 0$.\n\n{% endcut %}\n\n* Докажем, что функция $f(X) = \\log{\\text{det}(X)}$ является выпуклой вверх на множестве симметричных, положительно определённых матриц. Для этого мы должны проверить, что в любой точке квадратичная форма её дифференциала отрицательно определена. Для начала вычислим эту квадратичную форму.\n\n{% cut \"Попробуйте сделать это сами, прежде чем смотреть решение.\" %}\n\nВыше мы уже нашли дифференциал этой функции:\n\n$$\\color{#348FEA}{\\big[D_{X_0} \\log{\\text{det}(X)}\\big]}(H_1) = \\langle X_0^{-T}, H_1\\rangle\n$$\n\nПродифференцируем снова:\n\n$$\\color{#348FEA}{\\big[D_{X_0} \\langle X^{-T}, H_1\\rangle\\big]}(H_2) = \n\\langle \\color{#348FEA}{\\big[D_{x_0} X^{-T}\\big]}(H_2), h_1\\rangle =$$\n\n$$=\\langle -X_0^{-1}H_2X_0^{-1}, H_1\\rangle\n$$\n\n{% endcut %}\n\nЧтобы доказать требуемое в условии, мы должны проверить следующее: что для любой симметричной матрицы $X_0$ и для любого симметричного (чтобы не выйти из пространства симметричных матриц) приращения $H\\ne 0$ имеем\n\n$$\\color{#348FEA}{\\big[D^2_{X_0} \\log{\\text{det}(X)}\\big]}(H, H) < 0\n$$\n\nПокажем это явно.\nТак как $X_0$ — симметричная, положительно определённая матрица, у неё есть симметричный и положительно определённый квадратный корень: $X_0 = X_0^{1/2}\\cdot X_0^{1/2} = X_0^{1/2}\\cdot \\left(X_0^{1/2}\\right)^T.$ Тогда\n\n$$\\langle -X_0^{-1}HX_0^{-1}, H\\rangle = -\\text{tr}\\left(X_0^{1/2} \\left(X_0^{1/2}\\right)^THX_0^{1/2} \\left(X_0^{1/2}\\right)^TH^T\\right) =\n$$\n\n$$-\\text{tr}\\left(\\left(X_0^{1/2}\\right)^THX_0^{1/2} \\left(X_0^{1/2}\\right)^TH^TX_0^{1/2}\\right) = \n$$\n\n$$=-\\text{tr}\\left( \\left(X_0^{1/2}\\right)^THX_0^{1/2} \\left[\\left(X_0^{1/2}\\right)^THX_0^{1/2}\\right]^T\\right) =\n$$\n\n$$=-\\vert\\vert\\left(X_0^{1/2}\\right)^THX_0^{1/2}\\vert\\vert^2,\n$$\n\nчто, конечно, меньше нуля для любой ненулевой $H$.",
        "handbook": "Учебник по машинному обучению",
        "title": "Матричное дифференцирование",
        "description": "Как дифференцировать матрицы и дифференцировать по матрицам: всё, что вам не рассказали про дифференцирование на матанализе"
    },
    {
        "path": "/handbook/ml/article/matrichnaya-faktorizaciya",
        "content": "Если наш датасет таков, что все признаки целочисленные и вещественные, нет пропущенных значений и других приятных сюрпризов, то матрица объекты-признаки — это просто матрица, к которой можно пробовать применять инструменты из линейной алгебры, а среди таковых весьма полезными оказываются матричные разложения, то есть различные способы представить матрицу в виде произведения двух или более матриц, обычно специального вида. Такие разновидности, как LU-разложение, QR-разложение, разложение Холецкого вы несомненно встретите, если откроете код любой библиотеки численной линейной алгебры, но суждено ли матричным разложениям играть роль только лишь винтиков и шестерёнок, запрятанных внутри инструментов машинного обучения, или какие-то из них и сами по себе могут помочь вам анализировать данные? На этот вопрос мы попробуем ответить в данном разделе. Но прежде, чем переходить к конкретным методам, мы разберёмся, к каким моделям данных можно прийти, разложив матрицу в произведение.\n\n## Итак, я разложил матрицу в произведения — и что же?\n\nПредположим, что нашу матрицу объекты-признаки $X$ мы представили в виде произведения (или, более общно, приблизили в каком-либо смысле таким произведением):\n\n$$\\underset{N\\times D}{\\operatorname{X}} \\sim \\underset{N\\times R}{\\operatorname{B}} \\cdot \\underset{R\\times D}{\\operatorname{C}}\n$$\n\nгде внизу указаны размеры матриц (то есть в нашем датасете $N$ объектов и $D$ признаков). Что это может означать?\n\n### Смесь признаков\n\nМы считаем, что каждый из $D$ признаков нашего исходного датасета — это смесь (то есть линейная комбинация) $R$ скрытых (латентных) признаков:\n\n![Decomp1](https://yastatic.net/s3/education-portal/media/Decomp1_52765565e1_37afa1aa3e_f31c5aa293.svg)\n\nПо сути это одна из самых простых моделей с латентными переменными, в которой исходные признаки выражаются через латентные линейным образом. Если $R < D$, то мы получаем приближённое описание нашего датасета с помощью меньшего количества признаков. На уровне объектов каждый объект $x_i$ ($D$-мерная строка) приобретает <span style=\"color:blue\">латентное представление</span> $z_i$ ($R$-мерная строка), с которой он связан соотношением $x_i = z_i\\color{green}{C}$. Мы можем представлять, что наши объекты $x_i$ представляют из себя не $D$-мерное облако, а лежат на некоторой $R$-мерной плоскости; переходя к $R$-мерным представлениям $z_i$, мы обнажаем эту структуру.\n\nТочность аппроксимации можно измерять по-разному; наиболее популярной (в силу вычислительной простоты) является норма Фробениуса $| A |*{fro}^2  = \\sum\\limits* A_{i j}^2 = \\operatorname{tr}(A^TA)$  — соответствующую модель называют <span style=\"color:blue\"> анализом главных компонент, или PCA (Principal Component Analysis)</span>.\n\n### Понижение размерности признакового пространства\n\nМы можем захотеть описать наш датасет меньшим чем $D$ количеством признаков (а может быть, и вообще каким-то весьма маленьким). У нас может быть несколько причин для этого, например:\n\n* Признаков очень много, и мы боимся, что обучение на них будет занимать очень много времени или что в процессе обучения нам потребуется слишком много оперативной памяти;\n\n* Мы считаем, что в данных есть шум или что часть признаков связаны соотношением приближённой линейной зависимости — иными словами, мы уверены, что значительную часть информации можно закодировать меньшим числом признаков\n\nМы уже обсуждали, что это можно получить, построив приближённое разложение:\n\n$$\\underset{N\\times D}{\\operatorname{X}} \\sim \\underset{N\\times T}{\\operatorname{B}} \\cdot \\underset{T\\times D}{\\operatorname{C}}\n$$\n\n*Математика помогает*. Матрица имеет ранг $T$ тогда и только тогда, когда она представляется в виде\n$\\underset{Ntimes S}{\\operatorname{B}}\\cdot\\underset{S\\times D}{\\operatorname{C}}$ для $S = T$\nи не представляется в таком виде для меньших $S$.\n\nДоказывать это мы не будем, но подметим, что <span style=\"color:blue\"> приблизить датасет линейной смесью $T$ признаков — это то же самое, что приблизить матрицу $X$ матрицей $\\hat{X}$ ранга $T$ </span>.\n\n*Качество приближения.* Нам, конечно же, хочется, чтобы приближение было наилучшим — скажем, в том смысле, чтобы разность $X - BC$ была минимальной в каком-либо смысле. Можно предложить много разных метрик; остановимся на двух:\n\n* <span style=\"color:blue\"> Норма Фробениуса.</span>\n  Представим, что матрица $A = (X - BC)$ — это просто вектор из $N\\times D$ чисел, который зачем-то записали в виде прямоугольной таблицы. Тогда его норму можно записать в виде\n\n  $$\\|A\\|_{fro} = \\sqrt{\\sum\\limits_{i,j}a_{ij}^2} = \\sqrt{\\mathrm{tr}\\left(A^TA\\right)}\n  $$\n  \n  Эту норму (а точнее, её квадрат) легко оптимизировать.\n\n* <span style=\"color:blue\">Операторная  $l_2$-норма.</span>\n  Вычислять её тяжко, а уж оптимизировать вообще непонятно как, зато звучит круто. Идея в том, что отображения можно сравнивать в зависимости от того, как оно действует на векторы: чем больше оно умеет удлинять векторы — тем оно «больше»:\n\n  $$\\|A\\|_2 = \\sup \\left\\{ \\frac{\\vert Av \\vert}{\\vert v \\vert} \\mid v \\in\\mathbb{R}^D \\right\\}\n  $$\n  \n  Поскольку $\\frac{\\vert A(\\lambda v)\\vert}{\\vert \\lambda v \\vert} = \\frac{\\vert Av \\vert}{ \\vert v \\vert}$, достаточно брать супремум только по векторам единичной длины, то есть по единичной сфере. Так как это компакт, непрерывная функция $v\\mapsto \\vert Av \\vert$ достигает на нём своего максимального значения, то есть мы можем переписать\n\n  $$\\|A\\|_2 = \\sup \\left\\{ \\vert Av \\vert \\mid v\\in\\mathbb{R}^D,\\,\\vert v \\vert = 1 \\right\\}\n  $$\n  \n  \n\n#### Смесь объектов\n\nМы считаем, что каждый из $N$ объектов нашего исходного датасета — смесь (то есть линейная комбинация) $R$ скрытых объектов:\n\n![Decomp2](https://yastatic.net/s3/education-portal/media/Decomp2_cc106ea2fc_080a85b20f_5989f3a2a7.svg)\n\nТакая интерпретация может быть полезна, например, в ситуации, когда объекты — это записи с каждого из нескольких микрофонов в помещении, признаки — фреймы, а скрытые объекты — это голоса отдельных людей.\n\nТакже данную модель можно интерпретировать как что-то вроде поиска типичных объектов.\n\n#### Отдельные представления для объектов и признаков\n\nЭту интерпретацию лучше всего пояснить на примере. Пусть объекты нашего датасета соответствуют пользователям интернет-магазина, а признаки — товарам, причём в клетке с индексом $(i,j)$ записана единица, если пользователь интересовался товаром, и ноль — если нет (или, в более общей ситуации, рейтинги, которые пользователи ставят товарам).\n\n![Decomp3](https://yastatic.net/s3/education-portal/media/Decomp3_888ac5c12c_68549dfd4d_6d674d650e.svg)\n\nПри перемножении матриц $B$ и $C$ на $(i, j)$-м месте произведении стоит скалярное произведение $i$-й строки $B$ и $j$-го столбца $C$. Таким образом, степень релевантности товара пользователю моделируется скалярным произведением (напрашивается сравнение с косинусным расстоянием) вектора, представляющего $i$-го пользователя, и вектора, представляющего $j$-й товар.\n\n$$\\begin{array}{l}\nX_{\\color{red}{i} \\color{green}{j}}=\\color{red}{b_{i 1}} \\color{green}{c_{1 j}} + \\ldots + \\color{red}{b_{i k}} \\color{green}{c_{k j}}= \\\\\n= ( \\color{red}{\\text{i-ый пользователь}}, \\color{green}{ \\text{j-ый товар} })\n\\end{array}\n$$\n\nЗаметим ещё, что $R$ координат вектора, ответчающего пользователю, равно как и $R$ координат вектора, отвечающего товару, можно рассматривать как $R$ латентных признаков, которые в идеальном мире являются интерпретируемыми и характеризуют «сродство» пользователя и товара с некоторым аспектом бытия:\n\n![Decomp6](https://yastatic.net/s3/education-portal/media/Decomp6_8753618149_1ee134fd6f_8446a2b0ef.svg)\n\n### Матрицы в разложении: физический смысл\n\nНо матрицы в разложении обычно не абы какие — так какие из разновидностей могут быть полезны?\n\nВо всех известных вам матричных разложениях к отдельным сомножителям предъявляются определённые требования: симметричность, треугольность, ортогональность — некоторые из них (скажем, симметричность) не имеют физического смысла ни в одной из указанных выше интерпретаций. Но одно оказывается полезным.\n\n### Ковариация и дисперсия признаков\n\nДля начала — и это важно — <span style=\"color:blue\"> предположим, что матрица $X$ центрирована по столбцам</span>, то есть среднее в каждом из столбцов (= признаков) равно нулю (если это не так, то вычтем из каждого столбца его среднее).\n\nТеперь матрица ковариации признаков может быть с точностью до константы оценена как $X^TX$:\n\n![matrix](https://yastatic.net/s3/education-portal/media/matrix_factorization_noname_1_634f8852a9_8bb69c3ed6.svg)\n\nИ мы видим: <span style=\"color:blue\">$i$-й и $j$-й столбцы матрицы $X$ ортогональны тогда и только тогда, когда соответствующие признаки не коррелированы.</span>\n\nПри этом <span style=\"color:blue\">$(i,i)$-й диагональный элемент матрицы $X^TX$ — это дисперсия $i$-го признака.</span>\n\n**Вывод: матрица, ортонормированная по столбцам, отвечает датасету, в котором признаки не коррелированы и имеют единичную дисперсию**\n\n## Сингулярное разложение\n\nС помощью сингулярного разложения можно перейти от $D$ исходных признаков к потенциально небольшому количеству «самых важных» , по-быстрому визуализовать данные или построить простенькую рекомендательную систему. Конечно, глубинные автоэнкодеры, TSNE или DSSM справятся с этим гораздо лучше, но если данных относительно немного или если хочется что-нибудь быстро попробовать «на коленке», старое доброе сингулярное разложение всегда подставит плечо.\n\n### Математическое определение\n\n<span style=\"color:blue\">Сингулярным разложением</span> матрицы $X$ называется разложение\n\n$$X = \\color{orange}{U} \\color{green}{\\Sigma}\\color{magenta}{V^T},\n$$\n\nгде $\\color{orange}{U}$ и $\\color{magenta}{V}$ — матрицы, ортонормированные по столбцам, а $\\color{green}{\\Sigma} = \\mathrm{diag}(\\color{green}{\\sigma_1},\\color{green}{\\sigma_2},\\ldots)$ — диагональная матрица, у которой $\\color{green}{\\sigma_1} \\geqslant \\color{green}{\\sigma_2} \\geqslant \\ldots \\geqslant \\color{green}{\\sigma_R}> \\color{green}{\\sigma_{R+1}}=0$.\n\nЧисла $\\color{green}{\\sigma_i}$ называются $\\color{green}{\\text{сингулярными числами}}$, а столбцы $\\color{orange}{U}$ и $\\color{magenta}{V}$ — $\\color{orange}{\\text{левыми}}$  и $\\color{magenta}{\\text{правыми}}$ сингулярными векторами соответственно (их алгебраический смысл станет ясен чуть ниже).\n\nСингулярное разложение можно записать в полном или в усечённом виде:\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_1_d3b8d5a626_27ab400e29_482e8f4a97.svg)\n\nПара предостережений по поводу ортогональности по столбцам:\n\n$U$ ортогональна по столбцам\n\n$U^TU=E$ (элементы $U^TU$ — скалярные произведения столбцов $U$)\n\nно $UU^T \\neq E$ (не обязательно равно; элементы $UU^T$  — скалярные произведения строк $U$)\n\nЯсно, что хранить полное разложение нет смысла: ведь бесполезные, умножающиеся на нули, блоки будут лишь занимать память.\n\nПо-английски сингулярное разложение называется SVD (singular value decomposition), и мы будем активно использовать эту аббревиатуру.\n\n*Если вы не любите математику, можете пропустить*. С точки зрения математики сингулярное разложение говорит следующее. Пусть $X$ — матрица линейного отображения $\\varphi:\\mathbb{R}^D\\longrightarrow\\mathbb{R}^N$.\n\nТогда найдётся ортонормированый базис $\\color{magenta}{v_1},\\dots,\\color{magenta}{v_D}$ в пространстве $\\mathbb{R}^D$ и ортонормированый базис $\\color{orange}{u_1},\\dots,\\color{orange}{u_N}$ в пространстве $\\mathbb{R}^N$, в которых действие оператора записывается следующим образом:\n\n$$\\begin{align*}\n\\varphi(\\color{magenta}{v_1}) &= \\color{green}{\\sigma_1}\\color{orange}{u_1},\\\\\n\\vdots\\\\\n\\varphi(\\color{magenta}{v_R}) &= \\color{green}{\\sigma_r}\\color{orange}{u_R},\\\\\n\\varphi(\\color{magenta}{v_{R+1}}) &= 0,\\\\\n\\vdots\\\\\n\\varphi(\\color{magenta}{v_D}) &= 0\n\\end{align*}$$\n\n(знатоки функционального анализа могут узнать в этом частный случай теоремы Гильберта-Шмидта).\n\n*Сингулярное разложение и операторная l2-норма*.\nМожно показать, что $\\|\\|A\\|\\|_2$, эта самая операторная l2-норма матрицы, равна $\\sigma_1^2$ — квадрату наибольшего сингулярного числа.\n\n*Сингулярное разложение и норма Фробениуса*. Можно показать, что\n\n$$||A||_{fro} = \\sqrt{\\sum_i\\sigma_i^2}\n$$\n\n{% cut \"Контрольный вопрос.\" %}\n\nЕдинственно ли сингулярное разложение матрицы? Давайте сразу считать, что речь об усечённом разложении.\n\nЕсть очень простой источник неоднозначности: если $\\varphi(\\color{magenta}{v_i}) = \\color{green}{\\sigma_1}\\color{orange}{u_i}$, то и $\\varphi(\\color{magenta}{-v_i}) = \\color{green}{\\sigma_1}\\color{orange}{(-u_i)}$; при этом умножение вектора на $(-1)$ не попортит ортонормированности базиса. Иными словами, мы можем одновременно поменять знаки $i$-х столбцов матриц $\\color{orange}{U}$ и $\\color{magenta}{V}$ (без транспонирования!) без ущерба для разложения.\n\n{% endcut %}\n\nЕсть и более тонкие, хотя и весьма частные, ситуации. Можете ли вы, например, указать несколько различных сингулярных разложений матрицы $E$? Да-да, для неё сингулярное разложение максимально неоднозначно. Можете ли вы теперь придумать не скалярную матрицу, у которой были бы различные SVD, отличающиеся не только знаками столбцов матриц $\\color{orange}{U}$ и $\\color{magenta}{V}$?\n\n### Теоретико-вероятностная интерпретация SVD\n\nЕсли $X =\\color{orange}{U}\\color{green}{\\Sigma} \\color{magenta}{V^T}$ (рассмотрим сейчас не усечённое, а полное разложение, в котором матрицы $\\color{orange}{U}$ и $\\color{magenta}{V}$ квадратные ортогональные), то\n\n$$X^TX = \\color{magenta}{V}\\color{green}{\\Sigma^T}\\underbrace{\\color{orange}{U^T}\\cdot \\color{orange}{U}}_{=E}\\color{green}{\\Sigma} \\color{magenta}{V^T} =\n\\color{magenta}{V}\\color{green}{\\Sigma}^T\\color{green}{\\Sigma} \\color{magenta}{V^T}$$\n\nОтметим, что в рассматриваемой ситуации $\\color{green}{\\Sigma}$ не обязательно квадратная, и поэтому нельзя написать, что $\\color{green}{\\Sigma}^T\\color{green}{\\Sigma}=\\color{green}{\\Sigma}^2$; тем не менее, $\\color{green}{\\Sigma}^T\\color{green}{\\Sigma}$ — это квадратная матрица с числами $\\color{green}{\\sigma_1}^2,\\color{green}{\\sigma_2}^2,\\ldots$ на диагонали.\n\n{% cut \"Контрольный вопрос\" %}\n\nТочно так же мы можем вычислить $XX^T = \\color{orange}{U}^T\\color{green}{\\Sigma}\\color{green}{\\Sigma}^T\\color{orange}{U}$, где опять-таки $\\color{green}{\\Sigma}\\color{green}{\\Sigma}^T$ — квадратная матрица с числами $\\color{green}{\\sigma_1}^2,\\color{green}{\\sigma_2}^2,\\ldots$ на диагонали. И всё бы хорошо, но если $\\color{green}{\\Sigma}$ не квадратная, матрицы $\\color{green}{\\Sigma}^T\\color{green}{\\Sigma}$ и $\\color{green}{\\Sigma}\\color{green}{\\Sigma}^T$ имеют разные размеры. Так в чём же подвох?\n\n{% endcut %}\n\nКак бы то ни было, в (ортогональном!) базисе из (ортогональных!) столбцов $\\color{magenta}{V}$ матрица $X^TX$ приводится к диагональному виду с числами $\\color{green}{\\sigma_1}^2,\\color{green}{\\sigma_2}^2,\\ldots$ на диагонали.\n\nТеперь представим, что наши объекты $x_1,x_2,\\ldots,x_N$ выбраны из $D$-мерного нормального распределения\n\n$$p(x_i) = \\frac{1}{(2\\pi)^{D/2}|C|^{1/2}}e^{-\\frac12(x_i - \\mu)C^{-1}(x_i - \\mu)^T}\n$$\n\nгде $\\mu$ — вектор средних, а $C$ — матрица ковариации. Это, в частности, значит, что облако точек представляет из себя нечто вроде эллипсоида в $D$-мерном пространстве с центром $\\mu$.\n\nПредположим, что $\\mu = 0$ (все признаки центрированы); тогда оценкой матрицы ковариации признаков является матрица $\\frac1n X^TX$. Допустим, что эта оценка точная, тогда разложение $X^TX = \\color{magenta}{V}\\color{green}{\\Sigma}^T\\color{green}{\\Sigma} \\color{magenta}{V}^T$ даёт нам аналогичное разложение $C = \\color{magenta}{V}(\\frac1n\\color{green}{\\Sigma}^T\\color{green}{\\Sigma}) \\color{magenta}{V}^T$. Теперь замена координат $x = z\\color{magenta}{V}^T$ (с матрицей замены $\\color{magenta}{V}$ — то есть переход происходит в базис из столбцов матрицы $\\color{magenta}{V}$) даёт нам\n\n$$p(x_i) = \\mathrm{const}\\cdot \\exp\\left(-\\frac12\\cdot\\color{red}{x_i}\\cdot \\color{blue}{C^{-1}}\\cdot \\color{grey}{x_i^T}\\right)\n$$\n\nОбратите внимание, что $x_i$ и $x_i^T$ стоят в формуле на непривычных местах, как будто их перепутали, но нет — просто $x_i$ у нас является строкой, а не столбцом.\n\n$$p(z) = \\mathrm{const}\\cdot \\exp\\left(-\\frac12\\cdot\\color{red}{z_i}\\underbrace{\\color{red}{V^T}\\cdot \\color{blue}{V}}_{=E}\\color{blue}{(n\\Sigma^{-1}\\Sigma^{-T})}\\underbrace{\\color{blue}{V^T}\\cdot \\color{cyan}{V}}_{=E}\\color{grey}{z_i^T}\\right)=\n$$\n\n$$= \\mathrm{const}\\cdot \\exp\\left(-\\frac{n}2z_i\\Sigma^{-1}\\Sigma^{-T}z_i^T\\right)=\\mathrm{const}\\cdot \\exp\\left(-\\frac{n}2\\left(\\frac1{\\sigma_1^2}z_{i1}^2 + \\frac1{\\sigma_2^2}z_{i2}^2 + \\ldots\\right)\\right)=\n$$\n\n$$=p(x'_{i1})\\cdot\\ldots\\cdot p(x'_{iD})\n$$\n\nИтак, если наши данные взяты из многомерного нормального распределения, после перехода к базису из столбцов $\\color{magenta}{V}$ новые координаты становятся независимыми; вместе с тем это соответствует переходу к главным осям ковариационной матрицы — и геометрически столбцы $\\color{magenta}{V}$ соответствуют главным осям эллипсоида-облака точек.\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_3_91ed0c9da5_4c32c517f4.webp)\n\n## Использование SVD: латентные признаки\n\nЗапишем\n\n$$\\underset{N\\times D}{\\operatorname{X}} = \\underset{N\\times R}{\\operatorname{U\\Sigma}} \\cdot \\underset{R\\times D}{\\operatorname{V^T}}\n$$\n\nи вспомним самую первую интерпретацию матричного разложения.\n\n![matrix](https://yastatic.net/s3/education-portal/media/matrix_factorization_noname_2_435aadc098_8bfc9ce626.svg)\nСтолбцы $U\\Sigma$ ортогональны (так как они пропорциональны столбцам ортогональной по столбцам матрицы $U$) — то есть <span style=\"color:blue\"> латентные признаки не коррелированы</span>. При этом, поскольку длина каждого из столбцов $U$ равна 1, длины столбцов $U\\Sigma$ порпорциональны $\\sigma_i$ — а, значит, <span style=\"color:blue\"> латентные признаки упорядочены по невозрастанию дисперсии</span> (ведь с точностью до константы оценка дисперсии признака — это квадрат длины вектора его значений).\n\nЗаметим, что перед применением SVD признаки лучше центрировать, иначе первая компонента будет указывать в сторону центра масс облака точек (зачем нам это?), а остальные вынуждены будут ей быть ортогональны:\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_5_caa8d0689a_a3e3d940da.webp)\n\n### Понижение размерности признакового пространства\n\nМы уже обсуждали, что это можно получить, построив приближение ранга $T$ или, что то же самое, приближённое разложение\n\n$$\\underset{N\\times D}{\\operatorname{X}} \\sim \\underset{N\\times T}{\\operatorname{B}} \\cdot \\underset{T\\times D}{\\operatorname{C}}\n$$\n\nдля некоторого и желательно небольшого $T$. И тут SVD приходится более чем кстати.\n\n#### Теорема Эккарта-Янга\n\nНаилучшее по норме Фробениуса приближение ранга $T$ — это\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_6_3cb442dda7_81bc4687d4_b48107a292.svg)\n\nТаким образом, если вы хотите получить $T$ «самых важных» признаков, то вы можете использовать SVD. Но что это за признаки? Что именно означают эти слова «самые важные»? Давайте обратимся к геометрии, которая, как мы помним, тесно связана с теорией вероятностей:\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_7_9a0defd674_0d28b2c7a4_1dd9cee298.svg)\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_8_291d9eb393_c2ddd38303.webp)\n\nЕсли применить SVD к датасету, изображённому на последней картинке, и взять два первых латентных признака, то эллипсоид превратится в эллипс; меньшая из полуосей, похожая на шум, будет забыта, останется две бOльших. Видим: самое важное для SVD — это самое масштабное.\n\n*А правда ли у нас получится хорошее приближение с помощью* $T$ новых признаков? Посчитаем норму разности. Везде ниже $\\color{orange}{U}$ и $\\color{magenta}{V}$ — квадратные ортогональные матрицы; в частности $\\color{green}{\\Sigma}$ не обязательно квадратная матрица размера $N\\times D$.\n\n![SVD](https://yastatic.net/s3/education-portal/media/SVD_9_6a81edb703_564c7cf3ee_d6bbff0b2f.svg)\n\n$$||\\Delta||_{fro}^2 = \\mathrm{tr}\\left((\\color{orange}{U}\\color{green}{\\widetilde{\\Sigma}}\\color{magenta}{V}^T)^T\\color{orange}{U}\\color{green}{\\widetilde{\\Sigma}}\\color{magenta}{V}^T\\right) = \n\\mathrm{tr}\\left(\\color{magenta}{V}\\color{green}{\\widetilde{\\Sigma}}^T\\underbrace{\\color{orange}{U}^T\\color{orange}{U}}_{=E}\\color{green}{\\widetilde{\\Sigma}}\\color{magenta}{V}^T\\right) =$$\n\n$$=\\mathrm{tr}\\left(\\color{magenta}{V}\\color{green}{\\widetilde{\\Sigma}}^T\\color{green}{\\widetilde{\\Sigma}}\\color{magenta}{V}^T\\right) = \\mathrm{tr}\\left(\\color{green}{\\widetilde{\\Sigma}}^T\\color{green}{\\widetilde{\\Sigma}}\\underbrace{\\color{magenta}{V}^T\\color{magenta}{V}}_{=E}\\right) = ||\\color{green}{\\widetilde{\\Sigma}}||^2_{fro} = \\color{green}{\\sigma_{T+1}}^2 + \\ldots + \\color{green}{\\sigma_{R}}^2\n$$\n\nАналогичным образом\n\n$$||\\Delta||_2 = \\color{green}{\\sigma_{T+1}}\n$$\n\nпотому что умножение на ортогональную матрицу не меняет операторную $l_2$-норму. Таким образом, если сингулярные значения убывают достаточно медленно (например, линейно), то мы вряд ли сможем приблизить исходную матрицу матрицей маленького ранга с очень хорошей точностью.\n\n*Как избавиться от иллюзий*.\nСгенерируйте матрицу $100\\times100$ с помощью *np.random.rand* или *np.random.randn*. Для какого $T$ вы сможете найти матрицу ранга $T$, приближающую исходную с относительной точностью $10^{-6}$?\n\nК счастью, в реальных датасетах сингулярные значения убывают достаточно быстро или же нам хватает довольно грубого приближения.\n\n#### Переход из исходного признакового пространства в новое и обратно\n\nДопустим, мы построили приближённое разложение ранга $T$:\n\n$$ X\\sim\\color{orange}{\\widehat{U}}\\color{green}{\\widehat{\\Sigma}}\\color{magenta}{\\widehat{V}}^T =\n\\color{orange}{U}\\cdot\\underbrace{\\color{green}{\\begin{pmatrix}\n\\sigma_1 &\\\\\n & \\ddots & \\\\\n & & \\sigma_T &\\\\\n& & & 0 & \\\\\n& & & & \\ddots\\end{pmatrix}}}_{=:\\color{green}{\\Sigma'}}\\cdot\\color{magenta}{V}^T$$\n\nМатрица $\\color{orange}{\\widehat{U}}\\color{green}{\\widehat{\\Sigma}}$ — это первые $T$ столбцов матрицы $\\color{orange}{U}\\color{green}{\\Sigma'}$, и они же первые $T$ столбцов матрицы $\\color{orange}{U}\\color{green}{\\Sigma} = X\\cdot\\color{magenta}{V}$. Таким образом, <span style=\"color:blue\">для перевода объекта $x_i$ в новое признаковое пространство нужно произвести $x_i\\mapsto x_i\\cdot\\color{magenta}{V}$ и взять первые $T$ столбцов или, что то же самое, $x_i\\mapsto x_i\\cdot\\color{magenta}{V[:,:T]}$.</span>\n\nТеперь пусть задана вектор-строка $z_i$ длины $T$ — латентное представление, соответствующего некоторому объекту, то есть одна из строк матрицы $\\color{orange}{\\widehat{U}}\\color{green}{\\widehat{\\Sigma}}$. Тогда точно восстановить исходный $x_i$ мы не сможем: ведь равенство $X\\sim\\color{orange}{\\widehat{U}}\\color{green}{\\widehat{\\Sigma}}\\color{magenta}{\\widehat{V}}^T$ не точное, но <span style=\"color:blue\">для приближённого восстановления $x_i$ мы должны произвести $z_i\\mapsto z_i\\cdot \\color{magenta}{\\widehat{V}}^T = z_i\\cdot\\color{magenta}{V[:,:T]}^T$. </span>\n\n## На что не способно сингулярное разложение\n\nСингулярное разложение умеет находить дающие самый существенный вклад в дисперсию линейные комбинации признаков, притом некоррелированные; в случае нормально распределённых данных эти направления оказываются главными осями эллипсоида, которым является облако данных. К сожалению, эта суперспособность SVD столь же охотно превращается в слабость, ведь:\n\n* Данные не всегда распределены нормально, они могут обладать сложной геометрией, но SVD будет упрямо искать эллипсоид.\n* Самое важное не всегда самое масштабное. Забыть привести признаки к одному масштабу — хороший способ выстрелить себе в ногу при работе с сингулярным разложением.\n* Новые признаки не обязаны быть хорошо интерпретируемыми. Линейная комбинация возраста, стажа работы и зарплаты — это не то, что хотелось бы показывать банковскому регулятору.\n* Выбросы почти наверняка усложнят вам жизнь, хотя, возможно, SVD поможет вам их увидеть.\n\n## Практические кейсы\n\n### MNIST и путешествие по латентному пространству\n\nВозьмём большой датасет MNIST, состоящий из чёрно-белых изображений рукописных цифр размера $28\\times28$ пикселей (его можно загрузить, к примеру, [отсюда](https://ru-keras.com/datasets)), вытянем каждое из изображений в вектор, получив тем самым матрицу размера $60000\\times(28\\cdot28)$, и применим к этой матрице SVD. Теперь возьмём первые два латентных признака (то есть первые два столбца матрицы $U\\Sigma$) — получается, что каждая рукописная цифра у нас теперь кодируется вектором из двух чисел. Нарисуем на плоскости точки, соответствующие этим векторам (скажем, по 100 из каждого класса, чтобы хоть что-нибудь было понятно):\n\n![MNIST](https://yastatic.net/s3/education-portal/media/MNIST_SVD_latent_space_bad_d03acdc84a_eb4ea55797.webp)\n\nЧто же мы видим? Единицы и нули оказались особенными, то есть уже первые два латентных признака хорошо их различают, правда, с середине какая-то каша. А почему? Да потому, что мы забыли центрировать данные. Давайте перед применением SVD вычтем из каждого признака (то есть из каждого пикселя) его среднее по всем картинкам, а потом нарисуем всё заново:\n\n![MNIST](https://yastatic.net/s3/education-portal/media/MNIST_SVD_latent_space_2468ef3c4f_db1bd7b105.webp)\n\nТеперь стало получше: например, семёрки, девятки и четвёрки сгуппировались вместе с другой стороны от восьмёрок и троек (собственно говоря, это отражает тот факт, что рукописные написания семёрок, девяток и четвёрок могут быть похожи друг на друга, так и человек не сразу отличит — а вот с тройкой их спутать намного труднее).\n\nЗаметим ещё вот что. В $(28\\cdot28)$-мерном пространстве наборов пикселей совсем не каждая точка соответствует какой-то рукописной цифре — то, что может приходить из реального мира, лежит на некоторой хитрой поверхности в этом пространстве (если выражаться корректнее, то на подмногообразии). Если же мы попробуем нарисовать «изображения», лежащие на отрезке, соединяющем два изображения цифр, то получим нечто не слишком интересное:\n\n![mnist](https://yastatic.net/s3/education-portal/media/mnist_movie_svd_4b36164193_e5db6ad932.gif)\n\nОдно изображение просто наложилось и затем сменило другое — скучно! Но если мы сделаем то же самое в двумерном пространстве, образованном первыми двумя латентными признаками SVD, то мы будем получать, может быть, не совсем реалистичные изображения цифр, но что-то явно из мира рукописных символов:\n\n![mnist](https://yastatic.net/s3/education-portal/media/mnist_movie_svd1_6b42a304ae_fa63250ec5.gif)\n\n{% cut \"Контрольный вопрос\" %}\n\nЕсли $x_1$ — вектор-строка длины $28\\cdot28$, отвечающая первой картинке, $x_2$ — второй, а $U$, $\\Sigma$, $V^T$ — матрицы из сингулярного разложения, то как получить картинку, соответствующую середине отрезка, соединяющего в пространстве двух первых латентных признаков SVD точки $x_1'$ и $x_2'$, отвечающие этим картинкам?\n\n{% endcut %}\n\n### Химический состав рек\n\nПосмотрим на небольшой кусок вот [этого датасета](https://data.europa.eu/euodp/en/data/dataset/data_waterbase-rivers-10), который доступен для скачивания нигде (ха-ха), и попробуем что-нибудь понять про химических состав рек европейского союза, а заодно соберём шишки, которые могут попасться при визуализации с помощью SVD.\n\nКонечно, сразу хочется нарисовать все объекты датасета в виде точек на плоскости. Мы знаем, что в этом может помочь SVD — попробуем же! Центрируем признаки — и рисуем:\n\n![Rivers](https://yastatic.net/s3/education-portal/media/Rivers_bad_SVD_af94fc5e75_b268a69313.webp)\n\nОй, что-то пошло не так. Но почему же?! Наверное, надо хотя бы посмотреть на данные...\n\n* Объекты имеют вид «GBPKER0059», «GB20227», «LVV0120100» и так далее — это коды станций, измеряющих состав воды;\n* Признаки имеют вид «1985 BOD5», «1985 Chlorophyll a», «1985 Orthophosphates» и так далее — тут указан год измерения и показатель;\n* Посмотрев статистики, убеждаемся, что все показатели неотрицательны (то есть уж точно распределены не нормально — но может, и так сработает); при этом почти все элементы нашей матрицы находятся в пределах 1000, но три значения космически огромны, причём в одном столбце «2008 Total oxidised nitrogen» (а строки соответствуют каким-то греческим станциям, с которыми вообще всё странно), и ещё одно тоже очень большое («2005 Total organic carbon (TOC)») — вот они-то и дали нам четыре точки на графике, отличных от начала координат.\n  Кстати говоря, если космически большие значения, по-видимому, являются результатам поломки, то по поводу четвёртого, не столь злостного, выброса есть подозрение, что это реальные значения. Посмотрев в данные, мы видим, что показатель был измерен на станции Zidlochovice, на реке Srvatka ниже Брно — а, как говорит нам википедия: *As a result of water pollution by communal sewage, the reservoir suffered from an extensive amount of cyanobacteria for a long time*. Так или иначе, все четыре станции мы уберём, чтобы они не портили нам SVD.\n* Один из признаков «2002 Kjeldahl Nitrogen» принимает только нулевые значения. Уберём его, чтобы не мешался.\n\nПочистив выбросы в исходных данных, опять центрируем и рисуем:\n\n![Rivers](https://yastatic.net/s3/education-portal/media/Rivers_SVD_1_b7a6bf8940_2a8f3bbdbd.webp)\n\nУже лучше. Попробуем понять, что за вещества внесли вклад в первые два латентных признака. Как это сделать? Латентные признаки — это столбцы матрицы $U\\Sigma = XV$; линейная алгебра говорит нам, что $i$-й столбец произведения $XV$ — это линейная комбинация столбцов $X$ с коэффициентами из $i$-го столбца $V$. Находим номера самых больших по модулю координат $V$ — и оказывается, что первые два латентных признака складываются почти сплошь из насыщения воды кислородом, только за разные годы (первый за более старые, второй за чуть более свежие):\n\n**First latent feature**\n\n#|\n||\n\nПризнак\n\n|\n\nэлемент $V$\n\n||\n||\n\n2001 Oxygen saturation\n\n|\n\n0\\.27\n\n||\n||\n\n2002 Oxygen saturation\n\n|\n\n0\\.27\n\n||\n||\n\n2000 Oxygen saturation\n\n|\n\n0\\.26\n\n||\n||\n\n2004 Oxygen saturation\n\n|\n\n0\\.26\n\n||\n||\n\n$\\vdots$\n\n|\n\n$\\vdots$\n\n||\n|#\n\n**Second latent feature**\n\n#|\n||\n\nПризнак\n\n|\n\nэлемент $V$\n\n||\n||\n\n2001 Oxygen saturation\n\n|\n\n\\-0.62\n\n||\n||\n\n2002 Oxygen saturation\n\n|\n\n\\-0.49\n\n||\n||\n\n2000 Oxygen saturation\n\n|\n\n\\-0.45\n\n||\n||\n\n2004 Oxygen saturation\n\n|\n\n\\-0.26\n\n||\n||\n\n$\\vdots$\n\n|\n\n$\\vdots$\n\n||\n|#\n\nНеужели насыщение кислородом действительно так важно? Нет, просто мы не отмасштабировали признаки. Оказывается, что насыщение кислородом имеет на порядок больший масштаб, чем многое другое, и потому забивает все остальные признаки. Тем не менее, мы можем попробовать сделать вывод и из имеющейся картинки. По оси \"у\" что-то не очень интересное, а по оси \"х\" видим большой кластер (напомним, это меньшие значения насыщения воды кислородом в начале 2000-х), содержащий, если проверить, примерно три четверти всех точек, и ещё некоторой размазанный шлейф.\n\nИтак, на многих станциях насыщение воды кислородом в начале 2000-х было примерно в одинаковой степени мало — проверив глазами, обнаруживаем, что там просто нули. Поскольку вряд ли это так на самом деле, видимо, стоит сделать вывод, что в первой половине 2000-х насыщение кислородом измерялось из рук вон плохо.\n\nТеперь вдобавок к центрированию поделим каждый признак на его стандартное отклонение и снова нарисуем:\n\n![Rivers](https://yastatic.net/s3/education-portal/media/Rivers_SVD_2_d0e42b323f_fa2bedcc09.webp)\n\nОпять видим тесный кластер. При этом первый латентный признак складывается в основном из «Nitrate» , «pH»  и «Dissolved oxygen» за разные годы, все с положительными коэффициентами, а второй — из «Total ammonium», «Total phosphorus» и «Kjeldahl Nitrogen» за разные годы, причём с отрицательными коэффициентами. В частности, справа у нас точки с высоким содержанием нитратов и высокой кислотностью. Среди этих точек:\n\n* [Река Тейм](https://en.wikipedia.org/wiki/River_Tame,_West_Midlands), про которую Википедия пишет: *The Tame was once one of Britain's dirtiest rivers.*\n* Река Кёрёш, про которую тоже можно найти вот такую информацию: *For some time the municipal government of Kanjiža (to which the mouth of the river belongs) protests about the extreme pollution of the Kereš's water, as it represents the single largest polluter of the Tisa river*\n* Темза (станция немного выше Лондона).\n\nЧто ещё можно было бы сделать? Например, мы можем посмотреть распределения признаков и увидеть, что многие из них далеки от нормальных и в целом выиграли бы от логарифмирования — тогда, возможно, итоговая картинка стала бы красноречивей.\n\n## Использование SVD: разделённые представления и рекомендательная система для бедных\n\nМы уже обсуждали, что, вообще говоря, любое матричное разложение можно с той или иной степенью успеха использовать для построения рекомендательной системы. Основанные на этом модели называются **моделями латентных факторов** (Latent factor models). В 2006 году SVD-подобный алгоритм даже помог Саймону Фанку (Simon Funk; под этим псевдонимом скрывался Brandyn Webb) занять высокое место на соревновании Netflix Prize.\n\n### Подход на чистом SVD\n\nВернёмся к примеру из пункта 1.3. Пусть вновь объекты нашего датасета соответствуют пользователям интернет-магазина, а признаки — товарам, причём в клетке с индексом $(i,j)$ записаны рейтинги $\\rho_{ij}$, которые пользователи ставят товарам. На основе этих данных мы хотим порекомендовать некоторому $n$-му пользователю $k$ очередных товаров. Если бы нам были известны $\\rho_{nj}$ для всех индексов товаров $j$, задача не стоила бы выеденного яйца: мы бы просто взяли $k$ товаров с максимальными значениями рейтингов. Более того, мы могли бы с помощью матричного разложения построить модель и надеяться, что координаты латентных представлений пользователей и товаров окажутся интерпретируемыми (нет).\n\n![Decomp31](https://yastatic.net/s3/education-portal/media/Decomp31_908a5a0bc7_29f6c494ef_befa61800c.svg)\n\nА именно, если бы мы знали все $\\rho_{nj}$, построить отдельные представления для пользователей и для товаров некоторой (подбираемой; это гиперпараметр модели) длины $T$ мы могли бы с помощью SVD и приближения из теоремы Эккарта-Янга:\n\n$$X\\sim\\widehat{X}\\widehat{U}\\widehat{\\Sigma}\\widehat{V}^T = \\color{red}{\\widehat{U}\\widehat{\\Sigma}^{\\frac12}}\\cdot\n\\color{green}{\\widehat{\\Sigma}^{\\frac12}\\widehat{V}^T}$$\n\nНо на деле матрица $\\left(\\rho_{ij}\\right)_{i,j}$ обычно разреженная: в ней лишь сравнительно немного известных рейтингов, а в остальных ячейках стоят пропуски. Что же делать?\n\nНаивный вариант — заменить все пропуски нулями (то есть положить, что если пользователь не ставил рейтинг товару, то он ему вдребезги не интересен, что не всегда правдоподобно) или средними по строке/столбцу, после чего сделать SVD и радоваться жизни. В этой ситуации наша приближённая модель предсказывает рейтинг, выставленный $i$-м пользователем $j$-му товару, как скалярное произведение представлений пользователя и товара — то есть $i$-й строки матрицы $\\color{red}{\\widehat{U}\\widehat{\\Sigma}^{\\frac12}}$ и $j$-го столбца матрицы $\\color{green}{\\widehat{\\Sigma}^{\\frac12}\\widehat{V}^T}$\n\nТеперь <span style=\"color:blue\"> чтобы порекомендовать n-му пользователю k очередных товаров, мы просто берём n-ю строку матрицы $\\widehat{X}$ и находим номера её наибольших элементов.</span>\n\nК сожалению, у этого метода есть как минимум две проблемы:\n\n* Пропусков обычно очень много; если их все заменить какими попало значениями, оценка будет очень шумной;\n* При таком подходе нет простого способа обновить рекомендации при добавлении новых данных — SVD придётся переучивать заново.\n\n### Развиваем идею: как побороть разреженность\n\nК счастью, есть и другой путь. Давайте подумаем: чего вообще мы требуем от матриц $\\color{red}{B} := \\color{red}{\\widehat{U}\\widehat{\\Sigma}^{\\frac12}}$ и $\\color{green}{C}^T := \\color{green}{\\widehat{\\Sigma}^{\\frac12}\\widehat{V}^T}$? По сути нам нужны две вещи:\n\n* $\\color{red}{B}\\cdot\\color{green}{C}^T \\sim X$;\n* Обе матрицы ортогональны по столбцам.\n\nПоследнее можно опустить. Ясной пользы для рекомендательной системы от этого нет; да, это давало бы нам некоррелированность латентных признаков, но мы уже видели, что интерпретируемости это не влечёт. Первое же условие удобно сформулировать в терминах векторов латентных представлений пользователей (обозначим их $\\color{red}{b_i}$; это строки $\\color{red}{B}$) и товаров (обозначим их $\\color{green}{c_i}$ — это строки $\\color{green}{C}$). А именно, нам нужно, чтобы *скалярное произведение* $(\\color{red}{b_i},\\color{green}{c_j})$ было как можно ближе к $\\rho_{ij}$ **для всех пар** $(i, j)$, для которых $\\rho_{ij}$ нам известно.\n\nВот именно! Мы можем просто не обращать внимания на неизвестные значения, оптимизируя только по тем клеткам $X$, для которых нам что-то известно:\n\n$$\\sum_{i,j:,\\rho_{ij}\\neq\\mathrm{NA}}(\\rho_{ij}-(b_i,c_j))^2\\longrightarrow\\min_{b_i,c_i}\n$$\n\nНо как решить эту оптимизационную задачу? Разумеется, с помощью стохастического градиентного спуска. В базовом варианте мы случайным образом перебираем пары $(i, j)$, для которых $\\rho_{ij}$ нам известно, и обновляем координаты векторов $\\color{red}{b_i}$ и $\\color{green}{c_j}$ следующим образом:\n\n$$b_{it}:=b_{it}+\\eta\\varepsilon_{ij}c_{jt}\\\\c_{jt}:=c_{jt}+\\eta\\varepsilon_{ij}b_{it}, t=1,\\ldots,T,\\quad\\text{где }\\varepsilon_{ij}=\\rho_{ij}-(b_i,c_j)\n$$\n\nгде $\\eta$ — гиперпараметр, отвечающий за темп обучения.\n\nПриятное свойство такого подхода: в нём легко добавлять новые товары/пользователей (дообучаем их векторы, заморозив остальные), а также новые оценки $\\rho_{ij}$ (добавляем в оптимизируемый функционал и проводим дооптимизацию).\n\nОтметим, что в ходе оптимизации мы попеременно осуществляем градиентный спуск, обновляя то $\\color{red}{B}$, то $\\color{green}{C}$. Эту идею можно развить следующим образом. Заметим, что при фиксированной матрице $C$ задача минимизации по $B$ выражения\n\n$$\\sum_{i,j:,\\rho_{ij}\\neq\\mathrm{NA}}(\\rho_{ij}-(b_{i},c_{j}))^{2}\\longrightarrow\\min_{b_{i},c_{i}}\n$$\n\nпревращается по сути в обычный метод наименьших квадратов, для которого можно даже выписать «точное» решение (а вы можете это сделать?). Точно так же и при фиксированном $B$ легко находится минимум по $C$. Чередуя эти два шага, мы будем сходиться к решению быстрее и надёжнее, чем с помощью SGD. Данный алгоритм носит название <span style=\"color:blue\">Alternating Least Squares (ALS)</span>.\n\n### Развиваем идею: как ещё усовершенствовать модель\n\nМожно ввести много дополнительных эвристик и предположений, которые уведут нас совсем далеко от старого доброго SVD. Например:\n\n* Рейтинг не всегда является продуктом чистого взаимодействия пользователя с товаром. Бывают товары, которые сами по себе ужасно популярны (скажем, человек купит туалетную бумагу даже если не очень интересуется товарами для дома) или так ужасны, что даже интересующийся данной «латентной категорией» покупатель не станет их высоко оценивать. Это можно промоделировать, добавив к скалярному произведению члены, зависящие только от пользователя и только от товара соответственно:\n\n$$\\rho_{ij}\\sim \\color{red}{\\overline{b}_i} +\\color{green}{\\overline{c}_j} + (\\color{red}{b_i},\\color{green}{c_j})\n$$\n\nТогда наша задача оптимизации примет вид:\n\n$$\\sum_{i,j:\\rho_{ij}\\neq\\mathrm{NA}}(\\rho_{ij}-\\overline{b}_i-\\overline{c}_j-(b_i,c_j))^2\\longrightarrow\\min_{b_i,c_i,\\overline{b}_i,\\overline{c}_j}\n$$\n\n* Можно добавлять регуляризационные члены. Например:\n\n$$\\sum_{i,j:,\\rho_{ij}\\neq\\mathrm{NA}}(\\rho_{ij}-(b_i,c_j))^2+\\lambda\\sum_i||b_i||^2+\\mu\\sum_j||c_j||^2\\longrightarrow\\min_{b_i,c_i}\n$$\n\n* Мы можем не игнорировать неизвестные нам элементы матрицы $X$, а присвоить им нулевые значения и ставить более низкие веса соответствующим слагаемым функции потерь:\n\n$$\\color{blue}{\\sum_{i,j}w(\\rho_{ij})(\\rho_{ij} - (\\color{red}{b_i},\\color{green}{c_j}))^2\\longrightarrow \\min\\limits_{\\color{red}{b_i},\\color{green}{c_i}}}\n$$\n\nгде $w(\\rho_{ij})$ маленькое, если $\\rho_{ij}=\\mathrm{NA}$, и большое в противном случае. Это имеет смысл, например, если отсутствие данных в самом деле может быть логично интерпретировать, как отсутствие интереса.\n\n* Можно ввести требования неотрицательности: $\\color{red}{b_{it}}\\geqslant 0$, $\\color{green}{c_{js}}\\geqslant0$. Подробнее об этом в параграфе про неотрицательное матричное разложение.\n* Или даже всё это вместе :D\n\n{% cut \"Контрольный вопрос\" %}\n\nПредположим, что каждый рейтинг $\\rho_{ij}$ имеет также временную метку $t_{ij}$. Можете ли вы придумать, как их использовать?\n\n{% endcut %}\n\n## Вероятностное обличье модели латентных факторов\n\nВы могли заметить, что задача\n\n$$\\sum_{i,j:,\\rho_{ij}\\neq\\mathrm{NA}}(\\rho_{ij}-(b_i,c_j))^2\\longrightarrow\\min_{b_i,c_i}\n$$\n\nподозрительно напоминает задачу наименьших квадратов, и неспроста. В базовой формулировке мы предполагаем, что\n\n$$\\rho_{ij}=(b_i,c_j)+\\xi_{ij},\\quad\\text{где }\\xi_{ij}\\sim\\mathcal{N}(0,\\sigma^2)\\text{ - нормальный шум}\n$$\n\nИными словами,\n\n$$\\color{blue}{\\rho_{ij} \\sim\\mathcal{N}\\left((\\color{red}{b_i},\\color{green}{c_j}), \\sigma^2\\right)}\n$$\n\nПо крайней мере, те из них, которые нам известны. Нахождение $\\color{red}{b_i}$ и $\\color{green}{c_j}$ методом максимального правдоподобия как раз и приводит к описанной выше оптимизационной задаче.\n\nКак обычно, мы можем добавить априорную информацию о распределении латентных векторов $\\color{red}{b_i}$ и $\\color{green}{c_j}$. Например, такую:\n\n$$\\color{red}{b_i}\\sim\\mathcal{N}(0, \\sigma_bE),\\qquad\\color{green}{c_j}\\sim\\mathcal{N}(0, \\sigma_cE)\n$$\n\nРасписывая логарифм правдоподобия\n\n$$p(\\rho;\\color{red}{b},\\color{green}{c}) = p(\\rho|\\color{red}{b},\\color{green}{c})p(\\color{red}{b})p(\\color{green}{c})\n$$\n\nи убирая константные члены, которые содержат только сигмы, приводим задачу максимизации логарифма правдоподобия к виду\n\n$$-\\frac{1}{2\\sigma^{2}}\\sum_{i,j:,\\rho_{ij}\\neq\\mathrm{NA}}(\\rho_{ij}-(b_{i},c_{j}))^{2}-\\frac{1}{2\\sigma_{1}^{2}}\\sum_{i}||b_{i}||^{2}-\\frac{1}{2\\sigma_{2}^{2}}\\sum_{j}||c_{j}||^{2}\\longrightarrow\\max_{b_{i},c_{i}}\n$$\n\nвполне объясняющему, почему в предыдущем пункте у нас могла появляться L2-регуляризация.\n\n## Анализ независимых компонент (ICA)\n\nICA изначально был придуман для задачи разделения сигналов («blind source separation»). Рассмотрим [пример из sklearn](https://scikit-learn.org/stable/auto_examples/decomposition/plot_ica_blind_source_separation.html#sphx-glr-auto-examples-decomposition-plot-ica-blind-source-separation-py)\n\n![sklearn](https://yastatic.net/s3/education-portal/media/sklearn_ica_bb0edd0f70_128c3a9ef5.webp)\n\nИзначально были три сигнала (красный, рыжий и синий на второй сверху картинке), их смешали, получив три линейных комбинации (на верхней картинке). Теперь попробуем их разделить. Первая мысль, которая нам приходит в голову: воспользуемся SVD (проинтерпретировав моменты времени как объекты, а сигналы из смеси как признаки — то есть взяв матрицу $2000\\times3$)! Но на нижней картинке мы видим результат, который не радует, но не радует ожидаемо, и вот почему:\n\n* В первый латентный признак SVD старается собрать максимально возможную дисперсию — мы видим, что красный график на нижней картинке действительно ловит самые значительные колебания сигналов из смеси; при этом в третий (рыжий) сигнал уже попадает более или менее случайный шум.\n* Если посмотреть на значения исходных сигналов, то они распределены не нормально (распределения значений синего и красного имеют две моды, а у рыжего близко к равномерному), а мы помним, что SVD плохо приспособлено к работе с не гауссовскими данными.\n\n<span style=\"color:blue\">Анализ независимых компонент (ICA)</span> состоит в аппроксимации $x_i\\sim z_iV^T$ наблюдаемых признаков линейной смесью латентных, которые являются **независимыми** как случайные величины.\n\n*Замечание*. Оригинальная формулировка несколько другая: изначально ICA — это аппроксимация наблюдаемых сигналов линейной смесью некоторого числа независимых сигналов, то есть речь шла о смеси объектов. Описываемые далее методы можно точно также использовать и для разделения смеси объектов, конечно.\n\nВажно, что в данном случае предъявляется требование **независимости**, а не просто **некоррелированности** — более сильное, впрочем, труднодостижимое и столь же трудно проверяемое.\n\n### Как построить ICA? Путешествие в мир удивительных эвристик\n\nМы будем излагать алгоритм FastICA по [статье его создателей](https://www.cs.helsinki.fi/u/ahyvarin/papers/TNN99new.pdf), она же реализована в библиотеке sklearn; в статье вас ждёт гораздо больше подробностей и тонкостей реализации.\n\nАлгоритм базируется на следующем эвристическом соображении: <span style=\"color:blue\">линейная комбинация нескольких независимых негауссовских величин в большей степени гауссовская, чем сами эти величины </span> — довольно смелый вывод из   Центральной предельной теоремы. Таким образом, мы будем искать <span style=\"color:blue\">линейную комбинацию исходных признаков, которая была бы в наименьшей степени гауссовской</span> — это и будет первая из независимых компонент. Но как померить близость к нормальности?\n\nПусть $z$ — некоторая (одномерная) случайная величина с плотностью $p(z)$. Рассмотрим её энтропию\n\n$$H(z) = -\\int p(t)\\log{p(t)}dt\n$$\n\nИмеет место теорема: <span style=\"color:blue\">гауссовская случайная величина имеет максимальную энтропию среди всех случайных величин с заданной дисперсией</span>. Рассмотрим теперь\n\n$$J(z) = H(z_{gauss}) - H(z)\n$$\n\nгде $z_{gauss}$ — гауссовская случайная величина с той же дисперсией, что и у $z$. Величина $J(z)$ всегда неотрицательна и равна нулю в том случае, если $z$ гауссовская. Решая задачу\n\n$$J(Xw)\\longrightarrow\\max\\limits_{w}\n$$\n\nмы могли бы найти самую негауссовскую линейную комбинацию наших признаков. Проблема в том, что $J(z)$ трудно посчитать. Авторы статьи предлагают использовать приближение\n\n$$J(z)\\sim\\left(\\mathbb{E}G(z) - \\mathbb{E}G(w)\\right)^2,\n$$\n\nгде $w\\sim\\mathcal{N}(0,1)$, а $G$ неквадратичная функция (в статье предлагаются конкретные варианты). Последующие независимые компоненты можно искать в ортогональном подпространстве (всё-таки они должны быть и некоррелированными).\n\n### Подготовка данных для ICA\n\nПеред тем, как строить разложение нужно центрировать данные (вычесть из признаков их средние) и убедиться, что ковариационная матрица признаков является единичной.\n\n{% cut \"Контрольный вопрос: как добиться последнего с помощью линейной замены?\" %}\n\nПри линейной замене $x = Cx'$ матрица ковариации меняется, как $\\Sigma' = C^T\\Sigma C$. Осталось вспомнить, что, поскольку матрица ковариации симметричная и положительно определённая, существует линейная замена, для которой $C^T\\Sigma C = E$. Например, в качестве $C$ можно взять (симметричный положительно определённый) квадратный корень из $\\Sigma^{-1}$.\n\n{% endcut %}\n\n## Неотрицательное матричное разложение (NMF)\n\n### Мотивация: тематическое моделирование\n\nДопустим, что у нас есть датасет, в котором объекты — тексты, признаки — токены (например, слова), а на $(i,j)$-м месте написана частота встречаемости $j$-го токена в $i$-м тексте (то есть $\\frac{n_{ij}}{n_j}$, где $n_{ij}$ — сколько раз $i$-й токен встретился в $j$-м документе, а $n_j$ — общее число токенов в этом документе).\n\n![matrix](https://yastatic.net/s3/education-portal/media/matrix_factorization_noname_3_539bfbc386_0c10957e0f.svg)\n\nПриблизим нашу матрицу произведением\n\n$$\\underset{N\\times D}{\\operatorname{X}} \\sim \\underset{N\\times R}{\\operatorname{B}} \\cdot \\underset{R\\times D}{\\operatorname{C}}\n$$\n\nОдна из возможных интерпретаций такова. Есть $D$ тем:\n\n![matrix](https://yastatic.net/s3/education-portal/media/matrix_factorization_noname_4_e158549ceb_c50e43a574.svg)\n\nЗа этим стоит вполне ясная вероятностная модель:\n\n$$p(word\\mid document)\\sim\\sum_{theme}p(word\\mid theme)\\cdot p(theme\\mid document)\n$$\n\nВопрос в том, как получить такое разложение. Конечно, чисто технически можно использовать SVD. Но тогда элементы матриц разложения вряд ли будут иметь вероятностный смысл: они же даже не обязаны быть неотрицательными. С другой стороны, если потребовать, чтобы все элементы $\\color{red}{B}$ и $\\color{green}{C}$ были неотрицательными, ситуация исправится.\n\n### Определение NMF\n\n<span style=\"color:blue\">Неотрицательное матричное разложение</span> неотрицательной матрицы $X$ — это произведение $BC$ матриц с неотрицательным элементами, наилучшим образом приближающее $X$ по норме Фробениуса\n\n$$||X - BC||^2_{fro}\\longrightarrow\\min\\limits_{\\begin{smallmatrix}B, C\\\\b_{ij}, c_{kl}\\geqslant0\\,\\forall i,j,k,l\\end{smallmatrix}}\n$$\n\n### Alternating Least Squares (ALS)\n\nALS — один из популярных методов для решения факторизационных задач. Несмотря на то, что оптимизационная задача в целом не является выпуклой, по отдельности задача поиска каждого из сомножителей является выпуклой и может решаться с помощью привычных нам методов. Таким образом, мы можем чередовать поиск $B$ при фиксированном $C$ и поиск $C$ при фиксированном $B$, итеративно сходясь к итоговому решению:\n\n![als](https://yastatic.net/s3/education-portal/media/als_algo_5bff8ae1c2_6c08e4a1f1.webp)\n\nЗаметим, что из-за насильного обнуления элементов будут получаться разреженные матрицы.\n\nРазумеется, можно рассматривать и более сложные функционалы, прибавляя к $\\Vert X - BC\\Vert^2$ различные регуляризационные члены, скажем, поощряющие большую разреженность матриц $B$ и $C$.",
        "handbook": "Учебник по машинному обучению",
        "title": "Матричная факторизация",
        "description": "Матричная факторизация"
    },
    {
        "path": "/handbook/ml/article/veroyatnostnye-raspredeleniya",
        "content": "Принимая то или иное решение в условиях недостаточной информации, нам часто приходится взвешивать шансы, просчитывать риски, а то и вовсе уповать на удачу. Теория вероятностей предоставляет математические инструменты для проведения корректных рассуждений в условиях неопределённости, количественного измерения характеристик случайных событий и оценки правдоподобия их реализации.\n\nЭтот и последующий параграфы следует рассматривать как расширенный справочник, позволяющий освежить знания по вероятности и статистике, сделав при этом упор на приложении к машинному обучению. За более систематическим курсом по теории вероятностей читателю следует обратиться к серьёзным учебникам вроде Ширяева или Феллера.\nДля погружения в статистику смотри, например, книгу Лагутина. А особо нетерпеливым рекомендуем взглянуть на короткий и ёмкий Probability and Statistics Cookbook.\n\n## Вероятностное пространство\n\nВ учебниках вероятность традиционно поставляется в комплекте с [вероятностным пространством](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D1%80%D0%BE%D1%8F%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE). Не увлекаясь чрезмерным формализмом, можно сказать, что для задания вероятностного пространства нужны:\n\n- непустое множество $\\Omega$, называемое пространством **элементарных событий** (**исходов**);\n\n- [алгебра](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2) множеств $\\mathcal F \\subset 2^{\\Omega}$ — набор подмножеств $\\Omega$, замкнутый относительно дополнений, объединений и пересечений; каждый элемент $A\\in\\mathcal F$ называется **событием**;\n\n- **вероятностная мера** $\\mathbb P \\colon \\mathcal F \\to [0, 1]$, приписывающая каждому событию $A \\in \\mathcal F$ некоторую **вероятность** $\\mathbb P(A) \\in [0,1]$.\n\nК вероятностному пространству $(\\Omega, \\mathcal F, \\mathbb P)$ предъявляются следующие требования:\n\n- $\\varnothing \\in \\mathcal F$ (**невозможное** событие), $\\Omega \\in \\mathcal F$ (**достоверное** событие);\n- $\\mathbb P(\\Omega) = 1$;\n- $\\mathbb P(A\\cup B) = \\mathbb P(A) + \\mathbb P(B)$, если $A, B \\in \\mathcal F$ и $A\\cap B= \\varnothing$ (**аддитивность**).\n\n**Упражнение**. Докажите, что $\\mathbb P(\\varnothing) = 0$ и $\\mathbb P(\\bar A) = 1 - \\mathbb P(A)$, если $A\\in\\mathcal F$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nСобытия $A$ и $\\bar A = \\Omega \\setminus A$ не пересекаются (или, как говорят, **несовместны**), поэтому из аддитивности вероятностной меры следует, что\n$\\mathbb P(A) + \\mathbb P(\\bar A) = P(\\Omega) = 1$. Полагая $A = \\varnothing$, получаем $\\mathbb P(\\varnothing) + 1 = 1$, т.е. $\\mathbb P(\\varnothing) = 0$.\n\n{% endcut %}\n\nАддитивность вероятности легко обобщается по индукции до свойства **конечной аддитивности**: если события $A_1, \\ldots, A_n$ попарно несовместны, то\n\n$$\n    \\mathbb P\\Big(\\bigcup\\limits_{k=1}^n A_k\\Big) = \\sum\\limits_{k=1}^n \\mathbb P(A_k).\n$$\n\n{% cut \"Примечание\" %}\n\nЕсли подходить совсем строго, то система множеств $\\mathcal F$ должна быть <a href=\"https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BC%D0%B0-%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0\">сигма-алгеброй</a>, а вероятностная мера $\\mathbb P$ — сигма-аддитивной, т.е.\n\n$$\n  \\mathbb P\\Big(\\bigcup\\limits_{n=1}^\\infty A_n\\Big) = \\sum\\limits_{n=1}^\\infty \\mathbb P(A_n), \\quad A_i \\cap A_j = \\varnothing \\text{ при } i\\ne j.\n$$\n\nВпрочем, эти свойства носят преимущественно теоретичеческий интерес, поскольку в\nприкладных задачах редко встречаются бесконечные наборы событий.\n\n{% endcut %}\n\nМножество $\\Omega$ часто называют **носителем**; говорят также, что вероятностная мера (масса) $\\mathbb P$ **сосредоточена**, или **распределена**, на носителе $\\Omega$. В зависимости от типа носителя $\\Omega$ распределения делятся на два типа: **дискретные** и **непрерывные**.\n\n## Дискретные распределения\n\nВероятность на не более чем счётном пространстве элементарных событий $\\Omega = \\{\\omega_1, \\omega_2, \\ldots\\}$ задаётся просто приписыванием неотрицательного числа $p_k$ каждому элементарному исходу $\\omega_k$ с условием $\\sum\\limits_k p_k = 1$. Для произвольного события $A \\subset \\Omega$ полагают $\\mathbb P(A) =  \\sum\\limits_{\\omega_k \\in A} p_k$. Набор чисел $\\{p_k\\}$ называют также **распределением вероятностей** на множестве $\\Omega$. В англоязычной литературе распространён термин **probability mass function** (сокращённо **pmf**).\n\nЗачастую в результате эксперимента нас интересуют не вероятности событий сами по себе, а значения некоторой связанной с ними **случайной величины**, принимающей числовые значения. Например:\n\n- сумма очков, выпавших при броске двух кубиков;\n- число метеоритов диаметром более одного метра, падающих на Землю в течение года;\n- ежедневный доход от показа рекламных объявлений в интернете.\n\nНа каждом элементарном исходе $\\omega_k$ случайная величина $\\xi$ принимает некоторое числовое значение $\\xi_k = \\xi(\\omega_k)$. Иными словами, случайная величина — это функция $\\xi \\colon \\Omega \\to \\mathbb R$, принимающая значение $\\xi_k$ с вероятностью $p_k$; её **математическое ожидание** (**среднее**) и **дисперсия** (**среднеквадратичное отклонение**) вычисляются по формулам\n\n$$\n\\mathbb E\\xi = \\sum\\limits_{k} \\xi_k p_k \\text{ и }\\mathbb V\\xi = \\mathbb E\\big(\\xi - \\mathbb E \\xi\\big)^2 = \\mathbb E \\xi^2 - \\big(\\mathbb E \\xi\\big)^2\n$$\n\nсоответственно. Корень из дисперсии $\\sqrt{\\mathbb V \\xi}$ назвают **стандартным отклонением** случайной величины $\\xi$. Стандартное отклонение и дисперсия показывают, насколько далеко значения случайной величины могут отклоняться от среднего значения. Стандартное отклонение хорошо тем, что, в отличие от дисперсии, измеряется в тех же единицах, что и сама случайная величина.\n\n### Равномерное распределение\n\nТак называется распределение вероятностней на множестве $\\Omega = \\{\\omega_1, \\ldots, \\omega_n\\}$, у которого $p_k =\\mathbb P(\\omega_k) = \\frac 1n$, $1\\leqslant k\\leqslant n$. Тогда $\\mathbb P(A) = \\sum\\limits_{\\omega_k \\in A} \\frac 1n  = \\frac{\\vert A\\vert}{\\vert \\Omega\\vert}$, и мы получили формулу из классического подхода к вероятности, при котором вероятность события равна отношению числа благоприятных исходов к общему их количеству.\n\nРавномерным распределением моделируются различные игровые ситуации:\n\n- подбрасывание симметричной монеты ($\\omega_1 = «орёл»$, $\\omega_2 = «решка»$);\n- подбрасывание кубика ($\\omega_k = k$, $1\\leqslant k \\leqslant 6$);\n- вращение рулетки в казино ($n=37$ для европейской, $n=38$ для американской).\n\n**Упражнение.** У европейской рулетки по $18$ чёрных и красных секторов и один сектор «зеро». Игрок ставит €10 на чёрное. В случае успеха казино выплачивает ему ещё €10, в противном случае забирает ставку. Чему равно математическое ожидание, дисперсия и стандартное отклонение выигрыша?\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nЗдесь выигрыш — это случайная величина $\\xi$, принимающая значение $-10$ евро в $19$-ти исходах и $+10$ евро в $18$-ти. Распределение равномерное (если верить в честность казино), поэтому $\\mathbb E\\xi = 10\\cdot\\frac{18}{37} - 10\\cdot\\frac{19}{37} = -\\frac {10}{37}$ евро.\n\nСлучайная величина $\\xi^2$ постоянна (а вовсе не «случайна») и при любом исходе равна 100 («квадратных евро»?), поэтому\n\n$$\n  \\mathbb V\\xi = \\mathbb E \\xi^2 - \\big(\\mathbb E \\xi\\big)^2 = 100 \\cdot\\Big(1 - \\frac{1}{37^2}\\Big)\\approx 99.927.\n$$\n\nСтандартное отклонение выигрыша равно $\\frac{10 \\sqrt{1368}}{37} \\approx 9.996$ евро, что почти совпадает со ставкой игрока. Это отражает сущность игры в рулетку: либо пан, либо пропал. Причём последнее чуть вероятнее из-за отрицательности математического ожидания.\n\n{% endcut %}\n\n**Вопрос на подумать**. Бывают ли равномерные распределения в пространствах со счётным носителем?\n\n{% cut \"Ответ (не открывайте сразу, сначала подумайте самостоятельно)\" %}\n\nНет, поскольку условие нормировки требует сходимости ряда $\\sum\\limits_{k} p_k = 1$, а это равенство никак не может быть выполнено при одинаковых числах $p_k$. Либо все эти вероятности равны нулю, и тогда их сумма тоже равна нулю; либо же получается бесконечная сумма одинаковых положительных слагаемых, которая равна $+\\infty$.\n\n{% endcut %}\n\nРавномерные распределения преимущественно встречаются в разного сорта играх. В более жизненных ситациях случайность обычно распределена отнюдь не равномерно.\n\n### Распределение Бернулли\n\nТак называется очень простое распределение всего лишь с двумя исходами:\n\n$$\n    \\mathbb P(\\text{«успех»}) = p, \\quad \\mathbb P(\\text{«неудача»}) = 1-p, \\quad 0\\leqslant p \\leqslant 1.\n$$\n\n**Бернуллиевская** случайная величина $\\xi\\sim\\mathrm{Bern}(p)$ — это просто индикаторная функция успешного события: $\\xi = 1$, если случился «успех», $\\xi = 0$, если нас постигла «неудача». Несложные вычисления показывают, что\n\n$$\n\\mathbb E \\xi = 1\\cdot p + 0 \\cdot (1-p) = p, \\quad\n\\mathbb V \\xi = p-p^2 = p(1-p).\n$$\n\nЕсли $p=\\frac 12$, то снова получается равномерное распределение с двумя исходами. При $p\\ne \\frac 12$ бернуллиевская случайная величина моделирует подбрасывание несимметричной монеты. В машинном обучении часто встречается задача бинарной классификации, и разбиение на классы обычно кодируется с помощью $\\mathrm{Bern}(p)$, например:\n\n- диагностика болезни (болен — $1$, здоров — $0$);\n- оценка кредитоспособности клиента (одобрить кредит — $0$, отказать $1$);\n- предсказание поведения пользователя (кликнет на рекламу — $1$, пропустит — $0$).\n\nВ этих примерах вероятности классов явно не равны, поэтому несимметричное распределение Бернулли — типичная ситуация в реальных задачах.\n\n### Биномиальное распределение\n\n**Биномиальное распределение** $\\mathrm{Bin}(n, p)$ имеет сумма независимых бернуллиевских случайных величин $\\xi_k\\sim \\mathrm{Bern}(p)$: $\\eta \\sim \\mathrm{Bin}(n, p)$, если $\\eta = \\xi_1 + \\ldots + \\xi_n$. Другими словами, случайная величина $\\eta$ равна количеству успехов в $n$ независимых испытаниях Бернулли с вероятностью успеха $p$. Случайная величина $\\eta$ принимает значения от $0$ до $n$, и\n\n$$\n  p_k=P(\\eta = k) = \\binom nk p^k (1-p)^{n-k},\\quad 0\\leqslant k \\leqslant n.\n$$\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/slider_binomial_28dc938f6a_94f0fea15b.html\" width=100% height=500 frameborder=0></iframe>\n\nОтметим, что согласно [биному Ньютона](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%BD%D0%BE%D0%BC_%D0%9D%D1%8C%D1%8E%D1%82%D0%BE%D0%BD%D0%B0)\n\n$$\n  \\sum\\limits_{k=0}^n p_k = \\big(p + (1-p)\\big)^n = 1,\n$$\n\nпоэтому числа $\\{p_k\\}$ действительно представляют собой распределение вероятностей, называемое также **биномиальным**. Если $\\xi \\sim\\mathrm{Bin}(n, p)$, то\n\n$$\n\\mathbb E \\xi = np, \\quad \\mathbb V \\xi = np(1-p).\n$$\n\n**Пример**. Каждый день рекламу компании А поисковой выдаче Яндекса видят ровно $1000$ человек. Вчера $50$ из них кликнули на рекламу. Для прогнозирования объемов продаж компании А хочется знать, с какой вероятностью не менее 50 людей кликнут на ее рекламу сегодня.\n\nЕсли моделировать наличие или отсутствие клика бернуллиевской случайной величиной, то общее количество кликов за день моделируется случайной величиной $\\xi \\sim \\mathrm{Bin}(n, p)$ с параметрами $n=1000$ и $p = \\frac{50}{1000} = 0.05$. Тогда с помощью вычислительной техники получаем, что\n\n$$\n  \\mathbb P(\\xi \\geqslant 50) = \\sum\\limits_{k = 50}^{n} \\binom{n}{k} p^k (1 - p)^{n-k} = 1 - \\sum\\limits_{k = 0}^{49} \\binom {1000}{k} 0.05^k 0.95^{1000 - k} \\approx 0.52.\n$$\n\nОтметим, что параметр $p$ в предыдущем примере нам, строго говоря, не был известен, и вместо него мы использовали частотную оценку.\n\n### Распределение Пуассона\n\nЭто распределение имеет счётный носитель $\\Omega = \\mathbb N \\cup \\{0\\}$. Случайная величина $\\xi$ имеет **пуассоновское распределение** с параметром $\\lambda$, $\\xi \\sim \\mathrm{Pois}(\\lambda)$, если\n\n$$\n  \\mathbb P(\\xi = k) = e^{-\\lambda} \\frac{\\lambda^k}{k!}, \\quad k \\in \\mathbb N \\cup \\{0\\}.\n$$\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/slider_poisson_1566c16c9e_05597862cc.html\" width=100% height=500 frameborder=0></iframe>\n\nИзвестное разложение экспоненты в ряд Тейлора $e^\\lambda = \\sum\\limits_{k=0}^\\infty  \\frac{\\lambda^k}{k!}$ позволяет заключить, что вероятности распределения Пуассона действительно суммируются в единицу. Этот же ряд позволяет вычислить, что\n\n$$\n\\mathbb E \\xi = \\mathbb V \\xi = \\lambda.\n$$\n\nПуассоновская случайная величина моделирует число редких событий, происходящих в течение фиксированного промежутка времени: если события наступают со средней скоростью $r$, то\n\n$$\n  \\mathbb P(k \\text{ событий на промежутке } t) = e^{-rt} \\frac{(rt)^k}{k!}, \\quad k \\in \\mathbb N \\cup \\{0\\}.\n$$\n\nИногда приходится рассматривать биномиальное распределение $\\mathrm{Bin}(n, p)$ с большим числом попыток $n$ и вероятностью успеха $p$ с условием $np \\approx \\lambda > 0$. Оказывается, что вне зависимости от $n$ такое распределение быстро стабилизируется, сходясь к пуассоновскому распределению с параметром $\\lambda$. Точнее говоря, справедлива следующая теорема.\n\n**Теорема (Пуассон)**. Пусть $\\xi \\sim \\mathrm{Bin}(n, p_n)$ и $\\lim\\limits_{n \\to \\infty} np_n = \\lambda > 0$. Тогда\n\n$$\n  \\lim\\limits_{n \\to \\infty} \\mathbb{P}(\\xi = k) =  e^{-\\lambda} \\frac{\\lambda^k}{k!}, \\quad k \\in \\mathbb N \\cup \\{0\\}.\n$$\n\n**Пример**. Известно, что на поисковой выдаче яндекса на рекламу компании А кликает в среднем примерно 50 пользоваталей в день. Количество показов достаточно большое и может меняться изо дня в день. Требуется оценить вероятность того, что сегодня будет совершено не менее 50 кликов по рекламным объявлениям.\n\nРаспределение количества кликов снова будем моделировать биномиальным распределением $\\mathrm{Bin}(n, p)$. На этот раз число $n$ нам неизвестно, но сказано, что оно велико и $np \\approx 50$ (вспомним, что $\\mathbb E\\xi = np$, если $\\xi \\sim \\mathrm{Bin}(n, p)$). Поэтому можно воспользоваться теоремой Пуассона и заменить биномиальное распределение пуассоновским с параметром $\\lambda = 50$. Тогда искомая вероятность равна\n\n$$\n  1 - \\sum\\limits_{k = 0}^{49} e^{-50} \\frac{50^k}{k!} \\approx 0.518,\n$$\n\nчто практически совпадает ответом, полученным с помощью биномиального распределения при $n = 1000$.\n\n### Геометрическое распределение\n\nПусть монетка с вероятностью «успеха» $p$ подбрасывается до тех пор, пока впервые не случится «успех». Случайная величина $\\xi$, равная общему количеству попыток на этом пути, имеет **геометрическое** распределение, т.е.\n\n$$\n  \\mathbb P(\\xi = k) = q^{k-1}p, \\quad q = 1-p, \\quad k \\in \\mathbb N.\n$$\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/slider_geom_46e10aae89_bd7f66c833.html\" width=100% height=500 frameborder=0></iframe>\n\nПо формуле геометрической прогрессии находим, что\n\n$$\n  \\sum\\limits_{k=1}^\\infty \\mathbb P(\\xi = k) = \\sum\\limits_{k=0}^\\infty q^kp = \\frac p{1-q} = 1,\n$$\n\nпоэтому с нормировкой тут всё в порядке. Чем меньше $p$, тем больше геометрическое распределение похоже на равномерное, что подтверждают и формулы для среднего и дисперсии:\n\n$$\n\\mathbb E \\xi = \\frac 1p, \\quad \\mathbb V \\xi = \\frac{1-p}{p^2}.\n$$\n\n**Пример**. По оценкам за предыдущие дни пользователь нажимает на рекламу с вероятностью $p=0.05$. Сегодня компания B планирует показать очень важное рекламное объявление и требует от Яндекса, чтобы с вероятностью не менее $99\\%$ на него кликнули хотя бы раз. Скольким различным людям следует показать это объявление?\n\nЗдесь мы имеем дело с геометрическим распределением с вероятностью «успеха» (клика) $p$: именно так распределена случайная величина $\\xi$, равная количеству показов объявления до первого клика по нему. Следовательно,\n\n$$\n  \\mathbb P(\\xi \\leqslant n) = \\sum\\limits_{k=1}^n \\mathbb P(\\xi = k) = \\sum\\limits_{k=1}^n q^{k-1}p = p\\cdot \\frac{1 - q^{n}}{1-q} = 1-q^n.\n$$\n\nЭта вероятность должна быть не меньше $99\\%$, т. е. $0.95^n \\geqslant 0.01$. Отсюда находим, что\n$n \\geqslant \\frac{\\log 0.01}{\\log 0.95} \\approx 89.78$. Таким образом, рекламу надо показать как минимум $90$ раз.\n\n### Гипергеометрическое распределение\n\n**Пример**. Известно, что партия из $N$ деталей содержит $K$ бракованных. Какова вероятность того, что среди выбранных наугад $n$ деталей окажется ровно $k$ бракованных?\n\nВсего есть $\\binom N n$ способов выбора $n$ деталей из партии. Число вариантов выбрать $k$ деталей из $K$ бракованных и $n-k$ из $N-K$ деталей без дефектов равно $\\binom K k \\binom{N-K}{n-k}$. По классическому определению вероятности получаем, что искомая вероятность равна\n\n$$\n  p_k = \\frac{\\binom K k \\binom{N-K}{n-k}}{\\binom N n}, \\quad 0 \\leqslant k \\leqslant \\min\\{K, n\\}.\n$$\n\nТакое распределение называется **гипергеометрическим**. Равенство\n\n$$\n\\sum\\limits_{k=0}^{\\min\\{K, n\\}} p_k = 1\n$$\n\nследует из [тождества Вандермонда](https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D0%B6%D0%B4%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%92%D0%B0%D0%BD%D0%B4%D0%B5%D1%80%D0%BC%D0%BE%D0%BD%D0%B4%D0%B0). Если случайная величина $\\xi$ имеет гипергеометрическое распределение с параметрами $N$, $K$, $n$, то\n\n$$\n  \\mathbb E \\xi = \\frac{nK}{N}, \\quad \\mathbb V\\xi = n\\frac{K(N-K)(N-n)}{N^2(N-1)}.\n$$\n\nГипергеометрическое распределение является аналогом биномиального, при котором моделируется выбор без возвращения с вероятностью успеха $p\\approx \\frac KN$.\n\n## Непрерывные распределения\n\nВероятностная модель с конечным или счётным носителем не подходит в тех случаях, когда результатом эксперимента удобно считать произвольное действительное число, например, распределение людей по росту или по весу. Для этого требуется пересмотреть подход к построению пространства элементарных событий $\\Omega$: ведь множество действительных чисел $\\mathbb R$ континуально, и поэтому вероятность события не получится определить как сумму вероятностей всех составляющих исходов, коих тоже может оказаться континуум. Приходится искать другие способы задания вероятности.\n\nНаиболее часто встречающийся на практике класс непрерывных распределений на числовой прямой задаётся с помощью неотрицательной интегрируемой функции **плотности** (**probability density function**, **pdf**) $p(x)$ со свойством\n\n$$\n  \\int\\limits_{-\\infty}^{+\\infty} p(x) dx = 1.\n$$\n\nВероятность события $A$ определяется как\n\n$$\n  \\mathbb{P}(A) = \\int\\limits_{A} p(x) dx\n$$\n\nпри условии, что этот интеграл имеет смысл. В частности,\n\n$$\n  \\mathbb{P}([a, b)) = \\int\\limits_a^b p(x) dx.\n$$\n\n**Замечание**. Связь между вероятностью и плотностью распределения весьма напоминает связь между массой и физической плотностью. Когда плотность объекта всюду одинакова, то масса равна плотности, умноженной на объём. Если же объект неоднороден, то плотность становится функцией, сопоставляющей каждой точке некое число (что-то вроде предела отношения массы малого шарика вокруг этой точки к объёму шарика). Тогда масса любого куска объекта может быть вычислена, как интеграл функции плотности по объёму этого куска.\n\nС плотностью вероятности $p(x)$ автоматически связана случайная величина $\\xi\\colon  \\mathbb R  \\to  \\mathbb R$, для которой $\\mathbb P(a\\leqslant \\xi < b) = \\int\\limits_a^b p(x)\\,dx$. Функция $p(x)$ называется плотностью случайной величины $\\xi$, и обозначается также как $p_\\xi(x)$. Иногда используется запись $\\xi \\sim p(x)$. Среднее и дисперсия случайной величины $\\xi \\sim p(x)$ вычисляются по формулам\n\n$$\n  \\mathbb E \\xi = \\int\\limits_{-\\infty}^{\\infty} xp(x)\\,dx,\\quad\n  \\mathbb V \\xi = \\int\\limits_{-\\infty}^{\\infty} x^2p(x)\\,dx - (\\mathbb E \\xi)^2.\n$$\n\n### Равномерное распределение\n\n**Равномерное** распределение на отрезке $[a;b]$, которое часто обозначают $U[a,b]$, имеет постоянную плотность на этом отрезке:\n\n$$\n  p(x) = \\frac {\\mathbb I(a\\leqslant x \\leqslant b)}{b-a} = \\begin{cases}\n  \\frac 1{b-a},& x\\in[a, b],\\\\\n  0, & x \\notin [a, b].\n  \\end{cases}\n$$\n\nЕсли $\\xi \\sim U[a,b]$, то\n\n$$\n\\mathbb E \\xi = \\frac {a+b}2,\\quad \\mathbb V \\xi = \\frac{(b-a)^2}{12}.\n$$\n\n**Вопрос на подумать**. Можно ли задать равномерное распределения на неограниченном промежутке, например, на $\\mathbb R$ или на $\\mathbb [0, +\\infty)$?\n\n{% cut \"Ответ (не открывайте сразу, сначала подумайте самостоятельно)\" %}\n\nСтрого говоря, нет, покольку интеграл от константы по неограниченному промежутку расходится, и потому не может равняться единице. Однако при байесовском выводе в качестве априорного распределения иногда приходится выбирать ненормируемое распределение, в том числе, например, равномерное на $[0, +\\infty)$. Такое «распределение» (которое на самом деле никакое не распределение) также называют **несобственным**.\n\n{% endcut %}\n\nАналогичным образом вводится равномерное распределение в многомерном пространстве: если множество $V \\subset \\mathbb R^n$ имеет объём $\\vert V\\vert$, то плотность равномерно распределённой на $V$ случайной величины $\\xi$ задаётся как $p_\\xi(\\boldsymbol x) = \\frac{\\mathbb I(\\boldsymbol x \\in V)}{\\vert V\\vert}$. Если $A \\subset V$, то\n\n$$\n\\mathbb P(A) = \\frac 1{\\vert V\\vert}\\int\\limits_A d\\boldsymbol x = \\frac {\\vert A\\vert}{\\vert V\\vert},\n$$\n\nи мы получили формулу **геометрической вероятности**.\n\n### Нормальное распределение\n\nСлучайная величина $\\xi$ имеет **нормальное** (**гауссовское**) распределение $\\mathcal N(\\mu, \\sigma^2)$, если её плотность равна\n\n$$\np_\\xi(x) = \\frac 1{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}.\n$$\n\nПараметры нормального распределения $\\mathcal N(\\mu, \\sigma^2)$ представляют собой его среднее и дисперсию:\n\n$$\n\\mathbb E \\xi = \\mu,\\quad \\mathbb V \\xi = \\sigma^2.\n$$\n\nПараметр $\\sigma$ отвечает за выраженность «колокола» плотности нормального распределения:\n\n- при $\\sigma \\to 0$ «колокол» приобретает очертания резко выраженного пика, то есть практически вся вероятностная масса сосретдоточена в малой окрестности точки $x = \\mu$;\n- при $\\sigma \\to +\\infty$ «колокол», наоборот, размывается, и распределение становится больше похоже на равномерное.\n\nГауссиана, у которой $\\mu=0$ и $\\sigma = 1$, называется **стандартным нормальным распределением**.\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/button_gaussian_78c43b7d42_4272dd7886.html\" width=100% height=500 frameborder=0></iframe>\n\nИногда бывает полезно тесно связанное с гауссовским **логнормальное** распределение.\nСлучайная величина $\\xi \\colon (0, +\\infty) \\to \\mathbb R$ имеет логнормальное распределение, $\\xi \\sim \\mathcal{LogN}(\\mu, \\sigma^2)$, если $\\log \\xi \\sim \\mathcal N(\\mu, \\sigma^2)$. Плотность логнормальной случайной величины равна\n\n$$\np_\\xi(x) = \\frac 1{\\sqrt{2\\pi}\\sigma x} e^{-\\frac{(\\log x-\\mu)^2}{2\\sigma^2}}, \\quad x > 0,\n$$\n\nа её среднее и дисперсию можно вычислить по формулам\n\n$$\n  \\mathbb E\\xi = e^{\\mu + \\frac{\\sigma^2}2}, \\quad  \\mathbb V\\xi=\\big(e^{\\sigma^2} - 1\\big) e^{2\\mu + \\sigma^2}.\n$$\n\n### Показательное распределение\n\nПлотность **показательного** (**экспоненциального**) распределения $\\mathrm{Exp}(\\lambda)$ сосредоточена на луче $[0, +\\infty)$ и имеет параметр $\\lambda > 0$: $p(x) = \\lambda e^{-\\lambda x}$, $x \\geqslant 0$. Если $\\xi \\sim \\mathrm{Exp}(\\lambda)$, то\n\n$$\n\\mathbb E \\xi = \\frac 1\\lambda,\\quad \\mathbb V \\xi = \\frac 1{\\lambda^2}.\n$$\n\nПлотность показательного распределения является убывающей функцией на $[0, +\\infty)$, а параметр $\\lambda$ отвечает за скорость этого убывания:\n\n- при $\\lambda \\to 0$ убывание очень медленное, и распределение больше похоже на равномерное;\n- при $\\lambda \\to +\\infty$, наоборот, вся вероятностная масса сосредоточена около точки $0$.\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/button_exp_9b7b050329_f487e69793.html\" width=100% height=500 frameborder=0></iframe>\n\nПоказательное распределение моделирует временные интервалы между случайными событиями, наступающими с постоянной скоростью, например:\n\n- время ожидания автобуса на остановке;\n- время между телефонными звонками в колл-центре;\n- время до выхода из строя вычислительного узла в дата-центре.\n\n**Гамма-распределение** с положительными параметрами $\\alpha$ и $\\beta$ имеет плотность\n\n$$\n  p(x) = \\frac 1{\\Gamma(\\alpha) \\beta^\\alpha} x^{\\alpha - 1} e^{-\\frac x \\beta},\\quad x \\geqslant 0,\n$$\n\nгде $\\Gamma(\\alpha)$ — [гамма-функция Эйлера](https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BC%D0%BC%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F). При $\\alpha =1$ гамма-распределение превращается в показательное с параметром $\\lambda = \\frac 1\\beta$. Среднее и дисперсия случайной величины $\\xi$, имеющей гамма-распределение с параметрами $\\alpha$ и $\\beta$, равны\n\n$$\n\\mathbb E\\xi = \\alpha\\beta, \\quad \\mathbb V\\xi = \\alpha\\beta^2.\n$$\n\n### Бета-распределение\n\nПлотность **бета-распределения** с параметрами $\\alpha, \\beta > 0$ равна\n\n$$\n  p(x) = \\frac 1{B(\\alpha, \\beta)} x^{\\alpha - 1} (1-x)^{\\beta -1}, \\quad 0 < x < 1,\n$$\n\nгде $B(\\alpha, \\beta)$ — [бета-функция Эйлера](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%82%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F).\n\nБета-распределение имеет следующее статистическое приложение. Выберем случайным образом точки $x_1, \\ldots, x_n \\in [0,1]$, и упорядочим их по возрастанию. Получим набор значений\n\n$$\n  0\\leqslant x_{(1)} \\leqslant x_{(2)} \\leqslant \\ldots \\leqslant x_{(k)} \\leqslant \\ldots \\leqslant x_{(n)} \\leqslant 1.\n$$\n\nОказывается, что случайная величина $\\xi = x_{(k)}$, называемая **$k$-й порядковой статистикой**, имеет бета распределение с параметрами $k$ и $n+1 - k$:\n\n$$\n  p_\\xi(x) = \\frac{n!}{(k-1)!(n-k)!} x^{k-1}(1-x)^{n-k} = k \\binom nk x^{k-1}(1-x)^{n-k}.\n$$\n\n{% cut \"Доказательство \" %}\n\nПусть $y\\in [0, 1]$. Неравенство $x_{(k)}\\leqslant y$ означает, что из $n$ элементов выборки хотя бы $k$ не превосходят $y$. Заметим, что для каждого $i$ индикатор $\\mathbb{I}(x_i\\leqslant y)$ является бернуллиевской случайной величиной с вероятностью успеха $y$. У нас есть $n$ таких бернуллиевских величин, и неравенство $x_{(k)}\\leqslant y$ равносильно тому, что среди $n$ испытаний Бернулли случилось не менее $k$ успехов. Вероятность того, что случилось ровно $j$ успехов, равна, как мы уже знаем,\n\n$$\\binom {n}{j}y^j(1 - y)^{n-j}.$$\n\nЧтобы получить вероятность того, что успехов хотя бы $k$, надо просуммировать эти числа по $j$ от $k$ до $n$:\n\n$$F_\\xi(y) = \\mathbb P (x_{(k)} \\leqslant y) = \\sum_{j=k}^n\\binom {n}{j}y^j(1 - y)^{n-j}.$$\n\nЧтобы получить плотность, продифференцируем функцию распределения:\n\n$$\np_{\\xi}(y) = \\sum_{j=k}^n j\\binom nj y^{j-1}(1 - y)^{n-j} - \\sum_{j=k}^{n-1} (n-j)\\binom nj y^{j}(1 - y)^{n-1-j}.\n$$\n\nЛегко проверяется, что $j\\binom nj = n\\binom {n-1}{j-1}$, $(n-j)\\binom nj = n\\binom{n-1}j$, и поэтому\n\n$$\n  \\sum_{j=k}^n j\\binom nj y^{j-1}(1 - y)^{n-j}  = \\sum_{j=k-1}^{n-1} n\\binom{n-1}j y^{j}(1 - y)^{n-1-j}\n$$\n\nИ мы видим, что большинство слагаемых сокращается и выживает лишь одно:\n\n$$\np_{\\xi}(y) = \\frac{n!}{(k-1)!(n-k)!}y^{k-1}(1 - y)^{n-k}.\n$$\n\n{% endcut %}\n\n### Распределение Стьюдента\n\nПри проверке статистических гипотез бывает полезно **распределение Стьюдента** (**t-distribution**) с $\\nu$ степенями свободы, плотность которого равна\n\n$$\n  p(x) = \\frac{\\Gamma(\\frac{\\nu+1}{2})} {\\sqrt{\\nu\\pi}\\,\\Gamma(\\frac{\\nu}{2})} \\left(1+\\frac{x^2}\\nu \\right)^{-(\\nu+1)/2}, \\quad \\nu > 0,\n$$\n\nгде $\\Gamma(\\alpha)$ — гамма-функция Эйлера. Распределение Стьюдента похоже на стандартное нормальное распределение; более того, при $\\nu\\to +\\infty$ оно превращается в $\\mathcal N(0, 1)$.\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/sliders_t_c618ee8b26_bca1415c8b.html\" width=100% height=500 frameborder=0></iframe>\n\nОднако при малых значениях $\\nu$ распределение Стьюдента имеет гораздо более тяжёлые «хвосты»: например, при $\\nu \\leqslant 2$ его дисперсия бесконечна, а при $\\nu \\leqslant 1$ та же участь постигает и математическое ожидание (всё из-за расходимости соответствующих интегралов). В остальных случаях\n\n$$\n  \\mathbb E \\xi = 0, \\quad \\mathbb V \\xi = \\frac{\\nu}{\\nu-2},\n$$\n\nесли $\\xi$ имеет распределение Стьюдента с $\\nu$ степенями свободы.\n\n### Распределение Лапласа\n\nПлотность **распределения Лапласа** с параметрами $\\mu, b$ равна\n\n$$\n   p(x) = \\frac 1{2b} e^{-\\frac{\\vert x - \\mu\\vert}b}.\n$$\n\nТакое распределение иногда обозначают $\\mathrm{Laplace}(\\mu, b)$. Если $\\xi \\sim \\mathrm{Laplace}(\\mu, b)$, то\n\n$$\n  \\mathbb E \\xi = \\mu, \\quad \\mathbb V \\xi = 2b^2.\n$$\n\nПри $\\mu=0$ распределение Лапласа представляет собой экспоненциальное распределение, плотность которого симметрично отражена на отрицательную полуось: если $\\xi \\sim \\mathrm{Laplace}(0, b)$, то $\\vert \\xi \\vert \\sim \\mathrm{Exp}\\big(\\frac 1b\\big)$. Распределение Лапласа похоже на нормальное и отличается от него немного более тяжёлыми «хвостами» и тем, что его плотность теряет гладкость в нуле.\n\n## Характеристики случайных величин\n\n### Моменты\n\nЕсли $n\\in \\mathbb N$, то **$n$-й момент** $\\mu_n$ случайной величины $\\xi$ равен $\\mathbb E \\xi^n$. В зависимости от типа случайной величины моменты вычисляются по-разному:\n\n- $\\mu_n = \\sum\\limits_k x_k^n \\mathbb P(\\xi = x_k)$, если $\\xi$ принимает дискретные значения $x_1, x_2, \\ldots, x_k, \\ldots$;\n- $\\mu_n = \\int\\limits_{-\\infty}^{+\\infty} x^n p_\\xi(x)\\, dx$, если $\\xi$ имеет плотность $p_\\xi(x)$.\n\nПервый момент $\\mu_1$ — это в точности математическое ожидание (среднее) случайной величины $\\xi$. Дисперсию тоже можно выразить через моменты:\n\n$$\n\\mathbb V\\xi = \\mathbb E \\xi^2 - \\big(\\mathbb E\\xi\\big)^2 = \\mu_2 - \\mu_1^2.\n$$\n\nНе у всех случайных величин есть конечные среднее и дисперсия. Например, **распределение Коши** (оно же [распределение Стьюдента](#распределение-стьюдента) с одной степенью свободы) имеет плотность $p(x) = \\frac 1\\pi \\frac 1{1+x^2}$, и если мы попытаемся вычислить первые два момента, то получим расходящиеся интегралы\n\n$$\n  \\frac 1\\pi\\int\\limits_{-\\infty}^{+\\infty} \\frac{x}{1+x^2} dx \\text{ и }\n  \\frac 1\\pi\\int\\limits_{-\\infty}^{+\\infty} \\frac{x^2}{1+x^2} dx.\n$$\n\n**Упражнение**. Приведите пример дискретной случайной величины с бесконечным средним.\n\n{% cut \"Ответ\" %}\n\nТакое может быть только если случайная величина $\\xi$ принимает счётное число значений. Пусть, например, $\\mathbb P(\\xi = k) = \\frac 1{k(k+1)}$, $k\\in \\mathbb N$. Поскольку $\\sum\\limits_{k=1}^\\infty \\frac 1{k(k+1)} = 1$, это корректное распределение вероятностей. С другой стороны, $\\mathbb E\\xi = \\sum\\limits_{k=1}^\\infty \\frac 1{k+1}$, а это почти что гармонический ряд, который расходится.\n\n{% endcut %}\n\n### Свойства математического ожидания\n\n1. Если $\\xi = C$, то $\\mathbb E \\xi = C$.\n\n2. $\\mathbb E(a\\xi + b \\eta) = a\\mathbb E \\xi + b \\mathbb E \\eta$ (линейность).\n\n3. Если $\\xi \\leqslant \\eta$, то $\\mathbb E \\xi \\leqslant \\mathbb E \\eta$ (монотонность).\n\n4. $\\mathbb E \\mathbb I(A) = \\mathbb P(A)$.\n\n5. Если случайные величины $\\xi$ и $\\eta$ независимы, то $\\mathbb E\\xi\\eta = \\mathbb E\\xi \\mathbb E\\eta$.\n\n6. Если $\\xi \\geqslant 0$, то $\\mathbb P(\\xi \\geqslant a) \\leqslant \\frac{\\mathbb E \\xi}{a}$ (**неравенство Маркова**).\n\n7. Если функция $f$ выпукла вниз, то $f(\\mathbb E \\xi) \\leqslant \\mathbb E(f(\\xi))$ (**неравенство Йенсена**).\n\n**Law of the unconscious statistician (LOTUS)**\n\nЕсли случайная величина $\\eta$ получена применением некоторой детерминированной функцией из случайной величины $\\xi$, $\\eta = g(\\xi)$, то\n\n- $\\mathbb E\\eta = \\sum\\limits_k g(x_k) \\mathbb P(\\xi = x_k)$, если $\\xi$ дискретна;\n- $\\mathbb E\\eta = \\int\\limits_{-\\infty}^{+\\infty} g(x) p_{\\xi}(x)\\,dx$, если $\\xi$ непрерывна.\n\n### Дисперсия и ковариация\n\n**Ковариация** случайных величин $\\xi$ и $\\eta$ определяется по формуле\n\n$$\n\\mathrm{cov}(\\xi,\\eta) = \\mathbb E((\\xi - \\mathbb E\\xi) \\cdot (\\eta - \\mathbb E \\eta)) = \\mathbb E(\\xi \\cdot\\eta) - \\mathbb E\\xi \\cdot \\mathbb E\\eta\n$$\n\nВ частности, $\\mathrm{cov}(\\xi,\\xi) = \\mathbb V \\xi$. На практике часто применяют **коэффициент корреляции**, который получается нормированием ковариации:\n\n$$\n  \\mathrm{corr}(\\xi, \\eta) = \\frac{\\mathrm{cov}(\\xi,\\eta)}{\\sqrt{\\mathbb V \\xi}\\sqrt{\\mathbb V \\eta}}.\n$$\n\nКоэффициент корреляции всегда принимает значения из отрезка $[-1;1]$. Если $\\mathrm{corr}(\\xi, \\eta) = 0$, то случайные величины $\\xi$ и $\\eta$ называют **некоррелированными**.\n\n**Свойства дисперсии и ковариации**\n\n1. $\\mathbb V \\xi \\geqslant 0$, причём $\\mathbb V \\xi = 0 \\iff \\exists a\\in\\mathbb R \\colon \\mathbb P(\\xi = a) = 1$.\n\n2. $\\mathbb V (a\\xi) = a^2 \\mathbb V \\xi$, $\\mathbb V(\\xi + a) = \\mathbb V\\xi$.\n\n3. $\\mathrm{cov}(\\xi, \\eta) = \\mathrm{cov}(\\eta, \\xi)$, $\\mathrm{cov}(a\\xi, b\\eta) = ab\\mathrm{cov}(\\xi, \\eta)$.\n\n4. $\\mathbb V(\\xi + \\eta) = \\mathbb V \\xi + \\mathbb V \\eta + 2\\mathrm{cov}(\\xi, \\eta)$.\n\n5. Если случайные величины $\\xi$ и $\\eta$ независимы, то $\\mathrm{cov}(\\xi, \\eta) = 0$ и $\\mathbb V(\\xi + \\eta) =  \\mathbb V\\xi + \\mathbb V\\eta$.\n\n6. $\\mathbb P(\\vert\\xi - \\mathbb E\\xi\\vert \\geqslant a) \\leqslant \\frac{\\mathbb V \\xi}{a^2}$ (**неравенство Чебышева**).\n\n### Функции распределения и плотности\n\nСлучайная величина $\\xi \\colon \\Omega \\to \\mathbb{R}$ является числовой функцией, заданной на пространстве элементарных событий; однако, больший интерес обычно представляет порождаемое ею распределение вероятностей. В дискретном случае достаточно задать вероятности отдельных значений $\\mathbb{P}(\\xi = x_i)$; для непрерывных же случайных величин на помощь приходят функция распределения и функция плотности.\n\n**Функцией распределения** (**cumulative distribution function**, **cdf**) случайной величины $\\xi$ называется функция\n$$F_\\xi(x) = \\mathbb{P}(\\xi \\leqslant x).$$\n\nСвойства функции распределения $F_\\xi$:\n\n- $F_\\xi(-\\infty) = 0$, $F_\\xi(+\\infty) = 1$;\n- функция $F_\\xi$ неубывающая;\n- функция $F_\\xi$ непрерывна справа: $\\lim\\limits_{h \\to 0+ } F_\\xi(x + h) = F_\\xi(x)$;\n- $\\mathbb{P}(a < \\xi \\leqslant b) = F_\\xi(b) - F_\\xi(a)$.\n\nЛюбая дискретная случайная величина имеет ступенчатую функцию распределения. К примеру, вот как выглядит график функции $F_\\xi$ для $\\xi \\sim \\mathrm{Bin}(10, 0.5)$:\n\n<iframe src=\"https://yastatic.net/s3/education-portal/media/slider_binomial_cdf_21ed33b291_9b31c0ed41.html\" width=100% height=500 frameborder=0></iframe>\n\nЕсли непрерывная случайная величина $\\xi$ имеет непрерывную плотность $p_\\xi(x)$, то\n\n$$\n  F_\\xi(x) - F_\\xi(a) = \\int\\limits_a^x p_\\xi(t)\\, dt,\n$$\n\nоткуда следует, что $F'_\\xi(x) = p_\\xi(x)$. В типичных случаях непрерывная случайная величина имеет гладкую возрастающую функцию распределения с двумя горизонтальными асимптотами. Вот примеры графиков функций распределения гауссовских случайных величин:\n\n<br><br>\n\n{% cut \"Замечание о плотностях дискретных случайных величин\" %}\n\nДискретные случайные величины не имеют плотности в описанном выше смысле. Например, возьмем $\\xi$ – выпавшее число на идеальной кости. Тогда $p_\\xi$ равна 0 везде кроме 1, 2, 3, 4, 5, 6. При этом вероятность выпасть 1 равна $\\tfrac16$, то есть\n\n$$\n\\int\\limits_{1 - \\varepsilon}^{1 + \\varepsilon} p_\\xi(x)\\, dx = \\frac16\n$$\n\nдля любого малого $\\varepsilon > 0$. Среди обычных функций мы такой плотности не найдём, однако, её можно выразить в терминах <a href=\"https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D1%91%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F\">обобщенных функций</a>:\n\n$$\np_\\xi(x) = \\frac 16 \\sum\\limits_{k=1}^6 \\delta(x-k),\n$$\n\nгде $\\delta(x)$ – **дельта-функция Дирака**, обладающая свойством\n\n$$\n\\int\\limits_{-\\infty}^{+\\infty} \\delta(x)f(x)\\,dx = f(0)\n$$\n\nдля любой непрерывной функции $f$. Отсюда, в частности, следует, что\n\n$$\n\\int\\limits_{x_0-\\varepsilon}^{x_0 + \\varepsilon} \\delta(x - x_0)\\, dx = 1.\n$$\n\nДо какой-то степени $\\delta(x)$ можно представлять себе как «функцию», равную $0$ везде, кроме $x=0$, а в нуле принимающую некоторое экзотическое «бесконечное» значение.\n\n{% endcut %}\n\n### Медиана и мода\n\nМатематическое ожидание — не единственная числовая метрика, с помощью которой можно пытаться охарактеризовать, чему равно в среднем значение случайной величины. **Медиана** разбивает вероятностную массу распределения на две равные части. Если случайная величина $\\xi$ имеет плотность $p_\\xi(x)$, то её медиана $m = \\mathrm{med}\\xi$ определяется из условия\n\n$$\n  \\mathbb P(\\xi \\leqslant m) = \\int\\limits_{-\\infty}^m p_\\xi(x)\\,dx =\n  \\int\\limits_m^{+\\infty} p_\\xi(x)\\,dx = \\mathbb P(\\xi \\geqslant m) = \\frac 12.\n$$\n\nВ терминах функции распределения это означает, что $F_\\xi(m) = 1 - F_\\xi(m)$, или $F_\\xi(m) = \\frac 12$. В непрерывном случае функция распределения $F_\\xi(x)$ строго возрастает, поэтому уравнение $F_\\xi(m) = \\frac 12$ имеет единственное решение. Для дискретных случайных величин это может быть не так, и поэтому в общем случае медиану определяют как число $m$, удовлетворяющее условиям\n\n$$\n  \\mathbb P(\\xi \\leqslant m) \\geqslant \\frac 12, \\quad \\mathbb P(\\xi \\geqslant m) \\geqslant \\frac 12.\n$$\n\nНапример, если $\\xi \\sim \\mathrm{Bern}\\big(\\frac 12\\big)$, то $\\mathbb P(\\xi = 0) = \\mathbb P(\\xi = 1) = \\frac 12$, и поэтому любое число $m \\in (0, 1)$ является медианой симметричного бернуллиевского распределения. Бесконечное количество медиан будет у всякой дискретной случайной величины $\\xi$, для которой $F_\\xi(x) = \\frac 12$ на целом промежутке.\n\n**Мода** распределения максимизирует его pmf или pdf:\n\n$$\n  \\mathrm{mode}(\\xi) = \\mathrm{arg}\\max\\limits_k \\mathbb P(\\xi = k) \\text{ или }\n  \\mathrm{mode}(\\xi) = \\mathrm{arg}\\max\\limits_x p_\\xi(x).\n$$\n\nМод у распределения может быть больше одной; самое вырожденное в этом смысле распределение — равномерное, каждая точка носителя является его модой. Если плотность случайной величины имеет единственную точку максимума, то она и является модой. Например:\n\n- $\\mathrm{mode}(\\xi) = \\mu$, если $\\xi \\sim \\mathcal N(\\mu, \\sigma^2)$;\n- $\\mathrm{mode}(\\xi) = 0$, если $\\xi \\sim \\mathrm{Exp}(\\lambda)$;\n- мода t-распределения Стьюдента также равна нулю.\n\nВсе такие распределения **унимодальны**. Если плотность $p_\\xi(x)$ имеет два или более максимума, то случайная величина $\\xi$ называется **бимодальной** или **мультимодальной**.\n\n![image1_4467544f1b_d8a3e2d26b.svg](https://yastatic.net/s3/education-portal/media/image1_4467544f1b_d8a3e2d26b_25c2eea842.svg)\n\nДля симметричных распределений вроде нормального математическое ожидание, медиана и мода совпадают, однако, в общем случае это три различные меры типичного среднего значения случайной величины. Смысл каждой из этой мер наглядно демострирует следующая иллюстрация:\n\n![mmm_4238140d9e_5437f403f1.svg](https://yastatic.net/s3/education-portal/media/mmm_4238140d9e_5437f403f1_1ab256fcba.svg)\n\n**Упражнение**. Найдите среднее, медиану и моду экспоненциального распределения с параметром $\\lambda$ и сравните их между собой.\n\n{% cut \"Ответ\" %}\n\nЕсли $\\xi \\sim \\mathrm{Exp}(\\lambda)$, то\n\n$$\n\\mathbb E\\xi = \\frac 1\\lambda > \\mathrm{med}(\\xi) = \\frac{\\ln 2}\\lambda >\\mathrm{mode}(\\xi) = 0.\n$$\n\n{% endcut %}\n\n### Классификация случайных величин\n\nУ внимательного читателя (отягощённого математическим образованием впридачу) может возникнуть вопрос: а все ли случайные величины относятся к дискретным или непрерывным? В буквально такой постановке ответ, конечно, отрицательный, поскольку можно получить гибридную случайную величину, сложив дискретную и непрерывную. Но, может быть, всякая случайная величина равна сумме непрерывной и дискретной компонент?\n\nВ терминах функций распределения этот вопрос можно переформулировать так: верно ли, что всякая монотонная функция $F \\colon \\mathbb R \\to \\mathbb [0, 1]$ может быть представлена в виде $F = F_{\\mathrm{jump}} + F_{\\mathrm{smooth}}$, где $F_{\\mathrm{jump}}$ — неубывающая ступенчатая функция (функция скачков), а\n\n$$\n  F_{\\mathrm{smooth}}(x) = \\int\\limits_{-\\infty}^x p(t)\\,dt\n$$\n\n— гладкая возрастающая функция, полученная интегрированием плотности?\n\n{% cut \"Ответ (не открывайте, если не хотите его знать)\" %}\n\nИ здесь ответ отрицательный: существуют непрерывные монотонные функции вроде <a href=\"https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BD%D1%82%D0%BE%D1%80%D0%BE%D0%B2%D0%B0_%D0%BB%D0%B5%D1%81%D1%82%D0%BD%D0%B8%D1%86%D0%B0\">лестницы Кантора</a> с производной, равной нулю почти всюду. Поскольку $\\int\\limits_{-\\infty}^x 0\\,dt = 0$, лестница Кантора не может быть получена интегрированием никакой плотности. Случайные величины с такими функциями распределения, как лестница Кантора, называются **сингулярными**. Из <a href=\"https://en.wikipedia.org/wiki/Lebesgue's_decomposition_theorem\">теоремы Лебега о декомпозиции</a> вытекает, что любая вероятностная мера на числовой прямой может быть представлена в виде суммы дискретной, абсолютно непрерывной (имеющей плотность) и сингулярной компонент.\n\n{% endcut %}\n",
        "handbook": "Учебник по машинному обучению",
        "title": "Вероятностные распределения",
        "description": null
    },
    {
        "path": "/handbook/ml/article/mnogomernye-raspredeleniya",
        "content": "До этого мы рассматривали только одномерные распределения вероятностей на числовой прямой. Однако ничто не мешает в качестве носителя $\\Omega$ выбрать пространство более высокой размерности. И снова все представляющие практический интерес распределения делятся на два класса: дискретные и непрерывные.\n\n## Дискретные многомерные распределения\n\nПусть, например, эксперимент состоит из двух фаз: сначала подбрасывается монетка, а затем кубик. Тогда вероятностная масса сосредоточена в точках $(i, j)$, $i=0, 1$, $1\\leqslant j \\leqslant 6$. Вероятность каждого исхода можно записать в виде таблицы\n\n#|\n||\n\n\n|\n\n«Неудача»\n\n|\n\n«Успех»\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/1_d6deb4a9a1.svg\" width = 40px>\n\n|\n\n$\\frac 1{12}$\n\n|\n\n$\\frac 1{12}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_2_b_svg_6c29bed6c9.png\" width = 40px>\n\n|\n\n$\\frac 1{12}$\n\n|\n\n$\\frac 1{12}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_3_b_svg_08ff3a5f26.png\" width = 40px>\n\n|\n\n$\\frac 1{12}$\n\n|\n\n$\\frac 1{12}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_4_b_svg_e5bfd0baa3.png\" width = 40px>\n\n|\n\n$\\frac 1{12}$\n\n|\n\n$\\frac 1{12}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_5_b_svg_55095e524d.png\" width = 40px>\n\n|\n\n$\\frac 1{12}$\n\n|\n\n$\\frac 1{12}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/2_a00a98e5e6.svg\" width = 40px>\n\n|\n\n$\\frac 1{12}$\n\n|\n\n$\\frac 1{12}$\n\n||\n|#\n\nРезультат подбрасывания монеты моделирует бернуллиевская случайная величина $\\xi$, а результат броска кубика — равномерно распределённая на множестве $\\{1,2,3,4,5,6\\}$ случайная величина $\\eta$. Содержимое таблицы вероятностей каждого исхода можно также представить матрицей\n\n$$  P = \n  \\overbrace{\\left.\\begin{pmatrix}\n    \\frac 1{12} & \\frac 1{12} & \\frac 1{12} & \\frac 1{12} & \\frac 1{12} & \\frac 1{12} \\\\\n    \\frac 1{12} & \\frac 1{12} & \\frac 1{12} & \\frac 1{12} & \\frac 1{12} & \\frac 1{12} \n  \\end{pmatrix}\\right\\}}^\\eta  \\xi,\n$$\n\nкоторая задаёт **совместное распределение** случайных величин $\\xi$ и $\\eta$: $\\mathbb P(\\xi = i, \\eta = j) = P_{ij}$. Пару случайных величин $(\\xi, \\eta)$ в таком контексте называют также **случайным вектором**.\n\nЭлементы матрицы $P$ не обязаны совпадать; например, монета может быть несимметричной с вероятностью «успеха» $p$, и тогда таблица вероятностей примет вид\n\n#|\n||\n\n\n|\n\n«Неудача»\n\n|\n\n«Успех»\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/1_d6deb4a9a1.svg\" width = 40px>\n\n|\n\n$\\frac {1-p}{6}$\n\n|\n\n$\\frac p{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_2_b_svg_6c29bed6c9.png\" width = 40px>\n\n|\n\n$\\frac {1-p}{6}$\n\n|\n\n$\\frac p{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_3_b_svg_08ff3a5f26.png\" width = 40px>\n\n|\n\n$\\frac {1-p}{6}$\n\n|\n\n$\\frac p{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_4_b_svg_e5bfd0baa3.png\" width = 40px>\n\n|\n\n$\\frac {1-p}{6}$\n\n|\n\n$\\frac p{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_5_b_svg_55095e524d.png\" width = 40px>\n\n|\n\n$\\frac {1-p}{6}$\n\n|\n\n$\\frac p{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/2_a00a98e5e6.svg\" width = 40px>\n\n|\n\n$\\frac {1-p}{6}$\n\n|\n\n$\\frac p{6}$\n\n||\n|#\n\n**Контрольный вопрос**. Какая таблица вероятностей соответствует эксперименту, в котором результат подбрасывания монеты «портит» кубик следующим образом: на нём могут равновероятно выпасть только значения $1$ или $2$ в случае «неудачи» и $4$, $5$ или $6$ в случае «успеха»?\n\n{% cut \"Ответ\" %}\n\n#|\n||\n\n\n|\n\n«Неудача»\n\n|\n\n«Успех»\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/1_d6deb4a9a1.svg\" width = 40px>\n\n|\n$\\frac 1{4}$\n\n|\n$0$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_2_b_svg_6c29bed6c9.png\" width = 40px>\n\n|\n$\\frac 1{4}$\n\n|\n$0$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_3_b_svg_08ff3a5f26.png\" width = 40px>\n\n|\n$0$\n\n|\n$0$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_4_b_svg_e5bfd0baa3.png\" width = 40px>\n\n|\n$0$\n\n|\n$\\frac 1{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/Dice_5_b_svg_55095e524d.png\" width = 40px>\n\n|\n$0$\n\n|\n$\\frac 1{6}$\n\n||\n||\n\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/2_a00a98e5e6.svg\" width = 40px>\n\n|\n$0$\n\n|\n$\\frac 1{6}$\n\n||\n|#\n\n{% endcut %}\n\nВ общем случае дискретное $n$-мерное распределение задаётся многомерным тензором из неотрицательных чисел $p_{i_1\\ldots i_n}$, суммирующихся в единицу. Такие тензоры используются для задания совместного распределения вероятностей случайного вектора $(\\xi_1, \\ldots, \\xi_n)$ из дискретных случайных величин:\n\n$$ \\mathbb P(\\xi_1 = i_1, \\xi_2 = i_2, \\ldots, \\xi_n = i_n) = p_{i_1i_2\\ldots i_n}.\n$$\n\n## Непрерывные многомерные распределения\n\nНепрерывное распределение на плоскости задаётся плотностью $p(x, y) \\geqslant 0$; при этом вероятность события $A\\subset \\mathbb R^2$ равна\n\n$$  \\mathbb P(A) = \\iint\\limits_{A} p(x, y)\\,dxdy\n$$\n\nпри условии, что этот интеграл имеет смысл. Простейший пример — равномерное распределение на единичном квадрате $[0,1]^2$: его плотность равна $\\mathbb I_{[0, 1]^2}(x, y)$, и\n\n$$\\mathbb P(A) = \\iint \\limits_{A} dxdy = \\vert A\\vert \\text{ для } A\\subset [0,1]^2.\n$$\n\nИменно так на единичном квадрате формально определяется геометрическая вероятность.\n\nПлотность непрерывного распределения в $\\mathbb R^n$ является неотрицательной функцией вида $p(x_1, \\ldots, x_n)$ со свойством\n\n$$  \\int_{\\mathbb R^n} p(x_1, \\ldots, x_n)\\,dx_1\\ldots dx_n = 1.\n$$\n\nГоворят, что случайный вектор $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_n)$ имеет **совместную плотность** $p_{\\boldsymbol \\xi}(x_1, \\ldots, x_n)$, если\n\n$$  \\mathbb P(\\boldsymbol \\xi \\in A) = \\int\\limits_A p(x_1, \\ldots, x_n)\\,dx_1\\ldots dx_n\n$$\n\nдля всех достаточно «хороших» ([измеримых по Лебегу](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%80%D0%B0_%D0%9B%D0%B5%D0%B1%D0%B5%D0%B3%D0%B0)) множеств $A \\subset \\mathbb R^n$.\n\n## Маргинальные распределения\n\nИз совместного распределения можно получить распределение в пространстве меньшей размерности путём суммирования или интегрирования по части переменных. Например, если матрица $P_{ij}$ задаёт совместное распределение случайных величин $\\xi$ и $\\eta$, $P_{ij} = \\mathbb P(\\xi = i, \\eta = j)$, то каждый из наборов чисел\n\n$$  q_i = \\sum\\limits_j P_{ij}, \\quad r_j = \\sum\\limits_i P_{ij},\n$$\n\nнеотрицателен и суммируется в единицу:\n\n$$  \\sum\\limits_i q_i = \\sum\\limits_j r_j = \\sum\\limits_{i, j} P_{ij} = 1.\n$$\n\nТаким образом, числа $\\{q_i\\}$ и $\\{r_j\\}$ задают некоторые распределения вероятностей, называемые **маргинальными**.\n\n**Упражнение**. Найдите маргинальные распределения, если совместное распределение задано матрицей\n\n$$\\text{а) }\n\\begin{pmatrix}\n    \\frac {1-p}6 & \\frac {1-p}6 & \\frac {1-p}6 & \\frac {1-p}6 & \\frac {1-p}6 & \\frac {1-p}6 \\\\\n    \\frac p6 & \\frac p6 & \\frac p6 & \\frac p6 & \\frac p6 & \\frac p6 \n  \\end{pmatrix};\\quad\n$$\n\n$$\\text{б) }\n  \\begin{pmatrix}\n    \\frac 1{4} & \\frac 14 & 0 & 0 & 0 & 0 \\\\\n    \\frac 16& \\frac 16& \\frac 16 & 0 & 0 & 0 \\\\\n  \\end{pmatrix}.\n$$\n\n{% cut \"Ответ\" %}\n\nСуммируя столбцы этих матриц, получаем вероятности $(1-p, p)$ в случае а) и $\\big(\\frac 12, \\frac 12\\big)$ в случае б). Если же суммировать строки, то получаются наборы\n\n$$\\text{а) } \\Big(\\frac 16, \\frac 16,\\frac 16,\\frac 16,\\frac 16,\\frac 16 \\Big);\\quad\n\\text{б) } \\Big(\\frac 5{12}, \\frac 5{12},\\frac 16,0,0,0 \\Big).\n$$\n\nЗаметим, что в п. а) после маргинализации получились в точности распределения вероятностей компонент случайного вектора $(\\xi, \\eta)$ из приведённого выше [примера](https://education.yandex.ru/handbook/ml/article/mnogomernye-raspredeleniya#diskretnye-mnogomernye-raspredeleniya). Это следствие [независимости](https://education.yandex.ru/handbook/ml/article/mnogomernye-raspredeleniya#nezavisimost-sluchajnyh-velichin) случайных величин $\\xi$ и $\\eta$.\n\n{% endcut %}\n\nВ непрерывном случае ситуация похожая: если случайный вектор имеет совместную плотность $p(x,y)$, то функции\n\n$$  q(x) = \\int\\limits_{-\\infty}^\\infty p(x, y)\\,dy, \\quad r(y) = \\int\\limits_{-\\infty}^\\infty p(x, y)\\,dx\n$$\n\nявляются плотностями маргинальных распределений.\n\nДля $n$-мерных распределений можно находить маргинальные распределения, суммируя или интегрируя по любым наборам переменных с индексами $1\\leqslant i_1 < i_2 < \\ldots < i_k \\leqslant n$; в результате получится маргинальное распределение по оставшимся $n-k$ переменным.\n\n## Независимость случайных величин\n\nСлучайные величины $\\xi$ и $\\eta$ называются **независимыми**, если совместное распределение случайного вектора $(\\xi, \\eta)$ распадается на произведение одномерных. Точнее говоря,\n\n* дискретные случайные величины $\\xi$ и $\\eta$ независимы, если $\\mathbb P(\\xi = x_i, \\eta = y_j) = \\mathbb P(\\xi = x_i)\\mathbb P(\\eta = y_j)$ для всех возможных $x_i$ и $y_j$;\n* непрерывные случайные величины $\\xi$ и $\\eta$ независимы, если их совместная плотность\n  $p(x, y) = p_\\xi(x)p_\\eta(y)$.\n\nЕсли случайные величины $\\xi$ и $\\eta$ независимы, то распределение каждой из них является маргинальным распределением их совместного распределения, поскольку\n\n$$  \\sum\\limits_i\\mathbb P(\\xi = x_i)\\mathbb P(\\eta = y_j) = \\mathbb P(\\eta = y_j),\n$$\n\n$$  \\sum\\limits_j\\mathbb P(\\xi = x_i)\\mathbb P(\\eta = y_j) = \\mathbb P(\\xi = x_i),\n$$\n\nи\n\n$$  \\int\\limits_{-\\infty}^{+\\infty} p_\\xi(x)p_\\eta(y) dx = p_\\eta(y),\n$$\n\n$$  \\int\\limits_{-\\infty}^{+\\infty} p_\\xi(x)p_\\eta(y) dy = p_\\xi(x).\n$$\n\nСлучайные величины $(\\xi_1, \\ldots, \\xi_n)$  **независимы в совокупности**, если их совместное распределение (совместная плотность) распадается в произведение одномерных распределений (плотностей).\n\n**Пример**. Рассмотрим $n$ гауссовских случайных величин $\\xi_k \\sim \\mathcal N(\\mu_k, \\sigma_k^2)$ с плотностями\n\n$$  p_{\\xi_k}(x_k) = \\frac 1{\\sqrt{2\\pi}\\sigma_k} e^{-\\frac{(x_k - \\mu_k)^2}{2\\sigma_k^2}}.\n$$\n\nСовместную плотность случайного вектора $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_n)$ определим как произведение плотностей его компонент:\n\n$$  p_{\\boldsymbol \\xi}(x_1, \\ldots, x_n) = p_{\\xi_1}(x_1)\\ldots p_{\\xi_n}(x_n) = \\frac 1{(2\\pi)^{n/2}\\sigma_1\\ldots\\sigma_n} e^{-\\frac 12\\sum\\limits_{k=1}^n \\frac{(x_k - \\mu_k)^2}{\\sigma_k^2}}.\n$$\n\nСлучайный вектор $\\boldsymbol \\xi$ с такой плотностью имеет **многомерное нормальное (гауссовское) распределение** c независимыми в совокупности компонентами. Любое маргинальное распределение случайного вектора $\\boldsymbol \\xi$ обладает плотностью того же вида, и поэтому также является гауссовским.\n\n## Характеристики случайных векторов\n\nМатематическое ожидание случайного вектора $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_n)$ является вектором той же размерности и вычисляется покомпонентно:\n\n$$  \\mathbb E \\boldsymbol \\xi = (\\mathbb E \\xi_1, \\ldots, \\mathbb E\\xi_n).\n$$\n\nКаждая компонента случайного вектора — это обычная случайная величина, и её среднее можно вычислить стандартными методами:\n\n* $\\mathbb E\\xi_k = \\sum\\limits_{i_1, \\ldots, i_n} i_k p_{i_1\\ldots i_n}$ в дискретном случае;\n* $\\mathbb{E}\\xi_k=\\int\\limits_{\\mathbb{R}^n}x_kp(x_1,\\ldots,x_n),dx_1\\ldots dx_n$ в непрерывном случае.\n\nМатематическое ожидание перестановочно с линейным преобразованием случайного вектора: $\\mathbb E(\\boldsymbol{C\\xi}) = \\boldsymbol C \\mathbb E \\boldsymbol \\xi$, где $\\boldsymbol C$ — фиксированная матрица.\n\nВместо дисперсии у случайного вектора $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_n)$ есть **матрица ковариаций**:\n\n$$  \\mathbb V \\boldsymbol \\xi = \\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\xi) = \\mathbb E\\big(\\boldsymbol \\xi - \\mathbb E\\boldsymbol \\xi\\big)\\big(\\boldsymbol \\xi - \\mathbb E\\boldsymbol \\xi\\big)^T.\n$$\n\nМатрица ковариаций симметрична и состоит из попарных ковариаций компонент случайного вектора $\\boldsymbol \\xi$:\n\n$$  \\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\xi)_{ij} = \\mathrm{cov}(\\xi_i, \\xi_j).\n$$\n\n**Упражнение**. Докажите, что ковариационная матрица любого случайного вектора неотрицательно определена.\n\n{% cut \"Решение (не открывайте сразу, сначала попробуйте решить самостоятельно)\" %}\n\nПользуясь линейностью математического ожидания, получаем\n\n$$    \\boldsymbol x^T\\mathrm{cov}(\\boldsymbol\\xi, \\boldsymbol\\xi)\\boldsymbol x = \\mathbb{E}\\boldsymbol x^T(\\boldsymbol\\xi - \\mathbb{E}\\boldsymbol\\xi)(\\boldsymbol\\xi - \\mathbb{E}\\boldsymbol\\xi)^T\\boldsymbol x =\n$$\n\n$$    =\\mathbb{E}\\left(\\boldsymbol x^T\\boldsymbol\\xi - \\mathbb{E}(\\boldsymbol x^T\\boldsymbol\\xi)\\right)\\cdot\\left(\\boldsymbol x^T\\boldsymbol\\xi - \\mathbb{E}(\\boldsymbol x^T\\boldsymbol\\xi)\\right)^T = \\mathrm{cov}\\left(\\boldsymbol x^T\\boldsymbol\\xi, \\boldsymbol x^T\\boldsymbol\\xi\\right)=\\mathbb{V}(\\boldsymbol x^T\\boldsymbol\\xi)\\geqslant 0.\n$$\n\n{% endcut %}\n\nЕсли случайные величины $\\xi_1, \\ldots, \\xi_n$ независимы в совокупности, то $\\mathrm{cov}(\\xi_i, \\xi_j) = 0$, и ковариационая матрица случайного вектора $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_n)$ диагональна:\n\n$$\\mathrm{cov}(\\boldsymbol \\xi , \\boldsymbol \\xi) = \\mathrm{diag}\\{\\mathbb V \\xi_1, \\ldots, \\mathbb V \\xi_n\\}.\n$$\n\nНапример, матрица ковариации гауссовского случайного вектора $\\boldsymbol \\xi$ с плотностью\n\n$$p_{\\boldsymbol \\xi}(x_1, \\ldots, x_n) = \\frac 1{(2\\pi)^{n/2}\\sigma_1\\ldots\\sigma_n} e^{-\\frac 12\\sum\\limits_{k=1}^n \\frac{(x_k - \\mu_k)^2}{\\sigma_k^2}} = \\prod\\limits_{k=1}^n \\frac 1{\\sqrt{2\\pi}\\sigma_k} e^{-\\frac{(x_k - \\mu_k)^2}{2\\sigma_k^2}}\n$$\n\nравна $\\mathrm{diag}\\{\\sigma_1^2, \\ldots, \\sigma_n^2\\}$, поскольку компоненты вектора $\\boldsymbol \\xi$ независимы в совокупности и имеют нормальное распределение $\\mathcal N(\\mu_k, \\sigma_k^2)$.\n\nАналогом ковариации в многомерном случае служит матрица ковариаций между случайными векторами $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_n)$ и $\\boldsymbol \\eta = (\\eta_1, \\ldots, \\eta_n)$:\n\n$$  \\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\eta) = \\mathbb E\\big(\\boldsymbol \\xi - \\mathbb E\\boldsymbol \\xi\\big)\\big(\\boldsymbol \\eta - \\mathbb E\\boldsymbol \\eta\\big)^T.\n$$\n\nМатрицу ковариаций можно также вычислить по формуле\n\n$$  \\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\eta) = \\mathbb E\\boldsymbol \\xi\\boldsymbol \\eta^T - \\mathbb E\\boldsymbol \\xi(\\mathbb E\\boldsymbol \\eta)^T.\n$$\n\n**Упражнение**. Пусть случайный вектор $\\boldsymbol \\eta$ получен из случайного вектора $\\boldsymbol \\xi$ линейным преобразованием: $\\boldsymbol \\eta = \\boldsymbol {C\\xi}$. Как связаны между собой их ковариационные матрицы?\n\n{% cut \"Решение (не открывайте сразу, сначала попробуйте решить самостоятельно)\" %}\n\nРаспишем по определению:\n\n$$  \\mathrm{cov}(\\boldsymbol{C\\xi}, \\boldsymbol{C\\xi}) = \\mathbb{E}\\big(\\boldsymbol{C\\xi} - \\mathbb{E}(\\boldsymbol{C\\xi})\\big)\\big(\\boldsymbol{C\\xi} - \\mathbb{E}(\\boldsymbol{C\\xi})\\big)^T =\n$$\n\n$$  =\\mathbb{E}\\boldsymbol C(\\boldsymbol \\xi - \\mathbb{E}\\boldsymbol \\xi)(\\boldsymbol \\xi - \\mathbb{E}\\boldsymbol \\xi)^T\\boldsymbol C^T = \\boldsymbol C\\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\xi)\\boldsymbol C^T.\n$$\n\n{% endcut %}\n\n## Преобразования плотностей случайных векторов\n\nНередко приходится иметь дело не с самими случайными векторами, а с функциями от них. Но как найти плотность случайного вектора $\\boldsymbol \\eta = g(\\boldsymbol \\xi)$, зная плотность $p_{\\boldsymbol \\xi}(\\boldsymbol x)$?\n\nПредположим, что $g \\colon \\mathbb R^n \\to \\mathbb R^n$ — гладкая обратимая функция. Тогда для измеримого $A\\subset \\mathbb R^n$ имеем\n\n$$\\mathbb{P}(\\boldsymbol{\\eta}\\in A)=\\mathbb{P}\\big(g(\\boldsymbol{\\xi})\\in A\\big)=\\mathbb{P}\\big(\\boldsymbol{\\xi}\\in g^{-1}(A)\\big)=\\int\\limits_{g^{-1}(A)}p_{\\boldsymbol{\\xi}}(x)d\\boldsymbol{x}\n$$\n\nЧтобы перейти к интегралу по $A$, сделаем замену переменной $\\boldsymbol x = g^{-1}(\\boldsymbol z)$. По формуле замены координат в кратном интеграле получаем\n\n$$\\int\\limits_{g^{-1}(A)}p_{\\boldsymbol \\xi}(\\boldsymbol x)d\\boldsymbol x = \\int\\limits_{A}p_{\\boldsymbol \\xi}(g^{-1}(\\boldsymbol z))\\vert \\det J(\\boldsymbol z) \\vert d\\boldsymbol z,\n$$\n\nгде $\\det J(\\boldsymbol z)$ – якобиан преобразования $g^{-1}(\\boldsymbol z)$, т.е. определитель матрицы Якоби $J(\\boldsymbol z) = \\frac{\\partial g^{-1}(\\boldsymbol z)}{\\partial \\boldsymbol z}$.\nТаким образом,\n\n$$p_{\\boldsymbol \\eta}(\\boldsymbol z) = p_{\\boldsymbol \\xi}(g^{-1}(\\boldsymbol z))\\vert \\det J(\\boldsymbol z)\\vert.\n$$\n\n**Упражнение**. Пусть $\\boldsymbol \\xi$ – случайный вектор с плотностью $p_{\\boldsymbol \\xi}(\\boldsymbol x)$. Какова плотность случайного вектора $\\boldsymbol\\eta = \\boldsymbol\\mu + \\boldsymbol{C\\xi}$, где $\\boldsymbol \\mu$ – постоянный вектор, а $\\boldsymbol C$ – постоянная обратимая матрица?\n\n{% cut \"Решение (не открывайте сразу, сначала попробуйте решить самостоятельно)\" %}\n\nВ данном случае $g(\\boldsymbol x) = \\boldsymbol\\mu + \\boldsymbol{Cx}$, $g^{-1}(\\boldsymbol z) = \\boldsymbol C^{-1}(\\boldsymbol z - \\boldsymbol\\mu)$. Матрица Якоби преобразования $g^{-1}$ равна $\\boldsymbol C^{-1}$. Следовательно,\n\n$$  p_{\\boldsymbol \\eta}(\\boldsymbol z) = \\frac1{\\vert\\det(\\boldsymbol C)\\vert}p_{\\boldsymbol \\xi}(\\boldsymbol C^{-1}(\\boldsymbol z - \\boldsymbol\\mu)).\n$$\n\n{% endcut %}\n\n## Распределение суммы независимых случайных величин\n\nВ дискретном случае найти распределение суммы двух независимых случайных величин несложно. В самом деле,\n\n$$\\mathbb{P}(\\xi + \\eta = k) = \\sum_{i}\\mathbb{P}(\\xi + \\eta = k, \\eta = i)=\n\\sum_{i}\\mathbb{P}(\\xi = k - i, \\eta = i).\n$$\n\nВ силу независимости случайных величин $\\xi$ и $\\eta$ последняя сумма равна\n\n$$\\sum_{i}\\mathbb{P}(\\xi = k-i)\\mathbb{P}(\\eta = i).\n$$\n\nПолученная формула называется **формулой свёртки**.\n\nПусть теперь $\\xi_1$ и $\\xi_2$ – независимые непрерывные случайные величины с плотностями $p_{\\xi_1}(x)$ и $p_{\\xi_2}(x)$ соответственно. Сам собой напрашивается аналог формулы свёртки с плотностями вместо вероятностей, но чтобы достаточно строго вывести его и не запутаться, мы немного схитрим. А именно, мы рассмотрим случайный вектор $\\boldsymbol\\xi = (\\xi_1, \\xi_2)^T$ и его (обратимое!) преобразование\n\n$$g(\\boldsymbol\\xi) = \\begin{pmatrix}\\xi_1 + \\xi_2\\\\ \\xi_2\\end{pmatrix} = \\begin{pmatrix}1 & 1\\\\ 0& 1\\end{pmatrix}\\boldsymbol \\xi =: \\boldsymbol\\eta = \\begin{pmatrix}\\eta_1 \\\\ \\eta_2\\end{pmatrix}.\n$$\n\nОбратное к нему будет иметь вид\n\n$$h(\\boldsymbol \\eta) = \\begin{pmatrix}1 & -1\\\\ 0 & 1\\end{pmatrix}\\boldsymbol\\eta = \\begin{pmatrix} \\eta_1 - \\eta_2\\\\ \\eta_2\\end{pmatrix}\n$$\n\nТогда по правилу преобразования плотности\n\n$$p_{\\boldsymbol\\eta}(\\boldsymbol z) = \\underbrace{\\left|\\text{det}\\begin{pmatrix}1 & -1 \\\\ 0 & 1\\end{pmatrix}\\right|}_{=1}p_{\\boldsymbol\\xi}\\left(z_1 - z_2, z_2\\right) =\np_{\\xi_1}(z_1 - z_2)p_{\\xi_2}(z_2),\n$$\n\nгде в последнем равенстве мы воспользовались независимостью $\\xi_1$ и $\\xi_2$. Распределение случайной величины $\\eta_1 = \\xi_1+\\xi_2$ – это маргинальное распределение, которое вычисляется следующим образом:\n\n$$p_{\\eta_1}(y) = \\int\\limits_{-\\infty}^{+\\infty}p_{\\xi_1}(y - x)p_{\\xi_2}(x)dx.\n$$\n\nЭта формула также называется **формулой свёртки**.\n\n## Примеры многомерных распределений\n\nРассмотрим несколько популярных распределений случайных векторов.\n\n### Мультиномиальное распределение\n\nБиномиальное распределение $\\mathrm{Bin}(n, p)$ моделирует $n$-кратное подбрасывание монеты с вероятностями «успеха» $p$ и «неудачи» $q = 1-p$. **Мультиномиальное распределение** обобщает этот эксперимент: теперь подбрасывается кубик с $k\\geqslant 2$ гранями, и вероятность выпадения $i$-й грани равна $p_i$, $\\sum\\limits_{i=1}^k p_i = 1$. Обозначим через $\\xi_i$ количество выпадений $i$-й грани в серии из $n$ бросков. Тогда случайный вектор $\\boldsymbol \\xi = (\\xi_1, \\ldots, \\xi_k)$ имеет мультиномиальное распределение, при котором\n\n$$  \\mathbb P(\\xi_1 = m_1, \\ldots, \\xi_k = m_k) = \\frac{n!}{m_1!\\cdot \\ldots \\cdot m_k!} p_1^{m_1}\\cdot \\ldots \\cdot p_k^{m_k},\n$$\n\n$$  \\sum\\limits_{i = 1}^k m_i = n.\n$$\n\nПри $n=1$ мультиномиальное распределение превращается в **категориальное**, известное также под названием **multinoulli**. Категориальное распределение моделирует случайный выбор одного из $k$ классов с заданными вероятностями $(p_1, \\ldots, p_k)$.\n\n### Многомерное нормальное распределение\n\n**Многомерное нормальное (гауссовское) распределение** задаётся функцией плотности\n\n$$p(\\boldsymbol x) = \\frac1{(2\\pi)^{n/2}\\sqrt{\\det\\boldsymbol\\Sigma}}\\exp\\left(-\\frac12(\\boldsymbol x - \\boldsymbol\\mu)^T\\boldsymbol\\Sigma^{-1}(\\boldsymbol x - \\boldsymbol\\mu)\\right),\n$$\n\nгде $\\boldsymbol x, \\boldsymbol \\mu\\in\\mathbb{R}^n$, $\\boldsymbol\\Sigma$ — невырожденная симметричная матрица размера $n\\times n$. Такое распределение обозначается $\\mathcal{N}(\\boldsymbol\\mu, \\boldsymbol\\Sigma)$.\n\nЕсли случайный вектор $\\boldsymbol \\xi \\sim \\mathcal{N}(\\boldsymbol\\mu, \\boldsymbol\\Sigma)$, то $\\mathbb E\\boldsymbol \\xi =\\boldsymbol \\mu$, $\\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\xi ) = \\boldsymbol \\Sigma$; таким образом, параметры гауссовского распределения — это его среднее и матрица ковариаций.\n\n**Упражнение.** Пусть $\\boldsymbol \\xi \\sim \\mathcal{N}(\\boldsymbol\\mu, \\boldsymbol\\Sigma)$ и $\\boldsymbol \\eta =  \\boldsymbol{A\\xi} + \\boldsymbol b$. Докажите, что $\\boldsymbol \\eta \\sim \\mathcal{N}(\\boldsymbol{A\\mu} + \\boldsymbol b, \\boldsymbol{A\\Sigma A}^T)$.\n\n{% cut \"Решение (не открывайте сразу, сначала попробуйте решить самостоятельно)\" %}\n\nЕсли бы нам стало известно, что вектор $\\boldsymbol \\eta$ гауссовский, то мы нашли бы его параметры по стандартным формулам:\n\n$$  \\mathbb E\\boldsymbol \\eta = \\mathbb E (\\boldsymbol{A\\xi} + \\boldsymbol b) =  \\boldsymbol A\\mathbb E \\boldsymbol \\xi + \\boldsymbol b = \\boldsymbol{A\\mu} + \\boldsymbol b,\n$$\n\n$$  \\mathrm{cov}(\\boldsymbol \\eta, \\boldsymbol \\eta) = \\mathrm{cov}(\\boldsymbol{A\\xi} + \\boldsymbol b, \\boldsymbol{A\\xi} + \\boldsymbol b) = \\boldsymbol A \\mathrm{cov}(\\boldsymbol \\xi, \\boldsymbol \\xi) \\boldsymbol A^T = \\boldsymbol{A\\Sigma A}^T.\n$$\n\nРешим задачу честно в предположении, что матрица $\\boldsymbol A$ квадратная и невырожденная. Для этого воспользуемся формулой плотности линейного преобразования случайного вектора:\n\n$$p_{\\boldsymbol \\eta}(\\boldsymbol z) = \\frac1{\\vert\\!\\det(\\boldsymbol A)\\vert}p_{\\boldsymbol \\xi}(\\boldsymbol A^{-1}(\\boldsymbol z - \\boldsymbol b)) =\n$$\n\n$$=\n\\frac1{(2\\pi)^{n/2}\\sqrt{\\det\\boldsymbol\\Sigma}\\vert\\det(\\boldsymbol A)\\vert}\\exp\\left(-\\frac12(\\boldsymbol A^{-1}\\boldsymbol z - \\boldsymbol A^{-1}\\boldsymbol b - \\boldsymbol\\mu)^T\\boldsymbol\\Sigma^{-1}(\\boldsymbol A^{-1}\\boldsymbol z - \\boldsymbol A^{-1}\\boldsymbol b  - \\boldsymbol\\mu)\\right) =\n$$\n\n$$=\n\\frac1{(2\\pi)^{n/2}\\sqrt{\\det\\boldsymbol{A\\Sigma A}^T}}\\exp\\left(-\\frac12(\\boldsymbol z - \\boldsymbol b - \\boldsymbol{A\\mu})^T \\boldsymbol A^{-T}\\boldsymbol\\Sigma^{-1}\\boldsymbol A^{-1}(\\boldsymbol z - \\boldsymbol b  - \\boldsymbol{A\\mu})\\right).\n$$\n\nВ полученном выражении нетрудно узнать плотность гауссовского распределения $\\mathcal{N}(\\boldsymbol{A\\mu} + \\boldsymbol b, \\boldsymbol{A\\Sigma A}^T)$.\n\nЗаметим, что утверждение сохраняет силу и для случая прямоугольной матрицы $\\boldsymbol A$ размера $m\\times n$, где $n$ — размерность случайного вектора $\\boldsymbol \\xi$.\n\n{% endcut %}\n\nВажный частный случай случайного гауссовского вектора с независимыми компонентами был рассмотрен в примере из секции про <a href=\"https://education.yandex.ru/handbook/ml/article/mnogomernye-raspredeleniya#nezavisimost-sluchajnyh-velichin\">независимость случайных величин</a>. Такое распределение получается, если матрица $\\boldsymbol\\Sigma$ диагональна, $\\boldsymbol\\Sigma = \\mathrm{diag}\\{\\sigma_1^2, \\ldots, \\sigma_n^2\\}$. Тогда $\\sqrt{\\det \\boldsymbol\\Sigma} = \\sigma_1 \\ldots \\sigma_n$, $\\boldsymbol\\Sigma^{-1} = \\mathrm{diag}\\big\\{\\frac1{\\sigma_1^2}, \\ldots, \\frac 1{\\sigma_n^2}\\big\\}$, и поэтому\n\n$$-\\frac12(\\boldsymbol x - \\boldsymbol\\mu)^T\\boldsymbol\\Sigma^{-1}(\\boldsymbol x - \\boldsymbol\\mu) = -\\frac 12 \\sum\\limits_{k=1}^n \\frac{(x_k-\\mu_k)^2}{\\sigma_k^2}.\n$$\n\nОтсюда снова получаем формулу совместной плотности\n\n$$  p_{\\boldsymbol \\xi}(\\boldsymbol x) = \\frac 1{(2\\pi)^{n/2}\\sigma_1\\ldots\\sigma_n} e^{-\\frac 12\\sum\\limits_{k=1}^n \\frac{(x_k - \\mu_k)^2}{\\sigma_k^2}},\n$$\n\nкоторую можно переписать в виде\n\n$$  \\prod\\limits_{k=1}^n \\frac 1{\\sqrt{2\\pi}\\sigma_k} e^{-\\frac{(x_k - \\mu_k)^2}{2\\sigma_k^2}} = \\prod\\limits_{k=1}^n p_{\\xi_k}(x_k),\n  \\xi_k \\sim \\mathcal N(\\xi_k, \\sigma_k^2),\n$$\n\nоткуда следует независимость в совокупности компонент вектора $\\boldsymbol \\xi$.\n\nЕсли ковариационная матрица $\\boldsymbol \\Sigma$ не является диагональной, то отдельные компоненты случайного вектора $\\boldsymbol \\xi \\sim \\mathcal{N}(\\boldsymbol\\mu, \\boldsymbol\\Sigma)$ зависимы. Тем не менее, всегда найдётся линейное (и даже ортогональное) преобразование, которое превратит вектор $\\boldsymbol \\xi$ в гауссовский вектор с независимыми компонентами. Для этого достаточно найти ортогональную матрицу $\\boldsymbol Q$ со свойством\n\n$$\\boldsymbol Q \\boldsymbol \\Sigma \\boldsymbol Q^T = \\mathrm{diag}\\big\\{\\sigma_1^2,\\ldots,\\sigma_n^2\\big\\},\n$$\n\nи далее воспользоваться формулой плотности линейного преобразования гауссовского вектора.\n\nПо тем же соображениям облако точек, сгенерированных из распределения $\\mathcal{N}(\\boldsymbol\\mu, \\boldsymbol\\Sigma)$, будет напоминать эллипсоид с полуосями, пропорциональными вектору $(\\sigma_1^2,\\ldots,\\sigma_n^2)$. Линии уровня плотности $p(\\boldsymbol x)$ задаются уравнениями вида $p(\\boldsymbol x) = C$, а такое равенство эквивалентно квадратичной форме\n\n$$(\\boldsymbol x - \\boldsymbol\\mu)^T\\boldsymbol\\Sigma^{-1}(\\boldsymbol x - \\boldsymbol\\mu) = C_1,\n$$\n\nгде $C$ и $C_1$ – некоторые константы. С помощью описанной выше ортогональной замены эта квадратичная форма может быть приведена к главным осям:\n\n$$  \\boldsymbol z^T \\boldsymbol\\Lambda^{-1} \\boldsymbol z = C_2, \\quad \\boldsymbol \\Lambda = \\mathrm{diag}\\big\\{\\sigma_1^2,\\ldots,\\sigma_n^2\\big\\};\n$$\n\nв координатах это выглядит как\n\n$$  \\sum\\limits_{l=1}^n \\frac{z_k^2}{\\sigma_k^2} = C_2.\n$$\n\nМы получили практически каноническое уравнение $n$-мерного эллипсоида. В $\\mathbb R^2$ это будут эллипсы, сплюснутые тем сильнее, чем дальше от единицы отношение $\\kappa = \\frac{\\sigma_1}{\\sigma_2}$ собственных значений матрицы $\\boldsymbol \\Sigma$.\n\n<iframe src=\"https://yastatic.net/s3/ml-handbook/admin/slider_gaussian_2d_044a5877b0.html\" width=100% height=500 frameborder=0></iframe>\n\nНормальным будет и всякое маргинальное распределение многомерного гауссовского вектора.\n\n**Упражнение**. Пусть случайный вектор $\\boldsymbol \\xi = (\\boldsymbol\\xi_1, \\boldsymbol \\xi_2)$ имеет гауссовское распределение с параметрами\n\n$$  \\boldsymbol \\mu = \\begin{pmatrix}\\boldsymbol \\mu_1 \\\\ \\boldsymbol \\mu_2 \\end{pmatrix}, \\quad\n  \\boldsymbol \\Sigma = \\begin{pmatrix}\n  \\boldsymbol \\Sigma_{11} & \\boldsymbol\\Sigma_{12} \\\\ \\boldsymbol\\Sigma_{12}^T & \\boldsymbol\\Sigma_{22}  \\end{pmatrix},\n$$\n\nгде $\\boldsymbol \\xi_1, \\boldsymbol \\mu_1 \\in \\mathbb R^k$, $\\boldsymbol \\xi_2, \\boldsymbol \\mu_2 \\in \\mathbb R^{n-k}$, $\\boldsymbol \\Sigma_{11} \\in \\mathrm{Mat}_{k\\times k}$, $\\boldsymbol \\Sigma_{12} \\in \\mathrm{Mat}_{k\\times (n-k)}$, $\\boldsymbol \\Sigma_{22} \\in \\mathrm{Mat}_{(n-k)\\times (n-k)}$.\nДокажите, что случайный вектор $\\boldsymbol\\xi_1$, полученный маргинализацией по компонентам вектора $\\boldsymbol\\xi_2$, является гауссовским с параметрами $\\boldsymbol \\\\mu_1$ и $\\boldsymbol \\Sigma_{11}$.\n\n{% cut \"Решение (не открывайте сразу, сначала попробуйте решить самостоятельно)\" %}\n\nСуществует прямое и довольно утомительное решение с многочисленными матричными манипуляциями. Мы поступим хитрее: рассмотрим маргинализацию как линейное преобразование\n\n$$  \\boldsymbol\\xi_1 =  \\boldsymbol A\\boldsymbol\\xi, \\text{ где } \\boldsymbol A = \\begin{pmatrix}\\boldsymbol I_{k} & \\boldsymbol 0_{k\\times(n-k)}\\end{pmatrix} \\in \\mathrm{Mat}_{k\\times n},\n$$\n\nи воспользуемся результатом предыдущего упражнения. Имеем $\\boldsymbol A\\boldsymbol\\mu = \\boldsymbol I_{k}\\boldsymbol \\mu_1 =  \\boldsymbol \\mu_1$, $\\boldsymbol A \\boldsymbol \\Sigma \\boldsymbol A^T  = \\boldsymbol I_{k} \\boldsymbol \\Sigma_{11}\\boldsymbol I_{k}^T = \\boldsymbol \\Sigma_{11}$, и поэтому\n$\\boldsymbol\\xi_1 \\sim \\mathcal N(\\boldsymbol \\mu_1, \\boldsymbol \\Sigma_{11})$.\n\n{% endcut %}\n\n### Распределение Дирихле\n\n**Распределение Дирихле** сосредоточено на $K$-мерном симплексе\n\n$$\\{(x_1,\\ldots,x_K)\\colon x_1 + \\ldots + x_K = 1,\\; x_i\\geqslant 0\\}.\n$$\n\nПлотность распределения Дирихле $\\mathrm{Dir}(\\boldsymbol \\alpha)$ равна\n\n$$p(x_1,\\ldots,x_K) = \\frac1{B(\\boldsymbol \\alpha)}\\prod_{i=1}^Kx_i^{\\alpha_i - 1},\n$$\n\nгде $\\boldsymbol\\alpha = (\\alpha_1,\\ldots,\\alpha_K)$ – вектор положительных параметров, а $B(\\boldsymbol\\alpha) = \\frac{\\prod_i\\Gamma(\\alpha_i)}{\\Gamma(\\sum_i\\alpha_i)}$ – многомерная бета-функция. Если $\\boldsymbol \\xi \\sim \\mathrm{Dir}(\\boldsymbol \\alpha)$,\nто\n\n$$  \\mathbb E \\boldsymbol \\xi =\\frac{\\boldsymbol \\alpha}{\\alpha_0}, \\quad \n  \\mathrm{cov} (\\xi_i, \\xi_j)=\\frac{\\alpha_0 \\delta_{ij} - \\alpha_i\\alpha_j}{\\alpha_0^2(\\alpha_0 + 1)}, \\quad \\alpha_0 = \\sum\\limits_{k=1}^K \\alpha_k.\n$$\n\n{% cut \"Иллюстрация распределения Дирихле с помощью схемы Пойя\" %}\n\nПусть у нас есть $K$ категорий и на них задано вероятностное распределение\n\n$$\\boldsymbol q^{(1)} = \\frac{\\boldsymbol\\alpha}{\\alpha_0} = \\left(\\frac{\\alpha_1}{\\alpha_0},\\ldots,\\frac{\\alpha_K}{\\alpha_0}\\right),\n$$\n\nгде $\\alpha_0 = \\sum\\limits_{i=1}^K\\alpha_i$. Это корректное распределение вероятностей, так как его компоненты неотрицательны и в сумме дают $1$. Будем производить следующий процесс:\n\n* В первый момент генерируем одну из категорий с помощью распределения $\\boldsymbol q^{(1)}$; допустим, выпала $i_1$-я. Обновляем вероятностное распределение на категориях, прибавив единицу к $i_1$-й компоненте вектора $\\boldsymbol\\alpha$; получаем вектор $\\boldsymbol\\alpha^{(2)}$.\n* На $n$-м шаге генерируем одну из категорий с помощью распределения $\\boldsymbol q^{(n)} = \\frac{\\boldsymbol \\alpha^{(n)}}{\\sum\\limits_i\\alpha^{(n)}_i}$. Допустим, выпала $i_n$-я. Обновляем вероятностное распределение на категориях, прибавив единицу к $i_n$-й компоненте вектора $\\boldsymbol\\alpha^{(n)}$; получаем вектор $\\boldsymbol\\alpha^{(n+1)}$.\n\nМожно доказать, что вектор $\\lim\\limits_{n\\to\\infty} \\boldsymbol q^{(n)}$ подчиняется распределению Дирихле $\\mathrm{Dir}(\\boldsymbol \\alpha)$.\n\nЧтобы стало чуть понятнее, проследим, что будет при различных $\\boldsymbol\\alpha$.\n\n* Если $\\boldsymbol\\alpha = (10,10,10)$, то прибавление единицы будет не так сильно смещать вероятности, и дальше мы будем продолжать генерировать категорию из распределения, близкого к равномерному. Скорее всего, в пределе мы будем получать что-то, близкое к $(\\frac13, \\frac13,\\frac13)$.\n* Если $\\boldsymbol\\alpha = (1,1,20)$, то почти наверняка мы будем генерить третью категорию, причём со всё большей вероятностью (ведь при этом мы будем увеличивать $\\alpha^{(n)}_3$), то есть в пределе будет (почти $0$, почти $0$, почти $1$).\n* Если $\\boldsymbol\\alpha = (0.1,0.1,0.1)$, то та категория, которую мы сгенерировали на первом шаге, сразу вырвется вперёд и скорее всего будет доминировать в дальнейшем. Таким образом, нам следует ожидать в пределе векторов, в которых одна из компонент почти $1$, а остальные почти $0$. Важным отличием от предыдущего варианта является то, что здесь почти $1$ может быть в любой компоненте.\n* Если $\\boldsymbol\\alpha = (1,1,1)$, то соответствующее распределение Дирихле будет равномерным.\n\nТакже вам может оказаться полезна визуализация плотности этого распределения при разных $\\boldsymbol\\alpha$:\n\n<figure>\n<img src=\"https://yastatic.net/s3/ml-handbook/admin/page1_1500px_Dirichlet_pdf_961f276adf.jpg\" loading=\"lazy\" decoding=\"async\" alt=\"\">\n<figcaption>\n  <a href=\"https://en.wikipedia.org/wiki/File:Dirichlet.pdf\">ссылка на источник картинки</a>\n</figcaption>\n</figure>\n\n{% endcut %}",
        "handbook": "Учебник по машинному обучению",
        "title": "Многомерные распределения",
        "description": null
    },
    {
        "path": "/handbook/ml/article/nezavisimost-i-uslovnye-raspredeleniya-veroyatnostej",
        "content": "В этом параграфе описываются, пожалуй, главные фичи теории вероятностей: независимые события и условные вероятности. Эти концепции имеют большое прикладное значение, да и с теоретической точки зрения главным образом благодаря им теория вероятностей выделяется в отдельную ветвь математики.\n\n## Условная вероятность\n\nУсловная вероятность возникает при ответе на вопрос о том, каковы шансы события $A$ при условии,что случилось событие $B$, и обозначается $\\mathbb P(A\\vert B)$.\n\n**Пример**. Согласно исследованиям, в среднем $5\\%$ пациентов испытывают приступы кашля в течение дня, однако среди курильщиков доля кашляющих составляет $40\\%$. То есть (безусловная) вероятность $\\mathbb P(\\text{кашляет}) = 0.05$ при добавлении обусловливания может существенно измениться: $\\mathbb P(\\text{кашляет}\\vert\\text{курит}) = 0.4$.\n\n**Упражнение**. Известно, что в семье два ребёнка, причём один из них мальчик. Какова вероятность, что другой ребёнок тоже мальчик?\n\n{% cut \"Ответ (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nКак ни странно, ответ вовсе не $50\\%$. Пол новорождённого ребёнка можно приближённо считать результатом испытания Бернулли с вероятностью успеха $\\frac 12$.\nИз четырёх возможных вариантов ММ, МД, ДМ, ДД условию удовлетворяют только первые три, и лишь в одном случае из этих трёх второй ребёнок тоже мальчик. Поэтому правильный ответ — $\\frac 13$.\n\nДобавляя формализма, обозначим\n\n$$  A = \\{\\text{хотя бы один ребёнок — мальчик}\\}\n$$\n\n$$  B = \\{\\text{мальчики оба ребёнка}\\},\n$$\n\nи тогда условная вероятность $\\mathbb P(B\\vert A)$ вычисляется по формуле\n\n$$  \\mathbb P(B\\vert A) = \\frac{\\mathbb{P}(A \\cap B)}{\\mathbb{P}(A)} = \\frac{1/4}{3/4} = \\frac 13.\n$$\n\n{% endcut %}\n\nВ общем случае условная вероятность $\\mathbb P(B\\vert A)$ при $\\mathbb P(A) \\ne 0$ полагается равной\n\n$$  \\mathbb{P}(B \\vert A) = \\frac{\\mathbb{P}(A \\cap B)}{\\mathbb{P}(A)}.\n$$\n\nВ зависимости от соотношения событий $A$ и $B$ условная вероятность $\\mathbb{P}(B \\vert A)$ может принимать разные значения, например:\n\n* если $A\\cap B = \\varnothing$, то событие $A$ исключает реализацию события $B$, и $\\mathbb{P}(B \\vert A) = 0$;\n* если $A \\subset B$, то событие $A$ гарантирует осуществление события $B$, и $\\mathbb{P}(B \\vert A) = 1$.\n\nРазумеется, чаще всего события $A$ и $B$ соотносятся между собой более хитрым образом, и значение условной вероятности $\\mathbb{P}(B \\vert A)$ находится строго между $0$ и $1$.\n\n## Формула полной вероятности\n\nПусть пространство $\\Omega$ разбивается на попарно несовместные события $B_1, B_2, \\dots, B_n$:\n\n$$  \\Omega = B_1 \\cup \\ldots \\cup B_n, \\quad B_i \\cap B_j = \\varnothing \\text{ при } i\\ne j.\n$$\n\nТогда\n\n$$A = A\\cap\\Omega = (A\\cap B_1) \\cup \\ldots \\cup (A\\cap B_n);\n$$\n\nотсюда по свойству конечной аддитивности находим, что\n\n$$  \\mathbb P(A) = \\mathbb{P}(A \\cap B_1)  + \\ldots + \\mathbb{P}(A \\cap B_n).\n$$\n\nПереходя к условным вероятностям, получаем **формулу полной вероятности**:\n\n$$  \\mathbb{P}(A) = \\sum\\limits_{k=1}^n \\mathbb{P}(A \\vert B_k) \\mathbb{P}(B_k).\n$$\n\n**Пример**. Среди населения $33.7\\%$ имеют первую группу крови, $37.5\\%$ — вторую, $20.9\\%$ — третью, $7.9\\%$ — четвёртую. При переливании крови надо учитывать группы крови донора и рецепиента:\n\n* реципиенту с четвёртой группой крови можно перелить кровь любой группы;\n* реципиентам со второй и третьей группами можно перелить кровь той же группы или первой;\n* реципиентам с первой группой крови можно перелить только кровь первой группы.\n\nС какой вероятностью допустимо переливание в случайно взятой паре донор—реципиент?\n\n**Решение**. Пусть событие $A$ состоит в том, что переливание возможно, а событие $B_k$ — в том, что донор имеет группу $k$. По формуле полной вероятности\n\n$$  \\mathbb P(A) = \\mathbb P(A\\vert B_1) \\mathbb P(B_1) + \\mathbb P(A\\vert B_2) \\mathbb P(B_2) +\n  \\mathbb P(A\\vert B_3) \\mathbb P(B_3) + \\mathbb P(A\\vert B_4) \\mathbb P(B_4).\n$$\n\nВероятности $\\mathbb P(B_k)$ даны в условии, оттуда же находим, что\n\n$$  \\mathbb P(A\\vert B_1) = 1,\n$$\n\n$$  \\mathbb P(A\\vert B_2) =  \\mathbb P(B_2) + \\mathbb P(B_4),\n$$\n\n$$  P(A\\vert B_3) =  \\mathbb P(B_3) + \\mathbb P(B_4),\n$$\n\n$$  \\mathbb P(A\\vert B_4) = \\mathbb P(B_4). \n$$\n\nПодставляя численные значения, получаем\n\n$$  \\mathbb P(A) = 0.337 + (0.375+0.079)\\cdot 0.375 + (0.209+0.079)\\cdot 0.209 + 0.079^2 = 0.573683.\n$$\n\n**Упражнение**. Решите предыдущий пример, выбирая в качестве разбиения набор событий $C_k$, каждое из которых заключается в том, что реципиент имеет группу $k$.\n\n{% cut \"Ответ\" %}\n\nПо той же формуле полной вероятности получаем, что\n\n$$  \\mathbb P(A) = \\mathbb P(A\\vert С_1) \\mathbb P(С_1) + \\mathbb P(A\\vert С_2) \\mathbb P(С_2) +\n  \\mathbb P(A\\vert С_3) \\mathbb P(С_3) + \\mathbb P(A\\vert С_4) \\mathbb P(С_4).\n$$\n\nЯсно, что $\\mathbb P(C_k) = \\mathbb P(B_k)$; далее из условия находим, что\n\n$$  \\mathbb P(A\\vert С_1) = \\mathbb P(C_1),\n$$\n\n$$  \\mathbb P(A\\vert C_2) =  \\mathbb P(C_1) + \\mathbb P(C_2),\n$$\n\n$$  P(A\\vert C_3) =  \\mathbb P(C_1) + \\mathbb P(C_3),\n$$\n\n$$  \\mathbb P(A\\vert C_4) = 1. \n$$\n\nПодставляя численные значения, получаем тот же ответ $\\mathbb P(A) = 0.573683$.\n\n{% endcut %}\n\nФормула полной вероятности легко обобщается на случай счётного числа попарно несовместных событий $B_k$, а также на случай обусловливания по некоторому событию $C$, например:\n\n$$  \\mathbb{P}(A\\vert C) = \\sum\\limits_n \\mathbb{P}(A \\vert B_n, C) \\mathbb{P}(B_n \\vert C).\n$$\n\n## Формула Байеса\n\nЗаметим, что вероятность $\\mathbb{P}(A \\cap B)$ можно записать двумя способами\n\n$$  \\mathbb{P}(B \\vert A)\\mathbb{P}(A) = \\mathbb{P}(A \\cap B) = \\mathbb{P}(A \\vert B)\\mathbb{P}(B).\n$$\n\nОставим $\\mathbb{P}(B \\vert A)$ в левой части и получим формулу Байеса.\n\n**Формула Байеса**. Для любых событий $A$, $B$ c положительной вероятностью\n\n$$  \\mathbb{P}(B \\vert A) = \\frac{\\mathbb{P}(A \\vert B)\\mathbb{P}(B)}{\\mathbb{P}(A)}.\n$$\n\nДля вычисления знаменателя в формуле Байеса часто используется формула полной вероятности.\n\n**Упражнение**. Среди определенной группы людей вероятность некоторой болезни 0.02. Тест, позволяющий выявить болезнь, несовершенен. На больном он дает позитивный результат в 98 случаях из 100, и, кроме того, он дает позитивный результат в 4 случаях из 100 на здоровом. Найдите вероятность того, что человек, на котором тест дал положительный результат, действительно болен.\n\n{% cut \"Ответ (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nПо формуле Байеса,\n\n$$  \\mathbb{P}(\\text{болен}\\vert\\text{+}) = \\frac{\\mathbb{P}(\\text{+}\\vert\\text{болен}) \\mathbb{P}(\\text{болен})}{\\mathbb{P}(\\text{+})}.\n$$\n\nПо условию, $\\mathbb{P}(\\text{+} \\vert \\text{болен}) = 0.98$, $\\mathbb{P}(\\text{болен}) = 0.02$. Чтобы посчитать вероятность теста быть положительньным, применим формулу полной вероятности:\n\n$$  \\mathbb{P}(\\text{+}) = \\mathbb{P}(\\text{+} \\vert \\text{болен}) \\mathbb{P}(\\text{болен}) + \\mathbb{P}(\\text{+} \\vert \\text{здоров})\\mathbb{P}(\\text{здоров}) = 0.98 \\cdot 0.02 + 0.04 \\cdot 0.98 = 0.98 \\cdot 0.06.\n$$\n\nТогда по формуле Байеса\n\n$$  \\mathbb{P}(\\text{болен} \\vert \\text{+}) = \\frac{0.98 \\cdot 0.02}{0.98 \\cdot 0.06} = \\frac13.\n$$\n\nПолучается, что точность теста очень низка — всего лишь около 1 из 3. Это происходит, потому что больные люди встречаются редко (2 из 100), и эта частота сравнима с долей ошибок I и II рода — 0.02 и 0.04.\n\n{% endcut %}\n\nДля непрерывного случая тоже есть своя формула полной вероятности, см. раздел про [условную вероятность](https://education.yandex.ru/handbook/ml/article/nezavisimost-i-uslovnye-raspredeleniya-veroyatnostej#uslovnye-raspredeleniya).\n\n## Независимые события\n\nСобытия $A$ и $B$ называются **независимыми**, если\n$\\mathbb{P}(A \\vert B) = \\mathbb{P}(A)$, то есть информация о реализации события $B$ никак не влияет на вероятность события $A$.\n\nПо определению условной вероятности независимость событий $A$ и $B$ эквивалентна тому, что\n\n$$  \\mathbb{P}(A \\cap B) = \\mathbb{P}(A) \\mathbb{P}(B).\n$$\n\nПоследнее равенство годится для определения независмости событий $A$ и $B$ даже в том случае, если \\$\\\\mathbb{P}(A) = 0 \\$ или $\\mathbb{P}(B) = 0$.\n\n**Пример**. В полной колоде карт находится $52$ карты: $4$ масти от двойки до туза. Вероятность вытащить туза равна $\\mathbb P(\\mathrm{Ace}) = \\frac 4{52} = \\frac 1{13}$, карту пиковой масти — $\\mathbb P(\\spadesuit) = \\frac {13}{52} = \\frac 1{4}$. Эти события независимы, поскольку в пересечении этих событий лежит ровно одна карта — туз пик, вероятность появления которого равна $\\frac 1{52} = \\frac 1{13} \\cdot \\frac 14 = \\mathbb P(\\mathrm{Ace})\\mathbb P(\\spadesuit)$.\n\nПусть теперь вытаскивается сразу две карты. Зависимы ли события «вытащены две карты пиковой масти» и «вытащены туз и король»? Посчитаем:\n\n$$  \\mathbb P(\\spadesuit \\spadesuit) = \\frac{\\binom{13}2}{\\binom{52}2} = \\frac{13\\cdot 12}{52\\cdot 51} = \\frac 1{17},\n$$\n\n$$  \\mathbb P(\\mathrm{AK}) = \\frac{16}{\\binom{52}2} = \\frac{32}{52\\cdot 51} = \\frac 8{663}.\n$$\n\nВероятность вытащить туза и короля пик равна $\\frac 1{\\binom{52}2} = \\frac 1{1326}\\approx 0.00075$, что отличается от $\\mathbb P(\\spadesuit \\spadesuit)\\mathbb P(\\mathrm{AK})  = \\frac 8{11271} \\approx 0.00071$. Таким образом, эти события зависимы.\n\nСобытия $A_1, \\ldots, A_n$ **попарно независимы**, если $\\mathbb{P}(A_i \\cap A_j) = \\mathbb{P}(A_i) \\mathbb{P}(A_j)$ при $i \\ne j$. Эти же события **независимы в совокупности**, если\n\n$$  \\mathbb P\\big(A_{i_1}\\cap \\ldots \\cap A_{i_m}\\big) = \\prod\\limits_{k=1}^m \\mathbb P(A_{i_k})\n$$\n\n$$  \\text{ для любого набора индексов } 1\\leqslant i_1 < \\ldots < i_m\\leqslant n.\n$$\n\n**Упражнение**. Приведите пример попарно независимых событий $A_1$, $A_2$, $A_3$, не являющихся независимыми в совокупности.\n\n{% cut \"Ответ (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nРаскрасим тетраэдр в три цвета следующим образом: одна грань красная (R), вторая — зелёная (G), третья — синяя (B), а четвёртая содержит все три цвета. События $R$, $G$, $B$ состоят в том, что при случайном броске на нижней грани тетраэдра есть соответствующий цвет.\nТогда\n\n$$  \\mathbb P(R) = \\mathbb P(G) = \\mathbb P(B) = \\frac 12,\n$$\n\n$$  \\mathbb P(R \\cap G) = \\mathbb P(R \\cap B) = \\mathbb P(G\\cap B) = \\frac 14,\n$$\n\nчто влечёт попарную независимость событий $R$, $G$, $B$. Однако $\\mathbb P(R \\cap G \\cap B) = \\frac 14$, что не равно $\\mathbb P(R)\\mathbb P(G)\\mathbb P(B) = \\frac 18$, поэтому эти события не являются независимыми  совокупности.\n\n{% endcut %}\n\nОпределение [независимости случайных величин](https://education.yandex.ru/handbook/ml/article/mnogomernye-raspredeleniya#nezavisimost-sluchajnyh-velichin) из предыдущего параграфа полностью согласуется с только что введённым определением независимых событий. Например, для случая дискретных случайных величин $\\xi$ и $\\eta$ обозначим\n\n$$  A_i = \\mathbb P(\\xi = x_i), \\quad B_j = \\mathbb P(\\eta = y_j);\n$$\n\nтогда $\\mathbb P(\\xi = x_i, \\eta = y_j) = \\mathbb P(A_i \\cap B_j)$, и поэтому независимость случайных величин $\\xi$ и $\\eta$ эквивалентна независимости событий $A_i$ и $B_j$ для всевозможных значений $i$ и $j$.\n\n{% cut \"Замечание о статистической независимости\" %}\n\nМатематический термин «независимость» подразумевает **статистическую** (или **стохастическую**) независимость, которая может не вполне совпадать по смыслу с интуитивным значением этого термина. Например, если вы два раза подкидываете симметричную монетку, то **статистически** результат первого броска никак не влияет на результат второго броска. Но так ли это с философской точки зрения? Вот представим две ситуации:\n\n1. вы бросили монетку, быстро подняли с пола, и снова бросили;\n\n2. монетка при первом броске укатилась далеко под диван, и вы полчаса ворочали мебель, прежде чем произвести второе испытание.\n\nВесьма вероятно, что столь досадное происшествие после первого броска могло существенно повлиять на ваше физическое и моральное состояние. И уж точно второй бросок в ситуациях (1) и (2) вы бы совершили совершенно по-разному, что вполне могло отразиться на его результате.\n\nОднако в математике подобным метафизическим измышлениям нет места. С абстрактным понятием независимости гораздо проще работать, поскольку оно игнорирует замысловатые причинно-следственные связи и прочие несущественные детали. В модели независимых испытаний Бернулли каждое следующее испытание статистически никак не зависит от предыдущих. Что бы с вами не происходило, шансы во втором броске — 50 на 50, именно об этом говорит нам независимость испытаний Бернулли с вероятностью успеха $\\frac 12$, не больше и не меньше.\n\n{% endcut %}\n\n## Условная независимость\n\nБывает так, что зависимые события $A$ и $B$ становятся независимыми при выполнении некоторого третьего события $C$. Более формально, события $A$ и $B$ **условно независимы** по отношению к событию $C$, если $\\mathbb P(C) > 0$ и\n\n$$  \\mathbb P(A \\vert B, C) = \\mathbb P(A\\vert C).\n$$\n\nПоскольку\n\n$$  \\mathbb P(A \\vert B, C)  = \\frac{\\mathbb P(A \\cap B \\cap C)}{\\mathbb P(B \\cap C)}, \\quad\n  \\mathbb P(A \\vert C)  = \\frac{\\mathbb P(A \\cap C)}{\\mathbb P(C)},\n$$\n\nто условная независимость событий $A$ и $B$ эквивалетна равенству\n\n$$  \\frac{\\mathbb P(A \\cap B \\cap C)}{\\mathbb P(C)} =  \\frac{\\mathbb P(A \\cap C)}{\\mathbb P(C)} \\cdot  \\frac{\\mathbb P(B \\cap C)}{\\mathbb P(C)},\n$$\n\nа это, в свою очередь, означает, что\n\n$$  \\mathbb P(A \\cap B\\vert C) = \\mathbb P(A\\vert C) \\mathbb P(B\\vert C).\n$$\n\nТаким образом, вероятность произведения условно независимых событий равна произведению условных вероятностей. Эта формула полностью аналогична формуле $\\mathbb P(A\\cap B) = \\mathbb P(A)\\mathbb P(B)$ для (безусловно) независимых событий.\n\n**Пример** (цепь Маркова). Последовательность событий $S_0, S_1, S_2, \\ldots, S_t, \\ldots$ называется **марковской цепью**, если выполняется **марковское свойство**\n\n$$\\mathbb P (S_{t+1} \\vert S_t, S_{t-1}, \\ldots, S_0) = \\mathbb P(S_{t+1} \\vert S_t), \\quad t \\in \\mathbb N \\cup \\{0\\}.\n$$\n\nВ марковском свойстве заложен следующий смысл: в каждый момент времени $t$ «будущее» $S_{t+1}$ зависит только от «настоящего» $S_t$, но не зависит от «прошлого»\n\n$$P_t = S_{t-1} \\cap \\ldots \\cap S_0.\n$$\n\nИтак, цепь Маркова характеризуется равенством $\\mathbb P(S_{t+1} \\vert P_t, S_t) = \\mathbb P(S_{t+1} \\vert S_t)$, которое означает, что события $S_{t+1}$ и $P_t$ условно независимы по отношению к событию $S_t$.\n\n## Условные распределения\n\nПусть $\\xi$ и $\\eta$ — дискретные случайные величины и $\\mathbb P(\\eta = y) > 0$. По аналогии с условными вероятностями **условное распределение** случайной величины $\\xi$ при условии, что значение случайной величины $\\eta$ равно $y$, определяется по формуле\n\n$$  \\mathbb P(\\xi = x_i \\vert \\eta = y) = \\frac{\\mathbb P(\\xi = x_i , \\eta = y)}{\\mathbb P(\\eta = y)}.\n$$\n\nЭто действительно распределение вероятностей, поскольку $\\mathbb P(\\xi = x_i \\vert \\eta = y) \\geqslant 0$ и\n\n$$\\sum\\limits_{i}\\mathbb P(\\xi = x_i \\vert \\eta = y) = \\frac 1{\\mathbb P(\\eta = y)} \\sum\\limits_{i}\\mathbb P(\\xi = x_i , \\eta = y) = 1.\n$$\n\nВ непрерывном случае условное распределение задаётся **условной плотностью**\n\n$$  p_{\\xi\\vert \\eta}(x\\vert y) = \\frac{p(x, y)}{p_\\eta(y)},\n$$\n\nгде $p(x, y)$ — совместная плотность случайных величин $\\xi$ и $\\eta$. И снова проведением маргинализации по $x$ убеждаемся в том, что с нормировкой всё в порядке:\n\n$$  \\int\\limits_{-\\infty}^{+\\infty} p_{\\xi\\vert \\eta}(x\\vert y)\\,dx = \\frac 1{p_\\eta(y)}\\int\\limits_{-\\infty}^{+\\infty} p(x, y)\\,dx = \\frac {p_\\eta(y)}{p_\\eta(y)} = 1.\n$$\n\nПоскольку $\\int\\limits_{-\\infty}^{+\\infty} p(x, y)\\,dy = p_\\xi(x)$, из формулы условной плотности получаем непрерывный аналог **формулы полной вероятности**:\n\n$$  p_\\xi(x) = \\int\\limits_{\\mathbb{R}} p_{\\xi \\mid \\eta}(x\\vert y) p_\\eta(y) dy.\n$$\n\n**Пример**. Выберем случайное число $x\\in \\big[\\tfrac12, 1\\big]$, а затем — случайное число $y \\in [0, x]$. Как распределена случайная величина $y$?\n\nПереформулируем задачу: известно, что $\\xi \\sim U\\big[\\tfrac12, 1\\big]$ и $\\eta \\vert \\xi \\sim U[0, x]$. Требуется найти плотность случайной величины $\\eta$. Имеем\n\n$$  p_\\xi(x) = 2\\mathbb I_{\\big[\\tfrac12, 1\\big]}(x), \\quad\n  p_{\\eta\\mid\\xi}(y\\vert x) = \\frac 1x\\mathbb I_{[0, x]}(y).\n$$\n\nПрименяя формулу полной вероятности, находим\n\n$$  p_\\eta(y) = \\int\\limits_{1/2}^1 \\frac 2x \\mathbb I[y \\leqslant x]\\, dx =\n    \\begin{cases}\n      2 \\ln2, & 0 \\leqslant y < \\tfrac12, \\\\\n      -2 \\ln{y}, & \\tfrac12 \\leqslant y \\leqslant 1.\n    \\end{cases}\n$$\n\n**Упражнение**. Пусть случайные величины $\\xi_k \\sim \\mathrm{Exp}(\\lambda_k)$, $k=1, \\ldots, n$, независимы в совокупности. Чему равна вероятность $\\mathbb P\\big(\\xi_k = \\min \\{\\xi_1, \\ldots, \\xi_n \\}\\big)$?\n\n<br>\n\n{% cut \"Ответ (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nОбозначим $\\eta = \\operatorname*{argmin}\\limits_{1\\leqslant k \\leqslant n} \\{\\xi_k\\}$. Требуется найти $\\mathbb P(\\eta = k)$. По формуле полной вероятности имеем\n\n$$\\mathbb P(\\eta = k) = \\int\\limits_0^{+\\infty} p_{\\eta\\vert \\xi_k}(\\eta = k \\vert x) p_{\\xi_k}(x)\\,dx.\n$$\n\nДалее, $p_{\\xi_k}(x) = \\lambda_k e^{-\\lambda_k x}$, $x\\geqslant 0$,\n\n$$  p_{\\eta\\vert \\xi_k}(\\eta = k \\vert x) = \\mathbb P(\\xi_i > x,  i \\ne k) = \\prod\\limits_{i\\ne k} e^{-\\lambda_i x}.\n$$\n\nТаким образом,\n\n$$\\mathbb P(\\eta = k) = \\int\\limits_0^{+\\infty} \\lambda_k e^{-\\lambda_k x}\\prod\\limits_{i\\ne k} e^{-\\lambda_i x} \\, dx = \\lambda_k \\int\\limits_0^{+\\infty} \\exp\\Big(-\\sum\\limits_{i=1}^n \\lambda_i x\\Big)\\,dx= \\frac{\\lambda_k}{\\lambda_1 + \\ldots + \\lambda_n}.\n$$\n\nУсловные распределения случайных векторов определяется аналогично с поправкой на возросшее число аргументов: в этом случае $x$ и $y$ уже не числа, а вектора тех же размерностей, что и сами случайные вектора.\n\n{% endcut %}\n\n## Условные математические ожидания\n\n**Условное математическое ожидание** $\\mathbb E(\\xi\\vert\\eta = y)$ отвечает на вопрос «чему равно среднее значение случайной величины $\\xi$ при условии, что $\\eta = y$?».\nИмея в распоряжении матрицу условного дискретного распределения $\\mathbb P(\\xi = x_i\\vert \\eta = y_j)$ или условную плотность $p_{\\xi\\vert \\eta}(x\\vert y)$, условное математическое ожидание можно вычислить следующим образом:\n\n* $\\mathbb E(\\xi\\vert\\eta)\\equiv \\mathbb E(\\xi\\vert\\eta=y) = \\sum\\limits_i x_i \\mathbb P(\\xi = x_i\\vert \\eta = y)$ в дискретном случае;\n* $\\mathbb E(\\xi\\vert\\eta) \\equiv \\mathbb E(\\xi\\vert\\eta=y) = \\int\\limits_{\\mathbb R} x p_{\\xi\\vert \\eta}(x\\vert y)\\,dx$ для непрерывных $\\xi$ и $\\eta$.\n\nВажно отметить, что после суммирования или интегрирования по переменной $x$ в формуле условного математического ожидания остаются зависимость от $y$. Таким образом, в отличие от обычного среднего, которое является просто числом, условное ожидание представляет собой случайную величину $\\zeta = \\mathbb E(\\xi\\vert\\eta=y)$, поскольку его значение зависит от случайного значения $\\eta = y$.\n\n**Свойства условного математического ожидания**\n\n1. $\\mathbb E(a\\xi_1 + b \\xi_2 \\vert \\eta) = a\\mathbb E (\\xi_1\\vert \\eta) + b \\mathbb E (\\xi_2 \\vert\\eta)$ (линейность).\n\n2. Если $\\xi_1 \\leqslant \\xi_2$, то $\\mathbb E (\\xi_1\\vert \\eta) \\leqslant \\mathbb E (\\xi_2\\vert \\eta)$ (монотонность).\n\n3. Если случайные величины $\\xi$ и $\\eta$ независимы, то $\\mathbb E(\\xi\\vert\\eta) = \\mathbb E\\xi$.\n\n4. $\\mathbb E(g(\\eta) \\xi\\vert\\eta) = g(\\eta) \\mathbb E(\\xi\\vert \\eta)$.\n\n5. $\\mathbb E\\big(\\mathbb E(\\xi\\vert \\eta)\\big) = \\mathbb E\\xi$ (**law of total expectation**).\n\n**Упражнение.** Prove the law of total expectation.\n\n{% cut \"Ответ (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nПусть $\\zeta = \\mathbb E(\\xi \\vert \\eta)$. Начнём с дискретного случая:\n\n$$  \\mathbb E\\zeta = \\sum\\limits_j \\mathbb E(\\xi\\vert\\eta = y_j)\\mathbb P(\\eta = y_j) = \n  \\sum\\limits_j\\sum\\limits_i x_i \\mathbb P(\\xi = x_i\\vert \\eta = y_j)\\mathbb P(\\eta = y_j)=\n$$\n\n$$  =\\sum\\limits_i x_i \\sum\\limits_j\\mathbb P(\\xi = x_i, \\eta = y_j) \n  =\\sum\\limits_i x_i \\mathbb P(\\xi = x_i) = \\mathbb E\\xi.\n$$\n\nВ непрерывном случае вместо сумм потребуется переставить местами интегралы. Это позволяет сделать [теорема Фубини](https://en.wikipedia.org/wiki/Fubini%27s_theorem) о сведении двойного интеграла к повторному:\n\n$$  \\mathbb E\\zeta = \\int\\limits_{-\\infty}^{+\\infty}\\mathbb E(\\xi\\vert\\eta = y) p_\\eta(y)\\,dy =\n  \\int\\limits_{-\\infty}^{+\\infty} p_\\eta(y)\\,dy \\int\\limits_{-\\infty}^{+\\infty}x p_{\\xi\\vert\\eta}(x\\vert y)\\,dx =\n$$\n\n$$  = \\int\\limits_{-\\infty}^{+\\infty} x\\,dx \\int\\limits_{-\\infty}^{+\\infty} p(x, y)\\,dy  = \n  \\int\\limits_{-\\infty}^{+\\infty} xp_\\xi(x) \\,dx = \\mathbb E\\xi.\n$$\n\n{% endcut %}\n\n**Условная дисперсия** определяется по формуле\n\n$$  \\mathbb V(\\xi \\vert \\eta) = \\mathbb E\\big((\\xi - \\mathbb E(\\xi\\vert \\eta))^2 \\vert \\eta\\big) = \\mathbb E(\\xi^2 \\vert \\eta) - \\big(\\mathbb E(\\xi \\vert \\eta))^2.\n$$\n\nСправедливо равенство $\\mathbb V \\xi = \\mathbb E\\big(\\mathbb V(\\xi\\vert \\eta)\\big) + \\mathbb V\\big(\\mathbb E(\\xi\\vert \\eta)\\big)$ (**law of total variance**).\n\n## Регрессия\n\nВ машинном обучении часто встречается задача **регрессии**, в которой требуется восстановить зависимость $Y = f(X)$ при наличии выборки\n\n$$  (X_1, Y_1), \\ldots, (X_n, Y_n) \n$$\n\nиз некоторого неизвестного распределения с совместной плотностью $p(x, y)$. Стандартный способ решения задачи регресии — минимизация среднего значения **функции потерь** $\\mathcal L(Y, f(X))$:\n\n$$  \\mathbb E \\big[\\mathcal L(Y, f(X))\\big] = \\iint\\limits_{\\mathbb R^2} \\mathcal L(y, f(x)) p(x, y) \\,dxdy \\to \\min.\n$$\n\nВ качестве функции потерь на одном объекте $(x, y)$ в задаче регрессии обычно выбирают квадратичную функцию: $\\mathcal L(y, f(x)) = (y-f(x))^2$. Тогда\n\n$$  \\mathbb E \\big[\\mathcal L(Y, f(X))\\big] = \\iint\\limits_{\\mathbb R^2} \\mathcal (y-f(x))^2 p(x, y) \\,dxdy;\n$$\n\nдля минимизации этого функционала применим немножко вариационного исчисления и продифференцируем по функции $f(x)$. Получим\n\n$$2\\iint\\limits_{\\mathbb R^2} (f(x)-y) p(x, y) \\,dxdy = 0,\n$$\n\nоткуда\n\n$$  f(x) = \\frac 1{p(x)} \\int\\limits_{-\\infty}^{+\\infty} yp(x, y)\\,dy = \\int\\limits_{-\\infty}^{+\\infty} yp_{Y\\vert X}(y \\vert x)\\,dy = \\mathbb E(Y\\vert X = x).\n$$\n\nПолученное условное математическое ожидание, называемое **функцией регрессии**, показывает, чему в среднем равно значение зависимой переменной $Y$ при условии, что $X=x$.",
        "handbook": "Учебник по машинному обучению",
        "title": "Независимость и условные распределения вероятностей",
        "description": "Независимость и условные распределения вероятностей"
    },
    {
        "path": "/handbook/ml/article/parametricheskie-ocenki",
        "content": "Различные типы распределений, описанные в предыдущих параграфах, применяются в качестве теоретических моделей в задачах, связанных со случайностью и неопределённостью. Однако на практике далеко не всегда ясно, какое именно распределение моделирует имеющиеся в наличии данные. А если из каких-либо соображений тип распределения всё же установлен, то следующая задача — оценить параметры этого распределения, например, среднее и/или дисперсию в случае гауссовского распределения $\\mathcal N(\\mu, \\sigma^2)$.\n\nПодобными обратными по отношению к теории вероятностей задачами занимается **математическая статистика**. Типичный пример статистической задачи: по числовой выборке $X_1, \\ldots, X_n$ оценить параметры распределения, из которого они были получены. Обычно предполагается, что выборка **i.i.d.** (**i**ndependent and **i**dentically **d**istributed), то есть представляет собой независимые реализации случайной величины с одним и тем же распределением. Параметр этого определения $\\theta$ может быть числом или вектором; оценку этого параметра по выборке $X_1, \\ldots, X_n$ обычно обозначают $\\widehat \\theta(X_1, \\ldots, X_n)$ или просто $\\widehat \\theta$.\n\n## Предельные теоремы\n\nКак правило, чем больше размер выборки, тем более информативны параметрические оценки вида $\\widehat \\theta(X_1, \\ldots, X_n)$. Теоретические свойства таких оценок при $n\\to\\infty$ устанавливаются с помощью предельных теорем теории вероятностей.\n\n### Закон больших чисел\n\nВнимательный читатель мог обратить внимание, что в ряде примеров из предыдущих параграфов параметры некоторых распределений почему-то молчаливо подменялись средними значениями. Так мы поступили в задаче о показе рекламы, взяв в качестве параметра пуассоновского распределение среднее количество кликов пользователей. Фактически мы оценили неизвестный параметра $\\lambda$ средним по выборке:\n\n$$\\widehat\\lambda = \\frac 1n \\sum\\limits_{k=1}^n X_k.\n$$\n\nВ общем-то это кажется логичным, поскольку $\\lambda = \\mathbb E\\xi$, если $\\xi \\sim \\mathrm{Pois}(\\lambda)$. Однако у такой оценки есть также мощное теоретическое обоснование.\n\n**Теорема (Закон больших чисел, ЗБЧ)**. Пусть $X_1, X_2, \\dots$ – последовательность попарно независимых одинаково распределенных случайных величин с конечным математическим ожиданием $\\mu$. Тогда для любого $\\varepsilon > 0$\n\n$$  \\lim\\limits_{n \\to \\infty} \\mathbb{P}(|\\overline{X}_n - \\mu| > \\varepsilon) = 0, \\text{ где } \\overline{X}_n = \\frac{1}{n}\\sum\\limits_{k = 1}^n X_k.\n$$\n\nТаким образом, чем больше размер выборки $n$, тем менее вероятно отклонение **выборочного среднего** $\\overline{X}_n$ от истинного среднего $\\mu$ на любое число $\\varepsilon > 0$.\n\nЗакон больших чисел особенно легко обосновать для случая конечных дисперсий: $\\mathbb V X_k = \\sigma^2 < +\\infty$. Имеем\n\n$$    \\mathbb E \\overline{X}_n = \\frac 1n \\sum\\limits_{k=1}^n \\mathbb EX_k = \\mu, \\quad\n    \\mathbb V \\overline{X}_n = \\frac 1{n^2} \\sum\\limits_{k=1}^n \\mathbb VX_k = \\frac{\\sigma^2}n.\n$$\n\nОтсюда видно, что $\\lim\\limits_{n\\to\\infty} \\mathbb V \\overline{X}_n = 0$, поэтому при больших $n$ распределение случайной величины $\\mathbb V \\overline{X}_n$ всё больше похоже на распределение, сосредоточенное в одно лишь точке $\\mu$. Формально же утверждение ЗБЧ получается с помощью неравенства Чебышева:\n\n$$    \\mathbb{P}\\big(\\vert \\overline{X}_n - \\mu\\vert > \\varepsilon\\big) \\leqslant \\frac{\\mathbb{V} \\overline{X}_n}{\\varepsilon} = \\frac{\\sigma^2}{n \\varepsilon} \\to 0, \\quad n\\to\\infty.\n$$\n\nЗакон больших чисел допускает следующее усиление.\n\n**Теорема (Усиленный закон больших чисел, УЗБЧ)**. Пусть $X_1, X_2, \\dots$ – последовательность попарно независимых одинаково распределенных случайных величин с конечным математическим ожиданием $\\mu$. Тогда выборочное среднее $\\overline{X}_n$ **почти наверное** сходится к $\\mu$, т.е.\n$\\mathbb P\\big(\\lim\\limits_{n\\to\\infty}\\overline{X}_n = \\mu\\big) = 1$.\n\n{% cut \"Замечание о типах сходимостей случайных величин\" %}\n\nПоследовательность случайных величин $(X_n)$, $n\\in\\mathbb N$, сходится к случайной величине $X$\n\n1. **по распределению**, $X_n \\stackrel{D}{\\to} X$, если $F_{X_n}(x) \\to F_X(x)$;\n2. **по вероятности**, $X_n \\stackrel{P}{\\to} X$, если $\\lim\\limits_{n \\to \\infty} \\mathbb{P}(\\vert X_n - X\\vert > \\varepsilon) = 0$ для любого $\\varepsilon > 0$;\n3. **почти наверное**, $X_n \\stackrel{\\text{п.н.}}{\\to} X$, если $\\mathbb P\\big(\\lim\\limits_{n\\to\\infty}X_n = X\\big) = 1$;\n4. **в среднем квадратичном**, $X_n \\stackrel{L_2}{\\to} X$, если $\\lim\\limits_{n \\to \\infty} \\mathbb E(X_n - X)^2=0$.\n\nИзвестно, что\n\n* из сходимости по вероятности вытекает сходимость по распределению, $X_n \\stackrel{P}{\\to} X  \\implies X_n \\stackrel{D}{\\to} X$;\n* из сходимость почти наверное следует сходимость по вероятности, $X_n \\stackrel{\\text{п.н.}}{\\to} X  \\implies X_n \\stackrel{P}{\\to} X$;\n* сходимость в среднем квадратичном влечёт сходимость по вероятности, $X_n \\stackrel{L_2}{\\to} X  \\implies X_n \\stackrel{P}{\\to} X$.\n\nА вот из сходимости по вероятности, вообще говоря, не следует сходимость почти наверное (контрпример можно посмотреть [здесь](https://math.stackexchange.com/questions/2479440/convergence-in-probability-does-not-imply-almost-sure-convergence)).\n\nЗакон больших чисел утверждает, что выборочное среднее сходится по вероятности к истинному среднему. А согласно УЗБЧ имеет место более сильный тип сходимости — почти наверное.\n\n{% endcut %}\n\n### Теорема Муавра-Лапласа\n\n[Доска Гальтона](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D1%81%D0%BA%D0%B0_%D0%93%D0%B0%D0%BB%D1%8C%D1%82%D0%BE%D0%BD%D0%B0) иллюстрирует биномиальное распределение. До поворота на ее дне лежит множество маленьких шариков. Сразу после переворота шарики проходят через 10 рядов гладких круглых препятствий. Преодоление каждого препятствия можно рассматривать как испытание Бернулли: с равными вероятностями шарик может пойти как налево, так и направо. Поэтому финальное положение шарика в одной из 10 корзин является приблизительной реализацией биномиального распределения $\\mathrm{Bin}(10, 0.5)$.\n\n<iframe width=\"100%\" height=\"400\" src=\"https://frontend.vh.yandex.ru/player/4a4648c43887178282364bf5d057236f?from=partner&mute=1&autoplay=0&tv=0&no_ad=false&loop=false&play_on_visible=true&branding=0\" allow=\"autoplay; fullscreen; accelerometer; gyroscope; picture-in-picture; encrypted-media\" frameborder=\"0\" scrolling=\"no\" allowfullscreen></iframe>\n\nУже при $n=10$ биномиальное распределение напоминает нормальное. И действительно, чем больше $n$, тем лучше дискретная случайная величина $\\xi \\sim \\mathrm{Bin}(n, p)$ аппроксимируется непрерывной гауссианой $\\mathcal N\\big(np, np(1-p)\\big)$.\n\n**Теорема Муавра-Лапласа**. Пусть $\\xi \\sim \\mathrm{Bin}(n, p)$, $q=1-p$, тогда\n\n$$    \\lim\\limits_{n\\to\\infty} \\mathbb P\\Big(a < \\frac{\\xi - np}{\\sqrt{npq}} \\leqslant b\\Big) = \\frac 1{\\sqrt{2\\pi}} \\int\\limits_a^b e^{-\\frac{x^2}2}\\,dx.\n$$\n\nИз теоремы Муавра-Лапласа вытекает, что при больших $n$ вероятность попадания биномиальной случайной величины $\\xi \\sim \\mathrm{Bin}(n, p)$ в заданный интервал можно оценить как\n\n$$    \\mathbb P(A < \\xi \\leqslant B) \\approx \\Phi\\Big(\\frac{B - np}{\\sqrt{npq}}\\Big) - \\Phi\\Big(\\frac{A - np}{\\sqrt{npq}}\\Big).\n$$\n\nгде $\\Phi(z)$ — функция распределения стандартного нормального распределения.\n\n### Центральная предельная теорема\n\nПри выводе закона больших чисел мы видели, что выборочное среднее $\\overline X_n$ имеет среднее $\\mu$ и дисперсию $\\frac{\\sigma^2} n$. Но как именно выглядит распределение случайной величины $\\overline X_n$ при увеличении $n$? Оказывается, что оно становится всё больше похоже на $\\mathcal N\\big(\\mu, \\frac{\\sigma^2} n\\big)$. Вот как, например, выглядят нормализованные гистограммы $5000$ выборочных средних, построенных по i.i.d. выборкам $X_1, \\ldots, X_n  \\sim \\mathrm{Bin}(30, 0.3)$ для разных значений $n$:\n\n<iframe src=\"https://yastatic.net/s3/ml-handbook/admin/binomials_CLT_b73d4eacfb.html\" width=100% height=500 frameborder=0></iframe>\n\nЭти гистограммы и впрямь очень напоминают гауссианы, и это прямое следствие следующей теоремы.\n\n**Центральная предельная теорема, ЦПТ**. Пусть $X_1, X_2, \\dots$ – последовательность попарно независимых одинаково распределенных случайных величин с конечным математическим ожиданием $\\mu$ и дисперсией $\\sigma^2$. Тогда\n\n$$  Z_n := \\frac{\\sqrt n(\\overline X_n - \\mu)}{\\sigma} \\approx \\mathcal N(0, 1) \\text{ при } n \\gg 1. \n$$\n\nТочнее говоря, $\\lim\\limits_{n\\to\\infty}\\mathbb P(Z_n \\leqslant z) = \\Phi(z)$. Таким образом, случайная величина $Z_n$ *сходится по распределению* к $\\mathcal N(0,1)$: $Z_n \\stackrel{D}{\\to} \\mathcal N(0, 1)$.\n\nЕсли применить центральную предельную теорему к бернуллиевским случайным величинам с вероятностью успеха $p$, то вновь получим теорему Муавра-Лапласа.\n\n## Свойства параметрических оценок\n\nОценивать параметры можно по-разному, хочется делать это хорошо. Ценные свойства оценок, которые обычно желательны – это **несмещенность** и **состоятельность**.\n\n### Несмещённость\n\nКаждый элемент i.i.d выборки $X_1, \\ldots, X_n$ можно рассматривать как значение случайной величины из некоторого распределения с неизвестным параметром $\\theta$.\nА раз так, то всякую оценку этого параметра $\\widehat\\theta(X_1, \\dots, X_n)$ также можно считать случайной величиной, у которой можно пытаться вычислять математическое ожидание, например.\n\nОценка $\\widehat\\theta(X_1, \\dots, X_n)$ параметра $\\theta$ называется **несмещенной**, если $\\mathbb{E}\\widehat\\theta = \\theta$. Несмещённость оценки означает, что она в среднем будет равна истинному значению параметра.\n\nИнтуитивно можно представлять себе несмещённость следующим образом: если мы нагенерим большое количество выборок $X_1^{(i)}, X_2^{(i)}, \\dots, X_n^{(i)}$, $1\\leqslant i \\leqslant N$, и для каждой посчитаем оценку $\\widehat \\theta^{(i)}$, то в среднем получится более или менее истинное значение параметра $\\theta$: $\\frac 1N\\sum\\limits_{i=1}^N \\widehat \\theta^{(i)} \\approx \\theta$.\n\nПростейший пример несмещённой оценки среднего значения $\\theta$ даёт выборочное среднее $\\overline{X}n = \\frac{1}{n}\\sum\\limits^n X_k$, поскольку\n\n$$    \\mathbb E \\overline{X}_n = \\frac 1n \\sum\\limits_{k = 1}^n \\mathbb E X_k = \\frac 1n\\cdot n\\theta = \\theta.\n$$\n\n**Медианой** выборки $X_1, \\ldots, X_n$ называется средний член **вариационного ряда**, состоящего из отсортированных по возрастанию элементов выборки:\n\n$$    X_{(1)} \\leqslant X_{(2)} \\leqslant \\ldots \\leqslant X_{(n)}.\n$$\n\nЕсли $n$ нечётно, $n=2m+1$, то есть ровно один элемент в середине вариационного ряда, именно он называется медианой: $\\mathrm{med}(X_1,\\ldots, X_n) = X_{(m)} = X_{\\big(\\frac{n+1}2\\big)}$. При чётном $n=2m$ в качестве медианы берут среднее двух центральных элементов вариационного ряда:\n\n$$\\mathrm{med}(X_1,\\ldots, X_n) = \\frac 12(X_{(m)}+ X_{(m+1)}) = \\frac 12 \\big(X_{(\\frac n2)} + X_{(\\frac n2 + 1)}\\big).\n$$\n\n**Упражнение.**  Дана i.i.d. выборка $X_1, \\ldots, X_n$ из равномерного распределения $U[0,2\\theta]$. Докажите, что выборочная медиана даёт несмещённую оценку медианы распределения $U[0,2\\theta]$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nЕсли $\\xi \\sim U[0,2\\theta]$, то $\\mathbb E\\xi = \\mathrm{med}(\\xi) = \\theta$. В секции про [бета-распределение](https://education.yandex.ru/handbook/ml/article/veroyatnostnye-raspredeleniya#nepreryvnye-raspredeleniya) была найдена плотность $k$-й порядковой статистики, посчитанной по выборке из равномерного распределения на $[0,1]$:\n\n$$  p(x) = \\frac{n!}{(k-1)!(n-k)!} x^{k-1}(1-x)^{n-k}, \\quad 0 \\leqslant x \\leqslant 1.\n$$\n\nЧтобы получить отсюда плотность $k$-й порядковой статистики $X_{(k)}$ для нашей выборки из $U[0, 2\\theta]$, сделаем линейную замену $t = 2\\theta x$. Тогда\n\n$$  p_{X_{(k)}}(t) = \\frac 1{2\\theta}\\frac{n!}{(k-1)!(n-k)!} \\Big(\\frac t{2\\theta}\\Big)^{k-1}\\Big(1-\\frac t{2\\theta}\\Big)^{n-k},\n$$\n\n$$    0 \\leqslant t \\leqslant 2\\theta.\n$$\n\nРассмотрим два случая. Если $n = 2m+1$, то выборочная медиана равна $X_{(m+1)}$, и\n\n$$    \\mathbb E X_{(m+1)} = \\frac{(2m+1)!}{m!(m+1)!}\\int\\limits_0^{2\\theta} \\Big(\\frac t{2\\theta}\\Big)^{m+1} (1-\\frac t{2\\theta}\\Big)^m\\,dt.\n$$\n\nВозвращаясь к переменной $x= \\frac t{2\\theta}$, находим\n\n$$    \\mathbb E X_{(m+1)} = 2\\theta\\frac{(2m)!}{m!(m-1)!}\\int\\limits_0^1 x^{m+1} (1-x)^m\\,dx =\n$$\n\n$$    = 2\\theta\\frac{(2m+1)!}{m!(m+1)!} B(m+2, m+1)\n    =2\\theta\\frac{(2m+1)!}{m! m!} \\frac{(m+1)!m!}{(2m+2)!} = \\theta. \n$$\n\nЕсли же $n = 2m$, то нам потребуется найти $\\mathbb E \\big(\\frac 12(X_{(m)} + X_{(m+1)})\\big)$. Используя ту же самую замену $x= \\frac t{2\\theta}$, получаем\n\n$$    \\mathbb E X_{(m)} = 2\\theta\\frac{(2m)!}{m!(m-1)!}\\int\\limits_0^1 x^{m} (1-x)^m\\,dx =\n$$\n\n$$    =2\\theta\\frac{(2m)!}{m!(m-1)!} B(m+1, m+1) \n    =2\\theta\\frac{(2m)!}{m!(m-1)!}\\frac{m!m!}{(2m+1)!} = \\frac {2\\theta m}{2m+1};\n$$\n\n$$    \\mathbb E X_{(m+1)} = 2\\theta\\frac{(2m)!}{m!(m-1)!}\\int\\limits_0^1 x^{m+1} (1-x)^{m-1}\\,dx =\n$$\n\n$$    =2\\theta\\frac{(2m)!}{m!(m-1)!} B(m+2, m) \n    =2\\theta\\frac{(2m)!}{m!(m-1)!}\\frac{(m+1)!(m-1)!}{(2m+1)!} = \\frac {2\\theta(m+1)}{2m+1}.\n$$\n\nСледовательно,\n\n$$\\mathbb E \\Big(\\frac 12(X_{(m)} + X_{(m+1)})\\Big) = \\frac 12\\Big(\\mathbb E X_{(m)} + \\mathbb EX_{(m+1)}\\Big) = \\theta \\Big(\\frac m{2m+1} + \\frac {m+1}{2m+1}\\Big) = \\theta.\n$$\n\nИтак, выборочная медиана — несмещённая оценка как медианы, так и среднего распределения $U[0,2\\theta]$.\n\n{% endcut %}\n\nВ некоторых случаях оценка $\\widehat\\theta_n = \\widehat\\theta(X_1, \\dots, X_n)$ смещена, но с ростом $n$ это смещение нивелируется. Если $\\lim\\limits_{n\\to\\infty} \\mathbb E\\widehat\\theta_n = \\theta$, то оценка $\\widehat\\theta_n$ называется **асимптотически несмещённой**.\n\n**Упражнение.** Пусть $X_1, \\ldots, X_n \\sim U[0, \\theta]$ — i.i.d. выборка. Оценим параметр $\\theta$ как максимальное значение выборки:\n\n$$\\widehat \\theta_n = X_{(n)} = \\max\\{X_1, \\ldots, X_n\\}.\n$$\n\nЯвляется ли эта оценка несмещённой? Асимптотически несмещённой?\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nВ силу свойства i.i.d. для $0\\leqslant x \\leqslant \\theta$ имеем\n\n$$\\mathbb P(X_{(n)}\\leqslant x) = \\mathbb P(X_1 \\leqslant x, \\ldots, X_n \\leqslant x) = \n\\prod\\limits_{k=1}^n \\mathbb P(X_1 \\leqslant x) = \\Big(\\frac x\\theta\\Big)^n.\n$$\n\nСледовательно, плотность случайной величины $\\widehat \\theta_n = X_{(n)}$ равна $n\\frac {x^{n-1}}{\\theta^n}$, и поэтому\n\n$$    \\mathbb E \\widehat \\theta_n = \\frac n{\\theta^n} \\int\\limits_0^\\theta x^n\\,dx = \\frac {n\\theta}{n+1}.\n$$\n\nОтсюда видно, что оценка смещённая. Однако $\\lim\\limits_{n\\to\\infty} \\frac {n\\theta}{n+1} = \\theta$, так что оценка $\\widehat \\theta_n$ асимптотически несмещённая. Чтобы получить несмещённость в чистом виде, можно взять оценку $\\tilde \\theta_n = \\frac{n+1}n X_{(n)}$.\n\n{% endcut %}\n\n### Состоятельность\n\nОценка $\\widehat\\theta_n = \\widehat\\theta(X_1, \\dots, X_n)$ называется **состоятельной**, если она сходится по вероятности к $\\theta$, $\\widehat\\theta_n \\stackrel{P}{\\to} \\theta$, то есть\n\n$$  \\lim\\limits_{n \\to \\infty} \\mathbb{P}(|\\widehat\\theta_n - \\theta| > \\varepsilon) = 0 \\text{ для любого } \\varepsilon > 0.\n$$\n\nCостоятельность означает, что с ростом размера выборки всё менее вероятны хоть сколько нибудь значимые отклонения оценки от истинного значения параметра.\n\nЕсли i.i.d. выборка $X_1, \\ldots, X_n$ получена из распределения с конечным математическим ожиданием $\\theta$, то в силу закона больших чисел выборочное среднее $\\overline{X}_n$ является состоятельной оценкой для $\\theta$.\n\nСостоятельность оценки – независимое от несмещенности свойство: оценки могут быть состоятельными, но не несмещенными и наоборот. Например, оценка $\n\\widehat \\theta_n = X_{(n)}$ из предыдущего упражнения оказалась смещённой, однако, она состоятельна:\n\n$$    \\mathbb P(\\vert X_{(n)} - \\theta\\vert > \\varepsilon) = \\mathbb P(X_{(n)} < \\theta + \\varepsilon) = \n$$\n\n$$    = \\Big(\\frac{\\theta - \\varepsilon}{\\theta}\\Big)^n = \\Big(1 - \\frac \\varepsilon\\theta\\Big)^n \\to 0, n\\to\\infty.\n$$\n\n**Упражнение**. Приведите пример несмещённой оценки, не являющейся состоятельной.\n\nИмея i.i.d. выборку $X_1, \\ldots, X_n$ из невырожденного распределения с конечным средним $\\theta$, оценим это среднее как $\\widehat \\theta = X_1$. Эта оценка, очевидно, несмещённая: $\\mathbb E \\widehat \\theta = \\mathbb EX_1 = \\theta$. Состоятельной, однако, она не является, ведь выражение\n\n$$    \\mathbb P(\\vert \\widehat \\theta - \\theta\\vert > \\varepsilon) = \\mathbb P(\\vert X_1 - \\theta\\vert > \\varepsilon)\n$$\n\nникоим образом не зависит от $n$. Следовательно, состоятельность оценки $\\widehat \\theta$ означала бы, что $\\mathbb P(\\vert X_1 - \\theta\\vert > \\varepsilon)=0$ для любого $\\varepsilon >0$. Такое возможно только для вырожденного распределения, сосредоточенного в одной лишь точке $\\theta$: $\\mathbb P(X_1 = \\theta) = 1$.\n\n### Bias-variance decomposition\n\n**Смещение** (**bias**) оценки $\\widehat{\\theta}\\equiv\\widehat{\\theta}_n = \\widehat{\\theta}(X_1,\\ldots,X_n)$ определяется как\n\n$$\\mathrm{bias}(\\widehat{\\theta}) = \\mathbb{E}\\widehat{\\theta} - \\theta.\n$$\n\nСмещение показывает, насколько оценка в среднем отклоняется от истинного значения. Оценка $\\widehat{\\theta}_n$\n\n* несмещённая, если $\\mathrm{bias}(\\widehat{\\theta}_n) = 0$;\n* асимптотически несмещённая, если $\\lim\\limits_{n\\to\\infty}\\mathrm{bias}(\\widehat{\\theta}_n) = 0$.\n\n**Среднеквадратичной ошибкой** (**mean squared error**, **MSE**) оценки называется величина\n\n$$\\mathrm{MSE}(\\widehat{\\theta}) = \\mathbb{E}(\\widehat{\\theta} - \\theta)^2.\n$$\n\nСмещение, дисперсия и среднеквадратичная ошибка связаны между собой следующим соотношением (**bias-variance decomposition**):\n\n$$\\mathrm{MSE}(\\widehat{\\theta}) = \\text{bias}^2(\\widehat{\\theta}) + \\mathbb{V}(\\widehat{\\theta}).\n$$\n\n{% cut \"Доказательство\" %}\n\nИмеем\n\n$$\\mathrm{MSE}(\\widehat{\\theta}) = \\mathbb{E}(\\widehat{\\theta} - \\theta)^2 =\n\\mathbb{E}\\big(\\widehat{\\theta} - \\mathbb E\\widehat\\theta + \\mathbb E\\widehat\\theta  - \\theta\\big)^2=\n$$\n\n$$=\\mathbb{E}\\big(\\widehat{\\theta} - \\mathbb E\\widehat\\theta\\big)^2 + 2\\mathbb{E}(\\widehat{\\theta} - \\mathbb E\\widehat\\theta)(\\mathbb E\\widehat\\theta - \\theta) + \n\\mathbb{E}\\big(\\mathbb E\\widehat\\theta - \\theta\\big)^2 =\n$$\n\n$$  = \\mathbb{V}(\\widehat{\\theta})  + 2\\big(\\mathbb{E}\\widehat{\\theta} - \\mathbb E\\widehat\\theta\\big)\\big(\\mathbb E\\widehat\\theta - \\theta\\big) + \\mathrm{bias}^2(\\widehat{\\theta}).\n$$\n\nСреднее слагаемое здесь равно нулю, откуда и вытекает доказываемое равенство.\n\n{% endcut %}\n\n**Упражнение**. Докажите, что оценка $\\widehat{\\theta}_n$ состоятельная, если она асимптотически несмещённая и $\\lim\\limits_{n\\to\\infty}\\mathbb{V}(\\widehat{\\theta}_n) = 0$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nС помощью неравенства Маркова получаем, что\n\n$$\\mathbb{P}\\big(\\vert\\widehat{\\theta}_n - \\theta\\vert > \\varepsilon\\big)\\leqslant  \\mathbb{P}\\big((\\widehat{\\theta}_n - \\theta)^2 \\geqslant \\varepsilon^2\\big)\\leqslant \\frac{\\mathbb{E}(\\widehat{\\theta}_n - \\theta)^2}{\\varepsilon^2} = \\frac{\\mathrm{MSE}(\\widehat\\theta_n)}{\\varepsilon^2}.\n$$\n\nПо условию оба слагаемых в формуле bias-variance decomposition стремятся к нулю,\n\n$$\\mathrm{MSE}(\\widehat\\theta_n) = \\mathrm{bias}^2(\\widehat{\\theta}_n) + \\mathbb{V}(\\widehat{\\theta}_n) \\to 0, \\quad n\\to \\infty,\n$$\n\nи поэтому $\\lim\\limits_{n\\to\\infty}\\mathbb{P}\\big(\\vert\\widehat{\\theta}_n - \\theta\\vert > \\varepsilon\\big) = 0$ при любом фиксированном $\\varepsilon > 0$.\n\n{% endcut %}\n\nТаким образом, если $\\lim\\limits_{n\\to\\infty}\\mathrm{MSE}(\\widehat{\\theta}_n) = 0$, то оценка $\\widehat{\\theta}_n$ параметра $\\theta$ асимптотически несмещённая и состоятельная.\n\n### Асимптотическая нормальность\n\n**Стандартным отклонением** оценки $\\widehat{\\theta}_n$ параметра $\\theta$ называется корень из дисперсии:\n\n$$    \\mathrm{se}(\\widehat{\\theta}_n) = \\sqrt{\\mathbb V \\widehat{\\theta}_n}.\n$$\n\nОценка $\\widehat{\\theta}_n$ **асимптотически нормальна**, если $\\frac{\\widehat{\\theta}_n - \\theta}{\\mathrm{se}(\\widehat{\\theta}_n)} \\stackrel{D}{\\to} \\mathcal N(0,1)$, т.е.\n\n$$    \\lim\\limits_{n\\to\\infty}\\mathbb P\\Big(\\frac{\\widehat{\\theta}_n - \\theta}{\\mathrm{se}(\\widehat{\\theta}_n)} \\leqslant z\\Big) = \\mathbb \\Phi(z).\n$$\n\nСогласно центральной предельной теореме выборочное среднее i.i.d. выборки из распределения с конечными средним $\\mu$ и дисперсией $\\sigma^2$ является асимптотически нормальной оценкой параметра $\\mu$.\n\n### Эффективность\n\nПусть $\\widehat{\\theta}$ и $\\tilde{\\theta}$ — несмещённые оценки параметра $\\theta$. Оценка $\\widehat{\\theta}$ **эффективнее** оценки $\\tilde{\\theta}$, если $\\mathbb V\\widehat{\\theta} < \\mathbb V\\tilde{\\theta}$. Такое определение эффективности вполне логично, ведь чем меньше дисперсия несмещённой оценки, тем меньше у неё шансов удалиться куда-то далеко от истинного значения параметра.\n\n**Пример**. Пусть $X_1, \\ldots, X_n$ — i.i.d. выборка из распределения $U[0, 2\\theta]$. Какая оценка параметра $\\theta$ эффективнее: выборочное среднее или медиана?\n\nНесмещённость оценок $\\widehat{\\theta} = \\overline X _n$ и $\\tilde{\\theta} = \\mathrm{med}(X_1, \\ldots, X_n)$ уже была показана выше.\n\nНайдём дисперсию наших оценок. Диспресия случайной величины $\\xi \\sim U[0, 2\\theta]$ равна $\\mathbb V \\xi = \\frac{\\theta^2}{3}$, следовательно, $\\mathbb V \\widehat \\theta = \\frac{\\theta^2}{3n}$.\n\nНайти дисперсию медианы несколько сложнее. Ограничимся случаем $n = 2m+1$. Тогда $\\tilde{\\theta} = X_{(m+1)}$, и\n\n$$    \\mathbb E\\tilde{\\theta}^2 =  \\mathbb E X_{(m+1)} = \\frac 1{2\\theta}\\frac{(2m+1)!}{(m!)^2} \\int\\limits_0^{2\\theta} x^2 \\Big(\\frac x{2\\theta}\\Big)^{m}\\Big(1-\\frac x{2\\theta}\\Big)^{m}\\,dx.\n$$\n\nС помощью замены $t = \\frac x{2\\theta}$ отсюда находим, что\n\n$$\\mathbb E\\tilde{\\theta}^2 = \\frac{(2m+1)!}{(m!)^2}\\int\\limits_0^1 4\\theta^2t^{m+2}(1-t)^m\\,\n$$\n\n$$dt =4\\theta^2 \\frac{(2m+1)!}{(m!)^2} B(m+3, m+1) =\n$$\n\n$$=4\\theta^2 \\frac{(2m+1)!}{(m!)^2} \\frac{(m+2)!m!}{(2m+3)!} = 2\\theta^2 \\frac{m+2}{2m+3} = \\theta^2 + \\frac{\\theta^2}{n+3}.\n$$\n\nСледовательно, $\\mathbb V\\tilde{\\theta} = \\frac{\\theta^2}{n+3}$, что при $n>1$ больше, чем\n$\\mathbb V \\widehat \\theta = \\frac{\\theta^2}{3n}$, так что выборочное среднее эффективнее\nмедианы (примерно в $\\sqrt 3$ раз при больших $n$, если считать по отношению стандартных отклонений).\n\nНесмотря на то что в плане эффективности среднее оказалось предпочтительнее в этом примере,\nв статистике медиану любят за бОльшую устойчивость к выбросам.\n\nНиже приведён scatter-plot, по которому можно наглядно оценить меру разброса среднего и медианы выборки из равномерного распределения на отрезке $[0, 2\\theta]$ для $\\theta = 5$. Для построения этого графика были взяты $200$ i.i.d. выборок из $U[0, 10]$ размера $n=10, 100, 1000, 10000$, и для каждого $n$ посчитаны выборочное среднее и медиана. Эти статистики и задают координаты точки на графике. Разумеется, чем больше значение $n$, тем кучнее локализованы точки вокруг среднего значения $\\theta = 5$, совпадающего в данном случае с медианой. Как видно, облако точек сосредоточено вдоль прямой $y = \\theta + \\sqrt 3(x - \\theta)$.\n\n<iframe src=\"https://yastatic.net/s3/ml-handbook/admin/uniform_stats_cf66cbd1c0.html\" width=100% height=500 frameborder=0></iframe>\n\n### Выборочная дисперсия\n\nКак мы уже убедились, выборочное среднее $\\overline{X}_n = \\frac{1}{n}\\sum\\limits_{k = 1}^n X_k$ представляет собой несмещённую и состоятельную оценку для математического ожидания. Можно ли то же самое сказать про **выборочную дисперсию**\n\n$$    \\overline S_n = \\frac{1}{n} \\sum\\limits_{k = 1}^n (X_k - \\overline{X}_n)^2\n$$\n\nв предположении, что i.i.d. выборка $X_1, \\ldots, X_n$ состоит из реализаций случайной величины $\\xi$ с конечными моментами $\\mathbb E\\xi = \\theta_1$ и $\\mathbb E\\xi^2 = \\theta_2$?\n\nПрежде всего раскроем скобки и перепишем $\\overline S_n$ в виде\n\n$$    \\overline S_n  = \\frac{1}{n} \\sum\\limits_{k = 1}^n \\big(X_k^2 - 2X_k \\overline{X}_n + (\\overline{X}_n)^2\\big) = \n$$\n\n$$    = \\frac{1}{n} \\sum\\limits_{k = 1}^n X_k^2 - 2 (\\overline{X}_n)^2 + (\\overline{X}_n)^2 = \n    \\overline{X^2}_n - (\\overline{X}_n)^2,\n$$\n\nгде $\\overline{X^2}_n  = \\frac 1n\\sum\\limits_{k = 1}^n X_k^2$ — выборочное среднее, построенное по выборке $X_1^2, \\ldots, X_n^2$. Оно несмещённое, поэтому $\\mathbb E \\overline{X^2}_n  = \\theta_2$. Заметим также, что\n\n$$    (\\overline{X}_n)^2 = \\frac 1{n^2} \\Big(\\sum\\limits_{k=1}^n X_k\\Big)^2 =\n    \\frac 1{n^2} \\sum\\limits_{k=1}^n X_k^2 + \\frac 2{n^2} \\sum\\limits_{1\\leqslant i < j\\leqslant n} X_iX_j,\n$$\n\nоткуда в силу независимости $X_i$ и $X_j$ при $i\\ne j$ получаем\n\n$$    \\mathbb E(\\overline{X}_n)^2 = \\frac 1n \\mathbb E\\overline{X^2}_n + \\frac 2{n^2} \\sum\\limits_{1\\leqslant i < j\\leqslant n} \\mathbb E X_i \\mathbb E X_j=\n    \\frac{\\theta_2}n + \\frac{n-1}n\\theta_1^2.\n$$\n\nИтак,\n\n$$    \\mathbb E\\overline S_n = \\theta_2- \\frac {\\theta_2}n - \\frac{n-1}n\\theta_1^2 = \\frac{n-1}n \\mathbb V\\xi.\n$$\n\nТаким образом, оценка дисперсии $\\overline S_n$ смещённая (хотя и асимптотически несмещённая). По этой причине для оценки дисперсии часто используют аналогичную несмещённую оценку\n\n$$    \\overline \\sigma_n = \\frac n{n-1}\\overline S_n = \\frac{1}{n-1} \\sum\\limits_{k = 1}^n (X_k - \\overline{X}_n)^2,\n$$\n\nкоторую также называют выборочной дисперсией.\n\nОбоснуем теперь состоятельность оценки $\\overline S_n = \\overline{X^2}_n - (\\overline{X}_n)^2$. Согласно закону больших чисел $\\overline{X^2}_n \\stackrel{P}{\\to} \\theta_2$,\n$\\overline{X}_n \\stackrel{P}{\\to} \\theta_1$. Здесь нам потребуется пара свойств сходимости по вероятности.\n\n**Упражнение**. Пусть $\\xi_n \\stackrel{P}{\\to} \\xi$, $\\eta_n \\stackrel{P}{\\to} \\eta$. Докажите, что $\\xi_n + \\eta_n\\stackrel{P}{\\to} \\xi + \\eta$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nЗафиксируем некоторое $\\varepsilon > 0$. Поскольку $\\vert \\xi_n - \\xi\\vert + \\vert \\eta_n - \\eta\\vert \\geqslant \\vert \\xi_n + \\eta_n - \\xi - \\eta\\vert$, то\n\n$$    \\mathbb P\\big(\\vert \\xi_n + \\eta_n - \\xi - \\eta\\vert > \\varepsilon\\big) \\leqslant\n    \\mathbb P\\big(\\vert \\xi_n - \\xi\\vert  + \\vert \\eta_n - \\eta\\vert  > \\varepsilon\\big).\n$$\n\nДалее, если $\\vert \\xi_n - \\xi\\vert + \\vert \\eta_n - \\eta\\vert  > \\varepsilon$, то выполняется хотя бы одно из неравенств $\\vert \\xi_n - \\xi\\vert >\\frac \\varepsilon 2$ и $\\vert \\eta_n - \\eta\\vert >\\frac \\varepsilon 2$. Следовательно,\n\n$$    \\mathbb P\\big(\\vert \\xi_n + \\eta_n - \\xi - \\eta\\vert > \\varepsilon\\big) \\leqslant \\mathbb P\\Big(\\vert \\xi_n - \\xi\\vert >\\frac \\varepsilon 2\\Big) + \\mathbb P\\Big(\\vert \\eta_n - \\eta\\vert >\\frac \\varepsilon 2\\Big).\n$$\n\nНо последние две вероятности стремятся к нулю, так как $\\xi_n \\stackrel{P}{\\to} \\xi$ и $\\eta_n \\stackrel{P}{\\to} \\eta$. Следовательно, последовательность случайных величин $\\xi_n + \\eta_n$ сходится по вероятности к $\\xi + \\eta$.\n\n{% endcut %}\n\n**Упражнение**. Пусть $\\xi_n \\stackrel{P}{\\to} \\xi$. Докажите, что $\\xi_n^2 \\stackrel{P}{\\to} \\xi^2$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nПусть $0 < \\varepsilon < 1$ и $\\delta > 0$. Выберем число $M>1$ так, что $\\mathbb P(\\vert\\xi\\vert > M) < \\delta$. Если $\\vert \\xi_n - \\xi\\vert \\leqslant \\frac\\varepsilon M$ и $\\vert \\xi \\vert \\leqslant M$, то\n\n$$    \\vert \\xi_n^2 - \\xi^2\\vert = \\vert \\xi_n - \\xi\\vert \\cdot\\vert \\xi_n + \\xi\\vert = \\vert \\xi_n - \\xi\\vert \\cdot\\vert \\xi_n - \\xi + 2\\xi\\vert  \\leqslant\n$$\n\n$$    \\leqslant\\frac\\varepsilon M(\\vert \\xi_n - \\xi\\vert + 2\\vert \\xi\\vert) \\leqslant \\frac\\varepsilon M(1+ 2M) < 3\\varepsilon.\n$$\n\nСледовательно,\n\n$$    \\mathbb P\\big(\\vert \\xi_n^2 - \\xi^2\\vert > 3\\varepsilon\\big) \\leqslant  \\mathbb P \\Big(\\vert \\xi_n - \\xi\\vert > \\frac \\varepsilon M\\Big) + \\mathbb P(\\vert \\xi\\vert > M) < 2\\delta.\n$$\n\nПоследнее неравенство выполняется для всех достаточно больших $n$, при которых первое слагаемое меньше $\\delta$; этого же всегда можно достичь за счёт увеличения $n$, поскольку по условию $\\xi_n \\stackrel{P}{\\to} \\xi$. В силу произвольности $\\delta$ отсюда заключаем, что\n\n$$\\lim\\limits_{n\\to\\infty} \\mathbb P\\big(\\vert \\xi_n^2 - \\xi^2\\vert > 3\\varepsilon\\big) = 0,\n$$\n\nто есть последовательность $\\xi_n^2$ сходится по вероятности к случайной величине $\\xi^2$.\n\n{% endcut %}\n\nПользуясь результатами этих упражнений, заключаем, что\n$\\big(\\overline{X}_n\\big)^2 \\stackrel{P}{\\to} \\theta_1^2$ и\n$\\overline{S}_n \\stackrel{P}{\\to} \\theta_2 - \\theta_1^2 = \\mathbb V\\xi$, и, стало быть, оценка $\\overline S_n$ состоятельна.\n\n## Методы оценки параметров\n\nДо этого мы обсуждали разные приятные свойства оценок, а теперь рассмотрим некоторые методы, позволяющие систематически получать по выборке оценки параметров с нужными свойствами.\n\n### Метод моментов\n\nПусть выборка $X_1, \\ldots, X_n$ получена сэмплированием из некоторого семейства распределений $F_{\\boldsymbol \\theta}(x)$ с параметрами $\\boldsymbol \\theta = (\\theta_1, \\ldots, \\theta_m)$. **Метод моментов** для оценки этих параметров заключается в приравнивании выборочных моментов\n\n$$    \\overline{X^k}_n = \\frac 1n\\sum\\limits_{j=1}^n X_j^k\n$$\n\nк теоретическим\n\n$$ \\alpha_k(\\boldsymbol \\theta) = \\int\\limits_{-\\infty}^{+\\infty} x^k dF_{\\boldsymbol \\theta}(x).\n$$\n\nРешая полученную систему уравнений $\\alpha_k(\\boldsymbol \\theta) = \\overline{X^k}_n$, $1\\leqslant k \\leqslant m$, находим оценки параметров $\\widehat \\theta_k$.\n\n**Пример**. Оценим параметры нормального распределения $\\mathcal{N}(\\mu, \\sigma^2)$ с помощью метода моментов.\n\n{% cut \"Попробуйте сделать сами, прежде чем смотреть решение.\" %}\n\nТеоретические моменты равны\n\n$$\\alpha_1 = \\mu,\\quad\\alpha_2 = \\sigma^2 + \\mu^2.\n$$\n\nЗапишем систему:\n\n$$\\mu = \\overline X_n,\n$$\n\n$$\\sigma^2 + \\mu^2 = \\overline {X^2}_n.\n$$\n\nИз неё очевидным образом находим $\\widehat \\mu =  \\overline X_n$,\n\n$$\\widehat{\\sigma^2} =  \\overline {X^2}_n - \\big( \\overline X_n\\big)^2=\n\\frac1n \\sum\\limits_{k=1}^n\\big(X_k -  \\overline X_n \\big)^2.\n$$\n\nКак видно, оценки по методу моментов в данном случае совпадают с выборочными средним и дисперсией.\n\n{% endcut %}\n\n**Упражнение**. Оцените по методу моментов параметры $a$ и $b$ для выборки $X_1, \\ldots, X_n$ из $U[a, b]$.\n\n{% cut \"Ответ\" %}\n\nРешая систему уравнений $\\alpha_1 = \\frac{a+b}2 = \\overline X_n$, $\\alpha_2 = \\frac{a^2+ab + b^2}3 = \\overline{X^2}_n$, находим\n\n$$    \\widehat a =  \\overline X_n - \\sqrt{3 (\\overline {X^2}_n -  \\overline X_n^2)}, \\quad\n    \\widehat b =  \\overline X_n + \\sqrt{3 (\\overline {X^2}_n -  \\overline X_n^2)}\n$$\n\nТаким образом, согласно методу моментов оценки для границ отрезка отстоят от выборочного среднего на выборочное стандартное отклонение, помноженное на $\\sqrt 3$.\n\n{% endcut %}\n\nПри некоторых условиях на регулярность семейства распределений $F_{\\boldsymbol \\theta}(x)$ оценка по методу моментов получается состоятельной и асимптотически нормальной.\n\n### Метод максимального правдоподбия\n\nПусть, как обычно, выборка $X_1, \\ldots, X_n \\sim F_\\theta(x)$.\n**Правдоподобие** (**функция правдоподобия**, **likelihood**) выборки $X_1,\\ldots, \\ldots X_n$ — это просто её совместная pmf или pdf. Вне зависимости от типа распределения будем обозначать правдоподобие как\n\n$$\\mathcal L(\\theta) \\equiv L(X_1, \\ldots, X_n \\vert \\theta) = p(X_1, \\ldots, X_n \\vert \\theta).\n$$\n\nЕсли выборка i.i.d., то функция правдоподобия распадается в произведение одномерных функций:\n\n$$L(X_1, \\ldots, X_n \\vert \\theta) = \\prod\\limits_{k=1}^n  p(X_k\\vert \\theta). \n$$\n\n**Оценка максимального правдоподобия** (**maximum likelihood estimation**, **MLE**) максимизирует правдоподобие:\n\n$$    \\widehat \\theta_{\\mathrm{ML}} =  \\arg \\max\\limits_{\\theta} \\mathcal L(\\theta)\n$$\n\nПоскольку максимизировать сумму проще, чем произведение, обычно переходят к логарифму правдоподобия (**log-likelihood**). Это особенно удобно в случае i.i.d. выборки, тогда\n\n$$    \\widehat \\theta_{\\mathrm{ML}} =  \\arg \\max\\limits_{\\theta} \\log \\mathcal L(\\theta) =\n    \\arg \\max\\limits_{\\theta} \\sum\\limits_{k=1}^n \\log p(X_k\\vert \\theta).\n$$\n\n**Пример**. В результате $n$ подбрасываний монеты выпало $k$ «орлов» и $n-k$ «решек».\nОценим вероятность выпадения «орла» методом максимального правдоподобия.\n\nПусть $p$ — вероятность выпадения «орла», тогда правдоподобие равно\n\n$$\\mathcal L(p)=p^k (1-p)^{n-k}.\n$$\n\nДифференцируя логарифм правдоподобия\n\n$$\\log \\mathcal L(p) = k\\log p + (n-k)\\log(1-p)\n$$\n\nи приравнивая к нулю производную, находим\n\n$$    \\frac kp = \\frac{n-k}{1-p} \\iff k(1-p) = (n-k)p \\iff p = \\frac kn.\n$$\n\nНетрудно убедиться, что это точка максимума. Итак, оценка максимального правдоподобия $\\widehat p_{\\mathrm{ML}} = \\frac kn$ вероятности «успеха» в схеме Бернулли вполне ожидаемо оказалась равна доле «успехов» в серии из $n$ испытаний.\n\n**Упражнение**. Пусть i.i.d. выборка $X_1, \\ldots, X_n$ взята из пуассоновского распределения с параметром $\\lambda$. Найдите его оценку максимального правдоподобия.\n\n{% cut \"Ответ\" %}\n\n$$\\widehat \\lambda_{ML} = \\overline X_n = \\frac 1n \\sum\\limits_{k=1}^n X_k.\n$$\n\n{% endcut %}\n\nМетодом максимального правдоподобия можно оценить сразу несколько параметров.\n\n**Пример**. Найдём MLE-оценки параметров распределения $\\mathcal N(\\mu, \\tau)$ по i.i.d. выборке $X_1, \\ldots, X_n$.\n\nЗапишем правдоподобие:\n\n$$  \\mathcal L(\\mu, \\tau) = \\prod\\limits_{k = 1}^n \\frac{1}{\\sqrt{2\\pi\\tau}} \\exp{\\frac{-(X_k - \\mu)^2}{2\\tau}}.\n$$\n\nПерейдём к log-likelihood:\n\n$$  \\log \\mathcal L(\\mu, \\tau) = -\\frac{n}{2}(\\log{\\tau} + \\ln{2\\pi}) - \\frac{1}{2\\tau} \\sum\\limits_{k = 1}^n (X_k - \\mu)^2.\n$$\n\nПриравняем частные производные по $\\mu$ и $\\tau$ к нулю:\n\n$$  \\frac{\\partial \\log \\mathcal L}{\\partial \\mu} = \\frac{1}{\\tau}\\sum\\limits_{k = 1}^N (X_k - \\mu) = 0,\n$$\n\n$$  \\frac{\\partial \\log \\mathcal L}{\\partial \\tau} = -\\frac{n}{\\tau} + \\frac{1}{\\tau^2}\\sum\\limits_{k = 1}^n (X_k - \\mu)^2 = 0,\n$$\n\nоткуда $\\widehat\\mu_{\\mathrm{ML}} = \\overline{X}_n$ – выборочное среднее, $\\widehat\\tau_{\\mathrm{ML}} = \\frac{1}{n} \\sum\\limits_{k = 1}^n X_k^2 - (\\overline{X}_n)^2$ – выборочная дисперсия.\n\n**Упражнение**. Пусть i.i.d. выборка $X_1, \\ldots, X_n \\sim U[a, b]$. Найдите оценки максимального правдоподобия для параметров $a$ и $b$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nОказывается, при поиске MLE не всегда надо дифференцировать. Правдоподобие здесь имеет вид\n\n$$    L(X_1, \\ldots, X_n\\vert a, b) = \\frac 1{(b-a)^n}\\prod\\limits_{k=1}^n \\mathbb I(X_k \\in [a, b]).\n$$\n\nПри фиксированных иксах и $b$ это выражение максимально при $a = X_{(1)}$: ведь если взять чуть больше, то произведение индикаторов обнулится, если меньше — то правдоподобие уменьшится за счёт увеличения $(b-a)^n$. По аналогичным соображениям $\\widehat b_{\\mathrm{ML}} = X_{(n)}$.\n\n{% endcut %}\n\n**Свойства оценки максимального правдоподобия**\n\n* состоятельность: $\\widehat \\theta_{\\mathrm{ML}} \\stackrel{P}{\\to} \\theta$;\n* инвариантность относительно параметризации: если $\\widehat \\theta_{\\mathrm{ML}}$ — MLE-оценка для $\\theta$, то $\\varphi\\left( \\hat{\\theta}_{ML} \\right)$ — MLE-оценка для $\\varphi(\\theta)$;\n* асимптотическая нормальность: $\\frac{\\widehat \\theta_{\\mathrm{ML}} - \\theta}{\\widehat{\\mathrm{se}}} \\stackrel{D}{\\to} \\mathcal N(0,1)$;\n* асимптотическая оптимальность: при достаточно больших $n$ оценка\n  $\\widehat \\theta_{\\mathrm{ML}}$ имеет минимальную дисперсию.",
        "handbook": "Учебник по машинному обучению",
        "title": "Параметрические оценки",
        "description": null
    },
    {
        "path": "/handbook/ml/article/entropiya-i-semejstvo-eksponencialnyh-raspredelenij",
        "content": "## Энтропия\n\n### Информативность наблюдений\n\nПредставим, что вы пронаблюдали значение $x$ некоторой случайной величины $\\xi$. Как измерить количество информации $h(x)$, которое вы при этом получили? Следующие соображения кажутся в этом плане вполне естественными:\n\n* чем выше вероятность $\\mathbb P(\\xi = x)$, тем более ожидаемо появление значения $x$ и, соответственно, менее информативно;\n* и наоборот, наблюдение маловероятного значения $x$ обычно даёт обильную пищу для размышлений и повышает $h(x)$;\n* при наблюдении двух независимых реализаций $x$ и $y$ случайной величины $\\xi$ логично складывать полученную информацию: $h((x, y)) = h(x) + h(y)$.\n\nУказанные соображения наводят на мысль, что информацию следует считать убывающей функцией от вероятности: $h(x) = g\\big(\\mathbb P(\\xi = x)\\big)$. Кроме того, функция $g$ должна превращать произведение в сумму, поскольку для независимых случайных величин $\\xi$ и $\\eta$\nравенство $h((x, y)) = h(x) + h(y)$ влечёт\n\n$$   g\\big(\\mathbb P(\\xi = x, \\eta=y)\\big) = g\\big(\\mathbb P(\\xi = x) \\mathbb P(\\eta = y)\\big) = g\\big(\\mathbb P(\\xi = x)\\big) + g\\big(\\mathbb P(\\eta = y)\\big).\n$$\n\nНа самом деле выбор тут небогат. Единственная непрерывная функция, обладающая такими свойствами, — это логарифм: $g(p) = -\\log p$. Основание логарифма может быть любым числом больше единицы. Поскольку информацию измеряют в битах и байтах, в теории информации обычно предпочитают двоичные логарифмы. Однако для вычислений удобнее использовать натуральный логарифм, и по умолчанию мы будем подразумевать именно его (кстати, соответствующую единицу информации называют «нат»).\n\n### Энтропия Шеннона\n\nСреднее количество информации, которое несёт в себе значение дискретной случайной $\\xi$ с распределением вероятностей $p_k= \\mathbb P(\\xi = k)$, вычисляется по формуле\n\n$$    \\mathbb H\\xi = \\mathbb E \\big(g(p(\\xi))\\big) =  -\\mathbb E \\big(\\log p(\\xi)\\big)=-\\sum\\limits_k p_k \\log p_k.\n$$\n\nЭто так называемая **энтропия** (**Шэннона**).\n\n{% cut \"Небольшое математическое замечание\" %}\n\nПри вычислении энтропии регулярно можно встретить выражение $0\\cdot \\log 0$ с не вполне очевидным значением. Поскольку $\\lim \\limits_{t\\to 0+} t\\log t = 0$, по определению полагаем $0\\cdot \\log 0 = 0.$\n\n{% endcut %}\n\n**Пример**. Рассмотрим схему Бернулли с вероятностью «успеха» $p$. Энтропия её результата равна\n\n$$\\mathbb H\\xi = -(1 - p)\\log(1 - p) - p\\log p, \\quad \\xi \\sim \\mathrm{Bern}(p).\n$$\n\nДавайте посмотрим на график этой функции:\n\n![entropy](https://yastatic.net/s3/education-portal/media/entropy_bern_b21f03cc0e_d706952391.svg)\n\nМинимальное значение (нулевое) энтропия принимает при $p = 0$ или $p=1$. Исход такого вырожденного эксперимента заранее известен, и чтобы сообщить кому-то о его результате,  достаточно $0$ бит информации. Иначе говоря, можно вообще ничего не передавать, и так всё предельно ясно.\n\nМаксимальное значение энтропии достигается в точке $\\frac12$, что вполне соответствует тому, что при $p=\\frac12$ предсказать исход эксперимента сложнее всего.\n\n**Упражнение**. Найдите энтропию геометрического распределения с вероятностью «успеха» $p$: $\\xi \\sim \\mathrm{Geom}(p)$,\n\n$$\\mathbb P(\\xi = k) = p(1-p)^{k-1}, \\quad k \\in \\mathbb N, \\quad 0 < p \\leqslant 1.\n$$\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nПо определению энтропии имеем\n\n$$\\mathbb H\\xi = -\\sum\\limits_{k=1}^\\infty p(1-p)^{k-1} (\\log p + (k-1)\\log(1-p)) =\n$$\n\n$$= -\\log p -p\\log(1-p)\\sum\\limits_{k=1}^\\infty k(1-p)^k.\n$$\n\nДифференцированием геометрической прогрессии находим\n\n$$\\sum\\limits_{k=1}^\\infty kx^{k-1} = \\sum\\limits_{k=1}^\\infty (x^k)' = \\frac d{dx}\\sum\\limits_{k=0}^\\infty x^k = \\Big(\\frac 1{1-x}\\Big)' = \\frac 1{(1-x)^2};\n$$\n\nподставляя сюда $x = 1-p$, окончательно получаем, что\n\n$$    \\mathbb H\\xi = -\\log p -p(1-p)\\log(1-p)\\cdot \\frac 1{p^2} = -\\log p - \\frac{(1-p)\\log(1-p)}p.\n$$\n\nВспомним, что случайная величина $\\xi\\sim\\mathrm{Geom}(p)$ равна количеству независимых испытаний с вероятностью «успеха» $p$ до появления первого «успеха». При $p=1$ энтропия $\\mathbb H\\xi$ минимальна и равна нулю, ведь в этом случае геометрическое распределение становится вырожденным: «успех» наступает сразу же с вероятностью $1$. А вот при $p\\to 0+$ серия неудачных испытаний может быть сколь угодно длинной; распределение становится всё более неопределённым и «размазанным» по своему носителю, и его энтропия <br>стремится к $+\\infty$. График энтропии как функции от $p$ выглядит так:\n\n![entropy](https://yastatic.net/s3/education-portal/media/entropy_geom_2404990d13_1eb404572b.svg)\n\n{% endcut %}\n\nСледующие свойства энтропии дискретной случайной величины $\\xi$ вытекают прямо из определения:\n\n* неотрицательность: $\\mathbb H\\xi \\geqslant 0$;\n* $\\mathbb H\\xi = 0 \\iff \\mathbb P(\\xi = a) = 1$ при некотором $a\\in\\mathbb R$ (нулевую энтропию имеют вырожденные распределения и только они);\n* $\\mathbb H\\xi \\leqslant \\log n$, если случайная величина имеет конечный носитель мощности $n$.\n\nПоследнее свойство выводится из [неравенства Йенсена](https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D1%80%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%99%D0%B5%D0%BD%D1%81%D0%B5%D0%BD%D0%B0). Применяя его к выпуклой вверх логарифмической функции, с учётом нормировки условия $\\sum\\limits_{k=1}^n p_k = 1$ получаем\n\n$$    -\\sum\\limits_{k=1}^n p_k\\log p_k = \\sum\\limits_{k=1}^n p_k\\log \\frac 1p_k \\leqslant\n    \\log\\bigg(\\sum\\limits_{k=1}^n p_k\\cdot \\frac 1{p_k}\\bigg) = \\log n.\n$$\n\n**Вопрос на подумать**. Итак, всякое распределение с носителем $\\{1, 2, \\ldots, n\\}$ имеет энтропию не больше $\\log n$. А у какого распределения она в точности равна $\\log n$?\n\n{% cut \"Ответ (не открывайте сразу, сначала подумайте самостоятельно)\" %}\n\nТакое произойдёт, если все вероятности $p_k = \\frac 1n$, $1\\leqslant k \\leqslant n$, т.е. распределение равномерное.\n\n{% endcut %}\n\n### Дифференциальная энтропия\n\nЧтобы вычислить энтропию непрерывной случайной величины $\\xi$, надо, как водится, сумму заменить на интеграл, и получится формула **дифференциальной энтропии**:\n\n$$    \\mathbb H\\xi = -\\int p_{\\xi}(x) \\log p_{\\xi}(x)\\, dx.\n$$\n\n**Замечание.** В дальнейшем мы будем использовать одинаковый термин **энтропия** как для дискретных, так и для непрерывных случайных величин, для краткости опуская слово **дифференциальная** в последнем случае. Кроме того, энтропию распределения $p$, заданного через pmf или pdf, будем обозначать $\\mathbb H[p]$. Такое обозначение позволяет избежать привязки к случайной величине там, где это излишне. Если $\\xi \\sim p(x)$, то обозначения $\\mathbb H\\xi$ и $\\mathbb H[p]$ эквивалентны. Также отметим, что энтропию можно записать в виде математического ожидания:\n\n$$  \\mathbb H[p] = \\mathbb E_{\\xi \\sim p(x)} \\log\\frac 1{p(\\xi)}.\n$$\n\n**Пример**. Найдём энтропию нормального распределения $\\mathcal N(\\mu, \\sigma^2)$. Его плотность равна $p(x) = \\frac 1{\\sqrt{2\\pi} \\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$, следовательно,\n\n$$\\mathbb H[p] = \\int\\limits_{-\\infty}^{+\\infty}p(x)\\Big(\\frac 12\\ln\\big(2\\pi\\sigma^2\\big) + \\frac{(x-\\mu)^2}{2\\sigma^2}\\Big)dx =\n$$\n\n$$= \\frac 12\\ln\\big(2\\pi\\sigma^2\\big)  + \\frac 1{\\sqrt{2\\pi} \\sigma}\\int\\limits_{-\\infty}^{+\\infty}\\frac{(x-\\mu)^2}{2\\sigma^2}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\,dx.\n$$\n\nДелая в последнем интеграле замену $t = -\\frac{(x-\\mu)^2}{2\\sigma^2}$, получаем, что\n\n$$\\mathbb H[p] = \\frac 12\\ln\\big(2\\pi\\sigma^2\\big) + \\frac 1{\\sqrt{2\\pi}}\\int\\limits_{0}^{+\\infty}\\sqrt{2t}e^{-t}\\,dt =\\frac 12\\ln\\big(2\\pi\\sigma^2\\big) + \\frac{\\Gamma\\big(\\frac 32\\big)}{\\sqrt \\pi}.\n$$\n\nПо свойству гамма-функции $\\Gamma\\big(\\frac 32\\big) = \\frac 12 \\Gamma\\big(\\frac 12\\big) = \\frac{\\sqrt \\pi}2$. Таким образом,\n\n$$    \\mathbb H[p] = \\frac 12\\ln\\big(2\\pi\\sigma^2\\big) + \\frac 12.\n$$\n\nКак видно, энтропия гауссовского распределения $\\mathcal N(\\mu, \\sigma^2)$ не ограничена ни сверху, ни снизу:\n\n$$    \\lim\\limits_{\\sigma\\to +\\infty} \\frac 12\\ln\\big(2\\pi\\sigma^2\\big) = +\\infty, \\quad\n    \\lim\\limits_{\\sigma\\to 0+} \\frac 12\\ln\\big(2\\pi\\sigma^2\\big) = -\\infty.\n$$\n\nИ да, в отличие от энтропии дискретного распределения дифференциальная энтропия может быть отрицательной. Это связано с тем, что плотность может принимать значения больше единицы, и поэтому математическое ожидание её логарифма с обратным знаком может оказаться меньше нуля. В частности, с нормальным распределением так происходит, если $\\sigma^2 < \\frac 1{2\\pi e}$.\n\n**Упражнение**. Найдите энтропию показательного распределения $\\mathrm{Exp}(\\lambda)$.\n\n{% cut \"Решение (не открывайте сразу, попробуйте сначала решить самостоятельно)\" %}\n\nПлотность случайной величины $\\xi \\sim \\mathrm{Exp}(\\lambda)$ равна $p_{\\xi}(x) = \\lambda e^{-\\lambda x}$, $x \\geqslant 0$. Таким образом,\n\n$$    \\mathbb H\\xi = \\mathbb H[p_\\xi] = \\int\\limits_{0}^{+\\infty} p_{\\xi}(x)(\\lambda x - \\log \\lambda)\\, dx =\n    \\int\\limits_{0}^{+\\infty} \\lambda^2 xe^{-\\lambda x}\\,dx - \\log\\lambda.\n$$\n\nС помощью замены $t = \\lambda x$ находим, что\n\n$$    \\mathbb H\\xi = \\int\\limits_{0}^{+\\infty} te^{-t}\\,dt - \\log\\lambda = \\Gamma(2) - \\log\\lambda = 1 - \\log\\lambda.\n$$\n\n{% endcut %}\n\n### KL-дивергенция\n\nВ задачах машинного обучения истинное распределение $p(x)$, из которого приходят наблюдения, обычно неизвестно, и его пытаются приблизить распределением $q(x)$ из некоторого класса модельных распределений. **Дивергенция Кульбака-Лейблера** (**KL-дивергенция**, **относительная энтропия**) позволяет оценить расстояние между распределениями $p$ и $q$:\n\n$$\\mathbb{KL}(p\\vert\\vert q) = \\sum\\limits_k p_k\\log\\frac{p_k}{q_k}\n$$\n\nв дискретном случае и\n\n$$\\mathbb{KL}(p\\vert\\vert q) = \\int p(x)\\log \\frac{p(x)}{q(x)}dx\n$$\n\nв непрерывном. KL-дивергенцию можно представить в виде разности:\n\n$$\\mathbb{KL}(p\\vert\\vert q) = \\int p(x)\\log \\frac 1{q(x)}dx - \\int p(x)\\log\\frac 1{p(x)}dx =\n$$\n\n$$=\\underbrace{\\mathbb E_{\\xi \\sim p(x)} \\frac 1{\\log q(\\xi)}}_{\\text{кросс-энтропия}} - \\underbrace{\\mathbb E_{\\xi \\sim p(x)} \\frac1{\\log p(\\xi)}}_{\\text{энтропия}}.\n$$\n\nЗдесь вычитаемое – это уже знакомая нам энтропия распределения $p(x)$, которая показывает, сколько в среднем бит требуется, чтобы закодировать значение случайной величины $\\xi \\sim p(x)$. Уменьшаемое носит название **кросс-энтропии** распределений $p(x)$ и $q(x)$.\nКросс-энтропию можно интерпретировать как среднее число бит для кодирования значения случайной величины $\\xi \\sim p(x)$ алгоритмом, оптимизированным для кодирования случайной величины $\\eta \\sim q(x)$. Иными словами, дивергенция Кульбака-Лейблера говорит о том, насколько увеличится средняя длина кодов для значений $p$, если при настройке алгоритма кодирования вместо $p$ использовать $q$. Подробнее об этом вы можете почитать, например, в [данном посте](https://habr.com/ru/post/484756/).\n\nДивергенция Кульбака-Лейблера в некотором роде играет роль расстояния между распределениями. В частности, $\\mathbb{KL}(p\\vert\\vert q)\\geqslant 0$, причём дивергенция равна нулю, только если распределения совпадают почти всюду (для дискретных и непрерывных распределений это означает, что они просто тождественны). Но при этом она не является симметричной: вообще говоря, $\\mathbb{KL}(p\\vert\\vert q)\\ne \\mathbb{KL}(q\\vert\\vert p)$.\n\n**Упражнение**. Пользуясь неравенством $\\ln (1+t) \\leqslant t$, \\$ t \\> -1\\$, докажите неотрицательность KL-дивергенции.\n\n{% cut \"Попробуйте доказать самостоятельно, прежде чем смотреть решение\" %}\n\nУказанное неравенство можно переписать в виде $-\\ln t \\geqslant t - 1$, $t > 0$, поэтому\n\n$$  \\mathbb{KL}(p\\vert\\vert q) = -\\int p(x)\\ln{\\frac{q(x)}{p(x)}}dx \\geqslant \n$$\n\n$$  \\geqslant \\int p(x)\\Big(\\frac{q(x)}{p(x)} - 1\\Big)dx = \\int q(x)dx - \\int p(x)dx = 0.\n$$\n\n{% endcut %}\n\n**Пример.** С помощью KL-дивергенции измерим расстояние между двумя гауссианами $p(x) = \\mathcal N(x \\vert \\mu_1, \\sigma_1^2)$ и $q(x) = \\mathcal N(x \\vert \\mu_2, \\sigma_2^2)$.\n\nПодставляя явные выражения для плотностей\n\n$$p(x) = \\frac 1{\\sqrt{2\\pi}\\sigma_1} e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}}\\text{ и }\nq(x) = \\frac 1{\\sqrt{2\\pi}\\sigma_2} e^{-\\frac{(x-\\mu_2)^2}{2\\sigma_2^2}},\n$$\n\nнаходим\n\n$$\\ln \\frac{p(x)}{q(x)} = \\ln \\frac{\\sigma_2}{\\sigma_1} + \\frac{(x-\\mu_2)^2}{2\\sigma_2^2} -\\frac{(x-\\mu_1)^2}{2\\sigma_1^2} =\n$$\n\n$$=\\ln \\frac{\\sigma_2}{\\sigma_1} + \\Big(\\frac 1{2\\sigma_2^2} - \\frac 1{2\\sigma_1^2}\\Big)(x-\\mu_1)^2 + \\frac{\\mu_1 - \\mu_2}{\\sigma_2^2}(x-\\mu_1) + \\frac{(\\mu_1 - \\mu_2)^2}{2\\sigma_2^2}.\n$$\n\nИз свойств нормального распределения вытекает, что\n\n$$    \\int\\limits_{-\\infty}^{+\\infty}p(x) (x-\\mu_1)\\,dx = 0, \\quad\n    \\int\\limits_{-\\infty}^{+\\infty}p(x)  (x-\\mu_1)^2\\,dx = \\sigma_1^2.\n$$\n\nТаким образом,\n\n$$\\mathbb{KL}(p\\vert\\vert q) = \\mathbb E_{\\xi \\sim p(x)} \\ln \\frac{p(\\xi)}{q(\\xi)} = \\ln \\frac{\\sigma_2}{\\sigma_1} + \\frac{\\sigma_1^2 + (\\mu_1 - \\mu_2)^2}{2\\sigma_2^2} - \\frac 12.\n$$\n\nКак и должно быть, полученное выражение равно нулю, если гауссианы совпадают. При равных дисперсиях $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ получаем, что $\\mathbb{KL}(p\\vert\\vert q) = \\frac{(\\mu_1 - \\mu_2)^2}{2\\sigma^2}$. Это выражение остаётся прежним, если поменять местами $\\mu_1$ и $\\mu_2$, поэтому в этом случае $\\mathbb{KL}(p\\vert\\vert q) = \\mathbb{KL}(q\\vert\\vert p)$. Если же $\\sigma_1 \\ne \\sigma_2$, то выражение для $\\mathbb{KL}(q\\vert\\vert p)$ явно отличается от $\\mathbb{KL}(p\\vert\\vert q)$, что лишний раз показывает несимметричность KL-дивергенции.\n\n**Упражнение**. Найдите дивергенцию Кульбака-Лейблера двух показательных распределений $p(x) = \\mathrm{Exp}(x \\vert \\lambda)$ и $q(x) = \\mathrm{Exp}(x \\vert \\mu)$.\n\n{% cut \"Попробуйте решить самостоятельно, прежде чем смотреть решение\" %}\n\nИмеем $p(x) = \\lambda e^{-\\lambda x}$, $q(x) = \\mu e^{-\\mu x}$, $x\\geqslant 0$, откуда\n\n$$\\ln \\frac{p(x)}{q(x)} =  \\ln \\frac \\lambda\\mu + (\\mu-\\lambda)x.\n$$\n\nСледовательно,\n\n$$  \\mathbb{KL}(p\\vert\\vert q) = \\ln \\frac \\lambda\\mu + (\\mu-\\lambda)\\int\\limits_0^{+\\infty} \\lambda x e^{-\\lambda x}\\,dx =\n$$\n\n$$  =\\ln\\frac \\lambda\\mu + \\frac{\\mu-\\lambda}{\\lambda}\\int\\limits_0^{+\\infty} te^{-t}dt = \\ln \\frac \\lambda\\mu + \\frac \\mu \\lambda - 1.\n$$\n\nИ здесь KL-дивергенция равна нулю при $\\lambda = \\mu$.\n\n{% endcut %}\n\n### Кросс-энтропия\n\nПри определении KL-дивергенции мы уже встречались с **кросс-энтропией**\n\n$$    \\mathbb H[p, q] = -\\mathbb E_{\\xi \\sim p(x)} \\log q(\\xi)\n$$\n\nВ зависимости от типа распределений кросс-энтропия вычисляется по формуле\n\n$$    \\mathbb H[p, q] = -\\sum\\limits_k p_k \\log q_k \\text{ или  }\n    \\mathbb H[p, q] = -\\int\\limits_{-\\infty}^{+\\infty} p(x) \\log q(x)\\, dx.\n$$\n\nПоскольку\n\n$$    \\mathbb{KL}(p\\vert\\vert q) = \\mathbb H[p, q] - \\mathbb H[p],\n$$\n\nзадача минимизации KL-дивергенции между неизвестным распределением данных $p(x)$ и модельным распределением $q(x)$ эквивалентна задаче минимизации кросс-энтропии. Разница между ними равна энтропии распределения $p(x)$, которая, очевидно, не зависит от $q(x)$&nbsp.\n\nВ машинном обучении кросс-энтропию часто используют в качестве функции потерь в задаче классификации на $K>1$ классов. Истинное распределение на каждом обучающем объекте задаётся с помощью one hot encoding и является вырожденным:\n\n$$\\boldsymbol y = (y_1, \\ldots, y_K), \\quad y_k \\in \\{0,1\\}, \\quad \\sum\\limits_{k=1}^K y_k = 1.\n$$\n\nКлассификатор обычно выдаёт вероятности принадлежности каждому из классов,\n\n$$\\boldsymbol{\\widehat y} = (\\widehat y_1, \\ldots, \\widehat y_K), \\quad \\widehat y_k = \\mathbb P(\\text{класс }k).\n$$\n\nФункция потерь на одном объекте полагается равной кросс-энтропии между истинным и предсказанным распределениями:\n\n$$    \\mathcal L(\\boldsymbol y, \\boldsymbol {\\widehat y}) = -\\sum\\limits_{k=1}^K y_k \\log \\widehat y_k.\n$$\n\nИ это вполне логично: чем ближе модельное распределение к истинному, тем меньше наши потери. В идеале $\\mathcal L(\\boldsymbol y, \\boldsymbol {\\widehat y}) = 0$, если $\\boldsymbol y =  \\boldsymbol {\\widehat y}$.\n\nЧтобы вычислить функцию потерь по обучающей выборке из $N$ объектов с метками $\\boldsymbol y^{(i)}$, обычно берут усреднённную кросс-энтропию\n\n$$    \\frac 1N \\sum\\limits_{i=1}^N\\mathcal L(\\boldsymbol y^{(i)}, \\boldsymbol{\\widehat y}^{(i)})\n    =-\\frac 1N\\sum\\limits_{i=1}^N\\sum\\limits_{k=1}^K y^{(i)}_k \\log \\widehat y^{(i)}_k.\n$$\n\n## Принцип максимальной энтропии\n\nВ <a href='https://education.yandex.ru/handbook/ml/article/parametricheskie-ocenki'>параграфе про оценки параметров</a> были описаны различные свойства параметрических оценок и методы их получения, например, метод моментов или метод максимального правдоподобия. В принципе, если мы уже выбрали для наших данных $X_1, \\ldots, X_n$ некоторое параметрическое семейство $F_\\theta(x)$, моделирующее их распределение, восстановить его параметры чаще всего можно по выборочному среднему $\\overline{X}_n = \\frac{1}{n}\\sum\\limits_{k = 1}^n X_k$ и/или выборочной дисперсии $\\overline S_n = \\frac{1}{n} \\sum\\limits_{k = 1}^n (X_k - \\overline{X}_n)^2$.\n\nА теперь представим, что мы посчитали эти (или какие-то другие) статистики, а семейство распределений пока не выбрали. Как же совершить этот судьбоносный выбор? Давайте посмотрим на следующие три семейства и подумаем, в каком из них мы бы стали искать распределение, зная его истинные матожидание и дисперсию?\n\n![Three](https://yastatic.net/s3/education-portal/media/Three_classes_aaffab9011_c0262c0989.webp)\n\nПочему-то хочется сказать, что в первом. Почему? Второе не симметрично – но что нас может заставить подозревать, что интересующее нас распределение не симметрично? С третьим проблема в том, что, выбирая его, мы добавляем дополнительную информацию как минимум о том, что у распределения конечный носитель. А с чего бы? У нас такой инфомации вроде бы нет.\n\nОбщая идея такова: мы будем искать распределение, которое удовлетворяет только явно заданным нами ограничениям и не отражает никакого дополнительного знания о нём. Таким образом, искомое распределение должно обладать максимальной неопределённостью при заданных ограничениях, или, говоря более научно, иметь максимально возможную энтропию. В самом деле, энтропия выражает нашу меру незнания о том, как ведёт себя распределение, и чем она больше – тем более «‎произвольное» распределение, по крайней мере, в теории. В этом и заключается **принцип максимальной энтропии** для выбора модели машинного обучения.\n\nКак мы уже видели выше, среди распределений с конечным носителем максимальную энтропию имеет равномерное распределение. Примеры геометрического и нормального распределения показывают, что энтропия распределений с бесконечным носителем (счётным или континуальным) может быть сколь угодно большой, и среди них нет какого-то одного распределения с максимальной энтропией. Однако в более узком классе распределений с фиксированным средним и/или дисперсией найти распределение с максимальной энтропией, как правило, можно.\n\n**Пример**. Покажем, что среди распределений на множестве натуральных чисел $\\mathbb N$ и математическим ожиданием $\\mu > 1$ максимальную энтропию имеет геометрическое распределение.\n\nДля минимизации энтропии $\\mathbb H[p] = -\\sum\\limits_{n=1}^\\infty p_n \\log p_n$ с учётом ограничений\n\n$$\\sum\\limits_{n=1}^\\infty p_n = 1, \\quad \\sum\\limits_{n=1}^\\infty np_n = \\mu\n$$\n\nвоспользуемся [методом множителей Лагранжа](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B8%D1%82%D0%B5%D0%BB%D0%B5%D0%B9_%D0%9B%D0%B0%D0%B3%D1%80%D0%B0%D0%BD%D0%B6%D0%B0), согласно которому требуется минимизировать функцию Лагранжа\n\n$$    \\mathcal L(p, a, b) = \\sum\\limits_{n=1}^\\infty p_n \\log p_n - a\\Big(\\sum\\limits_{n=1}^\\infty p_n - 1\\Big) - b\\Big(\\sum\\limits_{n=1}^\\infty np_n - \\mu\\Big).\n$$\n\nПриравняем к нулю частные производные по $p_n$:\n\n$$    \\frac{\\partial \\mathcal L}{\\partial p_n} = 1 + \\log p_n - a - bn = 0.\n$$\n\nОтсюда следует, что $p_n = e^{a-1 + bn} = \\alpha \\beta^n$, так что распределение действительно получается геометрическое. Параметры $\\alpha$ и $\\beta$ найдём из уравнений\n\n$$    1 = \\sum\\limits_{n=1}^\\infty p_n  = \\sum\\limits_{n=1}^\\infty \\alpha \\beta^n = \\frac{\\alpha\\beta}{1-\\beta},\n$$\n\n$$    \\mu = \\sum\\limits_{n=1}^\\infty np_n  = \\alpha \\beta\\sum\\limits_{n=1}^\\infty n \\beta^{n-1} = \\frac{\\alpha\\beta}{(1-\\beta)^2}.\n$$\n\nДеля первое уравнение на второе, получаем $\\frac 1 \\mu = 1 - \\beta$, или $\\beta = 1 - \\frac 1\\mu$. Далее из первого уравнения находим $\\alpha = \\frac {1-\\beta}{\\beta} = \\frac 1{\\mu -1}$. Итак,\n\n$$p_n = \\frac 1{\\mu -1} \\Big(1 - \\frac 1\\mu\\Big)^n = \\frac 1\\mu \\Big(1 - \\frac 1\\mu\\Big)^{n-1},\n$$\n\nа это и есть геометрическое распределение с параметром $\\frac 1\\mu$.\n\nУ непрерывных распределений возможны более интересные комбинации из ограничений на носитель и параметры. И конечно же, первую скрипку среди распределений с максимальной энтропией играет гауссовское распределение.\n\n**Пример**. Докажем, что среди распределений на $\\mathbb R$ c математическим ожиданием $\\mu$ и дисперсией $\\sigma^2$ наибольшую энтропию имеет нормальное распределение $\\mathcal{N}(\\mu,\\sigma^2)$.\n\nПусть $p(x)$ – некоторое распределение со средним $\\mu$ и дисперсией $\\sigma^2$, $q(x)\\sim\\mathcal{N}(\\mu, \\sigma^2)$. Как было показано выше, $\\mathbb H[q] = \\frac12\\log(2\\pi\\sigma^2) + \\frac12$. Запишем дивергенцию Кульбака-Лейблера:\n\n$$\\mathbb KL(p\\vert\\vert q) = \\int\\limits_{-\\infty}^{+\\infty} p(x)\\log{p(x)}dx - \\int\\limits_{-\\infty}^{+\\infty} p(x)\\log{q(x)}dx =\n$$\n\n$$= -\\mathbb H[p] - \\int\\limits_{-\\infty}^{+\\infty} p(x)\\left(-\\frac12\\log(2\\pi\\sigma^2) - \\frac 1{2\\sigma^2}(x - \\mu)^2\\right)dx =\n$$\n\n$$= - \\mathbb H[p] +\\frac12\\log(2\\pi\\sigma^2)\\int\\limits_{-\\infty}^{+\\infty} p(x)\\,dx + \\frac1{2\\sigma^2}\\underbrace{\\int\\limits_{-\\infty}^{+\\infty}(x - \\mu)^2p(x)\\,dx}_{=\\mathbb{V}[p]=\\sigma^2} =\n$$\n\n$$= - \\mathbb H[p] + \\frac12\\log(2\\pi\\sigma^2) + \\frac12 = \\mathbb H[q] - \\mathbb H[p].\n$$\n\nТак как KL-дивергенция всегда неотрицательна, получаем, что $\\mathbb H[p]\\leqslant \\mathbb H[q]$ при любом распределении $p$, удовлетворяющем заданным ограничениям.\n\nМожно показать, что максимальную энтропию среди многомерных распределений с вектором средних $\\boldsymbol \\mu$ и матрицей ковариаций $\\boldsymbol \\Sigma$ имеет также гауссовское распределение $\\mathcal N(\\boldsymbol \\mu, \\boldsymbol \\Sigma)$.\n\n**Упражнение**. Докажите, что среди распределений на отрезке $[a,b]$ максимальную энтропию имеет равномерное распределение $U[a,b]$.\n\n{% cut \"Попробуйте доказать самостоятельно, прежде чем смотреть решение.\" %}\n\nПусть $q(x) \\sim U[a,b]$, тогда для произвольного распределения $p$ на отрезке $[a,b]$ имеем\n\n$$  \\mathbb H[p,q] = - \\int\\limits_a^b p(x)\\log q(x)\\,dx = \\int\\limits_a^b p(x) \\log(b-a)\\,dx = \\log(b-a).\n$$\n\nВ частности, отсюда следует, что $\\mathbb H[q] = \\log(b-a)$. Расписывая теперь KL-дивергенцию, получаем\n\n$$\\mathbb{KL}(p\\vert\\vert q) = \\mathbb H[p,q] - \\mathbb H[p] = \\log(b-a) - \\mathbb H[p] = \\mathbb H[q] - \\mathbb H[p] \\geqslant 0,\n$$\n\nчто и требовалось доказать.\n\n{% endcut %}\n\n**Упражнение**. Докажите, что среди распределений на промежутке $[0, +\\infty)$ с математическим ожиданием $\\lambda > 0$ максимальную энтропию имеет показательное распределение $\\mathrm{Exp\\big(\\frac 1\\lambda)}$.\n\n{% cut \"Попробуйте доказать самостоятельно, прежде чем смотреть решение.\" %}\n\nСогласно результату одного из предыдущих упражнений $\\mathbb H[q] = \\log \\lambda + 1$, если $q(x) \\sim \\mathrm{Exp}\\big(\\frac 1\\lambda)$, т.е. $q(x) = \\frac 1\\lambda e^{-\\frac x\\lambda}$, $x\\geqslant 0$. Далее, для произвольного распределения $p(x)$ на $[0, +\\infty)$ со средним $\\lambda$ имеем\n\n$$\\mathbb{KL}(p\\vert\\vert q) = \\mathbb H[p,q] - \\mathbb H[p] = - \\int\\limits_0^{+\\infty} p(x)\\Big(-\\log\\lambda - \\frac x\\lambda\\Big) \\,dx - \\mathbb H[p]=\n$$\n\n$$=\\log\\lambda + \\frac 1\\lambda \\int\\limits_0^{+\\infty} xp(x)\\, dx  - \\mathbb H[p] = \\log\\lambda + 1 - \\mathbb H[p] =  \\mathbb H[q]- \\mathbb H[p] \\geqslant 0.\n$$\n\n{% endcut %}\n\nКак выяснилось, многие классические распределения имеют максимальную энтропию при весьма естественных ограничениях. Но как быть, если даны не эти конкретные, а какие-то другие ограничения? Есть ли какой-нибудь надёжный алгоритм вывода распределения с максимальной энтропией, позволяющий избежать случайных озарений и гаданий на кофейной гуще? Оказывается, что при некоторых не очень обременительных ограничениях ответ можно записать с помощью распределений экспоненциального класса.\n\n## Экспоненциальное семейство распределений\n\nГоворят, что параметрическое семейство распределений относится к **экспоненциальному классу**, если его pdf (или pmf) может быть представлена в виде\n\n$$p(x\\vert \\boldsymbol\\theta) = \\frac{g(x)}{h(\\boldsymbol\\theta)}\\exp(\\boldsymbol \\theta^T \\boldsymbol u(x)) = g(x)\\exp(\\boldsymbol \\theta^T \\boldsymbol u(x) - A(\\boldsymbol \\theta)),\n$$\n\nгде\n\n* $\\boldsymbol\\theta \\in\\mathbb R^m$ – вектор **натуральных параметров** распределения;\n* $g(x)$ — неотрицательная функция (**base measure**), часто равная единице;\n* $h(\\boldsymbol\\theta) > 0$ — **нормализатор** (**partition**), обеспечивающий суммируемость pmf или интегрируемость pdf в единицу:\n\n$$h(\\boldsymbol\\theta) = \\int g(x)\\exp(\\boldsymbol \\theta^T \\boldsymbol u(x))dx;\n$$\n\n* $A(\\boldsymbol \\theta) = \\ln h(\\boldsymbol\\theta)$ — **log-partition**;\n* $\\boldsymbol u(x)\\in\\mathbb R^m$ — вектор **достаточных статистик** распределения.\n\n**Пример**. Покажем, что нормальное распределение $\\mathcal N(x\\vert \\mu, \\sigma^2)$ принадлежит экспоненциальному классу. Оно имеет два параметра, поэтому такую же размерность имеют $\\boldsymbol \\theta$ и вектор-функция $\\boldsymbol u$.\n\nРаспишем плотность:\n\n$$\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) =\n\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac 1{2\\sigma^2}x^2 + \\frac{\\mu}{\\sigma^2}x + \\frac{\\mu^2}{2\\sigma^2}\\right)=\n\\frac{\\exp\\left(-\\frac1{2\\sigma^2}x^2 + \\frac{\\mu}{\\sigma^2}x\\right)}{\\sqrt{2\\pi}\\sigma\\exp\\left(-\\frac{\\mu^2}{2\\sigma^2}\\right)}.\n$$\n\nПоложим $g(x) = \\frac 1{\\sqrt{2\\pi}}$, $\\boldsymbol u(x) = (x, x^2)$,\n\n$$\\boldsymbol \\theta = (\\theta_1, \\theta_2),\\quad \\theta_1 = \\frac{\\mu}{\\sigma^2},\\quad \\theta_2 = -\\frac1{2\\sigma^2}.\n$$\n\nОстаётся выразить функцию $h(\\boldsymbol\\theta) = \\sigma\\exp\\left(-\\frac{\\mu^2}{2\\sigma^2}\\right)$ через $\\theta_1$ и $\\theta_2$.\n\n**Упражнение**. Выразите partition $h(\\boldsymbol\\theta)$ и log-partition $A(\\boldsymbol\\theta)$ через $\\boldsymbol\\theta$ и запишите плотность нормального распределения в экспоненциальном виде.\n\n{% cut \"Ответ\" %}\n\n$$h(\\boldsymbol\\theta)=\\sqrt{-2\\theta_2} \\exp\\Big(\\frac{\\theta_1^2}{4\\theta_2}\\Big), \\quad  A(\\boldsymbol\\theta) = -\\frac{\\theta_1^2}{4\\theta_2} - \\frac 12\\ln(-2\\theta_2),\n$$\n\n$$\\mathcal N(x \\vert \\mu, \\sigma^2) = \\frac1{\\sqrt {2\\pi}}\\cdot \\frac 1{h(\\boldsymbol\\theta)}\\exp(\\boldsymbol\\theta^T \\boldsymbol u(x)) = \\frac1{\\sqrt {2\\pi}} \\exp(\\boldsymbol \\theta^T \\boldsymbol u(x) - A(\\boldsymbol \\theta)).\n$$\n\n{% endcut %}\n\n**Пример**. Покажем, что распределение Бернулли $\\mathrm{Bern}(p)$ принадлежит экспоненциальному классу. Его pmf $\\mathbb P(\\xi =x \\vert p)$ можно записать как\n\n$$  p^x(1 - p)^{1 - x} = \\exp\\big(x\\log{p} + (1 - x)\\log(1 - p)\\big)=\n  (1-p) \\exp\\Big(x\\log\\frac p{1-p}\\Big).\n$$\n\nПараметр здесь один, поэтому натуральный параметр $\\theta$ тоже один: $\\theta = \\log\\frac p{1-p}$. Такая функция от $p$ называется функцией логитов и активно участвует в построении модели [логистической регрессии](https://education.yandex.ru/handbook/ml/article/linear-models#linejnaya-klassifikaciya). Остальные функции положим равными $u(x) = x$, $g(x)=1$, $h(\\theta) = \\frac 1{1-p}$. Остаётся выразить partition через $\\theta$:\n\n$$  \\log\\frac p{1-p} = \\log\\Big(-1 + \\frac 1{1-p}\\Big) = \\theta \\iff \\frac 1{1-p} = 1 + e^\\theta. \n$$\n\nИтак, $h(\\theta) = 1+e^\\theta$, и экспоненциальный вид распределения Бернулли записывается как\n\n$$  \\frac 1{1+e^\\theta}\\exp(\\theta x) = \\exp\\big(\\theta x - \\log(1 + e^\\theta)\\big).\n$$\n\n**Вопрос на подумать**. Принадлежит ли к экспоненциальному классу семейство равномерных распределений на отрезках $U[a, b]$? Казалось бы, да, ведь\n\n$$p(x) = \\frac{1}{b - a}\\mathbb{I}_{[a,b]}(x)\\exp(0).\n$$\n\nВ чём может быть подвох?\n\n{% cut \"Попробуйте определить сами, прежде чем смотреть ответ.\" %}\n\nНет, не принадлежит. Давайте вспомним, как звучало определение экспоненциального семейства. Возможно, вас удивило, что там было написано не «распределение относится», а «семейство распределений относится». Это важно: ведь семейство определяется именно различными значениями $\\theta$, и если нас интересует семейство равномерных распределений на отрезках, определяемое параметрами $a$ и $b$, то они не могут быть в функции $g(x)$, они должны быть под экспонентой, а экспонента ни от чего не может быть равна индикатору.\n\nПри этом странное и не очень полезное семейство с нулём параметров, состоящее из одинокого распределения $U[0,1]$ можно считать относящимся к экспоненциальному классу: ведь для него формула\n\n$$p(x) = \\mathbb{I}_{[0,1]}(x)\\exp(0)\n$$\n\nбудет работать.\n\n{% endcut %}\n\nК экспоненциальным семействам относятся многие непрерывные и дискретные распределения из часто встречающихся в теории и на практике, в том числе\n\n* нормальное $\\mathcal N(\\mu, \\sigma^2)$;\n* распределение Пуассона $\\mathrm{Pois}(\\lambda)$;\n* экспоненциальное $\\mathrm{Exp}(\\lambda)$;\n* биномиальное $\\mathrm{Bin}(n, p)$;\n* геометрическое $\\mathrm{Geom}(p)$;\n* бета-распределение;\n* гамма-распределение;\n* распределение Дирихле.\n\nКак выглядят натуральные параметры, достаточные статистики и нормализаторы этих и других распределений из экспоненциального класса, можно посмотреть на [википедии](https://en.wikipedia.org/wiki/Exponential_family#Table_of_distributions).\n\nК экспоненциальным семействам не относятся, например, равномерное распределение $U[a,b]$, $t$-распределение Стьюдента, распределение Коши, смесь нормальных распределений.\n\n### Дифференцирование log-partition\n\nЕсли распределение $p(x\\vert \\boldsymbol\\theta)$ принадлежит экспоненциальному классу,\n\n$$p(x\\vert \\boldsymbol\\theta) = \\frac{g(x)}{h(\\boldsymbol\\theta)}\\exp(\\boldsymbol \\theta^T \\boldsymbol u(x)) = g(x)\\exp(\\boldsymbol \\theta^T \\boldsymbol u(x) - A(\\boldsymbol \\theta)),\n$$\n\nто моменты его достаточных статистик $\\boldsymbol u(x)$ могут быть получены дифференцированием функции $A(\\boldsymbol \\theta) = \\log h(\\boldsymbol\\theta)$.\n\n**Утверждение**. $\\nabla_{\\boldsymbol\\theta}\\log h(\\boldsymbol \\theta) = \\mathbb{E}_{\\xi \\sim p(x\\vert \\boldsymbol \\theta)} \\boldsymbol u(\\xi)$.\n\n**Доказательство**.\nПо правилу дифференцирования сложной функции имеем\n\n$$    \\nabla_{\\boldsymbol\\theta}\\log{h(\\boldsymbol\\theta)} = \\frac{\\nabla_{\\boldsymbol\\theta}{h(\\boldsymbol\\theta)}}{h(\\boldsymbol\\theta)}.\n$$\n\nНормализатор $h(\\boldsymbol\\theta)$ записывается в виде интеграла\n\n$$  h(\\boldsymbol\\theta) = \\int g(x)\\exp\\left(\\boldsymbol\\theta^T\\boldsymbol u(x)\\right)dx,\n$$\n\nкоторый мы продифференцируем внесением градиента внутрь под знак интеграла:\n\n$$\\nabla_{\\boldsymbol\\theta} h(\\boldsymbol\\theta) = \\nabla_{\\boldsymbol\\theta} \n \\int g(x)\\exp\\left(\\boldsymbol\\theta^T\\boldsymbol u(x)\\right)dx =\n$$\n\n$$ =\\int g(x)\\nabla_{\\boldsymbol\\theta}  \n \\exp\\left(\\boldsymbol\\theta^T\\boldsymbol u(x)\\right)dx = \n \\int g(x)\\boldsymbol u(x)\n \\exp\\big(\\boldsymbol\\theta^T\\boldsymbol u(x)\\big)dx.\n$$\n\nТаким образом,\n\n$$  \\frac{\\nabla_{\\boldsymbol\\theta}{h(\\boldsymbol\\theta)}}{h(\\boldsymbol\\theta)}\n    =\\int \\boldsymbol u(x)\\underbrace{\\frac{g(x)}{h(\\boldsymbol \\theta)}\\exp(\\boldsymbol \\theta^T\\boldsymbol u(x))}_{p(x\\vert\\boldsymbol \\theta)}dx = \\mathbb{E}_{\\xi \\sim p(x\\vert \\boldsymbol \\theta)} \\boldsymbol u(\\xi).\n$$\n\n{% cut \"Замечание о дифференцировании под знаком интегралом\" %}\n\nИспользованный в доказательстве приём внесения градиента под знак интеграла называют также [правилом Лейбница](https://en.wikipedia.org/wiki/Leibniz_integral_rule). Этот же метод используется для почленного дифференцирования ряда, что может быть полезно в случае дискретного распределения $p(x\\vert \\boldsymbol\\theta)$. В математическом анализе имеется ряд теорем, обеспечивающих применимость правила Лейбница, однако, мы не будем на них останавливаться. Будем считать, что все рассматриваемые экспоненциальные семейства таковы, что применение правила Лейбница законно.\n\n{% endcut %}\n\nЕсли $u_i(x) = x^i$, то в соответствии с только что доказанным частная производная $\\frac{\\partial A(\\boldsymbol \\theta)}{\\partial \\theta_i}$ даёт $i$-й момент распределения $p(x\\vert \\boldsymbol\\theta)$.\n\n**Упражнение**. Вычислите производные по натуральным параметрам от log-partition для распределения Бернулли $\\mathrm{Bern}(x\\vert p)$ и нормального распределения $\\mathcal N(\\mu, \\sigma^2)$ и проверьте, что они совпадают со значениями соответствующих моментов.\n\n{% cut \"Решение\" %}\n\nДля $\\xi \\sim \\mathrm{Bern}(x\\vert p)$ имеем\n\n$$  A(\\theta) = \\log(1 + e^\\theta), \\quad \\frac 1{1-p} = 1 + e^\\theta,\n$$\n\nпоэтому\n\n$$  A'(\\theta) = \\frac{e^\\theta}{1+e^\\theta} = 1 - \\frac 1{1+e^\\theta} = 1 -1 + p = p = \\mathbb E\\xi.\n$$\n\nДля гауссовской случайной величины $\\eta\\sim\\mathcal N(x \\vert\\mu, \\sigma^2)$ получаем\n\n$$  A(\\theta_1, \\theta_2) =  -\\frac{\\theta_1^2}{4\\theta_2} - \\frac 12\\ln(-2\\theta_2),\n$$\n\n$$  \\quad \\theta_1 = \\frac{\\mu}{\\sigma^2},\n$$\n\n$$  \\quad \\theta_2 = -\\frac1{2\\sigma^2},\n$$\n\nи, значит,\n\n$$  \\frac{\\partial A}{\\partial\\theta_1} = -\\frac{\\theta_1}{2\\theta_2} = \\mu = \\mathbb E\\eta,\n$$\n\n$$  \\frac{\\partial A}{\\partial\\theta_2} = \\frac{\\theta_1^2}{4\\theta_2^2} - \\frac 1{2\\theta_2} = \\mu^2 + \\sigma^2 = \\mathbb E\\eta^2.\n$$\n\n{% endcut %}\n\nКстати, можно продифференцировать ещё раз и доказать, что\n\n$$  \\nabla^2_{\\boldsymbol\\theta}\\log{h(\\boldsymbol\\theta)} = \\mathrm{cov}(\\boldsymbol u(\\xi), \\boldsymbol u(\\xi)).\n$$\n\n{% cut \"Доказательство\" %}\n\nВ предыдущий раз мы доказали, что\n\n$$\\nabla_{\\boldsymbol\\theta}A(\\boldsymbol\\theta) = \\int \\boldsymbol u(x)g(x)\\exp(\\boldsymbol \\theta^T\\boldsymbol u(x) - A(\\boldsymbol \\theta))\\,dx.\n$$\n\nТеперь возьмём ещё раз градиент по $\\boldsymbol \\theta$ от этого выражения:\n\n$$\\nabla^2_{\\boldsymbol\\theta}A(\\boldsymbol\\theta) = \\int \\boldsymbol u(x)g(x)\\nabla_{\\boldsymbol\\theta}\\exp\\big(\\boldsymbol \\theta^T\\boldsymbol u(x) - A(\\boldsymbol \\theta)\\big)\\,dx\n=\n$$\n\n$$= \\int \\boldsymbol u(x)g(x)\\big(\\boldsymbol u(x) - \\nabla_{\\boldsymbol\\theta}A(\\boldsymbol \\theta)\\big)^T \\exp\\big(\\boldsymbol \\theta^T\\boldsymbol u(x) - A(\\boldsymbol \\theta)\\big)\\,dx=\n$$\n\n$$=\\int \\boldsymbol u(x)g(x)\\big(\\boldsymbol u(x) -  \\mathbb{E} \\boldsymbol u\\big)^T \\exp\\big(\\boldsymbol \\theta^T\\boldsymbol u(x) - A(\\boldsymbol \\theta)\\big)\\,dx =\n$$\n\n$$= \\mathbb{E} \\boldsymbol u \\boldsymbol u^T - \\mathbb{E} \\boldsymbol u \\big(\\mathbb{E} \\boldsymbol u\\big)^T = \\mathrm{cov}(\\boldsymbol u(\\xi), \\boldsymbol u(\\xi)).\n$$\n\nВ последней выкладке для краткости обозначено $\\mathbb E \\boldsymbol u = \\mathbb{E}_{\\xi \\sim p(x\\vert \\boldsymbol \\theta)} \\boldsymbol u(\\xi)$.\n\n{% endcut %}\n\n### MLE для семейства из экспоненциального класса\n\nВозможно, вас удивил странный и на первый взгляд не очень естественный вид $p(x\\vert \\boldsymbol \\theta)$. Но всё не просто так: оказывается, что оценка максимального правдоподобия параметров распределений из экспоненциального класса устроена очень интригующе.\n\nЗапишем функцию правдоподобия i.i.d. выборки $x_1,\\ldots,x_n$:\n\n$$p(x_1, \\ldots, x_n\\vert\\boldsymbol \\theta) = h(\\boldsymbol \\theta)^{-n}\\cdot\\bigg(\\prod_{i=1}^ng(x_i)\\bigg)\\cdot\\exp\\bigg(\\boldsymbol \\theta^T \\sum_{i=1}^n \\boldsymbol u(x_i)\\bigg).\n$$\n\nЕё логарифм равен\n\n$$\\log p(x_1, \\ldots, x_n\\vert\\boldsymbol \\theta) = -n\\log{h(\\boldsymbol \\theta)} + \\sum_{i=1}^n\\log{g(x_i)} + \\boldsymbol \\theta^T\\sum_{i=1}^n \\boldsymbol u(x_i).\n$$\n\nДифференцируя по $\\boldsymbol \\theta$, получаем\n\n$$\\nabla_{\\boldsymbol\\theta}\\log p(x_1, \\ldots, x_n\\vert\\boldsymbol\\theta) = -n\\nabla_{\\boldsymbol\\theta}\\log{h(\\boldsymbol\\theta)} + \\sum_{i=1}^n \\boldsymbol u(x_i).\n$$\n\nПриравнивая $\\nabla_{\\boldsymbol\\theta}\\log p(x_1,\\ldots, x_n\\vert\\boldsymbol\\theta)$ к нулю и пользуясь равенством $\\nabla_{\\boldsymbol\\theta}\\log{h(\\boldsymbol\\theta)} = \\mathbb{E}_{\\xi \\sim p(x\\vert \\boldsymbol \\theta)} \\boldsymbol u(\\xi)$, находим\n\n$$\\mathbb{E}_{\\xi \\sim p(x\\vert \\boldsymbol \\theta)} \\boldsymbol u(\\xi) = \\frac1n \\sum_{i=1}^n \\boldsymbol u(x_i).\n$$\n\nТаким образом, теоретические матожидания всех компонент $u_i(\\xi)$ должны совпадать с их эмпирическими оценками, а метод максимального правдоподобия совпадает с методом моментов для $\\mathbb{E}u_i(\\xi)$ в качестве моментов. И в следующем пункте выяснится, что распределения из экспоненциальных семейств обладают максимальной энтропией среди тех, что имеют заданные моменты $\\mathbb{E}u_i(\\xi)$.\n\n### Теорема Купмана—Питмана—Дармуа\n\nТеперь мы наконец готовы сформулировать одно из самых любопытных свойств семейств экспоненциального класса.\n\nВ следующей теореме мы опустим некоторые не очень обременительные условия регулярности. Просто считайте, что для хороших дискретных и абсолютно непрерывных распределений, с которыми вы в основном и будете сталкиваться, это так.\n\n**Теорема**. Пусть параметр $\\boldsymbol\\theta\\in R^m$ распределения $p_{\\boldsymbol\\theta}(x) = \\frac1{h(\\boldsymbol\\theta)}\\exp\\big(\\boldsymbol\\theta^T\\boldsymbol u(x)\\big)$ выбран так, что\n\n$$\\mathbb{E}_{\\xi \\sim p_{\\boldsymbol\\theta}(x)} \\boldsymbol u(\\xi) = \\boldsymbol\\alpha\n$$\n\nдля некоторого фиксированного $\\boldsymbol \\alpha \\in\\mathbb R^m$. Тогда распределение $p_{\\boldsymbol\\theta}(x)$ обладает наибольшей энтропией среди распределений $q$ с тем же носителем, для которых $\\mathbb{E}_{\\xi \\sim q(x)} \\boldsymbol u(\\xi) = \\boldsymbol\\alpha$.\n\n{% cut \"Идея обоснования через оптимизацию.\" %}\n\nМы приведём рассуждение для дискретного случая; в абсолютно непрерывном рассуждения будут по сути теми же, только там придётся дифференцировать не по переменных, а по функциям, и мы решили не ввергать читателя в мир вариационного исчисления.\n\nВ дискретном случае у нас есть счётное семейство точек $x_1, x_2,\\ldots$, и распределение определяется счётным набором вероятностей $p_i$ принимать значение $x_i$. Мы будем решать задачу\n\n$$\\begin{cases}\n-\\sum_j p_j\\log{p_j}\\longrightarrow\\max,\\\\\n\\sum_jp_ju_i(x_j) = \\alpha_i, i = 1,\\ldots,m,\\\\\n\\sum_jp_j = 1,\\\\\np_j\\geqslant 0.\n\\end{cases}\n$$\n\nДля решения этой оптимизационной задачи нам понадобится обобщение метода множителей Лагранжа, известное также как [теорема Каруша—Куна—Таккера](https://ru.wikipedia.org/wiki/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F_%D0%9A%D0%B0%D1%80%D1%83%D1%88%D0%B0_%E2%80%94_%D0%9A%D1%83%D0%BD%D0%B0_%E2%80%94_%D0%A2%D0%B0%D0%BA%D0%BA%D0%B5%D1%80%D0%B0). В данном случае задача сводится к минимизации лагранжиана\n\n$$\\mathcal{L} = \\sum_j p_j\\log{p_j} + \\sum_i\\theta_i\\left(\\alpha_i - \\sum_jp_ju_i(x_j)\\right)+\\theta_0\\left(\\sum_jp_j - 1\\right) - \\sum_j\\lambda_jp_j\n$$\n\nпри имеющихся ограничениях и условиях дополняющей нежёсткости $\\lambda_jp_j = 0$.\nПриравняем частные производные по $p_j$ к нулю:\n\n$$\\frac{\\partial\\mathcal{L}}{\\partial p_j} = \\log{p_j} + 1 - \\sum_i\\theta_iu_i(x_j) + \\theta_0 - \\lambda_j = 0.\n$$\n\nОтсюда получаем, что\n\n$$p_j = \\frac{\\exp(\\boldsymbol \\theta^T \\boldsymbol u(x_j))}{\\exp\\left(\\lambda_j - \\theta_0 - 1\\right)}.\n$$\n\nЧислитель уже ровно такой, как и должен быть у распределения из экспоненциального класса; разберёмся со знаменателем. Поскольку $p_j >0$ (ведь тут сплошные экспоненты), $\\lambda_j = 0$ при всех $j$. Параметр $\\theta_0$ находится из условия $\\sum_jp_j = 1$, а точнее, выражается через остальные $\\theta_i$, что позволяет записать знаменатель в виде $h(\\boldsymbol \\theta)$.\n\n{% endcut %}\n\n{% cut \"Идея доказательства «в лоб».\" %}\n\nКак и следовало ожидать, оно ничем не отличается от того, как мы доказывали максимальность энтропии у равномерного или нормального распределения. Пусть $q(x)$ – ещё одно распределение, для которого\n\n$$\\int u_i(x)q(x)dx = \\int u_i(x)p_{\\boldsymbol\\theta}(x)dx\n$$\n\nдля всех $i = 1,\\ldots,m$. Тогда\n\n$$0\\leqslant \\mathbb{KL}(q\\vert\\vert p) = \\int q(x)\\log\\left(\\frac{q(x)}{p_{\\boldsymbol\\theta}(x)}\\right)dx = \n$$\n\n$$=\\underbrace{\\int q(x)\\log{q(x)}dx}_{-\\mathbb H[q]} - \\int q(x)\\log{p_{\\boldsymbol\\theta}(x)}dx=\n$$\n\n$$=-\\mathbb H[q] - \\int q(x)\\left(-\\log{h(\\boldsymbol \\theta)} + \\sum_i\\theta_iu_i(x)\\right)dx =\n$$\n\n$$=-\\mathbb H[q] - \\log{h(\\theta)}\\underbrace{\\int q(x)dx}_{=1=\\int p_{\\boldsymbol\\theta}(x)dx} - \\sum_i\\theta_i\\underbrace{\\int q(x)u_i(x)dx}_{=\\int p_{\\boldsymbol\\theta}(x)u_i(x)dx} =\n$$\n\n$$=-\\mathbb H[q] - \\int p(x)\\left(-\\log{h(\\boldsymbol\\theta)} + \\sum_i\\theta_iu_i(x)\\right)dx =\n$$\n\n$$=-\\mathbb H[q] + \\int p_{\\boldsymbol\\theta}(x)\\log{p_{\\boldsymbol\\theta}(x)}dx = -\\mathbb H[q] + \\mathbb H[p_{\\boldsymbol\\theta}].\n$$\n\nТаким образом, $\\mathbb H[p_{\\boldsymbol\\theta}]\\geqslant \\mathbb H[q]$, что и требовалось доказать.\n\n{% endcut %}\n\nВыше мы уже находили обладающее максимальной энтропией распределение на множестве натуральных чисел с заданным математическим ожиданием $\\mu>1$. Таковым оказалось геометрическое распределение $\\mathrm{Geom}\\big(\\frac 1\\mu\\big)$.\n\nТеорема Купмана—Питмана—Дармуа позволяет сделать это гораздо быстрее.\nВ данном случае у нас лишь одна функция $u_1(x) = x$, которая соответствует фиксации математического ожидания $\\mathbb E\\xi$. Искомое дискретное распределение имеет вид\n\n$$p_k =\\mathbb P(\\xi = k) = \\frac1{h(\\theta)}\\exp(\\theta k) =  \\frac1{h(\\theta)} \\big(e^{\\theta}\\big)^k.\n$$\n\nЭто уже похоже на геометрическое распределение с параметром $p = 1 - e^{\\theta}$. Его математическое ожидание равно $\\frac 1p$, что по условию должно равняться $\\mu$. Итак, наше распределение с максимальной этропией выглядит так:\n\n$$p_k = \\frac1{\\mu}\\left(1 - \\frac1{\\mu}\\right)^{k-1},\\quad k\\in\\mathbb N.\n$$\n\n**Пример**. Среди распределений на всей вещественной прямой с заданным математическим ожиданием $\\mu$ найдём распределение с максимальной энтропией.\n\n{% cut \"А сможете ли вы его найти? Решение под катом.\" %}\n\nТеория говорит нам, что его плотность должна иметь вид\n\n$$p(x) = \\frac1{h(\\theta)}\\exp\\left(\\theta x\\right),\n$$\n\nно интеграла экспоненты не существует, то есть применение «в лоб» теоремы провалилось. И неспроста: если даже рассмотреть все нормально распределённые случайные величины со средним $\\mu$, их энтропии, равные $\\frac12 + \\frac12\\log(2\\pi\\sigma^2)$, не ограничены сверху, то есть величины с наибольшей энтропией не существует.\n\n{% endcut %}",
        "handbook": "Учебник по машинному обучению",
        "title": "Энтропия и семейство экспоненциальных распределений",
        "description": null
    },
    {
        "path": "/handbook/ml/article/pervie-shagi",
        "content": "## Рабочее окружение для ML-специалиста\n\nГрубо говоря, оно делится на две большие категории:\n\n* Железо и вычислительные ресурсы для обучения моделей;\n* Программы и библиотеки для работы с данными.\n\nНачнём со второй категории.\n\nЧтобы начать работу, нужно установить Python — именно этот язык программирования доминирует в индустрии, благодаря большому количеству библиотек и фреймворкам, предназначенным именно для машинного обучения — TensorFlow или PyTorch.\n\nФреймворк — слой абстракции над языком программирования, который облегчает разработку. Например — нам нужно сделать отверстие в доске. Эту задачу можно решить разными способами: закрутить и выкрутить шуруп, забить и вытащить гвоздь и так далее. А можно взять дрель и сверло. Дрель в этом примере и есть фреймворк.\n\nPyTorch чаще выбирают для академических исследований — он более гибкий и больше подходит для экспериментов. TensorFlow — для продакшен-решений, поскольку он более подходит для масштабирования моделей.\n\nДалее нужно установить библиотеки для Python. Продолжая строительную аналогию: библиотека — это насадка для дрели. То есть инструмент для конкретной задачи: можно установить сверло для дерева, для бетона, для металла, а можно коронку или щётку — зависит от задачи.\n\nЧаще всего применяют:\n\n* Scikit-learn — библиотека машинного обучения для классических алгоритмов: классификации, регрессии, ансамблей и других. О них мы подробнее поговорим далее в этом хендбуке.\n* Pandas — библиотека для предварительной обработки данных, и работы с данными вообще. С её помощью можно загрузить датасет, обработать недостающие значения, закодировать категориальные переменные и многое другое.\n* Matplotlib и Seaborn — библиотеки для создания визуализаций и графиков в Python.\n\nПосле этого — выбрать IDE, то есть текстовый редактор для кода: Visual Studio Code, Jupyter, Sublime, PyCharm, и так далее.\n\nТеоретически, всё это можно установить на домашний компьютер или ноутбук — именно так и делали ещё 15-20 лет назад. Но вам не хватит вычислительных ресурсов для обучения моделей, в первую очередь — объёма памяти GPU (видеокарты).\n\nДаже для файнтюнинга небольших языковых моделей, таких как BERT, необходим графический процессор с минимум 16 Гб видеопамяти. Мало кто может позволить себе дома оборудование для обучения более сложных моделей.\n\nСейчас исследователи и студенты чаще берут вычислительные мощности в аренду. Тут есть два способа:\n\n* арендовать устройство «в облаке» (эта модель называется IaaS),\n* воспользоваться специальной платформой для ML (эта модель называется SaaS).\n\nIaaS-сервис, грубо говоря, — очень мощный удалённый компьютер. Это значит, что прежде чем решать задачу на такой машине, её всё равно необходимо настроить: развернуть IDE, установить Python, фреймворки и библиотеки и многое другое. Это не всегда удобно: иногда хочется, чтобы всё работало «из коробки».\n\n«Из коробки», как вы могли догадаться, работают SaaS-сервисы: они предоставляют полностью настроенные среды, готовые к немедленному использованию в решении задач.\n\nЭти платформы обычно включают в себя:\n\n* IDE или другие среды программирования, часто представленные в формате ноутбуков.\n* Заранее настроенные рабочие окружения, оптимизированные для конкретной системы.\n* Возможности для загрузки и хранения данных и файлов.\n* Интеграцию с известными сервисами, такими как GitHub.\n\nО них мы и поговорим далее. Но если вам ближе путь самурая — то вот несколько [IaaS](https://cloud.google.com/learn/what-is-iaas) [провайдеров](https://aws.amazon.com/ru/ai/machine-learning/). По ссылкам можно узнать, как развернуть окружение для ML в IaaS-сервисе.\n\n## SaaS-платформы\n\nКак мы уже выяснили, главное преимущество SaaS – это простота входа: вы получаете доступ к необходимым ресурсам без забот о их настройке и оптимизации, что позволяет быстро приступить к работе над ML-задачами.\n\nК популярным SaaS-платформам относят:\n\n* Google Colab\n* Kaggle Notebooks\n* AWS SageMaker\n* Azure ML Studio\n* Yandex DataSphere\n\nНиже мы собрали в таблицу их возможности, плюсы и минусы.\n\n![яндекс иллюстрации](https://yastatic.net/s3/education-portal/media/yandeks_illyustraczii_tablicza_01_b7f613ce76.svg)\n\nДалее мы расскажем, как решать ML-задачи на примере Yandex DataSphere. Но если вас заинтересовали другие платформы, то в конце параграфа будет список ссылок на руководства по работе с ними.\n\n## Получение доступа и настройка DataSphere\n\nПрежде чем мы начнём настройку — несколько важных моментов.\n\nDataSphere — это платный сервис, но вы можете начать работу бесплатно, с помощью [тестового гранта](https://yandex.cloud/ru/docs/getting-started/usage-grant). Также у сервиса есть специальные гранты для учебных программ. Чтобы воспользоваться грантом, нужно попросить своего преподавателя заполнить [форму](https://cloud.yandex.ru/for-education-and-science/for-tutors), — это откроет доступ к сервису для всех студентов группы.\n\nОтлично, теперь можем приступить к настройке. Для этого:\n\n* Перейдите на сайт [DataSphere](https://datasphere.yandex.ru/)\n* Нажмите большую синюю кнопку и авторизуйтесь в Яндекс ID\n* Создайте сообщество и нажмите «Привязать платежный аккаунт»\n  на появившемся красном дисклеймере.\n\nВ созданном сообществе вы сможете взаимодействовать со всеми важными сущностями в DataSphere. Теперь можно создать проект на вкладке «Проект».\n\n![3.webp](https://yastatic.net/s3/education-portal/media/3_9a414bf739.webp)\n\nВ созданном проекте вы можете запустить JupyterLab:\n\n![2.webp](https://yastatic.net/s3/education-portal/media/2_f09506b051.webp)\n\nПосле незначительного ожидания откроется выбор среды исполнения. Там вы можете выбрать любой из примеров ноутбуков с различными снипеттами кода под разные задачи. Создадим новый пустой ноутбук, нажав “DataSphere Kernel”.\n\n![1 (1).webp](https://yastatic.net/s3/education-portal/media/1_1_ca7b72bb0e.webp)\n\nТеперь, в появившемся новом ноутбуке, если мы запустим любой код в одной из ячеек, вам будет предложено выбрать конфигурацию виртуального рабочего места (более подробно о доступных конфигурациях можно почитать [тут](https://cloud.yandex.ru/ru/docs/datasphere/concepts/configurations)).\n\nПосле выделения ресурсов, которое тоже займет небольшое количество времени, все последующие выполнения ячеек будут происходить без выбора конфигурации.\n\nТеперь, когда у нас всё готово — DataSphere настроена, ресурсы выделены, можем выполнить тестовую лабораторную работу!\n\n## Лабораторная работа\n\nВ ней мы будем обучать генеративную трансформерную модель с помощью библиотеки `transformers`.\n\nСама работа находится в DataSphere — переходите по [ссылке](https://datasphere.yandex.cloud/import-ipynb?path=https://raw.githubusercontent.com/yandex-datasphere/sda-homeworks/main/train-trans/train-trans.ipynb), чтобы ознакомиться с заданием. А как закончите —  возвращайтесь, чтобы завершить урок.\n\nВот и всё! Если вы читаете эти строки, и у вас всё получилось — вы большой молодец. Если не получилось — ничего страшного, с первого раза мало у кого всё получается. Советуем вступить в [сообщество хендбука](https://t.me/MLhandbook) и попросить помощи или совета.\n\n## Полезные ссылки\n\n* [Руководство](https://colab.research.google.com/) по работе с Google Colab.\n* [Гайд](https://www.kaggle.com/code/shagkala/a-complete-guide-for-beginners) для новичков по Kaggle Notebooks.\n* [Руководство](https://docs.aws.amazon.com/sagemaker/latest/dg/onboard-quick-start.html) для AWS SageMaker.\n* [Документация](https://learn.microsoft.com/en-us/azure/machine-learning/tutorial-azure-ml-in-a-day?view=azureml-api-2) по настройке Azure ML Studio\n* [Статья](https://education.yandex.ru/journal/kak-ispolzovat-datasphere-vandnbspobrazovanii) про то, как используется DataSphere в образовании\n* [Как](https://habr.com/ru/companies/yandex/articles/786560/) DataSphere помогает изучать снежных барсов",
        "handbook": "Учебник по машинному обучению",
        "title": "Первые шаги",
        "description": "В этой главе мы поговорим о рабочем окружении ML-специалиста — какие сервисы и библиотеки в него входят, как его развернуть, на что обратить внимание. \n\nА кроме того, в качестве быстрой практики обучим собственную модель генерировать ответы в стиле Льва Толстого."
    }
]